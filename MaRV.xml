<?xml version="1.0"?>
<root><Extract_Method><refactoring><refactoring_id>1</refactoring_id><commit_sha>5cf21fa7d1b66469a7be78f273cd1edd13aa3b81</commit_sha><commit_link>https://github.com/apache/doris/commit/5cf21fa7d1b66469a7be78f273cd1edd13aa3b81</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/analysis/Expr.java</file_path><description>Extract Method public substitute(smap ExprSubstitutionMap, disjunctsMap ExprSubstitutionMap, analyzer Analyzer, preserveRootType boolean) : Expr extracted from public substitute(smap ExprSubstitutionMap, analyzer Analyzer, preserveRootType boolean) : Expr in class org.apache.doris.analysis.Expr</description><code_before>@@ -691,12 +691,17 @@ public static &lt;C extends Expr&gt; boolean containsAggregate(List&lt;? extends Expr&gt; in
      */
     public Expr trySubstitute(ExprSubstitutionMap smap, Analyzer analyzer,
                               boolean preserveRootType) throws AnalysisException {
         Expr result = clone();
         // Return clone to avoid removing casts.
         if (smap == null) {
             return result;
         }
-        result = result.substituteImpl(smap, analyzer);
         result.analyze(analyzer);
         if (preserveRootType &amp;&amp; !type.equals(result.getType())) {
             result = result.castTo(type);
@@ -717,8 +722,14 @@ public Expr trySubstitute(ExprSubstitutionMap smap, Analyzer analyzer,
      */
     public Expr substitute(ExprSubstitutionMap smap, Analyzer analyzer, boolean preserveRootType)
             throws AnalysisException {
         try {
-            return trySubstitute(smap, analyzer, preserveRootType);
         } catch (AnalysisException e) {
             throw e;
         } catch (Exception e) {
@@ -755,19 +766,22 @@ public static ArrayList&lt;Expr&gt; substituteList(
      * Exprs that have non-child exprs which should be affected by substitutions must
      * override this method and apply the substitution to such exprs as well.
      */
-    protected Expr substituteImpl(ExprSubstitutionMap smap, Analyzer analyzer)
-            throws AnalysisException {
         if (isImplicitCast()) {
-            return getChild(0).substituteImpl(smap, analyzer);
         }
         if (smap != null) {
             Expr substExpr = smap.get(this);
             if (substExpr != null) {
                 return substExpr.clone();
             }
         }
         for (int i = 0; i &lt; children.size(); ++i) {
-            children.set(i, children.get(i).substituteImpl(smap, analyzer));
         }
         // SlotRefs must remain analyzed to support substitution across query blocks. All
         // other exprs must be analyzed again after the substitution to add implicit casts
</code_before><code_after>@@ -691,12 +691,17 @@ public static &lt;C extends Expr&gt; boolean containsAggregate(List&lt;? extends Expr&gt; in
      */
     public Expr trySubstitute(ExprSubstitutionMap smap, Analyzer analyzer,
                               boolean preserveRootType) throws AnalysisException {
+        return trySubstitute(smap, null, analyzer, preserveRootType);
+    }
+
+    public Expr trySubstitute(ExprSubstitutionMap smap, ExprSubstitutionMap disjunctsMap, Analyzer analyzer,
+            boolean preserveRootType) throws AnalysisException {
         Expr result = clone();
         // Return clone to avoid removing casts.
         if (smap == null) {
             return result;
         }
+        result = result.substituteImpl(smap, disjunctsMap, analyzer);
         result.analyze(analyzer);
         if (preserveRootType &amp;&amp; !type.equals(result.getType())) {
             result = result.castTo(type);
@@ -717,8 +722,14 @@ public Expr trySubstitute(ExprSubstitutionMap smap, Analyzer analyzer,
      */
     public Expr substitute(ExprSubstitutionMap smap, Analyzer analyzer, boolean preserveRootType)
             throws AnalysisException {
+        return substitute(smap, null, analyzer, preserveRootType);
+    }
+
+    public Expr substitute(ExprSubstitutionMap smap, ExprSubstitutionMap disjunctsMap,
+            Analyzer analyzer, boolean preserveRootType)
+            throws AnalysisException {
         try {
+            return trySubstitute(smap, disjunctsMap, analyzer, preserveRootType);
         } catch (AnalysisException e) {
             throw e;
         } catch (Exception e) {
@@ -755,19 +766,22 @@ public static ArrayList&lt;Expr&gt; substituteList(
      * Exprs that have non-child exprs which should be affected by substitutions must
      * override this method and apply the substitution to such exprs as well.
      */
+    protected Expr substituteImpl(ExprSubstitutionMap smap, ExprSubstitutionMap disjunctsMap, Analyzer analyzer) {
         if (isImplicitCast()) {
+            return getChild(0).substituteImpl(smap, disjunctsMap, analyzer);
         }
         if (smap != null) {
             Expr substExpr = smap.get(this);
             if (substExpr != null) {
                 return substExpr.clone();
             }
         }
+        if (Expr.IS_OR_PREDICATE.apply(this) &amp;&amp; disjunctsMap != null) {
+            smap = disjunctsMap;
+            disjunctsMap = null;
+        }
         for (int i = 0; i &lt; children.size(); ++i) {
+            children.set(i, children.get(i).substituteImpl(smap, disjunctsMap, analyzer));
         }
         // SlotRefs must remain analyzed to support substitution across query blocks. All
         // other exprs must be analyzed again after the substitution to add implicit casts
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>73368</refactoring_id><commit_sha>3cf69c04aa382f96207ae111435ba6d75d9d67aa</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/3cf69c04aa382f96207ae111435ba6d75d9d67aa</commit_link><file_path>src/edu/stanford/nlp/pipeline/KBPAnnotator.java</file_path><description>Extract Method public KBPAnnotator(name String, props Properties) extracted from public KBPAnnotator(props Properties) in class edu.stanford.nlp.pipeline.KBPAnnotator</description><code_before>@@ -61,7 +61,7 @@ public class KBPAnnotator implements Annotator {
    *
    * @param props The properties to use when creating this extractor.
    */
-  public KBPAnnotator(Properties props) {
     // Parse standard properties
     this.threads = Integer.parseInt(props.getProperty("threads", "1"));
 
@@ -92,6 +92,12 @@ public KBPAnnotator(Properties props) {
   }
 
 
   /**
    * Returns whether the given token counts as a valid pronominal mention for KBP.
    * @param word The token to classify.
</code_before><code_after>@@ -61,7 +61,7 @@ public class KBPAnnotator implements Annotator {
    *
    * @param props The properties to use when creating this extractor.
    */
+  public KBPAnnotator(String name, Properties props) {
     // Parse standard properties
     this.threads = Integer.parseInt(props.getProperty("threads", "1"));
 
@@ -92,6 +92,12 @@ public KBPAnnotator(Properties props) {
   }
 
 
+  public KBPAnnotator(Properties properties) {
+    this(STANFORD_KBP, properties);
+
+  }
+
+
   /**
    * Returns whether the given token counts as a valid pronominal mention for KBP.
    * @param word The token to classify.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>23197</refactoring_id><commit_sha>9fecd21754562b8dd5858ef18664fd197b17de6e</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/9fecd21754562b8dd5858ef18664fd197b17de6e</commit_link><file_path>advanced/src/java/org/neo4j/impl/shell/NeoApp.java</file_path><description>Extract Method protected getCurrentNode(server NeoShellServer, session Session) : Node extracted from protected getCurrentNode(session Session) : Node in class org.neo4j.impl.shell.NeoApp</description><code_before>@@ -17,60 +17,62 @@
 package org.neo4j.impl.shell;
 
 import java.rmi.RemoteException;
 import org.neo4j.api.core.Direction;
 import org.neo4j.api.core.Node;
 import org.neo4j.api.core.Transaction;
 import org.neo4j.util.shell.AbstractApp;
 import org.neo4j.util.shell.AppCommandParser;
 import org.neo4j.util.shell.Output;
 import org.neo4j.util.shell.Session;
 import org.neo4j.util.shell.ShellException;
 
 /**
- * Completely server-side
  */
 public abstract class NeoApp extends AbstractApp
 {
 	private static final String NODE_KEY = "CURRENT_NODE";
 	
-	protected Node getCurrentNode( Session session )
 	{
 		Number id = ( Number ) safeGet( session, NODE_KEY );
 		Node node = null;
 		if ( id == null )
 		{
-			node =  this.getNeoServer().getNeo().getReferenceNode();
 			setCurrentNode( session, node );
 		}
 		else
 		{
-			node = getNeoServer().getNeo().getNodeById( id.intValue() );
 		}
 		return node;
 	}
 	
 	protected static void setCurrentNode( Session session, Node node )
 	{
 		safeSet( session, NODE_KEY, node.getId() );
 	}
 	
-	private NeoShellServer getNeoServer()
 	{
 		return ( NeoShellServer ) this.getServer();
 	}
 	
-/*	protected RelationshipType getRelationshipType( String name )
 	{
-		// this.ensureRelTypesInitialized();
-		RelationshipType result = ( ( EmbeddedNeo ) this.getNeoServer().
-			getNeo() ).getRelationshipType( name );
-		if ( result == null )
-		{
-			throw new RuntimeException( "No relationship type '" + name +
-				"' found" );
-		}
-		return result;
-	}*/
 	
 	protected Direction getDirection( String direction ) throws ShellException
 	{
@@ -149,15 +151,40 @@ protected String getDisplayNameForCurrentNode()
 		return "(me)";
 	}
 
 	public static String getDisplayNameForNode( Node node )
 	{
 		return node != null
 			? getDisplayNameForNode( node.getId() )
 			: getDisplayNameForNode( (Long) null );
 	}
 	
 	public static String getDisplayNameForNode( Long nodeId )
 	{
 		return "(" + nodeId + ")";
 	}
 }
</code_before><code_after>@@ -17,60 +17,62 @@
 package org.neo4j.impl.shell;
 
 import java.rmi.RemoteException;
+
 import org.neo4j.api.core.Direction;
 import org.neo4j.api.core.Node;
+import org.neo4j.api.core.RelationshipType;
 import org.neo4j.api.core.Transaction;
 import org.neo4j.util.shell.AbstractApp;
+import org.neo4j.util.shell.App;
 import org.neo4j.util.shell.AppCommandParser;
 import org.neo4j.util.shell.Output;
 import org.neo4j.util.shell.Session;
 import org.neo4j.util.shell.ShellException;
 
 /**
+ * An implementation of {@link App} which has common methods and functionality
+ * to use with neo.
  */
 public abstract class NeoApp extends AbstractApp
 {
 	private static final String NODE_KEY = "CURRENT_NODE";
 	
+	protected static Node getCurrentNode( NeoShellServer server,
+		Session session )
 	{
 		Number id = ( Number ) safeGet( session, NODE_KEY );
 		Node node = null;
 		if ( id == null )
 		{
+			node = server.getNeo().getReferenceNode();
 			setCurrentNode( session, node );
 		}
 		else
 		{
+			node = server.getNeo().getNodeById( id.longValue() );
 		}
 		return node;
 	}
 	
+	protected Node getCurrentNode( Session session )
+	{
+		return getCurrentNode( getNeoServer(), session );
+	}
+	
 	protected static void setCurrentNode( Session session, Node node )
 	{
 		safeSet( session, NODE_KEY, node.getId() );
 	}
 	
+	protected NeoShellServer getNeoServer()
 	{
 		return ( NeoShellServer ) this.getServer();
 	}
 	
+	protected RelationshipType getRelationshipType( String name )
 	{
+		return new NeoAppRelationshipType( name );
+	}
 	
 	protected Direction getDirection( String direction ) throws ShellException
 	{
@@ -149,15 +151,40 @@ protected String getDisplayNameForCurrentNode()
 		return "(me)";
 	}
 
+	/**
+	 * Returns the display name for a {@link Node}.
+	 * @param node the node to get the name-representation for.
+	 * @return the display name for a {@link Node}.
+	 */
 	public static String getDisplayNameForNode( Node node )
 	{
 		return node != null
 			? getDisplayNameForNode( node.getId() )
 			: getDisplayNameForNode( (Long) null );
 	}
 	
+	/**
+	 * Returns the display name for a {@link Node}.
+	 * @param nodeId the node id to get the name-representation for.
+	 * @return the display name for a {@link Node}.
+	 */
 	public static String getDisplayNameForNode( Long nodeId )
 	{
 		return "(" + nodeId + ")";
 	}
+	
+	private static class NeoAppRelationshipType implements RelationshipType
+	{
+		private String name;
+		
+		private NeoAppRelationshipType( String name )
+		{
+			this.name = name;
+		}
+		
+		public String name()
+		{
+			return this.name;
+		}
+	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>31043</refactoring_id><commit_sha>9eec15a34a5a3ef466c0a84f25775f688abbf7b6</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/9eec15a34a5a3ef466c0a84f25775f688abbf7b6</commit_link><file_path>src/java_tools/singlejar/java/com/google/devtools/build/singlejar/SingleJarWorker.java</file_path><description>Extract Method protected singleRun(args String[]) : int extracted from private runSingleJar(args String[]) : int in class com.google.devtools.build.singlejar.SingleJarWorker</description><code_before>@@ -34,7 +34,7 @@ public static void main(String[] args) {
   private PrintStream originalSterr;
   private ByteArrayOutputStream stdoutAndStderr;
 
-  private void runWorker() {
     trapOutputs();
 
     try {
@@ -81,7 +81,7 @@ private void outputResult(int returnCode) throws IOException {
 
   private int runSingleJar(String[] args) {
     try {
-      return SingleJar.singleRun(args);
     } catch (IOException e) {
       // Some IO failures are okay no need to quit the worker
       System.err.println("SingleJar threw exception : " + e.getMessage());
@@ -94,4 +94,8 @@ private int runSingleJar(String[] args) {
       return 1;
     }
   }
 }
</code_before><code_after>@@ -34,7 +34,7 @@ public static void main(String[] args) {
   private PrintStream originalSterr;
   private ByteArrayOutputStream stdoutAndStderr;
 
+  protected void runWorker() {
     trapOutputs();
 
     try {
@@ -81,7 +81,7 @@ private void outputResult(int returnCode) throws IOException {
 
   private int runSingleJar(String[] args) {
     try {
+      return singleRun(args);
     } catch (IOException e) {
       // Some IO failures are okay no need to quit the worker
       System.err.println("SingleJar threw exception : " + e.getMessage());
@@ -94,4 +94,8 @@ private int runSingleJar(String[] args) {
       return 1;
     }
   }
+
+  protected int singleRun(String[] args) throws Exception {
+    return SingleJar.singleRun(args);
+  }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>11305</refactoring_id><commit_sha>13939b028cce7e4befb2b86ea670a68fb08cc732</commit_sha><commit_link>https://github.com/cgeo/cgeo/commit/13939b028cce7e4befb2b86ea670a68fb08cc732</commit_link><file_path>main/src/cgeo/geocaching/storage/ContentStorage.java</file_path><description>Extract Method private isEmpty(uri Uri) : boolean extracted from public openForWrite(uri Uri, append boolean) : OutputStream in class cgeo.geocaching.storage.ContentStorage</description><code_before>@@ -184,7 +184,7 @@ public Uri create(final Folder folder, final FileNameCreator nameCreator, final
     }
      /** Deletes the file represented by given Uri */
     public boolean delete(final Uri uri) {
-        if (uri == null) {
             return false;
         }
         try {
@@ -312,7 +312,7 @@ public String getName(final Uri uri) {
      * Unfortunately it is not possible to retrieve this info from an Uri alone.
      * */
     public FileInformation getFileInfo(final Uri uri) {
-        if (uri == null) {
             return null;
         }
 
@@ -331,7 +331,7 @@ public OutputStream openForWrite(final Uri uri) {
     }
 
     public OutputStream openForWrite(final Uri uri, final boolean append) {
-        if (uri == null) {
             return null;
         }
 
@@ -375,7 +375,7 @@ public InputStream openForRead(final Uri uri) {
      * @param suppressWarningForUser if true then failure to open will NOT result in a toast to user
      */
     public InputStream openForRead(final Uri uri, final boolean suppressWarningForUser) {
-        if (uri == null) {
             return null;
         }
 
@@ -580,4 +580,8 @@ private void reportProblem(@StringRes final int messageId, final Exception ex, f
         }
         reportRunningFlag.set(false);
     }
 }
</code_before><code_after>@@ -184,7 +184,7 @@ public Uri create(final Folder folder, final FileNameCreator nameCreator, final
     }
      /** Deletes the file represented by given Uri */
     public boolean delete(final Uri uri) {
+        if (isEmpty(uri)) {
             return false;
         }
         try {
@@ -312,7 +312,7 @@ public String getName(final Uri uri) {
      * Unfortunately it is not possible to retrieve this info from an Uri alone.
      * */
     public FileInformation getFileInfo(final Uri uri) {
+        if (isEmpty(uri)) {
             return null;
         }
 
@@ -331,7 +331,7 @@ public OutputStream openForWrite(final Uri uri) {
     }
 
     public OutputStream openForWrite(final Uri uri, final boolean append) {
+        if (isEmpty(uri)) {
             return null;
         }
 
@@ -375,7 +375,7 @@ public InputStream openForRead(final Uri uri) {
      * @param suppressWarningForUser if true then failure to open will NOT result in a toast to user
      */
     public InputStream openForRead(final Uri uri, final boolean suppressWarningForUser) {
+        if (isEmpty(uri)) {
             return null;
         }
 
@@ -580,4 +580,8 @@ private void reportProblem(@StringRes final int messageId, final Exception ex, f
         }
         reportRunningFlag.set(false);
     }
+
+    private static boolean isEmpty(final Uri uri) {
+        return uri == null || uri.equals(Uri.EMPTY);
+    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>116505</refactoring_id><commit_sha>57ccedb50f509c7fd1e3c7f4ba87010f1abd2c4c</commit_sha><commit_link>https://github.com/robolectric/robolectric/commit/57ccedb50f509c7fd1e3c7f4ba87010f1abd2c4c</commit_link><file_path>robolectric-utils/src/main/java/org/robolectric/util/Scheduler.java</file_path><description>Extract Method public advanceBy(amount long, unit TimeUnit) : boolean extracted from public advanceBy(interval long) : boolean in class org.robolectric.util.Scheduler</description><code_before>@@ -4,6 +4,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.ListIterator;
 
 import static org.robolectric.util.Scheduler.IdleState.*;
 
@@ -29,7 +30,7 @@ public class Scheduler {
   /**
    * Describes the current state of a {@link Scheduler}.
    */
-  public static enum IdleState {
     /**
      * The &lt;tt&gt;Scheduler&lt;/tt&gt; will not automatically advance the clock nor execute any runnables.
      */
@@ -127,7 +128,7 @@ public synchronized boolean isPaused() {
    * @param runnable    Runnable to add.
    */
   public synchronized void post(Runnable runnable) {
-    postDelayed(runnable, 0);
   }
 
   /**
@@ -137,6 +138,14 @@ public synchronized void post(Runnable runnable) {
    * @param delayMillis Delay in millis.
    */
   public synchronized void postDelayed(Runnable runnable, long delayMillis) {
     if ((idleState != CONSTANT_IDLE &amp;&amp; (isPaused() || delayMillis &gt; 0)) || Thread.currentThread() != associatedThread) {
       queueRunnableAndSort(runnable, currentTime + delayMillis);
     } else {
@@ -195,9 +204,19 @@ public synchronized boolean advanceToNextPostedRunnable() {
    *
    * @param   interval  Time interval (in millis).
    * @return  True if a runnable was executed.
    */
   public synchronized boolean advanceBy(long interval) {
-    long endingTime = currentTime + interval;
     return advanceTo(endingTime);
   }
 
</code_before><code_after>@@ -4,6 +4,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.concurrent.TimeUnit;
 
 import static org.robolectric.util.Scheduler.IdleState.*;
 
@@ -29,7 +30,7 @@ public class Scheduler {
   /**
    * Describes the current state of a {@link Scheduler}.
    */
+  public enum IdleState {
     /**
      * The &lt;tt&gt;Scheduler&lt;/tt&gt; will not automatically advance the clock nor execute any runnables.
      */
@@ -127,7 +128,7 @@ public synchronized boolean isPaused() {
    * @param runnable    Runnable to add.
    */
   public synchronized void post(Runnable runnable) {
+    postDelayed(runnable, 0, TimeUnit.MILLISECONDS);
   }
 
   /**
@@ -137,6 +138,14 @@ public synchronized void post(Runnable runnable) {
    * @param delayMillis Delay in millis.
    */
   public synchronized void postDelayed(Runnable runnable, long delayMillis) {
+    postDelayed(runnable, delayMillis, TimeUnit.MILLISECONDS);
+  }
+
+  /**
+   * Add a runnable to the queue to be run after a delay.
+   */
+  public synchronized void postDelayed(Runnable runnable, long delay, TimeUnit unit) {
+    long delayMillis = unit.toMillis(delay);
     if ((idleState != CONSTANT_IDLE &amp;&amp; (isPaused() || delayMillis &gt; 0)) || Thread.currentThread() != associatedThread) {
       queueRunnableAndSort(runnable, currentTime + delayMillis);
     } else {
@@ -195,9 +204,19 @@ public synchronized boolean advanceToNextPostedRunnable() {
    *
    * @param   interval  Time interval (in millis).
    * @return  True if a runnable was executed.
+   * @deprecated Use {@link #advanceBy(long, TimeUnit)}.
    */
   public synchronized boolean advanceBy(long interval) {
+    return advanceBy(interval, TimeUnit.MILLISECONDS);
+  }
+
+  /**
+   * Run all runnables that are scheduled to run in the next time interval.
+   *
+   * @return  True if a runnable was executed.
+   */
+  public synchronized boolean advanceBy(long amount, TimeUnit unit) {
+    long endingTime = currentTime + unit.toMillis(amount);
     return advanceTo(endingTime);
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>50759</refactoring_id><commit_sha>9488fdf667d51af378a0cf534fc66eed7ac392d8</commit_sha><commit_link>https://github.com/spring-projects/spring-integration/commit/9488fdf667d51af378a0cf534fc66eed7ac392d8</commit_link><file_path>spring-integration-jpa/src/main/java/org/springframework/integration/jpa/core/JpaExecutor.java</file_path><description>Extract Method private checkDelete(payload Object) : void extracted from public poll(requestMessage Message&lt;?&gt;) : Object in class org.springframework.integration.jpa.core.JpaExecutor</description><code_before>@@ -472,6 +472,7 @@ else if (this.namedQuery != null) {
 	 * Execute the JPA operation. Delegates to {@link JpaExecutor#poll(Message)}.
 	 * @return The object or null.
 	 */
 	public Object poll() {
 		return poll(null);
 	}
@@ -485,6 +486,7 @@ public Object poll() {
 	 * @param requestMessage May be null.
 	 * @return The payload object, which may be null.
 	 */
 	public Object poll(@Nullable final Message&lt;?&gt; requestMessage) {
 		final Object payload;
 
@@ -508,8 +510,8 @@ public Object poll(@Nullable final Message&lt;?&gt; requestMessage) {
 				if (this.firstResultExpression != null) {
 					firstResult = getFirstResult(requestMessage);
 				}
-				ParameterSource parameterSource = determineParameterSource(requestMessage);
-				result = doPoll(parameterSource, firstResult, maxNumberOfResults);
 			}
 
 			if (result.isEmpty()) {
@@ -535,6 +537,11 @@ else if (requestMessage != null) {
 			}
 		}
 
 		if (payload != null &amp;&amp; this.deleteAfterPoll) {
 			if (payload instanceof Iterable) {
 				if (this.deleteInBatch) {
@@ -554,7 +561,6 @@ else if (requestMessage != null) {
 				this.jpaOperations.flush();
 			}
 		}
-		return payload;
 	}
 
 	protected List&lt;?&gt; doPoll(ParameterSource jpaQLParameterSource, int firstResult, int maxNumberOfResults) {
</code_before><code_after>@@ -472,6 +472,7 @@ else if (this.namedQuery != null) {
 	 * Execute the JPA operation. Delegates to {@link JpaExecutor#poll(Message)}.
 	 * @return The object or null.
 	 */
+	@Nullable
 	public Object poll() {
 		return poll(null);
 	}
@@ -485,6 +486,7 @@ public Object poll() {
 	 * @param requestMessage May be null.
 	 * @return The payload object, which may be null.
 	 */
+	@Nullable
 	public Object poll(@Nullable final Message&lt;?&gt; requestMessage) {
 		final Object payload;
 
@@ -508,8 +510,8 @@ public Object poll(@Nullable final Message&lt;?&gt; requestMessage) {
 				if (this.firstResultExpression != null) {
 					firstResult = getFirstResult(requestMessage);
 				}
+				ParameterSource paramSource = determineParameterSource(requestMessage);
+				result = doPoll(paramSource, firstResult, maxNumberOfResults);
 			}
 
 			if (result.isEmpty()) {
@@ -535,6 +537,11 @@ else if (requestMessage != null) {
 			}
 		}
 
+		checkDelete(payload);
+		return payload;
+	}
+
+	private void checkDelete(final Object payload) {
 		if (payload != null &amp;&amp; this.deleteAfterPoll) {
 			if (payload instanceof Iterable) {
 				if (this.deleteInBatch) {
@@ -554,7 +561,6 @@ else if (requestMessage != null) {
 				this.jpaOperations.flush();
 			}
 		}
 	}
 
 	protected List&lt;?&gt; doPoll(ParameterSource jpaQLParameterSource, int firstResult, int maxNumberOfResults) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>15078</refactoring_id><commit_sha>a34096dc94c239f253497cfd83dcc45adb7d586f</commit_sha><commit_link>https://github.com/batfish/batfish/commit/a34096dc94c239f253497cfd83dcc45adb7d586f</commit_link><file_path>projects/batfish-common-protocol/src/test/java/org/batfish/specifier/parboiled/TestParser.java</file_path><description>Extract Method public TestAddressGroupName() : Rule extracted from public TestSpecifierInput() : Rule in class org.batfish.specifier.parboiled.TestParser</description><code_before>@@ -71,14 +71,18 @@ public Rule TestNotOp() {
     return Sequence("! ", TestNot("! "), TestTerm());
   }
 
-  @Anchor(Type.ADDRESS_GROUP_AND_BOOK)
   public Rule TestSpecifierInput() {
-    return Sequence(
-        ReferenceObjectNameLiteral(),
-        WhiteSpace(),
-        ", ",
-        ReferenceObjectNameLiteral(),
-        WhiteSpace());
   }
 
   /** An instance of base dynamic value */
</code_before><code_after>@@ -71,14 +71,18 @@ public Rule TestNotOp() {
     return Sequence("! ", TestNot("! "), TestTerm());
   }
 
   public Rule TestSpecifierInput() {
+    return Sequence(TestAddressGroupName(), ", ", TestReferenceBookName());
+  }
+
+  @Anchor(Type.ADDRESS_GROUP_NAME)
+  public Rule TestAddressGroupName() {
+    return Sequence(NameLiteral(), WhiteSpace());
+  }
+
+  @Anchor(Type.REFERENCE_BOOK_NAME)
+  public Rule TestReferenceBookName() {
+    return Sequence(NameLiteral(), WhiteSpace());
   }
 
   /** An instance of base dynamic value */
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>66079</refactoring_id><commit_sha>81e5aa82d72e3042ce96d37641afce98402f1774</commit_sha><commit_link>https://github.com/techempower/frameworkbenchmarks/commit/81e5aa82d72e3042ce96d37641afce98402f1774</commit_link><file_path>frameworks/Java/netty/src/main/java/hello/HelloServerHandler.java</file_path><description>Extract Method private channelReadSlowPath(ctx ChannelHandlerContext, msg Object) : void extracted from public channelRead(ctx ChannelHandlerContext, msg Object) : void in class hello.HelloServerHandler</description><code_before>@@ -28,8 +28,10 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.AsciiString;
 import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCountUtil;
@@ -88,6 +90,20 @@ public void run() {
 
 	@Override
 	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
 		if (msg instanceof HttpRequest) {
 			try {
 				HttpRequest request = (HttpRequest) msg;
</code_before><code_after>@@ -28,8 +28,10 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.util.AsciiString;
 import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCountUtil;
@@ -88,6 +90,20 @@ public void run() {
 
 	@Override
 	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+		// fast path
+		if (msg == LastHttpContent.EMPTY_LAST_CONTENT) {
+			return;
+		}
+		if (msg.getClass() == DefaultHttpRequest.class) {
+			DefaultHttpRequest request = (DefaultHttpRequest) msg;
+			process(ctx, request);
+		} else {
+			channelReadSlowPath(ctx, msg);
+		}
+	}
+
+	private void channelReadSlowPath(ChannelHandlerContext ctx, Object msg) throws Exception {
+		// slow path
 		if (msg instanceof HttpRequest) {
 			try {
 				HttpRequest request = (HttpRequest) msg;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>60750</refactoring_id><commit_sha>15b4ecf87e8ba6cdbf450c05868fb4da29bf61ae</commit_sha><commit_link>https://github.com/groovy/groovy-core/commit/15b4ecf87e8ba6cdbf450c05868fb4da29bf61ae</commit_link><file_path>src/main/org/codehaus/groovy/sandbox/util/XmlSlurper.java</file_path><description>Extract Method private getTagFor(namespaceURI Object, current Map, pending Map, builder GroovyObject) : String extracted from public build(builder GroovyObject) : void in class org.codehaus.groovy.sandbox.util.XmlList</description><code_before>@@ -256,7 +256,7 @@ class XmlList extends GroovyObjectSupport implements Writable, Buildable {
   final Map attributes;
   final Map attributeNamespaces;
 	final Object[] children;
-	final String namespaceURI;
 	XmlList parent = null;
 	
     public XmlList(final String name, final Map attributes, final Map attributeNamespaces, final List body, final String namespaceURI) {
@@ -266,7 +266,7 @@ public XmlList(final String name, final Map attributes, final Map attributeNames
         this.attributes = attributes;
         this.attributeNamespaces = attributeNamespaces;
         this.children = body.toArray();
-        this.namespaceURI = namespaceURI;
     }
 
     public Object getProperty(final String elementName) {
@@ -440,51 +440,72 @@ public Object doCall(final Object o) {
 		}
 	};
 
-    // TODO: handle attributes in namespaces
-  	if (this.namespaceURI.length() == 0) {
   		builder.invokeMethod(this.name, new Object[]{this.attributes, rest});
     } else {
       builder.getProperty("mkp");
       final List namespaces = (List)builder.invokeMethod("getNamespaces", new Object[]{});
       
       final Map current = (Map)namespaces.get(0);
       final Map pending = (Map)namespaces.get(1);
-      String tag = findNamespaceTag(pending);
       
-      if (tag == null) {
-        tag = findNamespaceTag(current);
-        
-        if (tag == null) {
-        int suffix = 0;
         
-          do {
-          final String posibleTag = "tag" + suffix++;
-          
-            if (!pending.containsKey(posibleTag) &amp;&amp; !current.containsKey(posibleTag)) {
-              tag = posibleTag;
-            }
-          } while (tag == null);
         }
       }
-      
-      final Map newNamespace = new HashMap();
-      newNamespace.put(tag, this.namespaceURI);
-      builder.getProperty("mkp");
-      builder.invokeMethod("declareNamespace", new Object[]{newNamespace});
-      
-      builder.getProperty(tag);
-      builder.invokeMethod(this.name, new Object[]{this.attributes, rest});
     }		
 	}
   
-  private String findNamespaceTag(final Map tagMap) {
-      if (tagMap.containsValue(this.namespaceURI)) {
       final Iterator entries = tagMap.entrySet().iterator();
       
         while (entries.hasNext()) {
         final Map.Entry entry = (Map.Entry)entries.next();
         
-          if (this.namespaceURI.equals(entry.getValue())) {
             return (String)entry.getKey();
           }
         }
</code_before><code_after>@@ -256,7 +256,7 @@ class XmlList extends GroovyObjectSupport implements Writable, Buildable {
   final Map attributes;
   final Map attributeNamespaces;
 	final Object[] children;
+	final String elementNamespaceURI;
 	XmlList parent = null;
 	
     public XmlList(final String name, final Map attributes, final Map attributeNamespaces, final List body, final String namespaceURI) {
@@ -266,7 +266,7 @@ public XmlList(final String name, final Map attributes, final Map attributeNames
         this.attributes = attributes;
         this.attributeNamespaces = attributeNamespaces;
         this.children = body.toArray();
+        this.elementNamespaceURI = namespaceURI;
     }
 
     public Object getProperty(final String elementName) {
@@ -440,51 +440,72 @@ public Object doCall(final Object o) {
 		}
 	};
 
+  	if (this.elementNamespaceURI.length() == 0 &amp;&amp; this.attributeNamespaces.isEmpty()) {
   		builder.invokeMethod(this.name, new Object[]{this.attributes, rest});
     } else {
       builder.getProperty("mkp");
       final List namespaces = (List)builder.invokeMethod("getNamespaces", new Object[]{});
       
       final Map current = (Map)namespaces.get(0);
       final Map pending = (Map)namespaces.get(1);
       
+      if (this.attributeNamespaces.isEmpty()) {     
+        builder.getProperty(getTagFor(this.elementNamespaceURI, current, pending, builder));
+        builder.invokeMethod(this.name, new Object[]{this.attributes, rest});
+      } else {
+      final Map attributesWithNamespaces = new HashMap(this.attributes);
+      final Iterator attrs = this.attributes.keySet().iterator();
+      
+        while (attrs.hasNext()) {
+        final Object key = attrs.next();
+        final Object attributeNamespaceURI = this.attributeNamespaces.get(key);
         
+          if (attributeNamespaceURI != null) {
+            attributesWithNamespaces.put(getTagFor(attributeNamespaceURI, current, pending, builder) + "$" + key, attributesWithNamespaces.remove(key));
+          }
         }
+        
+        builder.getProperty(getTagFor(this.elementNamespaceURI, current, pending, builder));
+        builder.invokeMethod(this.name, new Object[]{attributesWithNamespaces, rest});
       }
     }		
 	}
   
+  private static String getTagFor(final Object namespaceURI, final Map current, final Map pending, final GroovyObject builder) {
+  String tag = findNamespaceTag(pending, namespaceURI);
+    
+    if (tag == null) {
+      tag = findNamespaceTag(current, namespaceURI);
+      
+      if (tag == null) {
+      int suffix = 0;
+      
+        do {
+        final String posibleTag = "tag" + suffix++;
+        
+          if (!pending.containsKey(posibleTag) &amp;&amp; !current.containsKey(posibleTag)) {
+            tag = posibleTag;
+          }
+        } while (tag == null);
+      }
+    }
+    
+    final Map newNamespace = new HashMap();
+    newNamespace.put(tag, namespaceURI);
+    builder.getProperty("mkp");
+    builder.invokeMethod("declareNamespace", new Object[]{newNamespace});
+    
+    return tag;
+  }
+  
+  private static String findNamespaceTag(final Map tagMap, final Object namespaceURI) {
+      if (tagMap.containsValue(namespaceURI)) {
       final Iterator entries = tagMap.entrySet().iterator();
       
         while (entries.hasNext()) {
         final Map.Entry entry = (Map.Entry)entries.next();
         
+          if (namespaceURI.equals(entry.getValue())) {
             return (String)entry.getKey();
           }
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>49830</refactoring_id><commit_sha>774f518ce76c061de454793436eb9716a7c71b54</commit_sha><commit_link>https://github.com/teammates/teammates/commit/774f518ce76c061de454793436eb9716a7c71b54</commit_link><file_path>src/main/java/teammates/ui/controller/AdminActivityLogPageData.java</file_path><description>Extract Method private getActionNameStringFromField(field Field) : String extracted from public printReference() : String in class teammates.ui.controller.AdminActivityLogPageData</description><code_before>@@ -8,6 +8,7 @@
 
 import teammates.common.datatransfer.AccountAttributes;
 import teammates.common.util.ActivityLogEntry;
 import teammates.common.util.Const;
 
 public class AdminActivityLogPageData extends PageData {
@@ -135,87 +136,106 @@ private QueryParameters parseQuery(String query) throws Exception{
         return q;
     }
     
-    public String printReference(){
         
-        List&lt;String&gt; instructorActions = new ArrayList&lt;String&gt;();
-        List&lt;String&gt; studentActions = new ArrayList&lt;String&gt;();
-        List&lt;String&gt; adminActions = new ArrayList&lt;String&gt;();
-        List&lt;String&gt; systemActions = new ArrayList&lt;String&gt;();
         
-       
-        for(Field field : Const.ActionURIs.class.getFields()){
-            
-            String rawActionString = "";
-            try {
-                rawActionString = field.get(Const.ActionURIs.class).toString();
-            } catch (IllegalArgumentException | IllegalAccessException e) {
-                e.printStackTrace();
-            }
-            
-            String[] splitedString = rawActionString.split("/");
-            String actionString = splitedString[splitedString.length - 1];
             
-            if(actionString.startsWith("instructor")){
-                instructorActions.add(actionString);
-            }else if(actionString.startsWith("student")){
-                studentActions.add(actionString);    
-            }else if(actionString.startsWith("admin")){
-                adminActions.add(actionString);
-            }else{
-                systemActions.add(actionString);    
             }
-            
         }
         
-        return assemblyReferenceString(instructorActions, 
-                                       studentActions,
-                                       adminActions, 
-                                       systemActions);
-             
     }
     
     
-    String assemblyReferenceString(List&lt;String&gt; instructorActions, List&lt;String&gt; studentActions, 
-                                   List&lt;String&gt; adminActions, List&lt;String&gt; systemActions){
         
-        String outPut="";
         
-        int size = instructorActions.size();
-        outPut += "&lt;tr&gt;";
-        outPut += getReferenceGroupFromList(instructorActions.subList(0, size / 6), null);
-        outPut += getReferenceGroupFromList(instructorActions.subList(size / 6, size * 2 / 6), null);
-        outPut += getReferenceGroupFromList(instructorActions.subList(size * 2 / 6, size * 3 / 6), null);
-        outPut += "&lt;/tr&gt;";
-        outPut += "&lt;tr&gt;";
-        outPut += getReferenceGroupFromList(instructorActions.subList(size * 3 / 6, size * 4 / 6), null);
-        outPut += getReferenceGroupFromList(instructorActions.subList(size * 4 / 6, size * 5 / 6), null);
-        outPut += getReferenceGroupFromList(instructorActions.subList(size * 5 / 6, size), null);
-        outPut += "&lt;/tr&gt;";          
-        outPut += "&lt;tr&gt;";
-        outPut += getReferenceGroupFromList(studentActions, "success"); 
-        outPut += getReferenceGroupFromList(systemActions, "warning"); 
-        outPut += getReferenceGroupFromList(adminActions, "danger"); 
-        outPut += "&lt;/tr&gt;";        
-        return outPut;    
     
     }
     
     
-    String getReferenceGroupFromList(List&lt;String&gt; actionList, String styleName){
         
-        String outPut = "";
         
-        String style = styleName != null ? "list-group-item-" + styleName : "";
         
-        outPut += "&lt;td&gt;";
-        outPut += "&lt;ul class=\"list-group\"&gt;";
-        for(String action : actionList){        
-            outPut += "&lt;li class=\"list-group-item " + style + "\"&gt;" + action + "&lt;/li&gt;";
-                                                              
-        } 
-        outPut += "&lt;/ul&gt;";
-        outPut += "&lt;/td&gt;";    
-        return outPut;
     }
     
     /**
</code_before><code_after>@@ -8,6 +8,7 @@
 
 import teammates.common.datatransfer.AccountAttributes;
 import teammates.common.util.ActivityLogEntry;
+import teammates.common.util.Assumption;
 import teammates.common.util.Const;
 
 public class AdminActivityLogPageData extends PageData {
@@ -135,87 +136,106 @@ private QueryParameters parseQuery(String query) throws Exception{
         return q;
     }
     
+    
+    /** 
+     * @return possible servlet requests list as html 
+     */
+    public String getActionListAsHtml(){       
+        List&lt;String&gt; allActionNames = getAllActionNames();   
         
+        int rowsPerCol = calculateRowsPerCol(allActionNames.size());
+        return convertActionListToHtml(allActionNames, rowsPerCol);
+    }
+    
+    
+    private String convertActionListToHtml(List&lt;String&gt; allActionNames, int rowsPerCol){
         
+        String outputHtml = "&lt;tr&gt;";      
+        int count = 0;      
+        for (int i = 0; i &lt; Const.TOTAL_COLUMNS; i++) {
             
+            outputHtml += "&lt;td&gt;";
+            outputHtml += "&lt;ul class=\"list-group\"&gt;";
+            for (int j = 0; j &lt; rowsPerCol; j++) {
+                
+                if(count &gt;= allActionNames.size()){
+                    break;
+                }
+                
+                outputHtml += "&lt;li class=\"list-group-item " 
+                              + getStyleForListGroupItem(allActionNames.get(count))
+                              + "\"&gt;" + allActionNames.get(count) + "&lt;/li&gt;";
+                              
+                count++;
             }
+            outputHtml += "&lt;/ul&gt;";
+            outputHtml += "&lt;/td&gt;";
         }
         
+       
+        return outputHtml;    
+
     }
     
     
+    private String getStyleForListGroupItem(String actionName){
+        
+        String style = "";
+        
+        if(actionName.startsWith("instructor")){
+            style = "list-group-item";
+        }else if(actionName.startsWith("student")){
+            style = "list-group-item-success";
+        }else if(actionName.startsWith("admin")){
+            style = "list-group-item-warning";
+        }else{
+            style = "list-group-item-danger";
+        }
+        
+        return style;
+    }
+    
+    private int calculateRowsPerCol(int totalNumOfActions){
+        
+        int rowsPerCol = totalNumOfActions / Const.TOTAL_COLUMNS;
+        int remainder = totalNumOfActions % Const.TOTAL_COLUMNS;
         
+        if(remainder &gt; 0){
+            rowsPerCol ++;
+        }
         
+        return rowsPerCol;
+    }
     
+     
+    private List&lt;String&gt; getAllActionNames(){
+       
+        List&lt;String&gt; actionNameList = new ArrayList&lt;String&gt;();
+        
+        for(Field field : Const.ActionURIs.class.getFields()){
+
+            String actionString = getActionNameStringFromField(field);
+            actionNameList.add(actionString);        
+        }
+        
+        return actionNameList;            
     }
     
     
+    private String getActionNameStringFromField(Field field){
         
+        String rawActionString = "";
+        
+        try {
+            rawActionString = field.get(Const.ActionURIs.class).toString();
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            Assumption.fail("Fail to get action URI");
+        }
         
+        String[] splitedString = rawActionString.split("/");
+        String actionString = splitedString[splitedString.length - 1];
         
+        return actionString;
     }
     
     /**
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>101470</refactoring_id><commit_sha>130d06a8549d132c09621e4e3bae551c32f17712</commit_sha><commit_link>https://github.com/cuba-platform/cuba/commit/130d06a8549d132c09621e4e3bae551c32f17712</commit_link><file_path>modules/web-widgets/src/com/haulmont/cuba/web/widgets/CubaTable.java</file_path><description>Extract Method protected getClickableColumnKeys(columnIds Collection&lt;Object&gt;) : String[] extracted from protected updateClickableColumnKeys() : void in class com.haulmont.cuba.web.widgets.CubaTable</description><code_before>@@ -71,6 +71,10 @@ public class CubaTable extends com.vaadin.v7.ui.Table implements TableSortableCo
 
     protected Set&lt;Object&gt; htmlCaptionColumns; // lazily initialized set
 
     protected AggregationStyle aggregationStyle = AggregationStyle.TOP;
     protected Object focusColumn;
     protected Object focusItem;
@@ -92,16 +96,20 @@ public class CubaTable extends com.vaadin.v7.ui.Table implements TableSortableCo
     public CubaTable() {
         registerRpc(new CubaTableServerRpc() {
             @Override
-            public void onClick(String columnKey, String rowKey) {
                 Object columnId = _columnIdMap().get(columnKey);
                 Object itemId = itemIdMapper.get(rowKey);
                 // itemId could be null if rendering in process
                 // If itemId is null it causes NPE
-                if (itemId != null &amp;&amp; cellClickListeners != null) {
-                    CellClickListener cellClickListener = cellClickListeners.get(columnId);
-                    if (cellClickListener != null) {
-                        cellClickListener.onClick(itemId, columnId);
                     }
                 }
             }
 
@@ -778,6 +786,34 @@ public void removeClickListener(Object propertyId) {
         }
     }
 
     @Override
     public boolean getColumnSortable(Object columnId) {
         return nonSortableProperties == null || !nonSortableProperties.contains(columnId);
@@ -829,6 +865,7 @@ public void beforeClientResponse(boolean initial) {
         super.beforeClientResponse(initial);
 
         updateClickableColumnKeys();
         updateColumnDescriptions();
         updateAggregatableTooltips();
         updateHtmlCaptionColumns();
@@ -871,15 +908,24 @@ protected void updateFooterAggregation() {
 
     protected void updateClickableColumnKeys() {
         if (cellClickListeners != null) {
-            String[] clickableColumnKeys = new String[cellClickListeners.size()];
-            int i = 0;
-            for (Object columnId : cellClickListeners.keySet()) {
-                clickableColumnKeys[i] = _columnIdMap().key(columnId);
-                i++;
-            }
 
-            getState().clickableColumnKeys = clickableColumnKeys;
         }
     }
 
     @Override
</code_before><code_after>@@ -71,6 +71,10 @@ public class CubaTable extends com.vaadin.v7.ui.Table implements TableSortableCo
 
     protected Set&lt;Object&gt; htmlCaptionColumns; // lazily initialized set
 
+    protected List&lt;Object&gt; clickableTableColumnIds; // lazily initialized list
+
+    protected Registration tableCellClickListenerRegistration;
+
     protected AggregationStyle aggregationStyle = AggregationStyle.TOP;
     protected Object focusColumn;
     protected Object focusItem;
@@ -92,16 +96,20 @@ public class CubaTable extends com.vaadin.v7.ui.Table implements TableSortableCo
     public CubaTable() {
         registerRpc(new CubaTableServerRpc() {
             @Override
+            public void onClick(String columnKey, String rowKey, boolean isText) {
                 Object columnId = _columnIdMap().get(columnKey);
                 Object itemId = itemIdMapper.get(rowKey);
                 // itemId could be null if rendering in process
                 // If itemId is null it causes NPE
+                if (itemId != null) {
+                    if (cellClickListeners != null &amp;&amp; isText) {
+                        CellClickListener cellClickListener = cellClickListeners.get(columnId);
+                        if (cellClickListener != null) {
+                            cellClickListener.onClick(itemId, columnId);
+                        }
                     }
+
+                    fireEvent(new TableCellClickEvent(CubaTable.this, itemId, columnId, isText));
                 }
             }
 
@@ -778,6 +786,34 @@ public void removeClickListener(Object propertyId) {
         }
     }
 
+    @Override
+    public void addTableCellClickListener(Object propertyId, TableCellClickListener listener) {
+        if (clickableTableColumnIds == null) {
+            clickableTableColumnIds = new ArrayList&lt;&gt;();
+        }
+        clickableTableColumnIds.add(propertyId);
+
+        // Register only one TableCellClickListener for all clickable table columns
+        if (tableCellClickListenerRegistration == null) {
+            tableCellClickListenerRegistration = addListener(TableCellClickEvent.class, listener, TableCellClickListener.clickMethod);
+        }
+    }
+
+    @Override
+    public void removeTableCellClickListener(Object propertyId) {
+        if (clickableTableColumnIds != null) {
+            clickableTableColumnIds.remove(propertyId);
+
+            if (tableCellClickListenerRegistration != null
+                    &amp;&amp; clickableTableColumnIds.isEmpty()) {
+                tableCellClickListenerRegistration.remove();
+                tableCellClickListenerRegistration = null;
+
+                clickableTableColumnIds = null;
+            }
+        }
+    }
+
     @Override
     public boolean getColumnSortable(Object columnId) {
         return nonSortableProperties == null || !nonSortableProperties.contains(columnId);
@@ -829,6 +865,7 @@ public void beforeClientResponse(boolean initial) {
         super.beforeClientResponse(initial);
 
         updateClickableColumnKeys();
+        updateClickableTableColumnKeys();
         updateColumnDescriptions();
         updateAggregatableTooltips();
         updateHtmlCaptionColumns();
@@ -871,15 +908,24 @@ protected void updateFooterAggregation() {
 
     protected void updateClickableColumnKeys() {
         if (cellClickListeners != null) {
+            getState().clickableColumnKeys = getClickableColumnKeys(cellClickListeners.keySet());
+        }
+    }
+
+    protected void updateClickableTableColumnKeys() {
+        if (clickableTableColumnIds != null) {
+            getState().clickableTableColumnKeys = getClickableColumnKeys(clickableTableColumnIds);
+        }
+    }
 
+    protected String[] getClickableColumnKeys(Collection&lt;Object&gt; columnIds) {
+        String[] clickableColumnKeys = new String[columnIds.size()];
+        int i = 0;
+        for (Object columnId : columnIds) {
+            clickableColumnKeys[i] = _columnIdMap().key(columnId);
+            i++;
         }
+        return clickableColumnKeys;
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>79647</refactoring_id><commit_sha>f161a447931f6903d38b95bc23b62b566ab5b045</commit_sha><commit_link>https://github.com/opentripplanner/opentripplanner/commit/f161a447931f6903d38b95bc23b62b566ab5b045</commit_link><file_path>src/main/java/org/opentripplanner/routing/api/request/preference/AccessibilityPreferences.java</file_path><description>Extract Method public toString(defaultCosts AccessibilityPreferences) : String extracted from public toString() : String in class org.opentripplanner.routing.api.request.preference.AccessibilityPreferences</description><code_before>@@ -38,6 +38,8 @@ private AccessibilityPreferences(
     this.inaccessibleCost = Units.cost(inaccessibleCost);
   }
 
   /**
    * Create a feature which only considers wheelchair-accessible trips/stops.
    */
@@ -92,14 +94,18 @@ public int hashCode() {
 
   @Override
   public String toString() {
     if (onlyConsiderAccessible) {
       return "OnlyConsiderAccessible";
     }
 
     return ToStringBuilder
       .of(AccessibilityPreferences.class)
-      .addCost("unknownCost", unknownCost, NOT_SET)
-      .addCost("inaccessibleCost", inaccessibleCost, NOT_SET)
       .toString();
   }
 }
</code_before><code_after>@@ -38,6 +38,8 @@ private AccessibilityPreferences(
     this.inaccessibleCost = Units.cost(inaccessibleCost);
   }
 
+  private static AccessibilityPreferences DEFAULT_UNSET = ofCost(NOT_SET, NOT_SET);
+
   /**
    * Create a feature which only considers wheelchair-accessible trips/stops.
    */
@@ -92,14 +94,18 @@ public int hashCode() {
 
   @Override
   public String toString() {
+    return toString(DEFAULT_UNSET);
+  }
+
+  public String toString(AccessibilityPreferences defaultCosts) {
     if (onlyConsiderAccessible) {
       return "OnlyConsiderAccessible";
     }
 
     return ToStringBuilder
       .of(AccessibilityPreferences.class)
+      .addCost("unknownCost", unknownCost, defaultCosts.unknownCost)
+      .addCost("inaccessibleCost", inaccessibleCost, defaultCosts.inaccessibleCost)
       .toString();
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>51111</refactoring_id><commit_sha>09fb4f78c9ffce753abd035f7754764d0a61ffa4</commit_sha><commit_link>https://github.com/spring-projects/spring-integration/commit/09fb4f78c9ffce753abd035f7754764d0a61ffa4</commit_link><file_path>spring-integration-core/src/main/java/org/springframework/integration/dispatcher/BroadcastingDispatcher.java</file_path><description>Extract Method private createMessageHandlingTask(handler MessageHandler, message Message&lt;?&gt;) : Runnable extracted from public dispatch(message Message&lt;?&gt;) : boolean in class org.springframework.integration.dispatcher.BroadcastingDispatcher</description><code_before>@@ -29,6 +29,8 @@
 import org.springframework.messaging.Message;
 import org.springframework.messaging.MessageHandler;
 import org.springframework.messaging.MessagingException;
 
 /**
  * A broadcasting dispatcher implementation. If the 'ignoreFailures' property is set to &lt;code&gt;false&lt;/code&gt; (the
@@ -62,6 +64,16 @@ public class BroadcastingDispatcher extends AbstractDispatcher implements BeanFa
 
 	private volatile boolean messageBuilderFactorySet;
 
 	private BeanFactory beanFactory;
 
 
@@ -117,6 +129,11 @@ public void setMinSubscribers(int minSubscribers) {
 		this.minSubscribers = minSubscribers;
 	}
 
 	@Override
 	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
 		this.beanFactory = beanFactory;
@@ -141,16 +158,18 @@ public boolean dispatch(Message&lt;?&gt; message) {
 			throw new MessageDispatchingException(message, "Dispatcher has no subscribers");
 		}
 		int sequenceSize = handlers.size();
-		for (final MessageHandler handler : handlers) {
-			final Message&lt;?&gt; messageToSend = (!this.applySequence) ? message : getMessageBuilderFactory().fromMessage(message)
-					.pushSequenceDetails(message.getHeaders().getId(), sequenceNumber++, sequenceSize).build();
 			if (this.executor != null) {
-				this.executor.execute(new Runnable() {
-					@Override
-					public void run() {
-						invokeHandler(handler, messageToSend);
-					}
-				});
 				dispatched++;
 			}
 			else {
@@ -170,6 +189,39 @@ public void run() {
 		return dispatched &gt;= minSubscribers;
 	}
 
 	private boolean invokeHandler(MessageHandler handler, Message&lt;?&gt; message) {
 		try {
 			handler.handleMessage(message);
</code_before><code_after>@@ -29,6 +29,8 @@
 import org.springframework.messaging.Message;
 import org.springframework.messaging.MessageHandler;
 import org.springframework.messaging.MessagingException;
+import org.springframework.messaging.support.MessageHandlingRunnable;
+import org.springframework.util.Assert;
 
 /**
  * A broadcasting dispatcher implementation. If the 'ignoreFailures' property is set to &lt;code&gt;false&lt;/code&gt; (the
@@ -62,6 +64,16 @@ public class BroadcastingDispatcher extends AbstractDispatcher implements BeanFa
 
 	private volatile boolean messageBuilderFactorySet;
 
+	private volatile MessageHandlingTaskDecorator messageHandlingTaskDecorator =
+			new MessageHandlingTaskDecorator() {
+
+				@Override
+				public Runnable decorate(MessageHandlingRunnable task) {
+					return task;
+				}
+
+			};
+
 	private BeanFactory beanFactory;
 
 
@@ -117,6 +129,11 @@ public void setMinSubscribers(int minSubscribers) {
 		this.minSubscribers = minSubscribers;
 	}
 
+	public void setMessageHandlingTaskDecorator(MessageHandlingTaskDecorator messageHandlingTaskDecorator) {
+		Assert.notNull(messageHandlingTaskDecorator, "'messageHandlingTaskDecorator' must not be null.");
+		this.messageHandlingTaskDecorator = messageHandlingTaskDecorator;
+	}
+
 	@Override
 	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
 		this.beanFactory = beanFactory;
@@ -141,16 +158,18 @@ public boolean dispatch(Message&lt;?&gt; message) {
 			throw new MessageDispatchingException(message, "Dispatcher has no subscribers");
 		}
 		int sequenceSize = handlers.size();
+		for (MessageHandler handler : handlers) {
+			Message&lt;?&gt; messageToSend = message;
+			if (this.applySequence) {
+				messageToSend = getMessageBuilderFactory()
+						.fromMessage(message)
+						.pushSequenceDetails(message.getHeaders().getId(), sequenceNumber++, sequenceSize)
+						.build();
+			}
+
 			if (this.executor != null) {
+				Runnable task = createMessageHandlingTask(handler, messageToSend);
+				this.executor.execute(task);
 				dispatched++;
 			}
 			else {
@@ -170,6 +189,39 @@ public void run() {
 		return dispatched &gt;= minSubscribers;
 	}
 
+
+	private Runnable createMessageHandlingTask(final MessageHandler handler, final Message&lt;?&gt; message) {
+		MessageHandlingRunnable task = new MessageHandlingRunnable() {
+
+			final MessageHandler delegate = new MessageHandler() {
+
+				@Override
+				public void handleMessage(Message&lt;?&gt; message) throws MessagingException {
+					invokeHandler(handler, message);
+				}
+
+			};
+
+			@Override
+			public void run() {
+				invokeHandler(handler, message);
+			}
+
+			@Override
+			public Message&lt;?&gt; getMessage() {
+				return message;
+			}
+
+			@Override
+			public MessageHandler getMessageHandler() {
+				return this.delegate;
+			}
+
+		};
+
+		return this.messageHandlingTaskDecorator.decorate(task);
+	}
+
 	private boolean invokeHandler(MessageHandler handler, Message&lt;?&gt; message) {
 		try {
 			handler.handleMessage(message);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>6552</refactoring_id><commit_sha>ce99b6f03966ffda81aec0050241b7c815556f96</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/ce99b6f03966ffda81aec0050241b7c815556f96</commit_link><file_path>plugins/org.jkiss.dbeaver.ui/src/org/jkiss/dbeaver/ui/controls/TextWithOpenFile.java</file_path><description>Extract Method public TextWithOpenFile(parent Composite, title String, filterExt String[], style int, binary boolean, secured boolean) extracted from public TextWithOpenFile(parent Composite, title String, filterExt String[], style int, binary boolean) in class org.jkiss.dbeaver.ui.controls.TextWithOpenFile</description><code_before>@@ -43,7 +43,11 @@ public class TextWithOpenFile extends TextWithOpen
     private boolean openFolder = false;
 
     public TextWithOpenFile(Composite parent, String title, String[] filterExt, int style, boolean binary) {
-        super(parent);
         this.title = title;
         this.filterExt = filterExt;
         this.style = style;
@@ -58,6 +62,10 @@ public TextWithOpenFile(Composite parent, String title, String[] filterExt, bool
         this(parent, title, filterExt, SWT.SINGLE | SWT.OPEN, binary);
     }
 
     public void setOpenFolder(boolean openFolder) {
         this.openFolder = openFolder;
     }
</code_before><code_after>@@ -43,7 +43,11 @@ public class TextWithOpenFile extends TextWithOpen
     private boolean openFolder = false;
 
     public TextWithOpenFile(Composite parent, String title, String[] filterExt, int style, boolean binary) {
+        this(parent, title, filterExt, style, binary, false);
+    }
+    
+    public TextWithOpenFile(Composite parent, String title, String[] filterExt, int style, boolean binary, boolean secured) {
+        super(parent, secured);
         this.title = title;
         this.filterExt = filterExt;
         this.style = style;
@@ -58,6 +62,10 @@ public TextWithOpenFile(Composite parent, String title, String[] filterExt, bool
         this(parent, title, filterExt, SWT.SINGLE | SWT.OPEN, binary);
     }
 
+    public TextWithOpenFile(Composite parent, String title, String[] filterExt, boolean binary, boolean secured) {
+        this(parent, title, filterExt, SWT.SINGLE | SWT.OPEN, binary, secured);
+    }
+
     public void setOpenFolder(boolean openFolder) {
         this.openFolder = openFolder;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>60970</refactoring_id><commit_sha>f9782192e8766ce5e7dcc4bdf703b407dbde401f</commit_sha><commit_link>https://github.com/groovy/groovy-core/commit/f9782192e8766ce5e7dcc4bdf703b407dbde401f</commit_link><file_path>src/main/groovy/ui/SystemOutputInterceptor.java</file_path><description>Extract Method public SystemOutputInterceptor(callback Closure, output boolean) extracted from public SystemOutputInterceptor(callback Closure) in class groovy.ui.SystemOutputInterceptor</description><code_before>@@ -23,13 +23,14 @@
 import java.io.PrintStream;
 
 /**
- * Intercepts System.out. Implementation helper for Console.groovy.
  *
  * @version $Id$
  */
 public class SystemOutputInterceptor extends FilterOutputStream {
 
     private Closure callback;
 
     /**
      * Constructor
@@ -40,26 +41,49 @@ public class SystemOutputInterceptor extends FilterOutputStream {
      *            System.out, otherwise it will not.
      */
     public SystemOutputInterceptor(final Closure callback) {
-        super(System.out);
         
         assert callback != null;
         
         this.callback = callback;
     }
 
     /**
-     * Starts intercepting System.out
      */
     public void start() {
-        System.setOut(new PrintStream(this));
     }
 
     /**
-     * Stops intercepting System.out, sending output to whereever it was
      * going when this interceptor was created.
      */
     public void stop() {
-        System.setOut((PrintStream) out);
     }
 
     /**
</code_before><code_after>@@ -23,13 +23,14 @@
 import java.io.PrintStream;
 
 /**
+ * Intercepts System.out/System.err. Implementation helper for Console.groovy.
  *
  * @version $Id$
  */
 public class SystemOutputInterceptor extends FilterOutputStream {
 
     private Closure callback;
+    private boolean output;
 
     /**
      * Constructor
@@ -40,26 +41,49 @@ public class SystemOutputInterceptor extends FilterOutputStream {
      *            System.out, otherwise it will not.
      */
     public SystemOutputInterceptor(final Closure callback) {
+        this(callback, true);
+    }
+
+    /**
+     * Constructor
+     * 
+     * @param callback
+     *            accepts a string to be sent to std out and returns a Boolean.
+     *            If the return value is true, output will be sent to
+     *            System.out/System.err, otherwise it will not.
+     * @param output
+     *            flag that tells whether System.out needs capturing ot System.err
+     */
+    public SystemOutputInterceptor(final Closure callback, boolean output) {
+        super(output ? System.out : System.err);
         
         assert callback != null;
         
         this.callback = callback;
+        this.output = output;
     }
 
     /**
+     * Starts intercepting System.out/System.err
      */
     public void start() {
+    	if(output) {
+            System.setOut(new PrintStream(this));
+    	} else {
+            System.setErr(new PrintStream(this));
+    	}
     }
 
     /**
+     * Stops intercepting System.out/System.err, sending output to whereever it was
      * going when this interceptor was created.
      */
     public void stop() {
+    	if(output) {
+            System.setOut((PrintStream) out);
+    	} else {
+            System.setErr((PrintStream) out);
+    	}
     }
 
     /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>115620</refactoring_id><commit_sha>9b5bc534ca9c40ce28c57b874f0d9f07b5c2fdd3</commit_sha><commit_link>https://github.com/bcgit/bc-java/commit/9b5bc534ca9c40ce28c57b874f0d9f07b5c2fdd3</commit_link><file_path>core/src/main/java/org/bouncycastle/crypto/params/RSAKeyParameters.java</file_path><description>Extract Method public RSAKeyParameters(isPrivate boolean, modulus BigInteger, exponent BigInteger, isInternal boolean) extracted from public RSAKeyParameters(isPrivate boolean, modulus BigInteger, exponent BigInteger) in class org.bouncycastle.crypto.params.RSAKeyParameters</description><code_before>@@ -2,11 +2,16 @@
 
 import java.math.BigInteger;
 
 import org.bouncycastle.util.Properties;
 
 public class RSAKeyParameters
     extends AsymmetricKeyParameter
 {
     // Hexadecimal value of the product of the 131 smallest odd primes from 3 to 743
     private static final BigInteger SMALL_PRIMES_PRODUCT = new BigInteger(
               "8138e8a0fcf3a4e84a771d40fd305d7f4aa59306d7251de54d98af8fe95729a1f"
@@ -24,6 +29,15 @@ public RSAKeyParameters(
         boolean     isPrivate,
         BigInteger  modulus,
         BigInteger  exponent)
     {
         super(isPrivate);
 
@@ -34,13 +48,20 @@ public RSAKeyParameters(
                 throw new IllegalArgumentException("RSA publicExponent is even");
             }
         }
-
-        this.modulus = validate(modulus);
         this.exponent = exponent;
-    }   
 
-    private BigInteger validate(BigInteger modulus)
     {
         if ((modulus.intValue() &amp; 1) == 0)
         {
             throw new IllegalArgumentException("RSA modulus is even");
@@ -53,13 +74,33 @@ private BigInteger validate(BigInteger modulus)
             return modulus;
         }
 
         if (!modulus.gcd(SMALL_PRIMES_PRODUCT).equals(ONE))
         {
             throw new IllegalArgumentException("RSA modulus has a small prime factor");
         }
 
-        // TODO: add additional primePower/Composite test - expensive!!
 
         return modulus;
     }
 
</code_before><code_after>@@ -2,11 +2,16 @@
 
 import java.math.BigInteger;
 
+import org.bouncycastle.crypto.CryptoServicesRegistrar;
+import org.bouncycastle.math.Primes;
+import org.bouncycastle.util.BigIntegers;
 import org.bouncycastle.util.Properties;
 
 public class RSAKeyParameters
     extends AsymmetricKeyParameter
 {
+    private static final BigIntegers.Cache validated = new BigIntegers.Cache();
+
     // Hexadecimal value of the product of the 131 smallest odd primes from 3 to 743
     private static final BigInteger SMALL_PRIMES_PRODUCT = new BigInteger(
               "8138e8a0fcf3a4e84a771d40fd305d7f4aa59306d7251de54d98af8fe95729a1f"
@@ -24,6 +29,15 @@ public RSAKeyParameters(
         boolean     isPrivate,
         BigInteger  modulus,
         BigInteger  exponent)
+    {
+        this(isPrivate, modulus, exponent, false);
+    }   
+
+    public RSAKeyParameters(
+        boolean     isPrivate,
+        BigInteger  modulus,
+        BigInteger  exponent,
+        boolean     isInternal)
     {
         super(isPrivate);
 
@@ -34,13 +48,20 @@ public RSAKeyParameters(
                 throw new IllegalArgumentException("RSA publicExponent is even");
             }
         }
+  
+        this.modulus = validated.contains(modulus) ? modulus : validate(modulus, isInternal);
         this.exponent = exponent;
+    }
 
+    private BigInteger validate(BigInteger modulus, boolean isInternal)
     {
+        if (isInternal)
+        {
+            validated.add(modulus);
+
+            return modulus;
+        }
+
         if ((modulus.intValue() &amp; 1) == 0)
         {
             throw new IllegalArgumentException("RSA modulus is even");
@@ -53,13 +74,33 @@ private BigInteger validate(BigInteger modulus)
             return modulus;
         }
 
+        int maxBitLength = Properties.asInteger("org.bouncycastle.rsa.max_size", 15360);
+
+        int qBitLength = modulus.bitLength();
+        if (maxBitLength &lt; qBitLength)
+        {
+            throw new IllegalArgumentException("modulus value out of range");
+        }
+
         if (!modulus.gcd(SMALL_PRIMES_PRODUCT).equals(ONE))
         {
             throw new IllegalArgumentException("RSA modulus has a small prime factor");
         }
 
+        int bits = modulus.bitLength() / 2;
+        int iterations = bits &gt;= 1536 ? 3
+            : bits &gt;= 1024 ? 4
+            : bits &gt;= 512 ? 7
+            : 50;
+
+        Primes.MROutput mr = Primes.enhancedMRProbablePrimeTest(modulus, CryptoServicesRegistrar.getSecureRandom(), iterations);
+        if (!mr.isProvablyComposite())
+        {
+            throw new IllegalArgumentException("RSA modulus is not composite");
+        }
 
+        validated.add(modulus);
+        
         return modulus;
     }
 
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>56756</refactoring_id><commit_sha>f062199bc53e1b119b49b39e96c77be3dc68613e</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/f062199bc53e1b119b49b39e96c77be3dc68613e</commit_link><file_path>CFML/src/com/intellij/coldFusion/UI/editorActions/structureView/CfmlStructureViewElement.java</file_path><description>Extract Method private collectResultsFromChildren(result Collection&lt;StructureViewTreeElement&gt;, element PsiElement) : void extracted from private collectResults(result Collection&lt;StructureViewTreeElement&gt;, element PsiElement) : void in class com.intellij.coldFusion.UI.editorActions.structureView.CfmlStructureViewElement</description><code_before>@@ -16,7 +16,6 @@
 package com.intellij.coldFusion.UI.editorActions.structureView;
 
 import com.intellij.coldFusion.model.files.CfmlFile;
-import com.intellij.coldFusion.model.info.CfmlFunctionDescription;
 import com.intellij.coldFusion.model.psi.CfmlComponent;
 import com.intellij.coldFusion.model.psi.CfmlFunction;
 import com.intellij.coldFusion.model.psi.CfmlTag;
@@ -43,18 +42,22 @@ protected CfmlStructureViewElement(final PsiElement psiElement) {
     super(psiElement);
   }
 
-  private void collectResults(Collection&lt;StructureViewTreeElement&gt; result, PsiElement element) {
     if (element instanceof CfmlComponent) {
       result.addAll(makeCollection(((CfmlComponent)element).getFunctions()));
     }
     else if (element instanceof CfmlFunction) {
       result.add(new CfmlStructureViewElement(element));
     }
     else if (element instanceof CfmlTag) {
-      final PsiElement[] children = element.getChildren();
-      for (PsiElement child : children) {
-        collectResults(result, child);
-      }
     }
   }
 
@@ -64,10 +67,7 @@ public Collection&lt;StructureViewTreeElement&gt; getChildrenBase() {
     Collection&lt;StructureViewTreeElement&gt; result = new LinkedList&lt;StructureViewTreeElement&gt;();
 
     if (element != null &amp;&amp; (element instanceof CfmlFile || !(element instanceof CfmlFunction))) {
-      final PsiElement[] children = element.getChildren();
-      for (PsiElement child : children) {
-        collectResults(result, child);
-      }
     }
 
     return result;
@@ -90,11 +90,7 @@ else if (element instanceof CfmlFile) {
     return "";
   }
 
-  public static String getParameterPresentation(CfmlFunctionDescription.CfmlParameterDescription param) {
-    return param.getPresetableText();
-  }
-
-  private Collection&lt;StructureViewTreeElement&gt; makeCollection(@Nullable PsiElement[] tags) {
     if (tags == null) {
       return Collections.emptyList();
     }
</code_before><code_after>@@ -16,7 +16,6 @@
 package com.intellij.coldFusion.UI.editorActions.structureView;
 
 import com.intellij.coldFusion.model.files.CfmlFile;
 import com.intellij.coldFusion.model.psi.CfmlComponent;
 import com.intellij.coldFusion.model.psi.CfmlFunction;
 import com.intellij.coldFusion.model.psi.CfmlTag;
@@ -43,18 +42,22 @@ protected CfmlStructureViewElement(final PsiElement psiElement) {
     super(psiElement);
   }
 
+  private static void collectResults(Collection&lt;StructureViewTreeElement&gt; result, PsiElement element) {
     if (element instanceof CfmlComponent) {
       result.addAll(makeCollection(((CfmlComponent)element).getFunctions()));
     }
     else if (element instanceof CfmlFunction) {
       result.add(new CfmlStructureViewElement(element));
     }
     else if (element instanceof CfmlTag) {
+      collectResultsFromChildren(result, element);
+    }
+  }
+
+  private static void collectResultsFromChildren(Collection&lt;StructureViewTreeElement&gt; result, PsiElement element) {
+    final PsiElement[] children = element.getChildren();
+    for (PsiElement child : children) {
+      collectResults(result, child);
     }
   }
 
@@ -64,10 +67,7 @@ public Collection&lt;StructureViewTreeElement&gt; getChildrenBase() {
     Collection&lt;StructureViewTreeElement&gt; result = new LinkedList&lt;StructureViewTreeElement&gt;();
 
     if (element != null &amp;&amp; (element instanceof CfmlFile || !(element instanceof CfmlFunction))) {
+      collectResultsFromChildren(result, element);
     }
 
     return result;
@@ -90,11 +90,7 @@ else if (element instanceof CfmlFile) {
     return "";
   }
 
+  private static Collection&lt;StructureViewTreeElement&gt; makeCollection(@Nullable PsiElement[] tags) {
     if (tags == null) {
       return Collections.emptyList();
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>84340</refactoring_id><commit_sha>47c1404865b6c1455de6aad825cc70c45d2ba5be</commit_sha><commit_link>https://github.com/google/exoplayer/commit/47c1404865b6c1455de6aad825cc70c45d2ba5be</commit_link><file_path>library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java</file_path><description>Extract Method private maybeStartWatchingRequirements() : void extracted from public onCreate() : void in class com.google.android.exoplayer2.offline.DownloadService</description><code_before>@@ -187,17 +187,6 @@ public void onCreate() {
     downloadManager = getDownloadManager();
     downloadManagerListener = new DownloadManagerListener();
     downloadManager.addListener(downloadManagerListener);
-
-    RequirementsHelper requirementsHelper;
-    synchronized (requirementsHelpers) {
-      Class&lt;? extends DownloadService&gt; clazz = getClass();
-      requirementsHelper = requirementsHelpers.get(clazz);
-      if (requirementsHelper == null) {
-        requirementsHelper = new RequirementsHelper(this, getRequirements(), getScheduler(), clazz);
-        requirementsHelpers.put(clazz, requirementsHelper);
-      }
-    }
-    requirementsHelper.start();
   }
 
   @Override
@@ -237,6 +226,7 @@ public int onStartCommand(Intent intent, int flags, int startId) {
         Log.e(TAG, "Ignoring unrecognized action: " + intentAction);
         break;
     }
     if (downloadManager.isIdle()) {
       stop();
     }
@@ -248,14 +238,7 @@ public void onDestroy() {
     logd("onDestroy");
     foregroundNotificationUpdater.stopPeriodicUpdates();
     downloadManager.removeListener(downloadManagerListener);
-    if (downloadManager.getTaskCount() == 0) {
-      synchronized (requirementsHelpers) {
-        RequirementsHelper requirementsHelper = requirementsHelpers.remove(getClass());
-        if (requirementsHelper != null) {
-          requirementsHelper.stop();
-        }
-      }
-    }
   }
 
   @Nullable
@@ -312,6 +295,31 @@ protected void onTaskStateChanged(TaskState taskState) {
     // Do nothing.
   }
 
   private void stop() {
     foregroundNotificationUpdater.stopPeriodicUpdates();
     // Make sure startForeground is called before stopping. Workaround for [Internal: b/69424260].
@@ -331,7 +339,7 @@ private void logd(String message) {
   private final class DownloadManagerListener implements DownloadManager.Listener {
     @Override
     public void onInitialized(DownloadManager downloadManager) {
-      // Do nothing.
     }
 
     @Override
</code_before><code_after>@@ -187,17 +187,6 @@ public void onCreate() {
     downloadManager = getDownloadManager();
     downloadManagerListener = new DownloadManagerListener();
     downloadManager.addListener(downloadManagerListener);
   }
 
   @Override
@@ -237,6 +226,7 @@ public int onStartCommand(Intent intent, int flags, int startId) {
         Log.e(TAG, "Ignoring unrecognized action: " + intentAction);
         break;
     }
+    maybeStartWatchingRequirements();
     if (downloadManager.isIdle()) {
       stop();
     }
@@ -248,14 +238,7 @@ public void onDestroy() {
     logd("onDestroy");
     foregroundNotificationUpdater.stopPeriodicUpdates();
     downloadManager.removeListener(downloadManagerListener);
+    maybeStopWatchingRequirements();
   }
 
   @Nullable
@@ -312,6 +295,31 @@ protected void onTaskStateChanged(TaskState taskState) {
     // Do nothing.
   }
 
+  private void maybeStartWatchingRequirements() {
+    if (downloadManager.getDownloadCount() == 0) {
+      return;
+    }
+    Class&lt;? extends DownloadService&gt; clazz = getClass();
+    RequirementsHelper requirementsHelper = requirementsHelpers.get(clazz);
+    if (requirementsHelper == null) {
+      requirementsHelper = new RequirementsHelper(this, getRequirements(), getScheduler(), clazz);
+      requirementsHelpers.put(clazz, requirementsHelper);
+      requirementsHelper.start();
+      logd("started watching requirements");
+    }
+  }
+
+  private void maybeStopWatchingRequirements() {
+    if (downloadManager.getDownloadCount() &gt; 0) {
+      return;
+    }
+    RequirementsHelper requirementsHelper = requirementsHelpers.remove(getClass());
+    if (requirementsHelper != null) {
+      requirementsHelper.stop();
+      logd("stopped watching requirements");
+    }
+  }
+
   private void stop() {
     foregroundNotificationUpdater.stopPeriodicUpdates();
     // Make sure startForeground is called before stopping. Workaround for [Internal: b/69424260].
@@ -331,7 +339,7 @@ private void logd(String message) {
   private final class DownloadManagerListener implements DownloadManager.Listener {
     @Override
     public void onInitialized(DownloadManager downloadManager) {
+      maybeStartWatchingRequirements();
     }
 
     @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>112373</refactoring_id><commit_sha>9e76585f1fa110288604913a73d86ac2f1542777</commit_sha><commit_link>https://github.com/apache/flink/commit/9e76585f1fa110288604913a73d86ac2f1542777</commit_link><file_path>flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/common/CommonExecSink.java</file_path><description>Extract Method private applyKeyBy(config TableConfig, inputTransform Transformation&lt;RowData&gt;, primaryKeys int[], sinkParallelism int, inputParallelism int, inputInsertOnly boolean, needMaterialize boolean) : Transformation&lt;RowData&gt; extracted from protected createSinkTransformation(planner PlannerBase, inputTransform Transformation&lt;RowData&gt;, rowtimeFieldIndex int, upsertMaterialize boolean) : Transformation&lt;Object&gt; in class org.apache.flink.table.planner.plan.nodes.exec.common.CommonExecSink</description><code_before>@@ -120,31 +120,48 @@ protected Transformation&lt;Object&gt; createSinkTransformation(
             int rowtimeFieldIndex,
             boolean upsertMaterialize) {
         final DynamicTableSink tableSink = tableSinkSpec.getTableSink(planner.getFlinkContext());
-        final ChangelogMode changelogMode = tableSink.getChangelogMode(inputChangelogMode);
         final ResolvedSchema schema = tableSinkSpec.getCatalogTable().getResolvedSchema();
-
         final SinkRuntimeProvider runtimeProvider =
                 tableSink.getSinkRuntimeProvider(new SinkRuntimeProviderContext(isBounded));
-
         final RowType physicalRowType = getPhysicalRowType(schema);
-
         final int[] primaryKeys = getPrimaryKeyIndices(physicalRowType, schema);
-
         final int sinkParallelism = deriveSinkParallelism(inputTransform, runtimeProvider);
 
         Transformation&lt;RowData&gt; sinkTransform =
                 applyConstraintValidations(
                         inputTransform, planner.getTableConfig(), physicalRowType);
 
-        sinkTransform =
-                applyKeyBy(
-                        changelogMode,
-                        sinkTransform,
-                        primaryKeys,
-                        sinkParallelism,
-                        upsertMaterialize);
 
-        if (upsertMaterialize) {
             sinkTransform =
                     applyUpsertMaterialize(
                             sinkTransform,
@@ -280,26 +297,29 @@ private int deriveSinkParallelism(
      * messages.
      */
     private Transformation&lt;RowData&gt; applyKeyBy(
-            ChangelogMode changelogMode,
             Transformation&lt;RowData&gt; inputTransform,
             int[] primaryKeys,
             int sinkParallelism,
-            boolean upsertMaterialize) {
-        final int inputParallelism = inputTransform.getParallelism();
-        if ((inputParallelism == sinkParallelism || changelogMode.containsOnly(RowKind.INSERT))
-                &amp;&amp; !upsertMaterialize) {
-            return inputTransform;
         }
-        if (primaryKeys.length == 0) {
-            throw new TableException(
-                    String.format(
-                            "The sink for table '%s' has a configured parallelism of %s, while the input parallelism is %s. "
-                                    + "Since the configured parallelism is different from the input's parallelism and "
-                                    + "the changelog mode is not insert-only, a primary key is required but could not "
-                                    + "be found.",
-                            tableSinkSpec.getObjectIdentifier().asSummaryString(),
-                            sinkParallelism,
-                            inputParallelism));
         }
 
         final RowDataKeySelector selector =
</code_before><code_after>@@ -120,31 +120,48 @@ protected Transformation&lt;Object&gt; createSinkTransformation(
             int rowtimeFieldIndex,
             boolean upsertMaterialize) {
         final DynamicTableSink tableSink = tableSinkSpec.getTableSink(planner.getFlinkContext());
         final ResolvedSchema schema = tableSinkSpec.getCatalogTable().getResolvedSchema();
         final SinkRuntimeProvider runtimeProvider =
                 tableSink.getSinkRuntimeProvider(new SinkRuntimeProviderContext(isBounded));
         final RowType physicalRowType = getPhysicalRowType(schema);
         final int[] primaryKeys = getPrimaryKeyIndices(physicalRowType, schema);
         final int sinkParallelism = deriveSinkParallelism(inputTransform, runtimeProvider);
+        final int inputParallelism = inputTransform.getParallelism();
+        final boolean inputInsertOnly = inputChangelogMode.containsOnly(RowKind.INSERT);
+        final boolean hasPk = primaryKeys.length &gt; 0;
+
+        if (!inputInsertOnly &amp;&amp; sinkParallelism != inputParallelism &amp;&amp; !hasPk) {
+            throw new TableException(
+                    String.format(
+                            "The sink for table '%s' has a configured parallelism of %s, while the input parallelism is %s. "
+                                    + "Since the configured parallelism is different from the input's parallelism and "
+                                    + "the changelog mode is not insert-only, a primary key is required but could not "
+                                    + "be found.",
+                            tableSinkSpec.getObjectIdentifier().asSummaryString(),
+                            sinkParallelism,
+                            inputParallelism));
+        }
+
+        // only add materialization if input has change
+        final boolean needMaterialization = !inputInsertOnly &amp;&amp; upsertMaterialize;
 
         Transformation&lt;RowData&gt; sinkTransform =
                 applyConstraintValidations(
                         inputTransform, planner.getTableConfig(), physicalRowType);
 
+        if (hasPk) {
+            sinkTransform =
+                    applyKeyBy(
+                            planner.getTableConfig(),
+                            sinkTransform,
+                            primaryKeys,
+                            sinkParallelism,
+                            inputParallelism,
+                            inputInsertOnly,
+                            needMaterialization);
+        }
 
+        if (needMaterialization) {
             sinkTransform =
                     applyUpsertMaterialize(
                             sinkTransform,
@@ -280,26 +297,29 @@ private int deriveSinkParallelism(
      * messages.
      */
     private Transformation&lt;RowData&gt; applyKeyBy(
+            TableConfig config,
             Transformation&lt;RowData&gt; inputTransform,
             int[] primaryKeys,
             int sinkParallelism,
+            int inputParallelism,
+            boolean inputInsertOnly,
+            boolean needMaterialize) {
+        final ExecutionConfigOptions.SinkKeyedShuffle sinkShuffleByPk =
+                config.getConfiguration().get(ExecutionConfigOptions.TABLE_EXEC_SINK_KEYED_SHUFFLE);
+        boolean sinkKeyBy = false;
+        switch (sinkShuffleByPk) {
+            case NONE:
+                break;
+            case AUTO:
+                sinkKeyBy = inputInsertOnly &amp;&amp; sinkParallelism != inputParallelism;
+                break;
+            case FORCE:
+                // single parallelism has no problem
+                sinkKeyBy = sinkParallelism != 1 || inputParallelism != 1;
+                break;
         }
+        if (!sinkKeyBy &amp;&amp; !needMaterialize) {
+            return inputTransform;
         }
 
         final RowDataKeySelector selector =
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>13462</refactoring_id><commit_sha>a764638b589ed1dc214e7f4b78342b003b55c103</commit_sha><commit_link>https://github.com/pentaho/pentaho-kettle/commit/a764638b589ed1dc214e7f4b78342b003b55c103</commit_link><file_path>experimental_test/org/pentaho/di/run/TimedTransRunner.java</file_path><description>Extract Method public init() : void extracted from public runOldAndNew() : void in class org.pentaho.di.run.TimedTransRunner</description><code_before>@@ -44,18 +44,23 @@ public TimedTransRunner(String filename, int logLevel, long records)
     }
     
     public void runOldAndNew() throws KettleXMLException
     {
         EnvUtil.environmentInit();
         LogWriter.getInstance(logLevel);
         
         // Set environment variables ${NR_OF_ROWS}
         //
         KettleVariables.getInstance().setVariable("NR_OF_ROWS", Long.toString(records));
-        
-        runOldEngine();
-        runNewEngine();
-        
-        compareResults();
     }
 
     public void runOldEngine() throws KettleXMLException
@@ -143,7 +148,7 @@ public void runNewEngine() throws KettleXMLException
     
     private static DecimalFormat factorDF = new DecimalFormat("##0.00");
     
-    private void compareResults()
     {
         double factor = oldRunTime/newRunTime;
         System.out.println("V3 / V2 = x"+factorDF.format(factor));
</code_before><code_after>@@ -44,18 +44,23 @@ public TimedTransRunner(String filename, int logLevel, long records)
     }
     
     public void runOldAndNew() throws KettleXMLException
+    {
+        init();
+        
+        runOldEngine();
+        runNewEngine();
+        
+        compareResults();
+    }
+
+    public void init()
     {
         EnvUtil.environmentInit();
         LogWriter.getInstance(logLevel);
         
         // Set environment variables ${NR_OF_ROWS}
         //
         KettleVariables.getInstance().setVariable("NR_OF_ROWS", Long.toString(records));
     }
 
     public void runOldEngine() throws KettleXMLException
@@ -143,7 +148,7 @@ public void runNewEngine() throws KettleXMLException
     
     private static DecimalFormat factorDF = new DecimalFormat("##0.00");
     
+    public void compareResults()
     {
         double factor = oldRunTime/newRunTime;
         System.out.println("V3 / V2 = x"+factorDF.format(factor));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>111515</refactoring_id><commit_sha>6f0d07633a5c8e6511f3d16e04561cb277b65407</commit_sha><commit_link>https://github.com/apache/flink/commit/6f0d07633a5c8e6511f3d16e04561cb277b65407</commit_link><file_path>flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/assigners/SlidingEventTimeWindows.java</file_path><description>Extract Method public of(size Duration, slide Duration) : SlidingEventTimeWindows extracted from public of(size Time, slide Time) : SlidingEventTimeWindows in class org.apache.flink.streaming.api.windowing.assigners.SlidingEventTimeWindows</description><code_before>@@ -27,6 +27,7 @@
 import org.apache.flink.streaming.api.windowing.triggers.Trigger;
 import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -41,7 +42,7 @@
  * DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; in = ...;
  * KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; keyed = in.keyBy(...);
  * WindowedStream&lt;Tuple2&lt;String, Integer&gt;, String, TimeWindow&gt; windowed =
- *   keyed.window(SlidingEventTimeWindows.of(Time.minutes(1), Time.seconds(10)));
  * }&lt;/pre&gt;
  */
 @PublicEvolving
@@ -115,9 +116,23 @@ public String toString() {
      * @param size The size of the generated windows.
      * @param slide The slide interval of the generated windows.
      * @return The time policy.
      */
     public static SlidingEventTimeWindows of(Time size, Time slide) {
-        return new SlidingEventTimeWindows(size.toMilliseconds(), slide.toMilliseconds(), 0);
     }
 
     /**
@@ -138,10 +153,34 @@ public static SlidingEventTimeWindows of(Time size, Time slide) {
      * @param slide The slide interval of the generated windows.
      * @param offset The offset which window start would be shifted by.
      * @return The time policy.
      */
     public static SlidingEventTimeWindows of(Time size, Time slide, Time offset) {
-        return new SlidingEventTimeWindows(
-                size.toMilliseconds(), slide.toMilliseconds(), offset.toMilliseconds());
     }
 
     @Override
</code_before><code_after>@@ -27,6 +27,7 @@
 import org.apache.flink.streaming.api.windowing.triggers.Trigger;
 import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -41,7 +42,7 @@
  * DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; in = ...;
  * KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; keyed = in.keyBy(...);
  * WindowedStream&lt;Tuple2&lt;String, Integer&gt;, String, TimeWindow&gt; windowed =
+ *   keyed.window(SlidingEventTimeWindows.of(Duration.ofMinutes(1), Duration.ofSeconds(10)));
  * }&lt;/pre&gt;
  */
 @PublicEvolving
@@ -115,9 +116,23 @@ public String toString() {
      * @param size The size of the generated windows.
      * @param slide The slide interval of the generated windows.
      * @return The time policy.
+     * @deprecated Use {@link #of(Duration, Duration)}
      */
+    @Deprecated
     public static SlidingEventTimeWindows of(Time size, Time slide) {
+        return of(size.toDuration(), slide.toDuration());
+    }
+
+    /**
+     * Creates a new {@code SlidingEventTimeWindows} {@link WindowAssigner} that assigns elements to
+     * sliding time windows based on the element timestamp.
+     *
+     * @param size The size of the generated windows.
+     * @param slide The slide interval of the generated windows.
+     * @return The time policy.
+     */
+    public static SlidingEventTimeWindows of(Duration size, Duration slide) {
+        return new SlidingEventTimeWindows(size.toMillis(), slide.toMillis(), 0);
     }
 
     /**
@@ -138,10 +153,34 @@ public static SlidingEventTimeWindows of(Time size, Time slide) {
      * @param slide The slide interval of the generated windows.
      * @param offset The offset which window start would be shifted by.
      * @return The time policy.
+     * @deprecated Use {@link #of(Duration, Duration, Duration)}
      */
+    @Deprecated
     public static SlidingEventTimeWindows of(Time size, Time slide, Time offset) {
+        return of(size.toDuration(), slide.toDuration(), offset.toDuration());
+    }
+
+    /**
+     * Creates a new {@code SlidingEventTimeWindows} {@link WindowAssigner} that assigns elements to
+     * time windows based on the element timestamp and offset.
+     *
+     * &lt;p&gt;For example, if you want window a stream by hour,but window begins at the 15th minutes of
+     * each hour, you can use {@code of(Duration.ofHours(1), Duration.ofMinutes(15))}, then you will
+     * get time windows start at 0:15:00,1:15:00,2:15:00,etc.
+     *
+     * &lt;p&gt;Rather than that,if you are living in somewhere which is not using UTC&#xB1;00:00 time, such as
+     * China which is using UTC+08:00,and you want a time window with size of one day, and window
+     * begins at every 00:00:00 of local time,you may use {@code of(Duration.ofDays(1),
+     * Duration.ofHours(-8))}. The parameter of offset is {@code Duration.ofHours(-8))} since
+     * UTC+08:00 is 8 hours earlier than UTC time.
+     *
+     * @param size The size of the generated windows.
+     * @param slide The slide interval of the generated windows.
+     * @param offset The offset which window start would be shifted by.
+     * @return The time policy.
+     */
+    public static SlidingEventTimeWindows of(Duration size, Duration slide, Duration offset) {
+        return new SlidingEventTimeWindows(size.toMillis(), slide.toMillis(), offset.toMillis());
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>37010</refactoring_id><commit_sha>4dff953c0b03e6b09162ac92edac8fdebc7adc4b</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/4dff953c0b03e6b09162ac92edac8fdebc7adc4b</commit_link><file_path>OsmAnd/src/net/osmand/plus/importfiles/ui/ImportTracksFragment.java</file_path><description>Extract Method private dismissAndOpenTracks() : void extracted from public onImportAsOneTrackClicked() : void in class net.osmand.plus.importfiles.ui.ImportTracksFragment</description><code_before>@@ -32,20 +32,21 @@
 import androidx.recyclerview.widget.LinearLayoutManager;
 import androidx.recyclerview.widget.RecyclerView;
 
 import net.osmand.gpx.GPXFile;
 import net.osmand.gpx.GPXUtilities.WptPt;
-import net.osmand.PlatformUtil;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.base.BaseOsmAndDialogFragment;
 import net.osmand.plus.helpers.AndroidUiHelper;
-import net.osmand.plus.importfiles.CollectTracksTask;
-import net.osmand.plus.importfiles.CollectTracksTask.CollectTracksListener;
 import net.osmand.plus.importfiles.ImportHelper;
-import net.osmand.plus.importfiles.SaveGpxAsyncTask;
 import net.osmand.plus.importfiles.SaveImportedGpxListener;
-import net.osmand.plus.importfiles.SaveTracksTask;
 import net.osmand.plus.importfiles.ui.ExitImportBottomSheet.OnExitConfirmedListener;
 import net.osmand.plus.importfiles.ui.ImportTracksAdapter.ImportTracksListener;
 import net.osmand.plus.importfiles.ui.SelectPointsFragment.PointsSelectionListener;
@@ -316,7 +317,7 @@ public void onImportAsOneTrackClicked() {
 		String existingFilePath = ImportHelper.getExistingFilePath(app, fileName, fileSize);
 		if (existingFilePath != null) {
 			app.showToastMessage(R.string.file_already_imported);
-			openTracksTabInMyPlaces();
 		} else {
 			File destinationDir = getFolderFile(selectedFolder);
 			SaveImportedGpxListener saveGpxListener = getSaveGpxListener(() -&gt; saveAsOneTrackTask = null);
@@ -447,11 +448,22 @@ public void onGpxSavingStarted() {
 			public void onGpxSavingFinished(@NonNull List&lt;String&gt; warnings) {
 				clearTaskCallback.run();
 				updateProgress();
-				openTracksTabInMyPlaces();
 			}
 		};
 	}
 
 	private void openTracksTabInMyPlaces() {
 		FragmentActivity activity = getActivity();
 		if (activity != null) {
@@ -464,7 +476,6 @@ private void openTracksTabInMyPlaces() {
 			intent.putExtra(MapActivity.INTENT_PARAMS, bundle);
 			activity.startActivity(intent);
 		}
-		dismissAllowingStateLoss();
 	}
 
 	@Nullable
</code_before><code_after>@@ -32,20 +32,21 @@
 import androidx.recyclerview.widget.LinearLayoutManager;
 import androidx.recyclerview.widget.RecyclerView;
 
+import net.osmand.PlatformUtil;
 import net.osmand.gpx.GPXFile;
 import net.osmand.gpx.GPXUtilities.WptPt;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.base.BaseOsmAndDialogFragment;
+import net.osmand.plus.configmap.tracks.TracksFragment;
 import net.osmand.plus.helpers.AndroidUiHelper;
 import net.osmand.plus.importfiles.ImportHelper;
 import net.osmand.plus.importfiles.SaveImportedGpxListener;
+import net.osmand.plus.importfiles.tasks.CollectTracksTask;
+import net.osmand.plus.importfiles.tasks.CollectTracksTask.CollectTracksListener;
+import net.osmand.plus.importfiles.tasks.SaveGpxAsyncTask;
+import net.osmand.plus.importfiles.tasks.SaveTracksTask;
 import net.osmand.plus.importfiles.ui.ExitImportBottomSheet.OnExitConfirmedListener;
 import net.osmand.plus.importfiles.ui.ImportTracksAdapter.ImportTracksListener;
 import net.osmand.plus.importfiles.ui.SelectPointsFragment.PointsSelectionListener;
@@ -316,7 +317,7 @@ public void onImportAsOneTrackClicked() {
 		String existingFilePath = ImportHelper.getExistingFilePath(app, fileName, fileSize);
 		if (existingFilePath != null) {
 			app.showToastMessage(R.string.file_already_imported);
+			dismissAndOpenTracks();
 		} else {
 			File destinationDir = getFolderFile(selectedFolder);
 			SaveImportedGpxListener saveGpxListener = getSaveGpxListener(() -&gt; saveAsOneTrackTask = null);
@@ -447,11 +448,22 @@ public void onGpxSavingStarted() {
 			public void onGpxSavingFinished(@NonNull List&lt;String&gt; warnings) {
 				clearTaskCallback.run();
 				updateProgress();
+				dismissAndOpenTracks();
 			}
 		};
 	}
 
+	private void dismissAndOpenTracks() {
+		MapActivity mapActivity = getMapActivity();
+		TracksFragment fragment = mapActivity != null ? mapActivity.getFragment(TracksFragment.TAG) : null;
+		if (fragment != null) {
+			fragment.reloadTracks();
+		} else {
+			openTracksTabInMyPlaces();
+		}
+		dismissAllowingStateLoss();
+	}
+
 	private void openTracksTabInMyPlaces() {
 		FragmentActivity activity = getActivity();
 		if (activity != null) {
@@ -464,7 +476,6 @@ private void openTracksTabInMyPlaces() {
 			intent.putExtra(MapActivity.INTENT_PARAMS, bundle);
 			activity.startActivity(intent);
 		}
 	}
 
 	@Nullable
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>123506</refactoring_id><commit_sha>c5cf0781d48a319098891e8a16e36633955fe56a</commit_sha><commit_link>https://github.com/oracle/graal/commit/c5cf0781d48a319098891e8a16e36633955fe56a</commit_link><file_path>graal/com.oracle.graal.loop/src/com/oracle/graal/loop/LoopFragment.java</file_path><description>Extract Method protected computeNodes(nodes NodeBitMap, graph Graph, blocks Iterable&lt;AbstractBeginNode&gt;, earlyExits Iterable&lt;LoopExitNode&gt;) : void extracted from protected computeNodes(graph Graph, blocks Iterable&lt;AbstractBeginNode&gt;, earlyExits Iterable&lt;LoopExitNode&gt;) : NodeBitMap in class com.oracle.graal.loop.LoopFragment</description><code_before>@@ -176,6 +176,11 @@ protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode
 
     protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;LoopExitNode&gt; earlyExits) {
         final NodeBitMap nodes = graph.createNodeBitMap();
         for (AbstractBeginNode b : blocks) {
             if (b.isDeleted()) {
                 continue;
@@ -227,8 +232,6 @@ protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode
                 }
             }
         }
-
-        return nodes;
     }
 
     private static boolean markFloating(Node n, NodeBitMap loopNodes, NodeBitMap notloopNodes) {
@@ -358,7 +361,7 @@ protected void mergeEarlyExits() {
                  * VirtualState nodes contained in the old exit's state may be shared by other
                  * dominated VirtualStates. Those dominated virtual states need to see the
                  * proxy-&gt;phi update that are applied below.
-                 * 
                  * We now update the original fragment's nodes accordingly:
                  */
                 originalExitState.applyToVirtual(node -&gt; original.nodes.clearAndGrow(node));
</code_before><code_after>@@ -176,6 +176,11 @@ protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode
 
     protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;LoopExitNode&gt; earlyExits) {
         final NodeBitMap nodes = graph.createNodeBitMap();
+        computeNodes(nodes, graph, blocks, earlyExits);
+        return nodes;
+    }
+
+    protected static void computeNodes(NodeBitMap nodes, Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;LoopExitNode&gt; earlyExits) {
         for (AbstractBeginNode b : blocks) {
             if (b.isDeleted()) {
                 continue;
@@ -227,8 +232,6 @@ protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode
                 }
             }
         }
     }
 
     private static boolean markFloating(Node n, NodeBitMap loopNodes, NodeBitMap notloopNodes) {
@@ -358,7 +361,7 @@ protected void mergeEarlyExits() {
                  * VirtualState nodes contained in the old exit's state may be shared by other
                  * dominated VirtualStates. Those dominated virtual states need to see the
                  * proxy-&gt;phi update that are applied below.
+                 *
                  * We now update the original fragment's nodes accordingly:
                  */
                 originalExitState.applyToVirtual(node -&gt; original.nodes.clearAndGrow(node));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>101294</refactoring_id><commit_sha>8581c4ca9617bd8112ece9c815b3c0224e65a307</commit_sha><commit_link>https://github.com/cuba-platform/cuba/commit/8581c4ca9617bd8112ece9c815b3c0224e65a307</commit_link><file_path>modules/core/src/com/haulmont/cuba/core/global/ScriptingProvider.java</file_path><description>Extract Method public getResourceAsStream(name String) : InputStream extracted from public getGroovyScriptEngine() : GroovyScriptEngine in class com.haulmont.cuba.core.global.ScriptingProvider</description><code_before>@@ -14,6 +14,9 @@
 import groovy.util.ResourceException;
 import groovy.util.ScriptException;
 import groovy.lang.Binding;
 
 public abstract class ScriptingProvider {
 
@@ -42,15 +45,17 @@ private static ScriptingProvider getInstance() {
         return instance;
     }
 
-    public static GroovyScriptEngine getGroovyScriptEngine() {
-        return getInstance().__getGroovyScriptEngine();
-    }
-
     public static void runGroovyScript(String name, Binding binding) {
         getInstance().__runGroovyScript(name, binding);
     }
 
-    protected abstract GroovyScriptEngine __getGroovyScriptEngine();
 
     protected void __runGroovyScript(String name, Binding binding) {
         try {
@@ -61,4 +66,20 @@ protected void __runGroovyScript(String name, Binding binding) {
             throw new RuntimeException(e);
         }
     }
 }
</code_before><code_after>@@ -14,6 +14,9 @@
 import groovy.util.ResourceException;
 import groovy.util.ScriptException;
 import groovy.lang.Binding;
+import groovy.lang.GroovyClassLoader;
+
+import java.io.InputStream;
 
 public abstract class ScriptingProvider {
 
@@ -42,15 +45,17 @@ private static ScriptingProvider getInstance() {
         return instance;
     }
 
     public static void runGroovyScript(String name, Binding binding) {
         getInstance().__runGroovyScript(name, binding);
     }
 
+    public static Class loadGroovyClass(String name) {
+        return getInstance().__loadGroovyClass(name);
+    }
+
+    public static InputStream getResourceAsStream(String name) {
+        return getInstance().__getResourceAsStream(name);
+    }
 
     protected void __runGroovyScript(String name, Binding binding) {
         try {
@@ -61,4 +66,20 @@ protected void __runGroovyScript(String name, Binding binding) {
             throw new RuntimeException(e);
         }
     }
+
+    private Class __loadGroovyClass(String name) {
+        try {
+            return __getGroovyClassLoader().loadClass(name, true, false);
+        } catch (ClassNotFoundException e) {
+            return null;
+        }
+    }
+
+    private InputStream __getResourceAsStream(String name) {
+        return __getGroovyClassLoader().getResourceAsStream(name);
+    }
+
+    protected abstract GroovyScriptEngine __getGroovyScriptEngine();
+
+    protected abstract GroovyClassLoader __getGroovyClassLoader();
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>48350</refactoring_id><commit_sha>e096daf9747a4837d8c054dcb384cf8d5c48023c</commit_sha><commit_link>https://github.com/apache/beam/commit/e096daf9747a4837d8c054dcb384cf8d5c48023c</commit_link><file_path>sdks/java/core/src/main/java/org/apache/beam/sdk/io/TextIO.java</file_path><description>Extract Method public withNumShards(numShards ValueProvider&lt;Integer&gt;) : TypedWrite&lt;UserT,DestinationT&gt; extracted from public withNumShards(numShards int) : TypedWrite&lt;UserT,DestinationT&gt; in class org.apache.beam.sdk.io.TextIO.TypedWrite</description><code_before>@@ -268,7 +268,6 @@ public static &lt;UserT&gt; TypedWrite&lt;UserT, Void&gt; writeCustomType() {
         .setDelimiter(new char[] {'\n'})
         .setWritableByteChannelFactory(FileBasedSink.CompressionType.UNCOMPRESSED)
         .setWindowedWrites(false)
-        .setNumShards(0)
         .setNoSpilling(false)
         .build();
   }
@@ -623,7 +622,7 @@ public abstract static class TypedWrite&lt;UserT, DestinationT&gt;
     abstract @Nullable String getFooter();
 
     /** Requested number of shards. 0 for automatic. */
-    abstract int getNumShards();
 
     /** The shard template of each file written, combined with prefix and suffix. */
     abstract @Nullable String getShardTemplate();
@@ -689,7 +688,8 @@ abstract Builder&lt;UserT, DestinationT&gt; setDestinationFunction(
       abstract Builder&lt;UserT, DestinationT&gt; setFormatFunction(
           @Nullable SerializableFunction&lt;UserT, String&gt; formatFunction);
 
-      abstract Builder&lt;UserT, DestinationT&gt; setNumShards(int numShards);
 
       abstract Builder&lt;UserT, DestinationT&gt; setWindowedWrites(boolean windowedWrites);
 
@@ -846,6 +846,14 @@ public TypedWrite&lt;UserT, DestinationT&gt; withSuffix(String filenameSuffix) {
      */
     public TypedWrite&lt;UserT, DestinationT&gt; withNumShards(int numShards) {
       checkArgument(numShards &gt;= 0);
       return toBuilder().setNumShards(numShards).build();
     }
 
@@ -1002,7 +1010,7 @@ public WriteFilesResult&lt;DestinationT&gt; expand(PCollection&lt;UserT&gt; input) {
                   getHeader(),
                   getFooter(),
                   getWritableByteChannelFactory()));
-      if (getNumShards() &gt; 0) {
         write = write.withNumShards(getNumShards());
       }
       if (getWindowedWrites()) {
@@ -1020,8 +1028,8 @@ public void populateDisplayData(DisplayData.Builder builder) {
 
       resolveDynamicDestinations().populateDisplayData(builder);
       builder
-          .addIfNotDefault(
-              DisplayData.item("numShards", getNumShards()).withLabel("Maximum Output Shards"), 0)
           .addIfNotNull(
               DisplayData.item("tempDirectory", getTempDirectory())
                   .withLabel("Directory for temporary files"))
@@ -1139,6 +1147,11 @@ public Write withNumShards(int numShards) {
       return new Write(inner.withNumShards(numShards));
     }
 
     /** See {@link TypedWrite#withoutSharding()}. */
     public Write withoutSharding() {
       return new Write(inner.withoutSharding());
</code_before><code_after>@@ -268,7 +268,6 @@ public static &lt;UserT&gt; TypedWrite&lt;UserT, Void&gt; writeCustomType() {
         .setDelimiter(new char[] {'\n'})
         .setWritableByteChannelFactory(FileBasedSink.CompressionType.UNCOMPRESSED)
         .setWindowedWrites(false)
         .setNoSpilling(false)
         .build();
   }
@@ -623,7 +622,7 @@ public abstract static class TypedWrite&lt;UserT, DestinationT&gt;
     abstract @Nullable String getFooter();
 
     /** Requested number of shards. 0 for automatic. */
+    abstract @Nullable ValueProvider&lt;Integer&gt; getNumShards();
 
     /** The shard template of each file written, combined with prefix and suffix. */
     abstract @Nullable String getShardTemplate();
@@ -689,7 +688,8 @@ abstract Builder&lt;UserT, DestinationT&gt; setDestinationFunction(
       abstract Builder&lt;UserT, DestinationT&gt; setFormatFunction(
           @Nullable SerializableFunction&lt;UserT, String&gt; formatFunction);
 
+      abstract Builder&lt;UserT, DestinationT&gt; setNumShards(
+          @Nullable ValueProvider&lt;Integer&gt; numShards);
 
       abstract Builder&lt;UserT, DestinationT&gt; setWindowedWrites(boolean windowedWrites);
 
@@ -846,6 +846,14 @@ public TypedWrite&lt;UserT, DestinationT&gt; withSuffix(String filenameSuffix) {
      */
     public TypedWrite&lt;UserT, DestinationT&gt; withNumShards(int numShards) {
       checkArgument(numShards &gt;= 0);
+      return withNumShards(StaticValueProvider.of(numShards));
+    }
+
+    /**
+     * Like {@link #withNumShards(int)}. Specifying {@code null} means runner-determined sharding.
+     */
+    public TypedWrite&lt;UserT, DestinationT&gt; withNumShards(
+        @Nullable ValueProvider&lt;Integer&gt; numShards) {
       return toBuilder().setNumShards(numShards).build();
     }
 
@@ -1002,7 +1010,7 @@ public WriteFilesResult&lt;DestinationT&gt; expand(PCollection&lt;UserT&gt; input) {
                   getHeader(),
                   getFooter(),
                   getWritableByteChannelFactory()));
+      if (getNumShards() != null) {
         write = write.withNumShards(getNumShards());
       }
       if (getWindowedWrites()) {
@@ -1020,8 +1028,8 @@ public void populateDisplayData(DisplayData.Builder builder) {
 
       resolveDynamicDestinations().populateDisplayData(builder);
       builder
+          .addIfNotNull(
+              DisplayData.item("numShards", getNumShards()).withLabel("Maximum Output Shards"))
           .addIfNotNull(
               DisplayData.item("tempDirectory", getTempDirectory())
                   .withLabel("Directory for temporary files"))
@@ -1139,6 +1147,11 @@ public Write withNumShards(int numShards) {
       return new Write(inner.withNumShards(numShards));
     }
 
+    /** See {@link TypedWrite#withNumShards(ValueProvider)}. */
+    public Write withNumShards(@Nullable ValueProvider&lt;Integer&gt; numShards) {
+      return new Write(inner.withNumShards(numShards));
+    }
+
     /** See {@link TypedWrite#withoutSharding()}. */
     public Write withoutSharding() {
       return new Write(inner.withoutSharding());
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>21758</refactoring_id><commit_sha>fb9f22ecd038bbd3af4408bcc81b899240541b9a</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/fb9f22ecd038bbd3af4408bcc81b899240541b9a</commit_link><file_path>enterprise/kernel/src/main/java/org/neo4j/kernel/enterprise/builtinprocs/BuiltInProcedures.java</file_path><description>Extract Method private getKernelTransactions() : KernelTransactions extracted from public listQueries() : Stream&lt;QueryStatusResult&gt; in class org.neo4j.kernel.enterprise.builtinprocs.BuiltInProcedures</description><code_before>@@ -26,7 +26,9 @@
 import org.neo4j.graphdb.DependencyResolver;
 import org.neo4j.kernel.api.ExecutingQuery;
 import org.neo4j.kernel.api.KernelTransaction;
 import org.neo4j.kernel.api.security.exception.InvalidArgumentsException;
 import org.neo4j.kernel.impl.api.KernelTransactions;
 import org.neo4j.kernel.internal.GraphDatabaseAPI;
 import org.neo4j.procedure.Context;
@@ -42,12 +44,27 @@ public class BuiltInProcedures
     @Context
     public KernelTransaction tx;
 
     @Procedure( name = "dbms.listQueries", mode = DBMS )
     public Stream&lt;QueryStatusResult&gt; listQueries() throws InvalidArgumentsException, IOException
     {
         DependencyResolver resolver = graph.getDependencyResolver();
-        KernelTransactions kernelTransactions = resolver.resolveDependency( KernelTransactions.class );
-        return kernelTransactions.executingQueries().stream().map( this::queryStatusResult );
     }
 
     private QueryStatusResult queryStatusResult( ExecutingQuery q )
</code_before><code_after>@@ -26,7 +26,9 @@
 import org.neo4j.graphdb.DependencyResolver;
 import org.neo4j.kernel.api.ExecutingQuery;
 import org.neo4j.kernel.api.KernelTransaction;
+import org.neo4j.kernel.api.security.AuthSubject;
 import org.neo4j.kernel.api.security.exception.InvalidArgumentsException;
+import org.neo4j.kernel.enterprise.api.security.EnterpriseAuthSubject;
 import org.neo4j.kernel.impl.api.KernelTransactions;
 import org.neo4j.kernel.internal.GraphDatabaseAPI;
 import org.neo4j.procedure.Context;
@@ -42,12 +44,27 @@ public class BuiltInProcedures
     @Context
     public KernelTransaction tx;
 
+    @Context
+    public AuthSubject authSubject;
+
     @Procedure( name = "dbms.listQueries", mode = DBMS )
     public Stream&lt;QueryStatusResult&gt; listQueries() throws InvalidArgumentsException, IOException
+    {
+        return getKernelTransactions().executingQueries().stream().filter(
+                ( query ) -&gt; isAdmin() || authSubject.doesUsernameMatch( query.authSubjectName() ) )
+                .map( this::queryStatusResult );
+    }
+
+    private KernelTransactions getKernelTransactions()
     {
         DependencyResolver resolver = graph.getDependencyResolver();
+        return resolver.resolveDependency( KernelTransactions.class );
+    }
+
+    private boolean isAdmin()
+    {
+        EnterpriseAuthSubject enterpriseAuthSubject = (EnterpriseAuthSubject) authSubject;
+        return enterpriseAuthSubject.isAdmin();
     }
 
     private QueryStatusResult queryStatusResult( ExecutingQuery q )
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>2379</refactoring_id><commit_sha>a7e5311704920cc774220089046da3311671165b</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/a7e5311704920cc774220089046da3311671165b</commit_link><file_path>de.metas.acct.base/src/main/java-legacy/org/compiere/acct/Fact.java</file_path><description>Extract Method public bpartnerIdIfNotNull(bpartnerId BPartnerId) : FactLineBuilder extracted from public setC_BPartner_ID_IfValid(bpartnerId int) : FactLineBuilder in class org.compiere.acct.Fact.FactLineBuilder</description><code_before>@@ -31,21 +31,25 @@
 import org.compiere.model.I_C_ElementValue;
 import org.compiere.model.MAccount;
 import org.compiere.model.MFactAcct;
 import org.slf4j.Logger;
 
 import de.metas.acct.api.AcctSchema;
 import de.metas.acct.api.AcctSchemaElement;
 import de.metas.acct.api.AcctSchemaElementType;
 import de.metas.acct.api.AcctSchemaElementsMap;
 import de.metas.acct.api.AcctSchemaGeneralLedger;
 import de.metas.acct.api.AcctSchemaId;
 import de.metas.bpartner.BPartnerId;
 import de.metas.currency.ICurrencyConversionContext;
 import de.metas.logging.LogManager;
 import de.metas.money.CurrencyId;
 import de.metas.product.acct.api.ActivityId;
 import de.metas.quantity.Quantity;
 import de.metas.util.Check;
 import lombok.NonNull;
 import lombok.ToString;
 
@@ -1109,7 +1113,13 @@ private final void markAsBuilt()
 			built = true;
 		}
 
-		public FactLineBuilder setAccount(MAccount account)
 		{
 			assertNotBuild();
 			this.account = account;
@@ -1318,9 +1328,9 @@ private OrgId getOrgId()
 		}
 
 		@Deprecated
-		public FactLineBuilder setC_BPartner_ID(Integer bpartnerIdInt)
 		{
-			final BPartnerId bpartnerId = bpartnerIdInt != null ? BPartnerId.ofRepoIdOrNull(bpartnerIdInt) : null;
 			return bpartnerId(bpartnerId);
 		}
 
@@ -1331,15 +1341,21 @@ public FactLineBuilder bpartnerId(final BPartnerId bpartnerId)
 			return this;
 		}
 
-		public FactLineBuilder setC_BPartner_ID_IfValid(final int bpartnerId)
 		{
-			assertNotBuild();
-			if (bpartnerId &gt; 0)
 			{
-				setC_BPartner_ID(bpartnerId);
 			}
-			return this;
 
 		}
 
 		private BPartnerId getBpartnerId()
</code_before><code_after>@@ -31,21 +31,25 @@
 import org.compiere.model.I_C_ElementValue;
 import org.compiere.model.MAccount;
 import org.compiere.model.MFactAcct;
+import org.compiere.util.Env;
 import org.slf4j.Logger;
 
+import de.metas.acct.api.AccountId;
 import de.metas.acct.api.AcctSchema;
 import de.metas.acct.api.AcctSchemaElement;
 import de.metas.acct.api.AcctSchemaElementType;
 import de.metas.acct.api.AcctSchemaElementsMap;
 import de.metas.acct.api.AcctSchemaGeneralLedger;
 import de.metas.acct.api.AcctSchemaId;
+import de.metas.acct.api.IAccountDAO;
 import de.metas.bpartner.BPartnerId;
 import de.metas.currency.ICurrencyConversionContext;
 import de.metas.logging.LogManager;
 import de.metas.money.CurrencyId;
 import de.metas.product.acct.api.ActivityId;
 import de.metas.quantity.Quantity;
 import de.metas.util.Check;
+import de.metas.util.Services;
 import lombok.NonNull;
 import lombok.ToString;
 
@@ -1109,7 +1113,13 @@ private final void markAsBuilt()
 			built = true;
 		}
 
+		public FactLineBuilder setAccount(@NonNull final AccountId accountId)
+		{
+			final IAccountDAO accountsRepo = Services.get(IAccountDAO.class);
+			return setAccount(accountsRepo.getById(Env.getCtx(), accountId));
+		}
+
+		public FactLineBuilder setAccount(final MAccount account)
 		{
 			assertNotBuild();
 			this.account = account;
@@ -1318,9 +1328,9 @@ private OrgId getOrgId()
 		}
 
 		@Deprecated
+		public FactLineBuilder setC_BPartner_ID(Integer bpartnerRepoId)
 		{
+			final BPartnerId bpartnerId = bpartnerRepoId != null ? BPartnerId.ofRepoIdOrNull(bpartnerRepoId) : null;
 			return bpartnerId(bpartnerId);
 		}
 
@@ -1331,15 +1341,21 @@ public FactLineBuilder bpartnerId(final BPartnerId bpartnerId)
 			return this;
 		}
 
+		public FactLineBuilder bpartnerIdIfNotNull(final BPartnerId bpartnerId)
 		{
+			if (bpartnerId != null)
 			{
+				return bpartnerId(bpartnerId);
 			}
+			else
+			{
+				return this;
+			}
+		}
 
+		public FactLineBuilder setC_BPartner_ID_IfValid(final int bpartnerRepoId)
+		{
+			return bpartnerIdIfNotNull(BPartnerId.ofRepoIdOrNull(bpartnerRepoId));
 		}
 
 		private BPartnerId getBpartnerId()
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>18487</refactoring_id><commit_sha>c5394b67824ff1838645b92b802c1c4889f57237</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/c5394b67824ff1838645b92b802c1c4889f57237</commit_link><file_path>orchestrator/src/main/java/com/yahoo/vespa/orchestrator/status/ZookeeperStatusService.java</file_path><description>Extract Method private acquireLock(context OrchestratorContext, applicationInstanceReference ApplicationInstanceReference) : Runnable extracted from public lockApplicationInstance_forCurrentThreadOnly(context OrchestratorContext, applicationInstanceReference ApplicationInstanceReference) : MutableStatusRegistry in class com.yahoo.vespa.orchestrator.status.ZookeeperStatusService</description><code_before>@@ -75,6 +75,14 @@ public boolean setHostStatus(ApplicationInstanceReference application, HostName
         });
     }
 
     @Override
     public Set&lt;ApplicationInstanceReference&gt; getAllSuspendedApplications() {
         try {
@@ -123,6 +131,36 @@ public Function&lt;ApplicationInstanceReference, HostInfos&gt; getHostInfosByApplicati
     public MutableStatusRegistry lockApplicationInstance_forCurrentThreadOnly(
             OrchestratorContext context,
             ApplicationInstanceReference applicationInstanceReference) throws UncheckedTimeoutException {
         ApplicationId applicationId = OrchestratorUtil.toApplicationId(applicationInstanceReference);
         String app = applicationId.application().value() + "." + applicationId.instance().value();
         Map&lt;String, String&gt; dimensions = Map.of(
@@ -152,20 +190,21 @@ public MutableStatusRegistry lockApplicationInstance_forCurrentThreadOnly(
             metric.add(acquireResultMetricName, 1, metricContext);
         }
 
-        Runnable updateLockHoldMetric = () -&gt; {
             Instant lockReleasedTime = timer.currentTime();
             double seconds = durationInSeconds(acquireEndTime, lockReleasedTime);
             metric.set("orchestrator.lock.hold-latency", seconds, metricContext);
         };
-
-        try {
-            return new ZkMutableStatusRegistry(lock, applicationInstanceReference, context.isProbe(), updateLockHoldMetric);
-        } catch (Throwable t) {
-            // In case the constructor throws an exception.
-            updateLockHoldMetric.run();
-            lock.close();
-            throw t;
-        }
     }
 
     private double durationInSeconds(Instant startInstant, Instant endInstant) {
@@ -337,19 +376,16 @@ private static String hostPath(ApplicationInstanceReference application, HostNam
 
     private class ZkMutableStatusRegistry implements MutableStatusRegistry {
 
-        private final Lock lock;
         private final ApplicationInstanceReference applicationInstanceReference;
         private final boolean probe;
-        private final Runnable onLockRelease;
 
-        public ZkMutableStatusRegistry(Lock lock,
                                        ApplicationInstanceReference applicationInstanceReference,
-                                       boolean probe,
-                                       Runnable onLockRelease) {
-            this.lock = lock;
             this.applicationInstanceReference = applicationInstanceReference;
             this.probe = probe;
-            this.onLockRelease = onLockRelease;
         }
 
         @Override
@@ -399,13 +435,12 @@ public void setApplicationInstanceStatus(ApplicationInstanceStatus applicationIn
 
         @Override
         public void close()  {
-            onLockRelease.run();
             try {
-                lock.close();
             } catch (RuntimeException e) {
                 // We may want to avoid logging some exceptions that may be expected, like when session expires.
                 log.log(LogLevel.WARNING,
-                        "Failed to close application lock for " +
                         ZookeeperStatusService.class.getSimpleName() + ", will ignore and continue",
                         e);
             }
</code_before><code_after>@@ -75,6 +75,14 @@ public boolean setHostStatus(ApplicationInstanceReference application, HostName
         });
     }
 
+    /** Non-private for testing only. */
+    ZookeeperStatusService(Curator curator, Metric metric, Timer timer, HostInfosCache hostInfosCache) {
+        this.curator = curator;
+        this.metric = metric;
+        this.timer = timer;
+        this.hostInfosCache = hostInfosCache;
+    }
+
     @Override
     public Set&lt;ApplicationInstanceReference&gt; getAllSuspendedApplications() {
         try {
@@ -123,6 +131,36 @@ public Function&lt;ApplicationInstanceReference, HostInfos&gt; getHostInfosByApplicati
     public MutableStatusRegistry lockApplicationInstance_forCurrentThreadOnly(
             OrchestratorContext context,
             ApplicationInstanceReference applicationInstanceReference) throws UncheckedTimeoutException {
+        Runnable onRegistryClose;
+
+        // A multi-application operation, aka batch suspension, will first issue a probe
+        // then a non-probe. With "large locks", the lock is not release in between -
+        // no lock is taken on the non-probe. Instead, the release is done on the multi-application
+        // context close.
+        if (!context.largeLocks() || !context.partOfMultiAppOp() || context.isProbe()) {
+            Runnable unlock = acquireLock(context, applicationInstanceReference);
+            if (context.largeLocks() &amp;&amp; context.isProbe()) {
+                context.runOnClose(unlock);
+                onRegistryClose = () -&gt; {};
+            } else {
+                onRegistryClose = unlock;
+            }
+        } else {
+            onRegistryClose = () -&gt; {};
+        }
+
+        try {
+            return new ZkMutableStatusRegistry(onRegistryClose, applicationInstanceReference, context.isProbe());
+        } catch (Throwable t) {
+            // In case the constructor throws an exception.
+            onRegistryClose.run();
+            throw t;
+        }
+    }
+
+    private Runnable acquireLock(OrchestratorContext context,
+                                 ApplicationInstanceReference applicationInstanceReference)
+            throws UncheckedTimeoutException {
         ApplicationId applicationId = OrchestratorUtil.toApplicationId(applicationInstanceReference);
         String app = applicationId.application().value() + "." + applicationId.instance().value();
         Map&lt;String, String&gt; dimensions = Map.of(
@@ -152,20 +190,21 @@ public MutableStatusRegistry lockApplicationInstance_forCurrentThreadOnly(
             metric.add(acquireResultMetricName, 1, metricContext);
         }
 
+        return () -&gt; {
+            try {
+                lock.close();
+            } catch (RuntimeException e) {
+                // We may want to avoid logging some exceptions that may be expected, like when session expires.
+                log.log(LogLevel.WARNING,
+                        "Failed to close application lock for " +
+                                ZookeeperStatusService.class.getSimpleName() + ", will ignore and continue",
+                        e);
+            }
+
             Instant lockReleasedTime = timer.currentTime();
             double seconds = durationInSeconds(acquireEndTime, lockReleasedTime);
             metric.set("orchestrator.lock.hold-latency", seconds, metricContext);
         };
     }
 
     private double durationInSeconds(Instant startInstant, Instant endInstant) {
@@ -337,19 +376,16 @@ private static String hostPath(ApplicationInstanceReference application, HostNam
 
     private class ZkMutableStatusRegistry implements MutableStatusRegistry {
 
+        private final Runnable onClose;
         private final ApplicationInstanceReference applicationInstanceReference;
         private final boolean probe;
 
+        public ZkMutableStatusRegistry(Runnable onClose,
                                        ApplicationInstanceReference applicationInstanceReference,
+                                       boolean probe) {
+            this.onClose = onClose;
             this.applicationInstanceReference = applicationInstanceReference;
             this.probe = probe;
         }
 
         @Override
@@ -399,13 +435,12 @@ public void setApplicationInstanceStatus(ApplicationInstanceStatus applicationIn
 
         @Override
         public void close()  {
             try {
+                onClose.run();
             } catch (RuntimeException e) {
                 // We may want to avoid logging some exceptions that may be expected, like when session expires.
                 log.log(LogLevel.WARNING,
+                        "Failed close application lock in " +
                         ZookeeperStatusService.class.getSimpleName() + ", will ignore and continue",
                         e);
             }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>82797</refactoring_id><commit_sha>48158b5dbe3dfe3cccc6138ef52b079939152a68</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/48158b5dbe3dfe3cccc6138ef52b079939152a68</commit_link><file_path>src/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclaration.java</file_path><description>Extract Method private maybeAddConstJSDoc(srcDeclaration Node, srcParent Node, srcName Node, destDeclaration Node) : void extracted from private varify() : void in class com.google.javascript.jscomp.Es6RewriteBlockScopedDeclaration</description><code_before>@@ -156,39 +156,48 @@ public boolean apply(Node n) {
     }
   };
 
   private void varify() {
     if (!letConsts.isEmpty()) {
       for (Node n : letConsts) {
         if (n.isConst()) {
-          // Normalize declarations like "const x = 1, y = 2;" so that inline
-          // type annotations are preserved.
-          Node insertPoint = n;
-          for (Node child : n.children()) {
-            Node declaration = IR.var(child.detachFromParent());
-            declaration.useSourceInfoFrom(n);
-            JSDocInfo existingInfo = n.getJSDocInfo();
-            if (existingInfo == null) {
-              existingInfo = child.getJSDocInfo();
-              child.setJSDocInfo(null);
-            }
-
-            if (NodeUtil.isForIn(n.getParent()) &amp;&amp; n == n.getParent().getFirstChild()) {
-              // Don't add @const for the left side of a for/in. If we do we get warnings
-              // from the NTI.
-              declaration.setJSDocInfo(existingInfo);
-            } else {
-              JSDocInfoBuilder builder = JSDocInfoBuilder.maybeCopyFrom(existingInfo);
-              builder.recordConstancy();
-              JSDocInfo info = builder.build();
-              declaration.setJSDocInfo(info);
-            }
-            n.getParent().addChildAfter(declaration, insertPoint);
-            insertPoint = declaration;
-          }
-          n.detachFromParent();
-        } else {
-          n.setType(Token.VAR);
         }
       }
       compiler.reportCodeChange();
     }
@@ -368,33 +377,16 @@ private void transformLoopClosure() {
               if (NodeUtil.isNameDeclaration(reference.getParent())) {
                 Node declaration = reference.getParent();
                 Node grandParent = declaration.getParent();
-                // Normalize: "let i = 0, j = 0;" becomes "let i = 0; let j = 0;"
-                while (declaration.getChildCount() &gt; 1) {
-                  Node name = declaration.getLastChild();
-                  grandParent.addChildAfter(
-                      IR.declaration(
-                          name.detachFromParent(), declaration.getType())
-                          .useSourceInfoIfMissingFromForTree(declaration),
-                      declaration);
-                }
-
                 declaration = reference.getParent(); // Might have changed after normalization.
                 // Change declaration to assignment, or just drop it if there's
                 // no initial value.
                 if (reference.hasChildren()) {
-                  JSDocInfo existingInfo = declaration.getJSDocInfo();
-                  if (existingInfo == null) {
-                    existingInfo = reference.getJSDocInfo();
-                    reference.setJSDocInfo(null);
-                  }
-                  JSDocInfoBuilder builder = JSDocInfoBuilder.maybeCopyFrom(existingInfo);
-                  if (declaration.isConst()) {
-                    builder.recordConstancy();
-                  }
-
                   Node newReference = reference.cloneNode();
                   Node assign = IR.assign(newReference, reference.removeFirstChild());
-                  assign.setJSDocInfo(builder.build());
 
                   Node replacement = IR.exprResult(assign)
                       .useSourceInfoIfMissingFromForTree(declaration);
</code_before><code_after>@@ -156,39 +156,48 @@ public boolean apply(Node n) {
     }
   };
 
+  private static void extractInlineJSDoc(Node srcDeclaration, Node srcName, Node destDeclaration) {
+    JSDocInfo existingInfo = srcDeclaration.getJSDocInfo();
+    if (existingInfo == null) {
+      // Extract inline JSDoc from "src" and add it to the "dest" node.
+      existingInfo = srcName.getJSDocInfo();
+      srcName.setJSDocInfo(null);
+    }
+    JSDocInfoBuilder builder = JSDocInfoBuilder.maybeCopyFrom(existingInfo);
+    destDeclaration.setJSDocInfo(builder.build());
+  }
+
+  private static void maybeAddConstJSDoc(Node srcDeclaration, Node srcParent, Node srcName,
+      Node destDeclaration) {
+    if (srcDeclaration.isConst()
+        // Don't add @const for the left side of a for/in. If we do we get warnings from the NTI.
+        &amp;&amp; !(NodeUtil.isForIn(srcParent) &amp;&amp; srcDeclaration == srcParent.getFirstChild())) {
+      extractInlineJSDoc(srcDeclaration, srcName, destDeclaration);
+      JSDocInfoBuilder builder = JSDocInfoBuilder.maybeCopyFrom(destDeclaration.getJSDocInfo());
+      builder.recordConstancy();
+      destDeclaration.setJSDocInfo(builder.build());
+    }
+  }
+
+  private static void handleDeclarationList(Node declarationList, Node parent) {
+    // Normalize: "const i = 0, j = 0;" becomes "/** @const */ var i = 0; /** @const */ var j = 0;"
+    while (declarationList.hasMoreThanOneChild()) {
+      Node name = declarationList.getLastChild();
+      Node newDeclaration = IR.var(name.detachFromParent()).useSourceInfoFrom(declarationList);
+      maybeAddConstJSDoc(declarationList, parent, name, newDeclaration);
+      parent.addChildAfter(newDeclaration, declarationList);
+    }
+    maybeAddConstJSDoc(declarationList, parent, declarationList.getFirstChild(), declarationList);
+    declarationList.setType(Token.VAR);
+  }
+
   private void varify() {
     if (!letConsts.isEmpty()) {
       for (Node n : letConsts) {
         if (n.isConst()) {
+          handleDeclarationList(n, n.getParent());
         }
+        n.setType(Token.VAR);
       }
       compiler.reportCodeChange();
     }
@@ -368,33 +377,16 @@ private void transformLoopClosure() {
               if (NodeUtil.isNameDeclaration(reference.getParent())) {
                 Node declaration = reference.getParent();
                 Node grandParent = declaration.getParent();
+                handleDeclarationList(declaration, grandParent);
                 declaration = reference.getParent(); // Might have changed after normalization.
                 // Change declaration to assignment, or just drop it if there's
                 // no initial value.
                 if (reference.hasChildren()) {
                   Node newReference = reference.cloneNode();
                   Node assign = IR.assign(newReference, reference.removeFirstChild());
+                  extractInlineJSDoc(declaration, reference, declaration);
+                  maybeAddConstJSDoc(declaration, grandParent, reference, declaration);
+                  assign.setJSDocInfo(declaration.getJSDocInfo());
 
                   Node replacement = IR.exprResult(assign)
                       .useSourceInfoIfMissingFromForTree(declaration);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>63127</refactoring_id><commit_sha>d0394d87ab3f82c766d50d0cb56b7e9b835f5b74</commit_sha><commit_link>https://github.com/yuliskov/SmartTube/commit/d0394d87ab3f82c766d50d0cb56b7e9b835f5b74</commit_link><file_path>smarttubetv/src/main/java/com/liskovsoft/smartyoutubetv2/tv/ui/common/Utils.java</file_path><description>Extract Method public convertDpToPixel(res Resources, dp int) : int extracted from public convertDpToPixel(ctx Context, dp int) : int in class com.liskovsoft.smartyoutubetv2.tv.ui.common.Utils</description><code_before>@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
 import android.graphics.Point;
 import android.media.MediaMetadataRetriever;
 import android.os.Build;
@@ -44,7 +45,11 @@ public static Point getDisplaySize(Context context) {
     }
 
     public static int convertDpToPixel(Context ctx, int dp) {
-        float density = ctx.getResources().getDisplayMetrics().density;
         return Math.round((float) dp * density);
     }
 
</code_before><code_after>@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Point;
 import android.media.MediaMetadataRetriever;
 import android.os.Build;
@@ -44,7 +45,11 @@ public static Point getDisplaySize(Context context) {
     }
 
     public static int convertDpToPixel(Context ctx, int dp) {
+        return convertDpToPixel(ctx.getResources(), dp);
+    }
+
+    public static int convertDpToPixel(Resources res, int dp) {
+        float density = res.getDisplayMetrics().density;
         return Math.round((float) dp * density);
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>55095</refactoring_id><commit_sha>b6fad6f598c1941eaa0ac9593171a53d65bbee69</commit_sha><commit_link>https://github.com/zstackio/zstack/commit/b6fad6f598c1941eaa0ac9593171a53d65bbee69</commit_link><file_path>utils/src/main/java/org/zstack/utils/SizeUtils.java</file_path><description>Extract Method public isSize(numeric UnitNumber, matchedUnits Collection&lt;String&gt;) : boolean extracted from public isSizeString2(str String) : boolean in class org.zstack.utils.SizeUtils</description><code_before>@@ -1,9 +1,11 @@
 package org.zstack.utils;
 
 import org.zstack.utils.data.SizeUnit;
 
 import java.util.Arrays;
-import java.util.List;
 
 /**
  */
@@ -23,68 +25,93 @@ public class SizeUtils {
     private static final String B_SUFFIX = "B";
     private static final String b_SUFFIX = "b";
 
-    private static final List&lt;String&gt; validSuffix = Arrays.asList(
-            T_SUFFIX,
-            TB_SUFFIX,
-            t_SUFFIX,
-            G_SUFFIX,
-            GB_SUFFIX,
-            g_SUFFIX,
-            M_SUFFIX,
-            MB_SUFFIX,
-            m_SUFFIX,
-            K_SUFFIX,
-            KB_SUFFIX,
-            k_SUFFIX,
-            B_SUFFIX,
-            b_SUFFIX
-    );
 
-    private static boolean isPositiveNumber(String str) {
-        return str.matches("\\d+");
     }
 
-    public static boolean isPositive(Number i){
-        return i != null &amp;&amp; i.doubleValue() &gt; 0;
     }
 
-    public static boolean isSizeString2(String str) {
-        String suffix = str.substring(str.length() - 2);
-        if (!validSuffix.contains(suffix)) {
-            return false;
-        }
 
-        String num = str.substring(0, str.length() - 2);
-        return isPositiveNumber(num);
     }
 
-    public static boolean isSizeString(String str) {
-        String suffix = str.substring(str.length() - 1);
-        if (!validSuffix.contains(suffix)) {
-            return isPositiveNumber(str);
-        } else {
-            String num = str.substring(0, str.length()-1);
-            return isPositiveNumber(num);
         }
     }
 
     public static long sizeStringToBytes(String str) {
-        String numStr = str.substring(0, str.length() - 1);
-        String suffix = str.substring(str.length() - 1);
-        if (!validSuffix.contains(suffix)) {
-            return Long.parseLong(str);
         }
 
-        long size = Long.parseLong(numStr);
-        if (suffix.equals(T_SUFFIX) || suffix.equals(t_SUFFIX)) {
             return SizeUnit.TERABYTE.toByte(size);
-        } else if (suffix.equals(G_SUFFIX) || suffix.equals(g_SUFFIX)) {
             return SizeUnit.GIGABYTE.toByte(size);
-        } else if (suffix.equals(M_SUFFIX) || suffix.equals(m_SUFFIX)) {
             return SizeUnit.MEGABYTE.toByte(size);
-        } else if (suffix.equals(K_SUFFIX) || suffix.equals(k_SUFFIX)) {
             return SizeUnit.KILOBYTE.toByte(size);
-        } else if (suffix.equals(B_SUFFIX) || suffix.equals(b_SUFFIX)) {
             return SizeUnit.BYTE.toByte(size);
         }
 
</code_before><code_after>@@ -1,9 +1,11 @@
 package org.zstack.utils;
 
+import org.zstack.utils.data.NumberUtils;
 import org.zstack.utils.data.SizeUnit;
+import org.zstack.utils.data.UnitNumber;
 
 import java.util.Arrays;
+import java.util.Collection;
 
 /**
  */
@@ -23,68 +25,93 @@ public class SizeUtils {
     private static final String B_SUFFIX = "B";
     private static final String b_SUFFIX = "b";
 
+    public static boolean isPositive(Number i){
+        return NumberUtils.isPositive(i);
+    }
 
+    /**
+     * &lt;p&gt;Check string is a valid size string with 2 characters size units&lt;/p&gt;
+     * &lt;p&gt;Valid size units list below:
+     * {@link #TB_SUFFIX}, {@link #GB_SUFFIX}, {@link #MB_SUFFIX}, {@link #KB_SUFFIX}, {@link #B_SUFFIX}&lt;/p&gt;
+     * &lt;p&gt;Example:
+     *   &lt;li&gt;1GB -&gt; true
+     *   &lt;li&gt;2MB -&gt; true
+     *   &lt;li&gt;3K -&gt; false
+     *   &lt;li&gt;4T -&gt; false
+     *   &lt;li&gt;5 -&gt; false
+     *   &lt;li&gt;-6GB -&gt; false
+     *   &lt;/li&gt;
+     * &lt;/p&gt;
+     * 
+     * @param str a string contains integer and size units
+     * @return if str is a valid size string with 2 characters size units.
+     * @see #isSizeString(String) 
+     */
+    public static boolean isSizeString2(String str) {
+        final UnitNumber numeric = NumberUtils.ofUnitNumber(str);
+        return numeric == null ? false : isSize2(numeric);
     }
 
+    /**
+     * &lt;p&gt;Check string is a valid size string with 1 character size units,
+     * or simply the positive value&lt;/p&gt;
+     * &lt;p&gt;Valid size units list below:
+     * {@link #T_SUFFIX}, {@link #t_SUFFIX}, {@link #G_SUFFIX}, {@link #g_SUFFIX}, 
+     * {@link #M_SUFFIX}, {@link #m_SUFFIX}, {@link #K_SUFFIX}, {@link #k_SUFFIX},
+     * {@link #B_SUFFIX}, {@link #b_SUFFIX}, ""&lt;/p&gt;
+     * &lt;p&gt;Example:
+     *   &lt;li&gt;1GB -&gt; false
+     *   &lt;li&gt;2MB -&gt; false
+     *   &lt;li&gt;3K -&gt; true
+     *   &lt;li&gt;4T -&gt; true
+     *   &lt;li&gt;5 -&gt; true
+     *   &lt;li&gt;-6G -&gt; false
+     *   &lt;/li&gt;
+     * &lt;/p&gt;
+     * 
+     * @param str a string contains integer and size units
+     * @return if str is a valid size string with 1 character size units, or simply the positive value
+     * @see #isSizeString2(String) 
+     */
+    public static boolean isSizeString(String str) {
+        final UnitNumber numeric = NumberUtils.ofUnitNumber(str);
+        return numeric == null ? false : isSize(numeric);
     }
 
+    public static boolean isSize2(UnitNumber numeric) {
+        return isSize(numeric, Arrays.asList(TB_SUFFIX, GB_SUFFIX, MB_SUFFIX, KB_SUFFIX, B_SUFFIX));
+    }
 
+    public static boolean isSize(UnitNumber numeric) {
+        return isSize(numeric, Arrays.asList(
+                T_SUFFIX, t_SUFFIX, G_SUFFIX, g_SUFFIX, M_SUFFIX, m_SUFFIX, K_SUFFIX, k_SUFFIX, B_SUFFIX, b_SUFFIX, ""));
     }
 
+    public static boolean isSize(UnitNumber numeric, Collection&lt;String&gt; matchedUnits) {
+        if (numeric.number &lt; 0) {
+            return false;
         }
+        return matchedUnits.contains(numeric.units);
     }
 
     public static long sizeStringToBytes(String str) {
+        final UnitNumber numeric = NumberUtils.ofUnitNumberOrThrow(str);
+        String suffix = numeric.units;
+        long size = numeric.number;
+        if (suffix.length() == 0) {
+            return size;
         }
 
+        switch (suffix) {
+        case T_SUFFIX: case t_SUFFIX: case TB_SUFFIX:
             return SizeUnit.TERABYTE.toByte(size);
+        case G_SUFFIX: case g_SUFFIX: case GB_SUFFIX:
             return SizeUnit.GIGABYTE.toByte(size);
+        case M_SUFFIX: case m_SUFFIX: case MB_SUFFIX:
             return SizeUnit.MEGABYTE.toByte(size);
+        case K_SUFFIX: case k_SUFFIX: case KB_SUFFIX:
             return SizeUnit.KILOBYTE.toByte(size);
+        case B_SUFFIX: case b_SUFFIX:
             return SizeUnit.BYTE.toByte(size);
         }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>36103</refactoring_id><commit_sha>fe9d25079fa329857912fb2dd2a17b037e34f0fa</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/fe9d25079fa329857912fb2dd2a17b037e34f0fa</commit_link><file_path>OsmAnd/src/net/osmand/plus/chooseplan/OsmAndProPlanFragment.java</file_path><description>Extract Method public getSubscriptions(app OsmandApplication, purchaseHelper InAppPurchaseHelper) : List&lt;InAppSubscription&gt; extracted from protected getVisibleSubscriptions() : List&lt;InAppSubscription&gt; in class net.osmand.plus.chooseplan.OsmAndProPlanFragment</description><code_before>@@ -7,9 +7,11 @@
 import androidx.annotation.Nullable;
 import androidx.fragment.app.FragmentActivity;
 
 import net.osmand.plus.R;
 import net.osmand.plus.chooseplan.button.PriceButton;
 import net.osmand.plus.chooseplan.button.PriceButtonsUtils;
 import net.osmand.plus.inapp.InAppPurchases;
 import net.osmand.plus.inapp.InAppPurchases.InAppSubscription;
 
@@ -37,7 +39,7 @@ protected void initData(@Nullable Bundle args) {
 	@Override
 	protected void collectPriceButtons(List&lt;PriceButton&lt;?&gt;&gt; priceButtons) {
 		priceButtons.clear();
-		priceButtons.addAll(PriceButtonsUtils.collectSubscriptions(app, purchaseHelper, getVisibleSubscriptions()));
 	}
 
 	@Override
@@ -63,7 +65,17 @@ protected int getHeaderIconId() {
 	}
 
 	@Override
-	protected List&lt;InAppSubscription&gt; getVisibleSubscriptions() {
 		InAppPurchases purchases = app.getInAppPurchaseHelper().getInAppPurchases();
 		List&lt;InAppSubscription&gt; subscriptions = new ArrayList&lt;&gt;();
 		List&lt;InAppSubscription&gt; visibleSubscriptions = purchaseHelper.getSubscriptions().getVisibleSubscriptions();
@@ -75,9 +87,4 @@ protected List&lt;InAppSubscription&gt; getVisibleSubscriptions() {
 		return subscriptions;
 	}
 
-	@Override
-	protected Drawable getPreviewListCheckmark() {
-		return getCheckmark();
-	}
-
 }
</code_before><code_after>@@ -7,9 +7,11 @@
 import androidx.annotation.Nullable;
 import androidx.fragment.app.FragmentActivity;
 
+import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.chooseplan.button.PriceButton;
 import net.osmand.plus.chooseplan.button.PriceButtonsUtils;
+import net.osmand.plus.inapp.InAppPurchaseHelper;
 import net.osmand.plus.inapp.InAppPurchases;
 import net.osmand.plus.inapp.InAppPurchases.InAppSubscription;
 
@@ -37,7 +39,7 @@ protected void initData(@Nullable Bundle args) {
 	@Override
 	protected void collectPriceButtons(List&lt;PriceButton&lt;?&gt;&gt; priceButtons) {
 		priceButtons.clear();
+		priceButtons.addAll(collectPriceButtons(app, purchaseHelper));
 	}
 
 	@Override
@@ -63,7 +65,17 @@ protected int getHeaderIconId() {
 	}
 
 	@Override
+	protected Drawable getPreviewListCheckmark() {
+		return getCheckmark();
+	}
+
+	public static List&lt;PriceButton&lt;?&gt;&gt; collectPriceButtons(OsmandApplication app,
+	                                                       InAppPurchaseHelper purchaseHelper) {
+		return new ArrayList&lt;&gt;(PriceButtonsUtils.collectSubscriptions(
+				app, purchaseHelper, getSubscriptions(app, purchaseHelper)));
+	}
+
+	public static List&lt;InAppSubscription&gt; getSubscriptions(OsmandApplication app, InAppPurchaseHelper purchaseHelper) {
 		InAppPurchases purchases = app.getInAppPurchaseHelper().getInAppPurchases();
 		List&lt;InAppSubscription&gt; subscriptions = new ArrayList&lt;&gt;();
 		List&lt;InAppSubscription&gt; visibleSubscriptions = purchaseHelper.getSubscriptions().getVisibleSubscriptions();
@@ -75,9 +87,4 @@ protected List&lt;InAppSubscription&gt; getVisibleSubscriptions() {
 		return subscriptions;
 	}
 
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>20011</refactoring_id><commit_sha>b593da034e477f846ab9cf44ad644f123b9ff535</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/b593da034e477f846ab9cf44ad644f123b9ff535</commit_link><file_path>community/io/src/main/java/org/neo4j/io/fs/FileUtils.java</file_path><description>Extract Method private rotationalPathFor(deviceName Path) : Path extracted from public highIODevice(pathOnDevice Path, defaultHunch boolean) : boolean in class org.neo4j.io.fs.FileUtils</description><code_before>@@ -383,8 +383,8 @@ public static boolean highIODevice( Path pathOnDevice, boolean defaultHunch )
 
                 Path device = Paths.get( name ).toRealPath(); // Use toRealPath to resolve any symlinks.
                 Path deviceName = device.getName( device.getNameCount() - 1 );
-                Path sysblock = Paths.get( "/sys/block" );
-                Path rotational = sysblock.resolve( deviceName ).resolve( "queue" ).resolve( "rotational" );
                 if ( Files.exists( rotational ) )
                 {
                     return readFirstCharacter( rotational ) == '0';
@@ -397,8 +397,8 @@ public static boolean highIODevice( Path pathOnDevice, boolean defaultHunch )
                     {
                         len--;
                     }
-                    namePart = namePart.substring( 0, len );
-                    rotational = sysblock.resolve( namePart ).resolve( "queue" ).resolve( "rotational" );
                     if ( Files.exists( rotational ) )
                     {
                         return readFirstCharacter( rotational ) == '0';
@@ -414,6 +414,11 @@ public static boolean highIODevice( Path pathOnDevice, boolean defaultHunch )
         return defaultHunch;
     }
 
     private static int readFirstCharacter( Path file ) throws IOException
     {
         try ( InputStream in = Files.newInputStream( file, StandardOpenOption.READ ) )
</code_before><code_after>@@ -383,8 +383,8 @@ public static boolean highIODevice( Path pathOnDevice, boolean defaultHunch )
 
                 Path device = Paths.get( name ).toRealPath(); // Use toRealPath to resolve any symlinks.
                 Path deviceName = device.getName( device.getNameCount() - 1 );
+
+                Path rotational = rotationalPathFor( deviceName );
                 if ( Files.exists( rotational ) )
                 {
                     return readFirstCharacter( rotational ) == '0';
@@ -397,8 +397,8 @@ public static boolean highIODevice( Path pathOnDevice, boolean defaultHunch )
                     {
                         len--;
                     }
+                    deviceName = Paths.get( namePart.substring( 0, len ) );
+                    rotational = rotationalPathFor( deviceName );
                     if ( Files.exists( rotational ) )
                     {
                         return readFirstCharacter( rotational ) == '0';
@@ -414,6 +414,11 @@ public static boolean highIODevice( Path pathOnDevice, boolean defaultHunch )
         return defaultHunch;
     }
 
+    private static Path rotationalPathFor( Path deviceName )
+    {
+        return Paths.get( "/sys/block" ).resolve( deviceName ).resolve( "queue" ).resolve( "rotational" );
+    }
+
     private static int readFirstCharacter( Path file ) throws IOException
     {
         try ( InputStream in = Files.newInputStream( file, StandardOpenOption.READ ) )
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>30506</refactoring_id><commit_sha>7005cb5b3edc2590e14470f55df86aa9d8379f6b</commit_sha><commit_link>https://github.com/igniterealtime/openfire/commit/7005cb5b3edc2590e14470f55df86aa9d8379f6b</commit_link><file_path>src/plugins/gateway/src/java/org/jivesoftware/wildfire/gateway/BaseTransport.java</file_path><description>Extract Method public cleanUpRoster(jid JID, leaveDomain Boolean) : void extracted from public deleteRegistration(jid JID) : void in class org.jivesoftware.wildfire.gateway.BaseTransport</description><code_before>@@ -208,6 +208,14 @@ private List&lt;Packet&gt; processPacket(Presence packet) {
                         session = this.registrationLoggedIn(registration, from, getPresenceType(packet), packet.getStatus(), packet.getPriority());
                         //sessionManager.storeSession(registration.getJID(), session);
                         sessionManager.storeSession(from, session);
                     }
                 }
                 else if (packet.getType() == Presence.Type.unavailable) {
@@ -301,8 +309,10 @@ private List&lt;Packet&gt; processPacket(IQ packet) {
 
         if (xmlns == null) {
             // No namespace defined.
-            // TODO: Should we return an error?
             Log.debug("No XMLNS:" + packet.toString());
             return reply;
         }
 
@@ -750,7 +760,7 @@ public void addOrUpdateRosterItem(JID userjid, JID contactjid, String nickname,
                     // roster items related to the gateway service will be persistent. Roster
                     // items of legacy users are never persisted in the DB.
                     RosterItem gwitem =
-                            roster.createRosterItem(contactjid, true, contactjid.getNode() != null);
                     gwitem.setSubStatus(RosterItem.SUB_BOTH);
                     gwitem.setAskStatus(RosterItem.ASK_NONE);
                     gwitem.setNickname(nickname);
@@ -974,6 +984,14 @@ public void addNewRegistration(JID jid, String username, String password) throws
         catch (UserNotFoundException e) {
             throw new UserNotFoundException("User not registered with server.");
         }
     }
 
     /**
@@ -990,11 +1008,38 @@ public void deleteRegistration(JID jid) throws UserNotFoundException {
         }
 
         // Clean up the user's contact list.
         try {
             Roster roster = rosterManager.getRoster(jid.getNode());
             for (RosterItem ri : roster.getRosterItems()) {
                 if (ri.getJid().getDomain().equals(this.jid.getDomain())) {
                     try {
                         roster.deleteRosterItem(ri.getJid(), false);
                     }
                     catch (Exception e) {
</code_before><code_after>@@ -208,6 +208,14 @@ private List&lt;Packet&gt; processPacket(Presence packet) {
                         session = this.registrationLoggedIn(registration, from, getPresenceType(packet), packet.getStatus(), packet.getPriority());
                         //sessionManager.storeSession(registration.getJID(), session);
                         sessionManager.storeSession(from, session);
+
+                        // TODO: TEMPORARY: Since we are using shared groups now, we will clean up our testers rosters for them.
+                        try {
+                            cleanUpRoster(from, true);
+                        }
+                        catch (UserNotFoundException ee) {
+                            throw new UserNotFoundException("Unable to find roster.");
+                        }
                     }
                 }
                 else if (packet.getType() == Presence.Type.unavailable) {
@@ -301,8 +309,10 @@ private List&lt;Packet&gt; processPacket(IQ packet) {
 
         if (xmlns == null) {
             // No namespace defined.
             Log.debug("No XMLNS:" + packet.toString());
+            IQ error = IQ.createResultIQ(packet);
+            error.setError(Condition.bad_request);
+            reply.add(error);
             return reply;
         }
 
@@ -750,7 +760,7 @@ public void addOrUpdateRosterItem(JID userjid, JID contactjid, String nickname,
                     // roster items related to the gateway service will be persistent. Roster
                     // items of legacy users are never persisted in the DB.
                     RosterItem gwitem =
+                            roster.createRosterItem(contactjid, true, contactjid.getNode() == null);
                     gwitem.setSubStatus(RosterItem.SUB_BOTH);
                     gwitem.setAskStatus(RosterItem.ASK_NONE);
                     gwitem.setNickname(nickname);
@@ -974,6 +984,14 @@ public void addNewRegistration(JID jid, String username, String password) throws
         catch (UserNotFoundException e) {
             throw new UserNotFoundException("User not registered with server.");
         }
+
+        // Clean up any leftover roster items from other transports.
+        try {
+            cleanUpRoster(jid, true);
+        }
+        catch (UserNotFoundException ee) {
+            throw new UserNotFoundException("Unable to find roster.");
+        }
     }
 
     /**
@@ -990,11 +1008,38 @@ public void deleteRegistration(JID jid) throws UserNotFoundException {
         }
 
         // Clean up the user's contact list.
+        try {
+            cleanUpRoster(jid, false);
+        }
+        catch (UserNotFoundException e) {
+            throw new UserNotFoundException("Unable to find roster.");
+        }
+    }
+
+    /**
+     * Cleans a roster of entries related to this transport.
+     *
+     * This function will run through the roster of the specified user and clean up any
+     * entries that share the domain of this transport.  This is primarily used during registration
+     * to clean up leftovers from other transports.
+     *
+     * @param jid JID of user whose roster we want to clean up.
+     * @param leaveDomain If set, we do not touch the roster item associated with the domain itself.
+     * @throws UserNotFoundException if the user is not found.
+     */
+    public void cleanUpRoster(JID jid, Boolean leaveDomain) throws UserNotFoundException {
         try {
             Roster roster = rosterManager.getRoster(jid.getNode());
             for (RosterItem ri : roster.getRosterItems()) {
                 if (ri.getJid().getDomain().equals(this.jid.getDomain())) {
+                    if (ri.isShared()) {
+                        continue;
+                    }
+                    if (leaveDomain &amp;&amp; ri.getJid().getNode() == null) {
+                        continue;
+                    }
                     try {
+                        Log.debug("Cleaning up roster entry " + ri.getJid().toString());
                         roster.deleteRosterItem(ri.getJid(), false);
                     }
                     catch (Exception e) {
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>107411</refactoring_id><commit_sha>a9a1737dd9be92a62e8a03775f54089285a99d56</commit_sha><commit_link>https://github.com/apache/cloudstack/commit/a9a1737dd9be92a62e8a03775f54089285a99d56</commit_link><file_path>server/src/main/java/com/cloud/network/router/CommandSetupHelper.java</file_path><description>Extract Method private getNetworkTrafficType(network Network) : TrafficType extracted from public createVpcAssociatePublicIPCommands(router VirtualRouter, ips List&lt;? extends PublicIpAddress&gt;, cmds Commands, vlanMacAddress Map&lt;String,String&gt;) : void in class com.cloud.network.router.CommandSetupHelper</description><code_before>@@ -104,7 +104,9 @@
 import com.cloud.network.vpc.StaticRouteProfile;
 import com.cloud.network.vpc.Vpc;
 import com.cloud.network.vpc.VpcGateway;
 import com.cloud.network.vpc.dao.VpcDao;
 import com.cloud.offering.NetworkOffering;
 import com.cloud.offerings.NetworkOfferingVO;
 import com.cloud.offerings.dao.NetworkOfferingDao;
@@ -170,6 +172,8 @@ public class CommandSetupHelper {
     @Inject
     private VpcDao _vpcDao;
     @Inject
     private VlanDao _vlanDao;
     @Inject
     private IPAddressDao _ipAddressDao;
@@ -707,7 +711,7 @@ public int compare(final PublicIpAddress o1, final PublicIpAddress o2) {
                 final IpAddressTO ip = new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, firstIP, sourceNat, BroadcastDomainType.fromString(ipAddr.getVlanTag()).toString(), ipAddr.getGateway(),
                         ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());
 
-                ip.setTrafficType(network.getTrafficType());
                 ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));
                 ipsToSend[i++] = ip;
                 if (ipAddr.isSourceNat()) {
@@ -823,7 +827,7 @@ public int compare(final PublicIpAddress o1, final PublicIpAddress o2) {
                 final IpAddressTO ip = new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, firstIP, sourceNat, vlanId, vlanGateway, vlanNetmask,
                         vifMacAddress, networkRate, ipAddr.isOneToOneNat());
 
-                ip.setTrafficType(network.getTrafficType());
                 ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));
                 ipsToSend[i++] = ip;
                 /*
@@ -948,7 +952,7 @@ public void createVpcAssociatePrivateIPCommands(final VirtualRouter router, fina
                 final IpAddressTO ip = new IpAddressTO(Account.ACCOUNT_ID_SYSTEM, ipAddr.getIpAddress(), add, false, ipAddr.getSourceNat(), ipAddr.getBroadcastUri(),
                         ipAddr.getGateway(), ipAddr.getNetmask(), ipAddr.getMacAddress(), null, false);
 
-                ip.setTrafficType(network.getTrafficType());
                 ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));
                 ipsToSend[i++] = ip;
 
@@ -1101,4 +1105,14 @@ protected String getGuestDhcpRange(final NicProfile guestNic, final Network gues
         }
         return dhcpRange;
     }
 }
</code_before><code_after>@@ -104,7 +104,9 @@
 import com.cloud.network.vpc.StaticRouteProfile;
 import com.cloud.network.vpc.Vpc;
 import com.cloud.network.vpc.VpcGateway;
+import com.cloud.network.vpc.VpcGatewayVO;
 import com.cloud.network.vpc.dao.VpcDao;
+import com.cloud.network.vpc.dao.VpcGatewayDao;
 import com.cloud.offering.NetworkOffering;
 import com.cloud.offerings.NetworkOfferingVO;
 import com.cloud.offerings.dao.NetworkOfferingDao;
@@ -170,6 +172,8 @@ public class CommandSetupHelper {
     @Inject
     private VpcDao _vpcDao;
     @Inject
+    private VpcGatewayDao _vpcGatewayDao;
+    @Inject
     private VlanDao _vlanDao;
     @Inject
     private IPAddressDao _ipAddressDao;
@@ -707,7 +711,7 @@ public int compare(final PublicIpAddress o1, final PublicIpAddress o2) {
                 final IpAddressTO ip = new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, firstIP, sourceNat, BroadcastDomainType.fromString(ipAddr.getVlanTag()).toString(), ipAddr.getGateway(),
                         ipAddr.getNetmask(), macAddress, networkRate, ipAddr.isOneToOneNat());
 
+                ip.setTrafficType(getNetworkTrafficType(network));
                 ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));
                 ipsToSend[i++] = ip;
                 if (ipAddr.isSourceNat()) {
@@ -823,7 +827,7 @@ public int compare(final PublicIpAddress o1, final PublicIpAddress o2) {
                 final IpAddressTO ip = new IpAddressTO(ipAddr.getAccountId(), ipAddr.getAddress().addr(), add, firstIP, sourceNat, vlanId, vlanGateway, vlanNetmask,
                         vifMacAddress, networkRate, ipAddr.isOneToOneNat());
 
+                ip.setTrafficType(getNetworkTrafficType(network));
                 ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));
                 ipsToSend[i++] = ip;
                 /*
@@ -948,7 +952,7 @@ public void createVpcAssociatePrivateIPCommands(final VirtualRouter router, fina
                 final IpAddressTO ip = new IpAddressTO(Account.ACCOUNT_ID_SYSTEM, ipAddr.getIpAddress(), add, false, ipAddr.getSourceNat(), ipAddr.getBroadcastUri(),
                         ipAddr.getGateway(), ipAddr.getNetmask(), ipAddr.getMacAddress(), null, false);
 
+                ip.setTrafficType(getNetworkTrafficType(network));
                 ip.setNetworkName(_networkModel.getNetworkTag(router.getHypervisorType(), network));
                 ipsToSend[i++] = ip;
 
@@ -1101,4 +1105,14 @@ protected String getGuestDhcpRange(final NicProfile guestNic, final Network gues
         }
         return dhcpRange;
     }
+
+    private TrafficType getNetworkTrafficType(Network network) {
+        final VpcGatewayVO gateway = _vpcGatewayDao.getVpcGatewayByNetworkId(network.getId());
+        if (gateway != null) {
+            s_logger.debug("network " + network.getId() + " (name: " + network.getName() + " ) is a vpc private gateway, set traffic type to Public");
+            return TrafficType.Public;
+        } else {
+            return network.getTrafficType();
+        }
+    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>123163</refactoring_id><commit_sha>c4bfa9b22eaaa38f0e8bddb84a442599ced91e6b</commit_sha><commit_link>https://github.com/oracle/graal/commit/c4bfa9b22eaaa38f0e8bddb84a442599ced91e6b</commit_link><file_path>truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/ImageBuildTimeOptions.java</file_path><description>Extract Method private getPropertyName(optionName String) : String extracted from package get(optionName String) : String in class com.oracle.truffle.polyglot.ImageBuildTimeOptions</description><code_before>@@ -54,16 +54,24 @@ final class ImageBuildTimeOptions {
     static final OptionKey&lt;String&gt; PreinitializeContexts = new OptionKey&lt;&gt;(null, OptionType.defaultType(String.class));
 
     static final String PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME = "PreinitializeContextsWithNative";
-    @Option(name = PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME, category = OptionCategory.EXPERT, help = "Pre-initialize language contexts for the given languages, allowing native access.")//
-    static final OptionKey&lt;String&gt; PreinitializeContextsWithNative = new OptionKey&lt;&gt;(null, OptionType.defaultType(String.class));
 
     static final String DISABLE_PRIVILEGES_NAME = "DisablePrivileges";
     @Option(name = DISABLE_PRIVILEGES_NAME, category = OptionCategory.EXPERT, help = "Disable Context privileges so the related code can be excluded from the image.")//
     static final OptionKey&lt;String&gt; DisablePrivileges = new OptionKey&lt;&gt;("");
 
     static String get(String optionName) {
-        String property = OptionValuesImpl.SYSTEM_PROPERTY_PREFIX + PolyglotEngineImpl.OPTION_GROUP_IMAGE_BUILD_TIME + "." + optionName;
         return System.getProperty(property, "");
     }
 
 }
</code_before><code_after>@@ -54,16 +54,24 @@ final class ImageBuildTimeOptions {
     static final OptionKey&lt;String&gt; PreinitializeContexts = new OptionKey&lt;&gt;(null, OptionType.defaultType(String.class));
 
     static final String PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME = "PreinitializeContextsWithNative";
+    @Option(name = PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME, category = OptionCategory.EXPERT, help = "Pre-initialize language contexts with native access privileges.")//
+    static final OptionKey&lt;Boolean&gt; PreinitializeContextsWithNative = new OptionKey&lt;&gt;(false);
 
     static final String DISABLE_PRIVILEGES_NAME = "DisablePrivileges";
     @Option(name = DISABLE_PRIVILEGES_NAME, category = OptionCategory.EXPERT, help = "Disable Context privileges so the related code can be excluded from the image.")//
     static final OptionKey&lt;String&gt; DisablePrivileges = new OptionKey&lt;&gt;("");
 
     static String get(String optionName) {
+        String property = getPropertyName(optionName);
         return System.getProperty(property, "");
     }
 
+    static Boolean getBoolean(String optionName) {
+        String property = getPropertyName(optionName);
+        return Boolean.getBoolean(property);
+    }
+
+    private static String getPropertyName(String optionName) {
+        return OptionValuesImpl.SYSTEM_PROPERTY_PREFIX + PolyglotEngineImpl.OPTION_GROUP_IMAGE_BUILD_TIME + "." + optionName;
+    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>64945</refactoring_id><commit_sha>5389da4d00e5fa9a8d5e8a070593fed57f10a905</commit_sha><commit_link>https://github.com/rstudio/rstudio/commit/5389da4d00e5fa9a8d5e8a070593fed57f10a905</commit_link><file_path>src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/AceEditor.java</file_path><description>Extract Method public insertCode(position Position, content String) : void extracted from public insertCode(position InputEditorPosition, content String) : void in class org.rstudio.studio.client.workbench.views.source.editors.text.AceEditor</description><code_before>@@ -728,7 +728,12 @@ public InputEditorSelection search(String needle,
    @Override
    public void insertCode(InputEditorPosition position, String content)
    {
-     getSession().insert(selectionToPosition(position), content);
    }
 
    @Override
</code_before><code_after>@@ -728,7 +728,12 @@ public InputEditorSelection search(String needle,
    @Override
    public void insertCode(InputEditorPosition position, String content)
    {
+      insertCode(selectionToPosition(position), content);
+   }
+   
+   public void insertCode(Position position, String content)
+   {
+      getSession().insert(position, content);
    }
 
    @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>119680</refactoring_id><commit_sha>0b0ecdddfd802e24b250653e1572c9ab93c1eb17</commit_sha><commit_link>https://github.com/oracle/graal/commit/0b0ecdddfd802e24b250653e1572c9ab93c1eb17</commit_link><file_path>compiler/src/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/ReassociateInvariantPhase.java</file_path><description>Extract Method private reassociateInvariants(graph StructuredGraph) : void extracted from protected run(graph StructuredGraph) : void in class org.graalvm.compiler.phases.common.ReassociationPhase</description><code_before>@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.graalvm.compiler.loop.phases;
-
-import org.graalvm.compiler.debug.DebugContext;
-import org.graalvm.compiler.loop.LoopEx;
-import org.graalvm.compiler.loop.LoopsData;
-import org.graalvm.compiler.nodes.StructuredGraph;
-import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;
-import org.graalvm.compiler.phases.Phase;
-
-/**
- * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} so that
- * invariant parts of the expression can move outside of the loop.
- */
-public class ReassociateInvariantPhase extends Phase {
-
-    @SuppressWarnings("try")
-    @Override
-    protected void run(StructuredGraph graph) {
-        int iterations = 0;
-        DebugContext debug = graph.getDebug();
-        try (DebugContext.Scope s = debug.scope("ReassociateInvariants")) {
-            boolean changed = true;
-            while (changed) {
-                changed = false;
-                final LoopsData dataReassociate = new LoopsData(graph);
-                for (LoopEx loop : dataReassociate.loops()) {
-                    changed |= loop.reassociateInvariants();
-                }
-                dataReassociate.deleteUnusedNodes();
-                iterations++;
-                debug.dump(DebugContext.VERBOSE_LEVEL, graph, "after iteration %d", iterations);
-            }
-        } catch (Throwable e) {
-            throw debug.handle(e);
-        }
-    }
-}
</code_before><code_after>@@ -1,61 +0,0 @@
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>67255</refactoring_id><commit_sha>42a61b966b7d38f073f65b1c1cacbd92ac0b9c2c</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/42a61b966b7d38f073f65b1c1cacbd92ac0b9c2c</commit_link><file_path>spring-core/src/test/java/org/springframework/core/annotation/AnnotationsScannerTests.java</file_path><description>Extract Method private scan(context C, source AnnotatedElement, searchStrategy SearchStrategy, searchEnclosingClass Predicate&lt;Class&lt;?&gt;&gt;, processor AnnotationsProcessor&lt;C,R&gt;) : R extracted from private scan(context C, source AnnotatedElement, searchStrategy SearchStrategy, processor AnnotationsProcessor&lt;C,R&gt;) : R in class org.springframework.core.annotation.AnnotationsScannerTests</description><code_before>@@ -26,13 +26,15 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 
 import org.springframework.core.annotation.MergedAnnotations.Search;
 import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
 import org.springframework.lang.Nullable;
 import org.springframework.util.ReflectionUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -422,29 +424,34 @@ void typeHierarchyStrategyOnMethodWithGenericParameterNonOverrideScansAnnotation
 	}
 
 	@Test
-	@SuppressWarnings("deprecation")
-	void typeHierarchyWithEnclosedStrategyOnEnclosedStaticClassScansAnnotations() {
 		Class&lt;?&gt; source = AnnotationEnclosingClassSample.EnclosedStatic.EnclosedStaticStatic.class;
-		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES))
 				.containsExactly("0:EnclosedThree", "1:EnclosedTwo", "2:EnclosedOne");
 	}
 
 	@Test
-	@SuppressWarnings("deprecation")
-	void typeHierarchyWithEnclosedStrategyOnEnclosedInnerClassScansAnnotations() {
 		Class&lt;?&gt; source = AnnotationEnclosingClassSample.EnclosedInner.EnclosedInnerInner.class;
-		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES))
 				.containsExactly("0:EnclosedThree", "1:EnclosedTwo", "2:EnclosedOne");
 	}
 
 	@Test
-	@SuppressWarnings("deprecation")
-	void typeHierarchyWithEnclosedStrategyOnMethodHierarchyUsesTypeHierarchyScan() {
 		Method source = methodFrom(WithHierarchy.class);
-		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES)).containsExactly(
-				"0:TestAnnotation1", "1:TestAnnotation5", "1:TestInheritedAnnotation5",
-				"2:TestAnnotation6", "3:TestAnnotation2", "3:TestInheritedAnnotation2",
-				"4:TestAnnotation3", "5:TestAnnotation4");
 	}
 
 	@Test
@@ -509,8 +516,14 @@ private Method methodFrom(Class&lt;?&gt; type) {
 	}
 
 	private Stream&lt;String&gt; scan(AnnotatedElement element, SearchStrategy searchStrategy) {
 		List&lt;String&gt; results = new ArrayList&lt;&gt;();
-		scan(this, element, searchStrategy,
 				(criteria, aggregateIndex, source, annotations) -&gt; {
 					trackIndexedAnnotations(aggregateIndex, annotations, results);
 					return null; // continue searching
@@ -521,7 +534,13 @@ private Stream&lt;String&gt; scan(AnnotatedElement element, SearchStrategy searchStrat
 	private static &lt;C, R&gt; R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy,
 			AnnotationsProcessor&lt;C, R&gt; processor) {
 
-		return AnnotationsScanner.scan(context, source, searchStrategy, Search.never, processor);
 	}
 
 	private void trackIndexedAnnotations(int aggregateIndex, Annotation[] annotations, List&lt;String&gt; results) {
</code_before><code_after>@@ -26,13 +26,15 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Objects;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 
 import org.springframework.core.annotation.MergedAnnotations.Search;
 import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
 import org.springframework.lang.Nullable;
+import org.springframework.util.ClassUtils;
 import org.springframework.util.ReflectionUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -422,29 +424,34 @@ void typeHierarchyStrategyOnMethodWithGenericParameterNonOverrideScansAnnotation
 	}
 
 	@Test
+	void typeHierarchyStrategyWithEnclosingClassPredicatesOnEnclosedStaticClassScansAnnotations() {
 		Class&lt;?&gt; source = AnnotationEnclosingClassSample.EnclosedStatic.EnclosedStaticStatic.class;
+		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY, ClassUtils::isInnerClass))
+				.containsExactly("0:EnclosedThree");
+		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY, Search.always).toList())
+				.isEqualTo(scan(source, SearchStrategy.TYPE_HIERARCHY, ClassUtils::isStaticClass).toList())
 				.containsExactly("0:EnclosedThree", "1:EnclosedTwo", "2:EnclosedOne");
 	}
 
 	@Test
+	void typeHierarchyStrategyWithEnclosingClassPredicatesOnEnclosedInnerClassScansAnnotations() {
 		Class&lt;?&gt; source = AnnotationEnclosingClassSample.EnclosedInner.EnclosedInnerInner.class;
+		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY, ClassUtils::isStaticClass))
+				.containsExactly("0:EnclosedThree");
+		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY, Search.always).toList())
+				.isEqualTo(scan(source, SearchStrategy.TYPE_HIERARCHY, ClassUtils::isInnerClass).toList())
 				.containsExactly("0:EnclosedThree", "1:EnclosedTwo", "2:EnclosedOne");
 	}
 
 	@Test
+	void typeHierarchyStrategyWithEnclosingClassPredicatesOnMethodHierarchyUsesTypeHierarchyScan() {
 		Method source = methodFrom(WithHierarchy.class);
+		assertThat(scan(source, SearchStrategy.TYPE_HIERARCHY, Search.always).toList())
+				.isEqualTo(scan(source, SearchStrategy.TYPE_HIERARCHY, ClassUtils::isInnerClass).toList())
+				.containsExactly(
+					"0:TestAnnotation1", "1:TestAnnotation5", "1:TestInheritedAnnotation5",
+					"2:TestAnnotation6", "3:TestAnnotation2", "3:TestInheritedAnnotation2",
+					"4:TestAnnotation3", "5:TestAnnotation4");
 	}
 
 	@Test
@@ -509,8 +516,14 @@ private Method methodFrom(Class&lt;?&gt; type) {
 	}
 
 	private Stream&lt;String&gt; scan(AnnotatedElement element, SearchStrategy searchStrategy) {
+		return scan(element, searchStrategy, Search.never);
+	}
+
+	private Stream&lt;String&gt; scan(AnnotatedElement element, SearchStrategy searchStrategy,
+			Predicate&lt;Class&lt;?&gt;&gt; searchEnclosingClass) {
+
 		List&lt;String&gt; results = new ArrayList&lt;&gt;();
+		scan(this, element, searchStrategy, searchEnclosingClass,
 				(criteria, aggregateIndex, source, annotations) -&gt; {
 					trackIndexedAnnotations(aggregateIndex, annotations, results);
 					return null; // continue searching
@@ -521,7 +534,13 @@ private Stream&lt;String&gt; scan(AnnotatedElement element, SearchStrategy searchStrat
 	private static &lt;C, R&gt; R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy,
 			AnnotationsProcessor&lt;C, R&gt; processor) {
 
+		return scan(context, source, searchStrategy, Search.never, processor);
+	}
+
+	private static &lt;C, R&gt; R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy,
+			Predicate&lt;Class&lt;?&gt;&gt; searchEnclosingClass, AnnotationsProcessor&lt;C, R&gt; processor) {
+
+		return AnnotationsScanner.scan(context, source, searchStrategy, searchEnclosingClass, processor);
 	}
 
 	private void trackIndexedAnnotations(int aggregateIndex, Annotation[] annotations, List&lt;String&gt; results) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>103250</refactoring_id><commit_sha>37770bb90ed835598782fa6b648095341aabf5b4</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/37770bb90ed835598782fa6b648095341aabf5b4</commit_link><file_path>hotspot/test/runtime/CheckEndorsedAndExtDirs/EndorsedExtDirs.java</file_path><description>Extract Method package fatalError(pb ProcessBuilder) : void extracted from package fatalError(args String...) : void in class EndorsedExtDirs</description><code_before>@@ -26,10 +26,16 @@
  * @bug 8064667
  * @summary Sanity test for -XX:+CheckEndorsedAndExtDirs
  * @library /testlibrary
- * @run main/othervm -XX:+CheckEndorsedAndExtDirs EndorsedExtDirs
  */
 
 import com.oracle.java.testlibrary.*;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -38,9 +44,28 @@ public class EndorsedExtDirs {
     public static void main(String arg[]) throws Exception {
         fatalError("-XX:+CheckEndorsedAndExtDirs", "-Djava.endorsed.dirs=foo");
         fatalError("-XX:+CheckEndorsedAndExtDirs", "-Djava.ext.dirs=bar");
     }
 
-    static void fatalError(String... args) throws Exception {
         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
         String java = System.getProperty("java.home") + "/bin/java";
         commands.add(java);
@@ -51,8 +76,15 @@ static void fatalError(String... args) throws Exception {
         commands.add(cpath);
         commands.add("EndorsedExtDirs");
 
-        System.out.println("Launching " + commands);
-        ProcessBuilder pb = new ProcessBuilder(commands);
         OutputAnalyzer output = new OutputAnalyzer(pb.start());
         output.shouldContain("Could not create the Java Virtual Machine");
         output.shouldHaveExitValue(1);
</code_before><code_after>@@ -26,10 +26,16 @@
  * @bug 8064667
  * @summary Sanity test for -XX:+CheckEndorsedAndExtDirs
  * @library /testlibrary
+ * @run main/othervm EndorsedExtDirs
  */
 
 import com.oracle.java.testlibrary.*;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -38,9 +44,28 @@ public class EndorsedExtDirs {
     public static void main(String arg[]) throws Exception {
         fatalError("-XX:+CheckEndorsedAndExtDirs", "-Djava.endorsed.dirs=foo");
         fatalError("-XX:+CheckEndorsedAndExtDirs", "-Djava.ext.dirs=bar");
+        testNonEmptySystemExtDirs();
     }
 
+    static void testNonEmptySystemExtDirs() throws Exception {
+        String home = System.getProperty("java.home");
+        Path ext = Paths.get(home, "lib", "ext");
+        String extDirs = System.getProperty("java.ext.dirs");
+        String[] dirs = extDirs.split(File.pathSeparator);
+        long count = 0;
+        for (String d : dirs) {
+            Path path = Paths.get(d);
+            if (Files.notExists(path) || path.equals(ext)) continue;
+            count += Files.find(path, 1, (Path p, BasicFileAttributes attr)
+                                       -&gt; p.getFileName().toString().endsWith(".jar"))
+                          .count();
+        }
+        if (count &gt; 0) {
+            fatalError("-XX:+CheckEndorsedAndExtDirs");
+        }
+    }
+
+    static ProcessBuilder newProcessBuilder(String... args) {
         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
         String java = System.getProperty("java.home") + "/bin/java";
         commands.add(java);
@@ -51,8 +76,15 @@ static void fatalError(String... args) throws Exception {
         commands.add(cpath);
         commands.add("EndorsedExtDirs");
 
+        System.out.println("Process " + commands);
+        return new ProcessBuilder(commands);
+    }
+
+    static void fatalError(String... args) throws Exception {
+        fatalError(newProcessBuilder(args));
+    }
+
+    static void fatalError(ProcessBuilder pb) throws Exception {
         OutputAnalyzer output = new OutputAnalyzer(pb.start());
         output.shouldContain("Could not create the Java Virtual Machine");
         output.shouldHaveExitValue(1);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>55554</refactoring_id><commit_sha>b5860c5f74844f02fb76d4a728db619acc0cae1a</commit_sha><commit_link>https://github.com/zstackio/zstack/commit/b5860c5f74844f02fb76d4a728db619acc0cae1a</commit_link><file_path>sdk/src/main/java/org/zstack/sdk/DestroyVmInstanceAction.java</file_path><description>Extract Method private makeResult(res ApiResult) : Result extracted from public call() : Result in class org.zstack.sdk.DestroyVmInstanceAction</description><code_before>@@ -42,33 +42,29 @@ public Result throwExceptionIfError() {
     public long pollingInterval;
 
 
-    public Result call() {
-        ApiResult res = ZSClient.call(this);
         Result ret = new Result();
         if (res.error != null) {
             ret.error = res.error;
             return ret;
         }
         
         DestroyVmInstanceResult value = res.getResult(DestroyVmInstanceResult.class);
-        ret.value = value == null ? new DestroyVmInstanceResult() : value;
         return ret;
     }
 
     public void call(final Completion&lt;Result&gt; completion) {
         ZSClient.call(this, new InternalCompletion() {
             @Override
             public void complete(ApiResult res) {
-                Result ret = new Result();
-                if (res.error != null) {
-                    ret.error = res.error;
-                    completion.complete(ret);
-                    return;
-                }
-                
-                DestroyVmInstanceResult value = res.getResult(DestroyVmInstanceResult.class);
-                ret.value = value == null ? new DestroyVmInstanceResult() : value;
-                completion.complete(ret);
             }
         });
     }
</code_before><code_after>@@ -42,33 +42,29 @@ public Result throwExceptionIfError() {
     public long pollingInterval;
 
 
+    private Result makeResult(ApiResult res) {
         Result ret = new Result();
         if (res.error != null) {
             ret.error = res.error;
             return ret;
         }
         
         DestroyVmInstanceResult value = res.getResult(DestroyVmInstanceResult.class);
+        ret.value = value == null ? new DestroyVmInstanceResult() : value; 
+
         return ret;
     }
 
+    public Result call() {
+        ApiResult res = ZSClient.call(this);
+        return makeResult(res);
+    }
+
     public void call(final Completion&lt;Result&gt; completion) {
         ZSClient.call(this, new InternalCompletion() {
             @Override
             public void complete(ApiResult res) {
+                completion.complete(makeResult(res));
             }
         });
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>85576</refactoring_id><commit_sha>081700f72b2a43e1e0d01a0130cf283c7d59b9bc</commit_sha><commit_link>https://github.com/google/exoplayer/commit/081700f72b2a43e1e0d01a0130cf283c7d59b9bc</commit_link><file_path>library/transformer/src/main/java/com/google/android/exoplayer2/transformer/AudioSamplePipeline.java</file_path><description>Extract Method private createFallbackRequest(transformationRequest TransformationRequest, requestedFormat Format, actualFormat Format) : TransformationRequest extracted from public AudioSamplePipeline(inputFormat Format, transformationRequest TransformationRequest, encoderFactory Codec.EncoderFactory, decoderFactory Codec.DecoderFactory) in class com.google.android.exoplayer2.transformer.AudioSamplePipeline</description><code_before>@@ -29,7 +29,9 @@
 import com.google.android.exoplayer2.audio.AudioProcessor.AudioFormat;
 import com.google.android.exoplayer2.audio.SonicAudioProcessor;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import java.nio.ByteBuffer;
 
 /**
  * Pipeline to decode audio samples, apply transformations on the raw samples, and re-encode them.
@@ -39,13 +41,12 @@
   private static final String TAG = "AudioSamplePipeline";
   private static final int DEFAULT_ENCODER_BITRATE = 128 * 1024;
 
-  private final TransformationRequest transformationRequest;
-
   private final Codec decoder;
   private final DecoderInputBuffer decoderInputBuffer;
 
   private final SonicAudioProcessor sonicAudioProcessor;
   private final SpeedProvider speedProvider;
 
   private final Codec encoder;
   private final AudioFormat encoderInputAudioFormat;
@@ -63,9 +64,9 @@ public AudioSamplePipeline(
       Format inputFormat,
       TransformationRequest transformationRequest,
       Codec.EncoderFactory encoderFactory,
-      Codec.DecoderFactory decoderFactory)
       throws TransformationException {
-    this.transformationRequest = transformationRequest;
     decoderInputBuffer =
         new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
     encoderInputBuffer =
@@ -75,6 +76,7 @@ public AudioSamplePipeline(
 
     this.decoder = decoderFactory.createForAudioDecoding(inputFormat);
 
     sonicAudioProcessor = new SonicAudioProcessor();
     sonicOutputBuffer = AudioProcessor.EMPTY_BUFFER;
     speedProvider = new SegmentSpeedProvider(inputFormat);
@@ -86,7 +88,7 @@ public AudioSamplePipeline(
             // The decoder uses ENCODING_PCM_16BIT by default.
             // https://developer.android.com/reference/android/media/MediaCodec#raw-audio-buffers
             C.ENCODING_PCM_16BIT);
-    if (transformationRequest.flattenForSlowMotion) {
       try {
         encoderInputAudioFormat = sonicAudioProcessor.configure(encoderInputAudioFormat);
       } catch (AudioProcessor.UnhandledAudioFormatException impossible) {
@@ -96,19 +98,23 @@ public AudioSamplePipeline(
       sonicAudioProcessor.setPitch(currentSpeed);
       sonicAudioProcessor.flush();
     }
-
-    encoder =
-        encoderFactory.createForAudioEncoding(
-            new Format.Builder()
-                .setSampleMimeType(
-                    transformationRequest.audioMimeType == null
-                        ? inputFormat.sampleMimeType
-                        : transformationRequest.audioMimeType)
-                .setSampleRate(encoderInputAudioFormat.sampleRate)
-                .setChannelCount(encoderInputAudioFormat.channelCount)
-                .setAverageBitrate(DEFAULT_ENCODER_BITRATE)
-                .build());
     this.encoderInputAudioFormat = encoderInputAudioFormat;
   }
 
   @Override
@@ -293,7 +299,7 @@ private void queueEndOfStreamToEncoder() throws TransformationException {
   }
 
   private boolean isSpeedChanging(BufferInfo bufferInfo) {
-    if (!transformationRequest.flattenForSlowMotion) {
       return false;
     }
     float newSpeed = speedProvider.getSpeed(bufferInfo.presentationTimeUs);
@@ -325,4 +331,15 @@ private void computeNextEncoderInputBufferTimeUs(
     }
     nextEncoderInputBufferTimeUs += bufferDurationUs;
   }
 }
</code_before><code_after>@@ -29,7 +29,9 @@
 import com.google.android.exoplayer2.audio.AudioProcessor.AudioFormat;
 import com.google.android.exoplayer2.audio.SonicAudioProcessor;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
+import org.checkerframework.dataflow.qual.Pure;
 
 /**
  * Pipeline to decode audio samples, apply transformations on the raw samples, and re-encode them.
@@ -39,13 +41,12 @@
   private static final String TAG = "AudioSamplePipeline";
   private static final int DEFAULT_ENCODER_BITRATE = 128 * 1024;
 
   private final Codec decoder;
   private final DecoderInputBuffer decoderInputBuffer;
 
   private final SonicAudioProcessor sonicAudioProcessor;
   private final SpeedProvider speedProvider;
+  private final boolean flattenForSlowMotion;
 
   private final Codec encoder;
   private final AudioFormat encoderInputAudioFormat;
@@ -63,9 +64,9 @@ public AudioSamplePipeline(
       Format inputFormat,
       TransformationRequest transformationRequest,
       Codec.EncoderFactory encoderFactory,
+      Codec.DecoderFactory decoderFactory,
+      FallbackListener fallbackListener)
       throws TransformationException {
     decoderInputBuffer =
         new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
     encoderInputBuffer =
@@ -75,6 +76,7 @@ public AudioSamplePipeline(
 
     this.decoder = decoderFactory.createForAudioDecoding(inputFormat);
 
+    this.flattenForSlowMotion = transformationRequest.flattenForSlowMotion;
     sonicAudioProcessor = new SonicAudioProcessor();
     sonicOutputBuffer = AudioProcessor.EMPTY_BUFFER;
     speedProvider = new SegmentSpeedProvider(inputFormat);
@@ -86,7 +88,7 @@ public AudioSamplePipeline(
             // The decoder uses ENCODING_PCM_16BIT by default.
             // https://developer.android.com/reference/android/media/MediaCodec#raw-audio-buffers
             C.ENCODING_PCM_16BIT);
+    if (flattenForSlowMotion) {
       try {
         encoderInputAudioFormat = sonicAudioProcessor.configure(encoderInputAudioFormat);
       } catch (AudioProcessor.UnhandledAudioFormatException impossible) {
@@ -96,19 +98,23 @@ public AudioSamplePipeline(
       sonicAudioProcessor.setPitch(currentSpeed);
       sonicAudioProcessor.flush();
     }
     this.encoderInputAudioFormat = encoderInputAudioFormat;
+
+    Format requestedOutputFormat =
+        new Format.Builder()
+            .setSampleMimeType(
+                transformationRequest.audioMimeType == null
+                    ? inputFormat.sampleMimeType
+                    : transformationRequest.audioMimeType)
+            .setSampleRate(encoderInputAudioFormat.sampleRate)
+            .setChannelCount(encoderInputAudioFormat.channelCount)
+            .setAverageBitrate(DEFAULT_ENCODER_BITRATE)
+            .build();
+    encoder = encoderFactory.createForAudioEncoding(requestedOutputFormat);
+
+    fallbackListener.onTransformationRequestFinalized(
+        createFallbackRequest(
+            transformationRequest, requestedOutputFormat, encoder.getConfigurationFormat()));
   }
 
   @Override
@@ -293,7 +299,7 @@ private void queueEndOfStreamToEncoder() throws TransformationException {
   }
 
   private boolean isSpeedChanging(BufferInfo bufferInfo) {
+    if (!flattenForSlowMotion) {
       return false;
     }
     float newSpeed = speedProvider.getSpeed(bufferInfo.presentationTimeUs);
@@ -325,4 +331,15 @@ private void computeNextEncoderInputBufferTimeUs(
     }
     nextEncoderInputBufferTimeUs += bufferDurationUs;
   }
+
+  @Pure
+  private static TransformationRequest createFallbackRequest(
+      TransformationRequest transformationRequest, Format requestedFormat, Format actualFormat) {
+    // TODO(b/210591626): Also update bitrate and other params once encoder configuration and
+    // fallback are implemented.
+    if (Util.areEqual(requestedFormat.sampleMimeType, actualFormat.sampleMimeType)) {
+      return transformationRequest;
+    }
+    return transformationRequest.buildUpon().setAudioMimeType(actualFormat.sampleMimeType).build();
+  }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>101419</refactoring_id><commit_sha>638211eb41a9acf5d5b76cd3583f60ef7a6f20b2</commit_sha><commit_link>https://github.com/cuba-platform/cuba/commit/638211eb41a9acf5d5b76cd3583f60ef7a6f20b2</commit_link><file_path>modules/web/src/com/haulmont/cuba/web/app/ui/report/ReportHelper.java</file_path><description>Extract Method private openReportParamsDialog(report Report, window Window) : void extracted from public createRunReportButton(captionId String, window Window) : AbstractAction in class com.haulmont.cuba.web.app.ui.report.ReportHelper</description><code_before>@@ -46,14 +46,18 @@ private ReportHelper() {
     public static void runReport(Report report, Window window) {
         if (report != null) {
             if (report.getInputParameters() != null &amp;&amp; report.getInputParameters().size() &gt; 0) {
-                window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG,
-                        Collections.&lt;String, Object&gt;singletonMap("report", report));
             } else {
                 ReportHelper.printReport(report, Collections.&lt;String, Object&gt;emptyMap());
             }
         }
     }
 
     public static void runReport(Report report, Window window, final String paramAlias, final Object paramValue) {
         runReport(report, window, paramAlias, paramValue, null);
     }
@@ -62,8 +66,7 @@ public static void runReport(Report report, Window window, final String paramAli
         if (report != null) {
             List&lt;ReportInputParameter&gt; params = report.getInputParameters();
             if (params != null &amp;&amp; params.size() &gt; 1) {
-                window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG,
-                        Collections.&lt;String, Object&gt;singletonMap("report", report));
             } else {
                 if (params != null &amp;&amp; params.size() == 1) {
                     if (name == null)
@@ -97,14 +100,6 @@ public static void printReport(Report report, String name, Map&lt;String, Object&gt; p
         }
         if (find)
             printReport(report, name, params, item.getKey(), item.getValue());
-        /*
-        if (ReportOutputType.XLS.equals(reportOutputType))
-            printReport(report, params, ReportOutputType.XLS, ExportFormat.XLS);
-        else if (ReportOutputType.DOC.equals(reportOutputType))
-            printReport(report, params, ReportOutputType.DOC, ExportFormat.DOC);
-        else if (ReportOutputType.PDF.equals(reportOutputType))
-            printReport(report, params, ReportOutputType.PDF, ExportFormat.PDF);
-        */
     }
 
     private static void printReport(Report report, String name, Map&lt;String, Object&gt; params, ReportOutputType reportOutputType, ExportFormat exportFormat) {
@@ -131,7 +126,7 @@ public void handleLookup(Collection items) {
                             report = window.getDsContext().getDataService().reload(report, "report.edit");
                             if (report != null) {
                                 if (report.getInputParameters() != null &amp;&amp; report.getInputParameters().size() &gt; 0) {
-                                    window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG, Collections.&lt;String, Object&gt;singletonMap("report", report));
                                 } else {
                                     ReportHelper.printReport(report, Collections.&lt;String, Object&gt;emptyMap());
                                 }
</code_before><code_after>@@ -46,14 +46,18 @@ private ReportHelper() {
     public static void runReport(Report report, Window window) {
         if (report != null) {
             if (report.getInputParameters() != null &amp;&amp; report.getInputParameters().size() &gt; 0) {
+                openReportParamsDialog(report, window);
             } else {
                 ReportHelper.printReport(report, Collections.&lt;String, Object&gt;emptyMap());
             }
         }
     }
 
+    private static void openReportParamsDialog(Report report, Window window) {
+        window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG,
+                Collections.&lt;String, Object&gt;singletonMap("report", report));
+    }
+
     public static void runReport(Report report, Window window, final String paramAlias, final Object paramValue) {
         runReport(report, window, paramAlias, paramValue, null);
     }
@@ -62,8 +66,7 @@ public static void runReport(Report report, Window window, final String paramAli
         if (report != null) {
             List&lt;ReportInputParameter&gt; params = report.getInputParameters();
             if (params != null &amp;&amp; params.size() &gt; 1) {
+                openReportParamsDialog(report, window);
             } else {
                 if (params != null &amp;&amp; params.size() == 1) {
                     if (name == null)
@@ -97,14 +100,6 @@ public static void printReport(Report report, String name, Map&lt;String, Object&gt; p
         }
         if (find)
             printReport(report, name, params, item.getKey(), item.getValue());
     }
 
     private static void printReport(Report report, String name, Map&lt;String, Object&gt; params, ReportOutputType reportOutputType, ExportFormat exportFormat) {
@@ -131,7 +126,7 @@ public void handleLookup(Collection items) {
                             report = window.getDsContext().getDataService().reload(report, "report.edit");
                             if (report != null) {
                                 if (report.getInputParameters() != null &amp;&amp; report.getInputParameters().size() &gt; 0) {
+                                    openReportParamsDialog(report, window);
                                 } else {
                                     ReportHelper.printReport(report, Collections.&lt;String, Object&gt;emptyMap());
                                 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>23231</refactoring_id><commit_sha>7fe7002f2ffafdb9405ffb57b1e6236d439c6588</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/7fe7002f2ffafdb9405ffb57b1e6236d439c6588</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/coreapi/LegacyIndexProxy.java</file_path><description>Extract Method private internalGet(key String, value Object, statement Statement) : LegacyIndexHits extracted from public get(key String, value Object) : IndexHits&lt;T&gt; in class org.neo4j.kernel.impl.coreapi.LegacyIndexProxy</description><code_before>@@ -42,6 +42,10 @@
 
 import static java.lang.String.format;
 
 public class LegacyIndexProxy&lt;T extends PropertyContainer&gt; implements Index&lt;T&gt;
 {
     public interface Lookup
@@ -102,14 +106,6 @@ void drop( DataWriteOperations operations, String name )
             {
                 operations.nodeLegacyIndexDrop( name );
             }
-
-            @Override
-            long putIfAbsent( DataWriteOperations operations, long id, String key, Object value )
-                    throws EntityNotFoundException, InvalidTransactionTypeKernelException,
-                    ReadOnlyDatabaseKernelException
-            {
-                return operations.nodeLegacyIndexPutIfAbsent( id, key, value );
-            }
         },
         RELATIONSHIP
         {
@@ -160,14 +156,6 @@ void drop( DataWriteOperations operations, String name ) throws InvalidTransacti
             {
                 operations.relationshipLegacyIndexDrop( name );
             }
-
-            @Override
-            long putIfAbsent( DataWriteOperations operations, long id, String key, Object value )
-                    throws EntityNotFoundException, InvalidTransactionTypeKernelException,
-                    ReadOnlyDatabaseKernelException
-            {
-                return operations.relationshipLegacyIndexPutIfAbsent( id, key, value );
-            }
         }
 
         ;
@@ -190,9 +178,6 @@ abstract void remove( DataWriteOperations operations, String name, long id )
 
         abstract void drop( DataWriteOperations operations, String name )
                 throws InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException;
-
-        abstract long putIfAbsent( DataWriteOperations operations, long id, String key, Object value )
-                throws EntityNotFoundException, InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException;
     }
 
     private final String name;
@@ -226,14 +211,20 @@ public IndexHits&lt;T&gt; get( String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
-            return wrapIndexHits( statement.readOperations().nodeLegacyIndexGet( name, key, value ) );
         }
         catch ( LegacyIndexNotFoundKernelException e )
         {
             throw new NotFoundException( type + " index '" + name + "' doesn't exist" );
         }
     }
 
     private IndexHits&lt;T&gt; wrapIndexHits( final LegacyIndexHits ids )
     {
         return new IndexHits&lt;T&gt;()
@@ -344,7 +335,7 @@ public void add( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
-            type.add( statement.dataWriteOperations(), name, entity.getId(), key, value );
         }
         catch ( EntityNotFoundException e )
         {
@@ -433,7 +424,27 @@ public T putIfAbsent( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
-            return entityOf( type.putIfAbsent( statement.dataWriteOperations(), entity.getId(), key, value ) );
         }
         catch ( EntityNotFoundException e )
         {
@@ -447,5 +458,15 @@ public T putIfAbsent( T entity, String key, Object value )
         {
             throw new ReadOnlyDbException();
         }
     }
 }
</code_before><code_after>@@ -42,6 +42,10 @@
 
 import static java.lang.String.format;
 
+import static org.neo4j.collection.primitive.PrimitiveLongCollections.single;
+import static org.neo4j.kernel.impl.locking.ResourceTypes.LEGACY_INDEX;
+import static org.neo4j.kernel.impl.locking.ResourceTypes.legacyIndexResourceId;
+
 public class LegacyIndexProxy&lt;T extends PropertyContainer&gt; implements Index&lt;T&gt;
 {
     public interface Lookup
@@ -102,14 +106,6 @@ void drop( DataWriteOperations operations, String name )
             {
                 operations.nodeLegacyIndexDrop( name );
             }
         },
         RELATIONSHIP
         {
@@ -160,14 +156,6 @@ void drop( DataWriteOperations operations, String name ) throws InvalidTransacti
             {
                 operations.relationshipLegacyIndexDrop( name );
             }
         }
 
         ;
@@ -190,9 +178,6 @@ abstract void remove( DataWriteOperations operations, String name, long id )
 
         abstract void drop( DataWriteOperations operations, String name )
                 throws InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException;
     }
 
     private final String name;
@@ -226,14 +211,20 @@ public IndexHits&lt;T&gt; get( String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
+            return wrapIndexHits( internalGet( key, value, statement ) );
         }
         catch ( LegacyIndexNotFoundKernelException e )
         {
             throw new NotFoundException( type + " index '" + name + "' doesn't exist" );
         }
     }
 
+    private LegacyIndexHits internalGet( String key, Object value, Statement statement )
+            throws LegacyIndexNotFoundKernelException
+    {
+        return statement.readOperations().nodeLegacyIndexGet( name, key, value );
+    }
+
     private IndexHits&lt;T&gt; wrapIndexHits( final LegacyIndexHits ids )
     {
         return new IndexHits&lt;T&gt;()
@@ -344,7 +335,7 @@ public void add( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
+            internalAdd( entity, key, value, statement );
         }
         catch ( EntityNotFoundException e )
         {
@@ -433,7 +424,27 @@ public T putIfAbsent( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
+            // Does it already exist?
+            long existing = single( internalGet( key, value, statement ), -1L );
+            if ( existing != -1 )
+            {
+                return entityOf( existing );
+            }
+
+            // No, OK so Grab lock
+            statement.readOperations().acquireExclusive( LEGACY_INDEX, legacyIndexResourceId( name, key ) );
+            // and check again -- now holding an exclusive lock
+            existing = single( internalGet( key, value, statement ), -1L );
+            if ( existing != -1 )
+            {
+                // Someone else created this entry before us just before we got the lock,
+                // release the lock as we won't be needing it
+                statement.readOperations().releaseExclusive( LEGACY_INDEX, legacyIndexResourceId( name, key ) );
+                return entityOf( existing );
+            }
+
+            internalAdd( entity, key, value, statement );
+            return null;
         }
         catch ( EntityNotFoundException e )
         {
@@ -447,5 +458,15 @@ public T putIfAbsent( T entity, String key, Object value )
         {
             throw new ReadOnlyDbException();
         }
+        catch ( LegacyIndexNotFoundKernelException e )
+        {
+            throw new RuntimeException( e );
+        }
+    }
+
+    private void internalAdd( T entity, String key, Object value, Statement statement ) throws EntityNotFoundException,
+            InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException
+    {
+        type.add( statement.dataWriteOperations(), name, entity.getId(), key, value );
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>33154</refactoring_id><commit_sha>2060664018a90cc341025800cc644474ed586cb1</commit_sha><commit_link>https://github.com/apache/storm/commit/2060664018a90cc341025800cc644474ed586cb1</commit_link><file_path>storm-client/src/jvm/org/apache/storm/testing/FixedTupleSpout.java</file_path><description>Extract Method public FixedTupleSpout(tuples List, fields Fields) extracted from public FixedTupleSpout(tuples List, fieldName String) in class org.apache.storm.testing.FixedTupleSpout</description><code_before>@@ -60,13 +60,21 @@ public static void clear(String stormId) {
     private Map&lt;String, FixedTuple&gt; _pending;
 
     private String _id;
-    private String _fieldName;
 
     public FixedTupleSpout(List tuples) {
-        this(tuples, null);
     }
 
     public FixedTupleSpout(List tuples, String fieldName) {
         _id = UUID.randomUUID().toString();
         synchronized(acked) {
             acked.put(_id, 0);
@@ -84,7 +92,7 @@ public FixedTupleSpout(List tuples, String fieldName) {
             }
             _tuples.add(ft);
         }
-        _fieldName = fieldName;
     }
 
     public List&lt;FixedTuple&gt; getSourceTuples() {
@@ -168,8 +176,8 @@ public void deactivate() {
 
     @Override
     public void declareOutputFields(OutputFieldsDeclarer declarer) { 
-        if (_fieldName != null) {
-            declarer.declare(new Fields(_fieldName));
         }
     }
 
</code_before><code_after>@@ -60,13 +60,21 @@ public static void clear(String stormId) {
     private Map&lt;String, FixedTuple&gt; _pending;
 
     private String _id;
+    private Fields _fields;
 
     public FixedTupleSpout(List tuples) {
+        this(tuples, (Fields) null);
     }
 
+    /**
+     * @deprecated please use {@link #FixedTupleSpout(List, Fields)}
+     */
+    @Deprecated
     public FixedTupleSpout(List tuples, String fieldName) {
+        this(tuples, new Fields(fieldName));
+    }
+
+    public FixedTupleSpout(List tuples, Fields fields) {
         _id = UUID.randomUUID().toString();
         synchronized(acked) {
             acked.put(_id, 0);
@@ -84,7 +92,7 @@ public FixedTupleSpout(List tuples, String fieldName) {
             }
             _tuples.add(ft);
         }
+        _fields = fields;
     }
 
     public List&lt;FixedTuple&gt; getSourceTuples() {
@@ -168,8 +176,8 @@ public void deactivate() {
 
     @Override
     public void declareOutputFields(OutputFieldsDeclarer declarer) { 
+        if (_fields != null) {
+            declarer.declare(_fields);
         }
     }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>118466</refactoring_id><commit_sha>0a194be29b0b643c773c294999cd8f4a7ad479f3</commit_sha><commit_link>https://github.com/StarRocks/starrocks/commit/0a194be29b0b643c773c294999cd8f4a7ad479f3</commit_link><file_path>fe/fe-core/src/main/java/com/starrocks/sql/ast/ImportColumnsStmt.java</file_path><description>Extract Method public ImportColumnsStmt(columns List&lt;ImportColumnDesc&gt;, pos NodePosition) extracted from public ImportColumnsStmt(columns List&lt;ImportColumnDesc&gt;) in class com.starrocks.sql.ast.ImportColumnsStmt</description><code_before>@@ -16,13 +16,19 @@
 package com.starrocks.sql.ast;
 
 import com.starrocks.analysis.RedirectStatus;
 
 import java.util.List;
 
 public class ImportColumnsStmt extends StatementBase {
     private final List&lt;ImportColumnDesc&gt; columns;
 
     public ImportColumnsStmt(List&lt;ImportColumnDesc&gt; columns) {
         this.columns = columns;
     }
 
</code_before><code_after>@@ -16,13 +16,19 @@
 package com.starrocks.sql.ast;
 
 import com.starrocks.analysis.RedirectStatus;
+import com.starrocks.sql.parser.NodePosition;
 
 import java.util.List;
 
 public class ImportColumnsStmt extends StatementBase {
     private final List&lt;ImportColumnDesc&gt; columns;
 
     public ImportColumnsStmt(List&lt;ImportColumnDesc&gt; columns) {
+        this(columns, NodePosition.ZERO);
+    }
+
+    public ImportColumnsStmt(List&lt;ImportColumnDesc&gt; columns, NodePosition pos) {
+        super(pos);
         this.columns = columns;
     }
 
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>99932</refactoring_id><commit_sha>394aa7426117d0d04666c1c2a63d5f98229b7894</commit_sha><commit_link>https://github.com/AutoMQ/automq/commit/394aa7426117d0d04666c1c2a63d5f98229b7894</commit_link><file_path>streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java</file_path><description>Extract Method private forward(child ProcessorNode, key K, value V) : void extracted from public forward(key K, value V, childIndex int) : void in class org.apache.kafka.streams.processor.internals.ProcessorContextImpl</description><code_before>@@ -18,12 +18,13 @@
 
 import org.apache.kafka.streams.StreamsConfig;
 import org.apache.kafka.streams.StreamsMetrics;
 import org.apache.kafka.streams.processor.Cancellable;
 import org.apache.kafka.streams.processor.PunctuationType;
 import org.apache.kafka.streams.processor.Punctuator;
 import org.apache.kafka.streams.processor.StateStore;
-import org.apache.kafka.streams.errors.StreamsException;
 import org.apache.kafka.streams.processor.TaskId;
 import org.apache.kafka.streams.state.internals.ThreadCache;
 
 import java.util.List;
@@ -32,6 +33,8 @@ public class ProcessorContextImpl extends AbstractProcessorContext implements Re
 
     private final StreamTask task;
     private final RecordCollector collector;
 
     ProcessorContextImpl(final TaskId id,
                          final StreamTask task,
@@ -77,32 +80,60 @@ public StateStore getStateStore(final String name) {
 
     @SuppressWarnings("unchecked")
     @Override
     public &lt;K, V&gt; void forward(final K key, final V value, final int childIndex) {
         final ProcessorNode previousNode = currentNode();
-        final ProcessorNode child = (ProcessorNode&lt;K, V&gt;) currentNode().children().get(childIndex);
-        setCurrentNode(child);
         try {
-            child.process(key, value);
         } finally {
             setCurrentNode(previousNode);
         }
     }
 
     @SuppressWarnings("unchecked")
-    @Override
-    public &lt;K, V&gt; void forward(final K key, final V value, final String childName) {
-        for (ProcessorNode child : (List&lt;ProcessorNode&lt;K, V&gt;&gt;) currentNode().children()) {
-            if (child.name().equals(childName)) {
-                ProcessorNode previousNode = currentNode();
-                setCurrentNode(child);
-                try {
-                    child.process(key, value);
-                    return;
-                } finally {
-                    setCurrentNode(previousNode);
-                }
-            }
-        }
     }
 
     @Override
</code_before><code_after>@@ -18,12 +18,13 @@
 
 import org.apache.kafka.streams.StreamsConfig;
 import org.apache.kafka.streams.StreamsMetrics;
+import org.apache.kafka.streams.errors.StreamsException;
 import org.apache.kafka.streams.processor.Cancellable;
 import org.apache.kafka.streams.processor.PunctuationType;
 import org.apache.kafka.streams.processor.Punctuator;
 import org.apache.kafka.streams.processor.StateStore;
 import org.apache.kafka.streams.processor.TaskId;
+import org.apache.kafka.streams.processor.To;
 import org.apache.kafka.streams.state.internals.ThreadCache;
 
 import java.util.List;
@@ -32,6 +33,8 @@ public class ProcessorContextImpl extends AbstractProcessorContext implements Re
 
     private final StreamTask task;
     private final RecordCollector collector;
+    private final ToInternal toInternal = new ToInternal();
+    private final static To SEND_TO_ALL = To.all();
 
     ProcessorContextImpl(final TaskId id,
                          final StreamTask task,
@@ -77,32 +80,60 @@ public StateStore getStateStore(final String name) {
 
     @SuppressWarnings("unchecked")
     @Override
+    public &lt;K, V&gt; void forward(final K key, final V value) {
+        forward(key, value, SEND_TO_ALL);
+    }
+
+    @SuppressWarnings({"unchecked", "deprecation"})
+    @Override
     public &lt;K, V&gt; void forward(final K key, final V value, final int childIndex) {
+        forward(key, value, To.child(((List&lt;ProcessorNode&gt;) currentNode().children()).get(childIndex).name()));
+    }
+
+    @SuppressWarnings({"unchecked", "deprecation"})
+    @Override
+    public &lt;K, V&gt; void forward(final K key, final V value, final String childName) {
+        forward(key, value, To.child(childName));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public &lt;K, V&gt; void forward(final K key, final V value, final To to) {
+        toInternal.update(to);
+        if (toInternal.hasTimestamp()) {
+            recordContext.setTimestamp(toInternal.timestamp());
+        }
         final ProcessorNode previousNode = currentNode();
         try {
+            final List&lt;ProcessorNode&lt;K, V&gt;&gt; children = (List&lt;ProcessorNode&lt;K, V&gt;&gt;) currentNode().children();
+            final String sendTo = toInternal.child();
+            if (sendTo != null) {
+                final ProcessorNode child = currentNode().getChild(sendTo);
+                if (child == null) {
+                    throw new StreamsException("Unknown processor name: " + sendTo);
+                }
+                forward(child, key, value);
+            } else {
+                if (children.size() == 1) {
+                    final ProcessorNode child = children.get(0);
+                    forward(child, key, value);
+                } else {
+                    for (final ProcessorNode child : children) {
+                        forward(child, key, value);
+                    }
+                }
+            }
         } finally {
             setCurrentNode(previousNode);
         }
     }
 
     @SuppressWarnings("unchecked")
+    private &lt;K, V&gt; void forward(final ProcessorNode child,
+                                final K key,
+                                final V value) {
+        setCurrentNode(child);
+        child.process(key, value);
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>22633</refactoring_id><commit_sha>e8e79a37be13a5979222344539254c76558a44d9</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/e8e79a37be13a5979222344539254c76558a44d9</commit_link><file_path>community/neo4j/src/main/java/org/neo4j/server/startup/BootloaderOsAbstraction.java</file_path><description>Extract Method private getConfiguredJvmOpts() : List&lt;String&gt; extracted from protected getJvmOpts() : List&lt;String&gt; in class org.neo4j.server.startup.BootloaderOsAbstraction</description><code_before>@@ -52,6 +52,16 @@
 
 abstract class BootloaderOsAbstraction
 {
     static final long UNKNOWN_PID = Long.MAX_VALUE;
 
     protected final BootloaderContext ctx;
@@ -203,6 +213,15 @@ private static String bytesToSuitableJvmString( long bytes )
     }
 
     protected List&lt;String&gt; getJvmOpts()
     {
         // If JAVA_OPTS is provided, it has the highest priority
         // and we just use that as it is without any modification
</code_before><code_after>@@ -52,6 +52,16 @@
 
 abstract class BootloaderOsAbstraction
 {
+    private static final List&lt;String&gt; JVM_ADD_OPENS = List.of(
+            "--add-opens", "java.base/java.lang=ALL-UNNAMED",
+            "--add-opens", "java.base/java.nio=ALL-UNNAMED",
+            "--add-opens", "java.base/java.io=ALL-UNNAMED",
+            "--add-opens", "java.base/java.util=ALL-UNNAMED",
+            "--add-opens", "java.base/java.util.concurrent=ALL-UNNAMED",
+            "--add-opens", "java.base/sun.net.www.protocol.http=ALL-UNNAMED",
+            "--add-opens", "java.base/sun.nio.ch=ALL-UNNAMED"
+    );
+
     static final long UNKNOWN_PID = Long.MAX_VALUE;
 
     protected final BootloaderContext ctx;
@@ -203,6 +213,15 @@ private static String bytesToSuitableJvmString( long bytes )
     }
 
     protected List&lt;String&gt; getJvmOpts()
+    {
+        MutableList&lt;String&gt; opts = Lists.mutable.empty();
+        opts.withAll( getConfiguredJvmOpts() );
+        // Always add --add-opens options because database can't start without them
+        opts.withAll( JVM_ADD_OPENS );
+        return opts;
+    }
+
+    private List&lt;String&gt; getConfiguredJvmOpts()
     {
         // If JAVA_OPTS is provided, it has the highest priority
         // and we just use that as it is without any modification
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>104968</refactoring_id><commit_sha>febb9d78311ca92bd1eb8fa514a552f299f191cb</commit_sha><commit_link>https://github.com/freeplane/freeplane/commit/febb9d78311ca92bd1eb8fa514a552f299f191cb</commit_link><file_path>freeplane/src/org/freeplane/view/swing/ui/DefaultNodeMouseMotionListener.java</file_path><description>Extract Method private showMenuAndConsumeEvent(popupmenu JPopupMenu, e MouseEvent) : void extracted from public showPopupMenu(e MouseEvent) : void in class org.freeplane.view.swing.ui.DefaultNodeMouseMotionListener</description><code_before>@@ -25,6 +25,7 @@
 import org.freeplane.core.util.LogUtils;
 import org.freeplane.core.util.SysUtils;
 import org.freeplane.features.link.LinkController;
 import org.freeplane.features.map.IMapSelection;
 import org.freeplane.features.map.MapController;
 import org.freeplane.features.map.NodeModel;
@@ -295,24 +296,40 @@ public void mouseReleased(final MouseEvent e) {
 	}
 
 	public void showPopupMenu(final MouseEvent e) {
-		if (isInside(e) 
-				&amp;&amp; e.isPopupTrigger()) {
 			stopTimerForDelayedSelection();
 			final MainView component = (MainView) e.getComponent();
 			final NodeView nodeView = component.getNodeView();
-			if(! nodeView.isSelected()){
-				Controller.getCurrentController().getSelection().selectAsTheOnlyOneSelected(nodeView.getModel());
-			}
 			ModeController mc = Controller.getCurrentController().getModeController();
-			final JPopupMenu popupmenu = mc.getUserInputListenerFactory().getNodePopupMenu();
-			if (popupmenu != null) {
-				popupmenu.addHierarchyListener(popupListener);
-				popupmenu.show(e.getComponent(), e.getX(), e.getY());
-				e.consume();
 			}
 		}
 	}
 
 	protected boolean isInside(final MouseEvent e) {
 		return new Rectangle(0, 0, e.getComponent().getWidth(), e.getComponent().getHeight()).contains(e.getPoint());
 	}
</code_before><code_after>@@ -25,6 +25,7 @@
 import org.freeplane.core.util.LogUtils;
 import org.freeplane.core.util.SysUtils;
 import org.freeplane.features.link.LinkController;
+import org.freeplane.features.map.FoldingController;
 import org.freeplane.features.map.IMapSelection;
 import org.freeplane.features.map.MapController;
 import org.freeplane.features.map.NodeModel;
@@ -295,24 +296,40 @@ public void mouseReleased(final MouseEvent e) {
 	}
 
 	public void showPopupMenu(final MouseEvent e) {
+		if (! e.isPopupTrigger())
+			return;
+		final boolean inside = isInside(e);
+		final boolean inFoldingRegion = ! inside &amp;&amp; isInFoldingRegion(e);
+		if (inside || inFoldingRegion) {
 			stopTimerForDelayedSelection();
 			final MainView component = (MainView) e.getComponent();
 			final NodeView nodeView = component.getNodeView();
 			ModeController mc = Controller.getCurrentController().getModeController();
+			if(inside){
+				if(! nodeView.isSelected()){
+					Controller.getCurrentController().getSelection().selectAsTheOnlyOneSelected(nodeView.getModel());
+				}
+				final JPopupMenu popupmenu = mc.getUserInputListenerFactory().getNodePopupMenu();
+				showMenuAndConsumeEvent(popupmenu, e);
+			}
+			else if(inFoldingRegion){
+				final FoldingController foldingController = mc.getExtension(FoldingController.class);
+				if(foldingController == null)
+					return;
+				final JPopupMenu popupmenu = foldingController.createFoldingPopupMenu(nodeView.getModel());
+				showMenuAndConsumeEvent(popupmenu, e);
 			}
 		}
 	}
 
+	private void showMenuAndConsumeEvent(final JPopupMenu popupmenu, final MouseEvent e) {
+	    if (popupmenu != null) {
+	    	popupmenu.addHierarchyListener(popupListener);
+	    	popupmenu.show(e.getComponent(), e.getX(), e.getY());
+	    	e.consume();
+	    }
+    }
+
 	protected boolean isInside(final MouseEvent e) {
 		return new Rectangle(0, 0, e.getComponent().getWidth(), e.getComponent().getHeight()).contains(e.getPoint());
 	}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>44358</refactoring_id><commit_sha>44cca1a26f5c395420111fafa122bed5aeecfeb7</commit_sha><commit_link>https://github.com/netty/netty/commit/44cca1a26f5c395420111fafa122bed5aeecfeb7</commit_link><file_path>buffer/src/main/java/io/netty/buffer/Unpooled.java</file_path><description>Extract Method package wrappedBuffer(maxNumComponents int, wrapper ByteWrapper&lt;T&gt;, array T[]) : ByteBuf extracted from public wrappedBuffer(maxNumComponents int, buffers ByteBuffer...) : ByteBuf in class io.netty.buffer.Unpooled</description><code_before>@@ -15,15 +15,14 @@
  */
 package io.netty.buffer;
 
 import io.netty.util.internal.PlatformDependent;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.CharBuffer;
 import java.nio.charset.Charset;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
 
 
 /**
@@ -262,40 +261,39 @@ public static ByteBuf wrappedBuffer(ByteBuffer... buffers) {
         return wrappedBuffer(buffers.length, buffers);
     }
 
-    /**
-     * Creates a new big-endian composite buffer which wraps the specified
-     * arrays without copying them.  A modification on the specified arrays'
-     * content will be visible to the returned buffer.
-     */
-    public static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays) {
-        switch (arrays.length) {
         case 0:
             break;
         case 1:
-            if (arrays[0].length != 0) {
-                return wrappedBuffer(arrays[0]);
             }
             break;
         default:
-            // Get the list of the component, while guessing the byte order.
-            final List&lt;ByteBuf&gt; components = new ArrayList&lt;ByteBuf&gt;(arrays.length);
-            for (byte[] a: arrays) {
-                if (a == null) {
-                    break;
                 }
-                if (a.length &gt; 0) {
-                    components.add(wrappedBuffer(a));
                 }
             }
-
-            if (!components.isEmpty()) {
-                return new CompositeByteBuf(ALLOC, false, maxNumComponents, components);
-            }
         }
 
         return EMPTY_BUFFER;
     }
 
     /**
      * Creates a new big-endian composite buffer which wraps the readable bytes of the
      * specified buffers without copying them.  A modification on the content
@@ -336,32 +334,7 @@ public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers) {
      * specified buffers will be visible to the returned buffer.
      */
     public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers) {
-        switch (buffers.length) {
-        case 0:
-            break;
-        case 1:
-            if (buffers[0].hasRemaining()) {
-                return wrappedBuffer(buffers[0].order(BIG_ENDIAN));
-            }
-            break;
-        default:
-            // Get the list of the component, while guessing the byte order.
-            final List&lt;ByteBuf&gt; components = new ArrayList&lt;ByteBuf&gt;(buffers.length);
-            for (ByteBuffer b: buffers) {
-                if (b == null) {
-                    break;
-                }
-                if (b.remaining() &gt; 0) {
-                    components.add(wrappedBuffer(b.order(BIG_ENDIAN)));
-                }
-            }
-
-            if (!components.isEmpty()) {
-                return new CompositeByteBuf(ALLOC, false, maxNumComponents, components);
-            }
-        }
-
-        return EMPTY_BUFFER;
     }
 
     /**
</code_before><code_after>@@ -15,15 +15,14 @@
  */
 package io.netty.buffer;
 
+import io.netty.buffer.CompositeByteBuf.ByteWrapper;
 import io.netty.util.internal.PlatformDependent;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.CharBuffer;
 import java.nio.charset.Charset;
 import java.util.Arrays;
 
 
 /**
@@ -262,40 +261,39 @@ public static ByteBuf wrappedBuffer(ByteBuffer... buffers) {
         return wrappedBuffer(buffers.length, buffers);
     }
 
+    static &lt;T&gt; ByteBuf wrappedBuffer(int maxNumComponents, ByteWrapper&lt;T&gt; wrapper, T[] array) {
+        switch (array.length) {
         case 0:
             break;
         case 1:
+            if (!wrapper.isEmpty(array[0])) {
+                return wrapper.wrap(array[0]);
             }
             break;
         default:
+            for (int i = 0, len = array.length; i &lt; len; i++) {
+                T bytes = array[i];
+                if (bytes == null) {
+                    return EMPTY_BUFFER;
                 }
+                if (!wrapper.isEmpty(bytes)) {
+                    return new CompositeByteBuf(ALLOC, false, maxNumComponents, wrapper, array, i);
                 }
             }
         }
 
         return EMPTY_BUFFER;
     }
 
+    /**
+     * Creates a new big-endian composite buffer which wraps the specified
+     * arrays without copying them.  A modification on the specified arrays'
+     * content will be visible to the returned buffer.
+     */
+    public static ByteBuf wrappedBuffer(int maxNumComponents, byte[]... arrays) {
+        return wrappedBuffer(maxNumComponents, CompositeByteBuf.BYTE_ARRAY_WRAPPER, arrays);
+    }
+
     /**
      * Creates a new big-endian composite buffer which wraps the readable bytes of the
      * specified buffers without copying them.  A modification on the content
@@ -336,32 +334,7 @@ public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuf... buffers) {
      * specified buffers will be visible to the returned buffer.
      */
     public static ByteBuf wrappedBuffer(int maxNumComponents, ByteBuffer... buffers) {
+        return wrappedBuffer(maxNumComponents, CompositeByteBuf.BYTE_BUFFER_WRAPPER, buffers);
     }
 
     /**
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>94690</refactoring_id><commit_sha>368e2a84f40397f3f7efa84ba4a0495fd786f925</commit_sha><commit_link>https://github.com/apache/cassandra/commit/368e2a84f40397f3f7efa84ba4a0495fd786f925</commit_link><file_path>src/java/org/apache/cassandra/db/Table.java</file_path><description>Extract Method public getTimestampedSnapshotName(clientSuppliedName String) : String extracted from public snapshot(clientSuppliedName String) : void in class org.apache.cassandra.db.Table</description><code_before>@@ -152,20 +152,30 @@ public void forceCleanup()
      * @param clientSuppliedName the tag associated with the name of the snapshot.  This
      *                           value can be null.
      */
-    public void snapshot(String clientSuppliedName) throws IOException
     {
-        String snapshotName = Long.toString(System.currentTimeMillis());
-        if (clientSuppliedName != null &amp;&amp; !clientSuppliedName.equals(""))
-        {
-            snapshotName = snapshotName + "-" + clientSuppliedName;
-        }
 
         for (ColumnFamilyStore cfStore : columnFamilyStores.values())
         {
             cfStore.snapshot(snapshotName);
         }
     }
 
 
     /**
      * Clear all the snapshots for a given table.
</code_before><code_after>@@ -152,20 +152,30 @@ public void forceCleanup()
      * @param clientSuppliedName the tag associated with the name of the snapshot.  This
      *                           value can be null.
      */
+    public void snapshot(String clientSuppliedName)
     {
+        String snapshotName = getTimestampedSnapshotName(clientSuppliedName);
 
         for (ColumnFamilyStore cfStore : columnFamilyStores.values())
         {
             cfStore.snapshot(snapshotName);
         }
     }
 
+    /**
+     * @param clientSuppliedName; may be null.
+     * @return
+     */
+    public static String getTimestampedSnapshotName(String clientSuppliedName)
+    {
+        String snapshotName = Long.toString(System.currentTimeMillis());
+        if (clientSuppliedName != null &amp;&amp; !clientSuppliedName.equals(""))
+        {
+            snapshotName = snapshotName + "-" + clientSuppliedName;
+        }
+        return snapshotName;
+    }
+
 
     /**
      * Clear all the snapshots for a given table.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>20485</refactoring_id><commit_sha>161e5014776608632c681764e77e0f8a045f3584</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/161e5014776608632c681764e77e0f8a045f3584</commit_link><file_path>community/graphviz/src/main/java/org/neo4j/visualization/asciidoc/AsciidocHelper.java</file_path><description>Extract Method public createGraphViz(title String, graph GraphDatabaseService, identifier String, graphStyle GraphStyle, graphvizOptions String) : String extracted from public createGraphViz(title String, graph GraphDatabaseService, identifier String, graphStyle GraphStyle) : String in class org.neo4j.visualization.asciidoc.AsciidocHelper</description><code_before>@@ -49,27 +49,63 @@ public static String createGraphViz( String title,
                 AsciiDocSimpleStyle.withAutomaticRelationshipTypeColors() );
     }
 
     public static String createGraphVizWithNodeId( String title,
             GraphDatabaseService graph, String identifier )
     {
         return createGraphViz( title, graph, identifier,
                 AsciiDocStyle.withAutomaticRelationshipTypeColors() );
     }
 
     public static String createGraphVizDeletingReferenceNode( String title,
             GraphDatabaseService graph, String identifier )
     {
         removeReferenceNode( graph );
         return createGraphViz( title, graph, identifier,
-                AsciiDocSimpleStyle.withAutomaticRelationshipTypeColors() );
     }
 
     public static String createGraphVizWithNodeIdDeletingReferenceNode(
             String title, GraphDatabaseService graph, String identifier )
     {
         removeReferenceNode( graph );
         return createGraphViz( title, graph, identifier,
-                AsciiDocStyle.withAutomaticRelationshipTypeColors() );
     }
 
     /**
@@ -80,6 +116,13 @@ public static String createGraphVizWithNodeIdDeletingReferenceNode(
      */
     public static String createGraphViz( String title,
             GraphDatabaseService graph, String identifier, GraphStyle graphStyle )
     {
         GraphvizWriter writer = new GraphvizWriter( graphStyle );
         OutputStream out = new ByteArrayOutputStream();
@@ -96,10 +139,8 @@ public static String createGraphViz( String title,
 
         return "." + title + "\n[\"dot\", \""
                + ( safeTitle + "-" + identifier ).replace( " ", "-" )
-               + ".svg\", \"neoviz\"]\n" +
-                "----\n" +
-                out.toString() +
-                "----\n";
     }
 
     private static void removeReferenceNode( GraphDatabaseService graph )
</code_before><code_after>@@ -49,27 +49,63 @@ public static String createGraphViz( String title,
                 AsciiDocSimpleStyle.withAutomaticRelationshipTypeColors() );
     }
 
+    public static String createGraphViz( String title,
+            GraphDatabaseService graph, String identifier,
+            String graphvizOptions )
+    {
+        return createGraphViz( title, graph, identifier,
+                AsciiDocSimpleStyle.withAutomaticRelationshipTypeColors(),
+                graphvizOptions );
+    }
+
     public static String createGraphVizWithNodeId( String title,
             GraphDatabaseService graph, String identifier )
     {
         return createGraphViz( title, graph, identifier,
                 AsciiDocStyle.withAutomaticRelationshipTypeColors() );
     }
 
+    public static String createGraphVizWithNodeId( String title,
+            GraphDatabaseService graph, String identifier,
+            String graphvizOptions )
+    {
+        return createGraphViz( title, graph, identifier,
+                AsciiDocStyle.withAutomaticRelationshipTypeColors(),
+                graphvizOptions );
+    }
+
     public static String createGraphVizDeletingReferenceNode( String title,
             GraphDatabaseService graph, String identifier )
+    {
+        return createGraphVizDeletingReferenceNode( title, graph, identifier,
+                "" );
+    }
+
+    public static String createGraphVizDeletingReferenceNode( String title,
+            GraphDatabaseService graph, String identifier,
+            String graphvizOptions )
     {
         removeReferenceNode( graph );
         return createGraphViz( title, graph, identifier,
+                AsciiDocSimpleStyle.withAutomaticRelationshipTypeColors(),
+                graphvizOptions );
     }
 
     public static String createGraphVizWithNodeIdDeletingReferenceNode(
             String title, GraphDatabaseService graph, String identifier )
+    {
+        return createGraphVizWithNodeIdDeletingReferenceNode( title, graph,
+                identifier, "" );
+    }
+
+    public static String createGraphVizWithNodeIdDeletingReferenceNode(
+            String title, GraphDatabaseService graph, String identifier,
+            String graphvizOptions )
     {
         removeReferenceNode( graph );
         return createGraphViz( title, graph, identifier,
+                AsciiDocStyle.withAutomaticRelationshipTypeColors(),
+                graphvizOptions );
     }
 
     /**
@@ -80,6 +116,13 @@ public static String createGraphVizWithNodeIdDeletingReferenceNode(
      */
     public static String createGraphViz( String title,
             GraphDatabaseService graph, String identifier, GraphStyle graphStyle )
+    {
+        return createGraphViz( title, graph, identifier, graphStyle, "" );
+    }
+
+    public static String createGraphViz( String title,
+            GraphDatabaseService graph, String identifier,
+            GraphStyle graphStyle, String graphvizOptions )
     {
         GraphvizWriter writer = new GraphvizWriter( graphStyle );
         OutputStream out = new ByteArrayOutputStream();
@@ -96,10 +139,8 @@ public static String createGraphViz( String title,
 
         return "." + title + "\n[\"dot\", \""
                + ( safeTitle + "-" + identifier ).replace( " ", "-" )
+               + ".svg\", \"neoviz\", \"" + graphvizOptions + "\"]\n"
+               + "----\n" + out.toString() + "----\n";
     }
 
     private static void removeReferenceNode( GraphDatabaseService graph )
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>23856</refactoring_id><commit_sha>56376ed2eeeacb12d6448746347b1cc4352b3dab</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/56376ed2eeeacb12d6448746347b1cc4352b3dab</commit_link><file_path>logstreams/src/main/java/io/camunda/zeebe/logstreams/impl/log/LogStreamImpl.java</file_path><description>Extract Method private tryOpenAppender() : void extracted from private openAppender() : ActorFuture&lt;LogStorageAppender&gt; in class io.camunda.zeebe.logstreams.impl.log.LogStreamImpl</description><code_before>@@ -213,6 +213,7 @@ private &lt;T extends LogStreamWriter&gt; void createWriter(
     } else if (appenderFuture != null) {
       appenderFuture.onComplete(onOpenAppender(writerFuture, creator));
     } else {
       openAppender().onComplete(onOpenAppender(writerFuture, creator));
     }
   }
@@ -255,21 +256,23 @@ private ActorFuture&lt;Void&gt; closeAppender() {
   }
 
   private ActorFuture&lt;LogStorageAppender&gt; openAppender() {
-    if (appenderFuture != null) {
-      return appenderFuture;
     }
 
-    final var appenderOpenFuture = new CompletableActorFuture&lt;LogStorageAppender&gt;();
-
-    appenderFuture = appenderOpenFuture;
-
     final long lastPosition;
     try {
       lastPosition = getLastPosition();
-    } catch (final UnrecoverableException e) {
       onUnrecoverableFailure();
-      appenderFuture.completeExceptionally(e);
-      return appenderFuture;
     }
 
     final long initialPosition;
@@ -315,8 +318,6 @@ private ActorFuture&lt;LogStorageAppender&gt; openAppender() {
                 onOpenAppenderFailed(throwable);
               }
             });
-
-    return appenderOpenFuture;
   }
 
   private void onOpenAppenderFailed(final Throwable error) {
</code_before><code_after>@@ -213,6 +213,7 @@ private &lt;T extends LogStreamWriter&gt; void createWriter(
     } else if (appenderFuture != null) {
       appenderFuture.onComplete(onOpenAppender(writerFuture, creator));
     } else {
+      appenderFuture = new CompletableActorFuture&lt;&gt;();
       openAppender().onComplete(onOpenAppender(writerFuture, creator));
     }
   }
@@ -255,21 +256,23 @@ private ActorFuture&lt;Void&gt; closeAppender() {
   }
 
   private ActorFuture&lt;LogStorageAppender&gt; openAppender() {
+    try {
+      tryOpenAppender();
+    } catch (final Exception error) {
+      onOpenAppenderFailed(error);
     }
+    return appenderFuture;
+  }
 
+  private void tryOpenAppender() {
     final long lastPosition;
     try {
       lastPosition = getLastPosition();
+    } catch (final UnrecoverableException error) {
+      LOG.error("Unexpected error when opening appender", error);
       onUnrecoverableFailure();
+      appenderFuture.completeExceptionally(error);
+      return;
     }
 
     final long initialPosition;
@@ -315,8 +318,6 @@ private ActorFuture&lt;LogStorageAppender&gt; openAppender() {
                 onOpenAppenderFailed(throwable);
               }
             });
   }
 
   private void onOpenAppenderFailed(final Throwable error) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>76473</refactoring_id><commit_sha>7bf6008efe485e3f0c93411f46b77f263150dc8f</commit_sha><commit_link>https://github.com/spring-projects/spring-security/commit/7bf6008efe485e3f0c93411f46b77f263150dc8f</commit_link><file_path>config/src/main/java/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.java</file_path><description>Extract Method private createLogoutRequestMatcher(httpMethod String) : RequestMatcher extracted from private getLogoutRequestMatcher(http H) : RequestMatcher in class org.springframework.security.config.annotation.web.configurers.LogoutConfigurer</description><code_before>@@ -276,7 +276,6 @@ public void init(H http) {
 			PermitAllSupport.permitAll(http, this.logoutSuccessUrl);
 			PermitAllSupport.permitAll(http, this.getLogoutRequestMatcher(http));
 		}
-
 		DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http
 				.getSharedObject(DefaultLoginPageGeneratingFilter.class);
 		if (loginPageGeneratingFilter != null &amp;&amp; !isCustomLogoutSuccess()) {
@@ -334,20 +333,28 @@ private LogoutFilter createLogoutFilter(H http) {
 		return result;
 	}
 
-	@SuppressWarnings("unchecked")
 	private RequestMatcher getLogoutRequestMatcher(H http) {
 		if (this.logoutRequestMatcher != null) {
 			return this.logoutRequestMatcher;
 		}
 		if (http.getConfigurer(CsrfConfigurer.class) != null) {
-			this.logoutRequestMatcher = new AntPathRequestMatcher(this.logoutUrl, "POST");
-		}
-		else {
-			this.logoutRequestMatcher = new OrRequestMatcher(new AntPathRequestMatcher(this.logoutUrl, "GET"),
-					new AntPathRequestMatcher(this.logoutUrl, "POST"), new AntPathRequestMatcher(this.logoutUrl, "PUT"),
-					new AntPathRequestMatcher(this.logoutUrl, "DELETE"));
 		}
-		return this.logoutRequestMatcher;
 	}
 
 }
</code_before><code_after>@@ -276,7 +276,6 @@ public void init(H http) {
 			PermitAllSupport.permitAll(http, this.logoutSuccessUrl);
 			PermitAllSupport.permitAll(http, this.getLogoutRequestMatcher(http));
 		}
 		DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http
 				.getSharedObject(DefaultLoginPageGeneratingFilter.class);
 		if (loginPageGeneratingFilter != null &amp;&amp; !isCustomLogoutSuccess()) {
@@ -334,20 +333,28 @@ private LogoutFilter createLogoutFilter(H http) {
 		return result;
 	}
 
 	private RequestMatcher getLogoutRequestMatcher(H http) {
 		if (this.logoutRequestMatcher != null) {
 			return this.logoutRequestMatcher;
 		}
+		this.logoutRequestMatcher = createLogoutRequestMatcher(http);
+		return this.logoutRequestMatcher;
+	}
+
+	@SuppressWarnings("unchecked")
+	private RequestMatcher createLogoutRequestMatcher(H http) {
+		RequestMatcher post = createLogoutRequestMatcher("POST");
 		if (http.getConfigurer(CsrfConfigurer.class) != null) {
+			return post;
 		}
+		RequestMatcher get = createLogoutRequestMatcher("GET");
+		RequestMatcher put = createLogoutRequestMatcher("PUT");
+		RequestMatcher delete = createLogoutRequestMatcher("DELETE");
+		return new OrRequestMatcher(get, post, put, delete);
+	}
+
+	private RequestMatcher createLogoutRequestMatcher(String httpMethod) {
+		return new AntPathRequestMatcher(this.logoutUrl, httpMethod);
 	}
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>45948</refactoring_id><commit_sha>94316d7ab9155e9b8a05b60702c173d5a59078cb</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/94316d7ab9155e9b8a05b60702c173d5a59078cb</commit_link><file_path>core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java</file_path><description>Extract Method public sendMessageAsync(server RaftPeerId, message Message, timeoutMs long) : CompletableFuture&lt;RaftClientReply&gt; extracted from public sendMessageAsync(server RaftPeerId, message Message) : CompletableFuture&lt;RaftClientReply&gt; in class alluxio.master.journal.raft.RaftJournalSystem</description><code_before>@@ -458,8 +458,11 @@ public synchronized RaftGroup getCurrentGroup() {
   }
 
   private RaftClient createClient() {
-    long timeoutMs =
-        Configuration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_RAFT_CLIENT_REQUEST_TIMEOUT);
     long retryBaseMs =
         Configuration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_RAFT_CLIENT_REQUEST_INTERVAL);
     long maxSleepTimeMs =
@@ -880,7 +883,21 @@ public synchronized List&lt;QuorumServerInfo&gt; getQuorumServerInfoList() throws IOEx
    */
   public synchronized CompletableFuture&lt;RaftClientReply&gt; sendMessageAsync(
       RaftPeerId server, Message message) {
-    RaftClient client = createClient();
     RaftClientRequest request = RaftClientRequest.newBuilder()
             .setClientId(mRawClientId)
             .setServerId(server)
</code_before><code_after>@@ -458,8 +458,11 @@ public synchronized RaftGroup getCurrentGroup() {
   }
 
   private RaftClient createClient() {
+    return createClient(Configuration.getMs(
+        PropertyKey.MASTER_EMBEDDED_JOURNAL_RAFT_CLIENT_REQUEST_TIMEOUT));
+  }
+
+  private RaftClient createClient(long timeoutMs) {
     long retryBaseMs =
         Configuration.getMs(PropertyKey.MASTER_EMBEDDED_JOURNAL_RAFT_CLIENT_REQUEST_INTERVAL);
     long maxSleepTimeMs =
@@ -880,7 +883,21 @@ public synchronized List&lt;QuorumServerInfo&gt; getQuorumServerInfoList() throws IOEx
    */
   public synchronized CompletableFuture&lt;RaftClientReply&gt; sendMessageAsync(
       RaftPeerId server, Message message) {
+    return sendMessageAsync(server, message, Configuration.getMs(
+        PropertyKey.MASTER_EMBEDDED_JOURNAL_RAFT_CLIENT_REQUEST_TIMEOUT));
+  }
+
+  /**
+   * Sends a message to a raft server asynchronously.
+   *
+   * @param server the raft peer id of the target server
+   * @param message the message to send
+   * @param timeoutMs the message timeout in milliseconds
+   * @return a future to be completed with the client reply
+   */
+  public synchronized CompletableFuture&lt;RaftClientReply&gt; sendMessageAsync(
+      RaftPeerId server, Message message, long timeoutMs) {
+    RaftClient client = createClient(timeoutMs);
     RaftClientRequest request = RaftClientRequest.newBuilder()
             .setClientId(mRawClientId)
             .setServerId(server)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>4429</refactoring_id><commit_sha>39dea4b07813acf6f13a14aa4f2db230ae6d899d</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/39dea4b07813acf6f13a14aa4f2db230ae6d899d</commit_link><file_path>services/src/main/java/org/keycloak/services/resources/admin/permissions/UserPermissions.java</file_path><description>Extract Method public canImpersonate() : boolean extracted from public canImpersonate(user UserModel) : boolean in class org.keycloak.services.resources.admin.permissions.UserPermissions</description><code_before>@@ -451,6 +451,12 @@ public void requireView() {
 
     @Override
     public boolean canImpersonate(UserModel user) {
         if (root.hasOneAdminRole(ImpersonationConstants.IMPERSONATION_ROLE)) return true;
 
         if (!root.isAdminSameRealm()) {
@@ -476,7 +482,6 @@ public boolean canImpersonate(UserModel user) {
 
         Scope scope = root.realmScope(IMPERSONATE_SCOPE);
         return root.evaluatePermission(resource, scope, server);
-
     }
 
     @Override
</code_before><code_after>@@ -451,6 +451,12 @@ public void requireView() {
 
     @Override
     public boolean canImpersonate(UserModel user) {
+        return canImpersonate();
+
+    }
+
+    @Override
+    public boolean canImpersonate() {
         if (root.hasOneAdminRole(ImpersonationConstants.IMPERSONATION_ROLE)) return true;
 
         if (!root.isAdminSameRealm()) {
@@ -476,7 +482,6 @@ public boolean canImpersonate(UserModel user) {
 
         Scope scope = root.realmScope(IMPERSONATE_SCOPE);
         return root.evaluatePermission(resource, scope, server);
     }
 
     @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>3657</refactoring_id><commit_sha>6615691c63d41d46c128067e95bdbc4e31822baa</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/6615691c63d41d46c128067e95bdbc4e31822baa</commit_link><file_path>authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/role/RolePolicyProvider.java</file_path><description>Extract Method private getSubject(identity Identity, realm RealmModel, authorizationProvider AuthorizationProvider) : UserModel extracted from private hasRole(identity Identity, role RoleModel, realm RealmModel, authorizationProvider AuthorizationProvider, fetchRoles boolean) : boolean in class org.keycloak.authorization.policy.provider.role.RolePolicyProvider</description><code_before>@@ -22,6 +22,7 @@
 
 import org.jboss.logging.Logger;
 import org.keycloak.authorization.AuthorizationProvider;
 import org.keycloak.authorization.identity.Identity;
 import org.keycloak.authorization.model.Policy;
 import org.keycloak.authorization.policy.evaluation.Evaluation;
@@ -31,6 +32,8 @@
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.representations.idm.authorization.RolePolicyRepresentation;
 
 /**
@@ -74,9 +77,8 @@ public void evaluate(Evaluation evaluation) {
 
     private boolean hasRole(Identity identity, RoleModel role, RealmModel realm, AuthorizationProvider authorizationProvider, boolean fetchRoles) {
         if (fetchRoles) {
-            KeycloakSession session = authorizationProvider.getKeycloakSession();
-            UserModel user = session.users().getUserById(realm, identity.getId());
-            return user.hasRole(role);
         }
         String roleName = role.getName();
         if (role.isClientRole()) {
@@ -86,8 +88,26 @@ private boolean hasRole(Identity identity, RoleModel role, RealmModel realm, Aut
         return identity.hasRealmRole(roleName);
     }
 
     @Override
     public void close() {
 
     }
-}
\ No newline at end of file
</code_before><code_after>@@ -22,6 +22,7 @@
 
 import org.jboss.logging.Logger;
 import org.keycloak.authorization.AuthorizationProvider;
+import org.keycloak.authorization.attribute.Attributes.Entry;
 import org.keycloak.authorization.identity.Identity;
 import org.keycloak.authorization.model.Policy;
 import org.keycloak.authorization.policy.evaluation.Evaluation;
@@ -31,6 +32,8 @@
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.UserProvider;
+import org.keycloak.representations.JsonWebToken;
 import org.keycloak.representations.idm.authorization.RolePolicyRepresentation;
 
 /**
@@ -74,9 +77,8 @@ public void evaluate(Evaluation evaluation) {
 
     private boolean hasRole(Identity identity, RoleModel role, RealmModel realm, AuthorizationProvider authorizationProvider, boolean fetchRoles) {
         if (fetchRoles) {
+            UserModel subject = getSubject(identity, realm, authorizationProvider);
+            return subject != null &amp;&amp; subject.hasRole(role);
         }
         String roleName = role.getName();
         if (role.isClientRole()) {
@@ -86,8 +88,26 @@ private boolean hasRole(Identity identity, RoleModel role, RealmModel realm, Aut
         return identity.hasRealmRole(roleName);
     }
 
+    private UserModel getSubject(Identity identity, RealmModel realm, AuthorizationProvider authorizationProvider) {
+        KeycloakSession session = authorizationProvider.getKeycloakSession();
+        UserProvider users = session.users();
+        UserModel user = users.getUserById(realm, identity.getId());
+
+        if (user == null) {
+            Entry sub = identity.getAttributes().getValue(JsonWebToken.SUBJECT);
+
+            if (sub == null || sub.isEmpty()) {
+                return null;
+            }
+
+            return users.getUserById(realm, sub.asString(0));
+        }
+
+        return user;
+    }
+
     @Override
     public void close() {
 
     }
\ No newline at end of file
+}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>78898</refactoring_id><commit_sha>117f6d698ed29ecc47b97c1c3b4e669448305639</commit_sha><commit_link>https://github.com/opentripplanner/opentripplanner/commit/117f6d698ed29ecc47b97c1c3b4e669448305639</commit_link><file_path>src/main/java/org/opentripplanner/routing/fares/impl/RideMapper.java</file_path><description>Extract Method private getSecondsSinceMidnight(time Calendar, leg Leg) : int extracted from public rideForTransitPathLeg(leg Leg) : Ride in class org.opentripplanner.routing.fares.impl.RideMapper</description><code_before>@@ -1,6 +1,7 @@
 package org.opentripplanner.routing.fares.impl;
 
 import java.time.ZoneOffset;
 import java.util.List;
 import java.util.stream.Collectors;
 import org.opentripplanner.model.plan.Itinerary;
@@ -37,20 +38,29 @@ public static Ride rideForTransitPathLeg(Leg leg) {
 
         // In almost all cases (except some loop routes) this should get the right set of zones passed through.
         // We don't have the position of the stops within the pattern so can't readily get more accurate than this.
-        var zones = leg.intermediateStops.stream().map(stopArrival -&gt; stopArrival.place.stop.getFirstZoneAsString()).collect(
-                Collectors.toSet());
         ride.zones = zones;
         ride.agency = leg.getRoute().getAgency().getId();
         ride.route = leg.getRoute().getId();
         ride.trip = leg.getTrip().getId();
 
         // TODO verify that times are in seconds after midnight
-        ride.startTime = leg.startTime.toInstant().atOffset(ZoneOffset.ofTotalSeconds(leg.agencyTimeZoneOffset)).toLocalTime().toSecondOfDay();
-        ride.endTime = leg.startTime.toInstant().atOffset(ZoneOffset.ofTotalSeconds(leg.agencyTimeZoneOffset)).toLocalTime().toSecondOfDay();
 
         // In the default fare service, we classify rides by mode.
         ride.classifier = leg.mode;
         return ride;
     }
 
 }
</code_before><code_after>@@ -1,6 +1,7 @@
 package org.opentripplanner.routing.fares.impl;
 
 import java.time.ZoneOffset;
+import java.util.Calendar;
 import java.util.List;
 import java.util.stream.Collectors;
 import org.opentripplanner.model.plan.Itinerary;
@@ -37,20 +38,29 @@ public static Ride rideForTransitPathLeg(Leg leg) {
 
         // In almost all cases (except some loop routes) this should get the right set of zones passed through.
         // We don't have the position of the stops within the pattern so can't readily get more accurate than this.
+        var zones = leg.intermediateStops.stream()
+                .map(stopArrival -&gt; stopArrival.place.stop.getFirstZoneAsString())
+                .collect(Collectors.toSet());
+
         ride.zones = zones;
         ride.agency = leg.getRoute().getAgency().getId();
         ride.route = leg.getRoute().getId();
         ride.trip = leg.getTrip().getId();
 
         // TODO verify that times are in seconds after midnight
+        ride.startTime = getSecondsSinceMidnight(leg.startTime, leg);
+        ride.endTime = getSecondsSinceMidnight(leg.endTime, leg);
 
         // In the default fare service, we classify rides by mode.
         ride.classifier = leg.mode;
         return ride;
     }
 
+    private static int getSecondsSinceMidnight(Calendar time, Leg leg) {
+        return time.toInstant()
+                .atOffset(ZoneOffset.ofTotalSeconds(leg.agencyTimeZoneOffset))
+                .toLocalTime()
+                .toSecondOfDay();
+    }
+
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>6431</refactoring_id><commit_sha>1e336fb57bfc7b8f02fef4d0f116a224bf62100e</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/1e336fb57bfc7b8f02fef4d0f116a224bf62100e</commit_link><file_path>plugins/org.jkiss.dbeaver.ui.editors.sql/src/org/jkiss/dbeaver/ui/editors/sql/SQLEditorBase.java</file_path><description>Extract Method private getPreviousParameter(parameters List&lt;SQLQueryParameter&gt;, parameter SQLQueryParameter) : SQLQueryParameter extracted from protected parseParameters(document IDocument, queryOffset int, queryLength int) : List&lt;SQLQueryParameter&gt; in class org.jkiss.dbeaver.ui.editors.sql.SQLEditorBase</description><code_before>@@ -1205,16 +1205,7 @@ protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, int queryO
                         tokenOffset - queryOffset,
                         tokenLength);
 
-                    SQLQueryParameter previous = null;
-                    if (parameter.isNamed()) {
-                        for (int i = parameters.size(); i &gt; 0; i--) {
-                            if (parameters.get(i - 1).getName().equals(paramName)) {
-                                previous = parameters.get(i - 1);
-                                break;
-                            }
-                        }
-                    }
-                    parameter.setPrevious(previous);
                     parameters.add(parameter);
                 } catch (BadLocationException e) {
                     log.warn("Can't extract query parameter", e);
@@ -1251,7 +1242,7 @@ protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, int queryO
                             if (parameters == null) {
                                 parameters = new ArrayList&lt;&gt;();
                             }
-
                             parameters.add(param.getOrdinalPosition(), param);
                         }
                     }
@@ -1265,6 +1256,18 @@ protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, int queryO
         return parameters;
     }
 
     protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, SQLQuery query) {
         return parseParameters(document, query.getOffset(), query.getLength());
     }
</code_before><code_after>@@ -1205,16 +1205,7 @@ protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, int queryO
                         tokenOffset - queryOffset,
                         tokenLength);
 
+                    parameter.setPrevious(getPreviousParameter(parameters, parameter));
                     parameters.add(parameter);
                 } catch (BadLocationException e) {
                     log.warn("Can't extract query parameter", e);
@@ -1251,7 +1242,7 @@ protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, int queryO
                             if (parameters == null) {
                                 parameters = new ArrayList&lt;&gt;();
                             }
+                            param.setPrevious(getPreviousParameter(parameters, param));
                             parameters.add(param.getOrdinalPosition(), param);
                         }
                     }
@@ -1265,6 +1256,18 @@ protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, int queryO
         return parameters;
     }
 
+    private static SQLQueryParameter getPreviousParameter(List&lt;SQLQueryParameter&gt; parameters, SQLQueryParameter parameter) {
+        String varName = parameter.getVarName();
+        if (parameter.isNamed()) {
+            for (int i = parameters.size(); i &gt; 0; i--) {
+                if (parameters.get(i - 1).getVarName().equals(varName)) {
+                    return parameters.get(i - 1);
+                }
+            }
+        }
+        return null;
+    }
+
     protected List&lt;SQLQueryParameter&gt; parseParameters(IDocument document, SQLQuery query) {
         return parseParameters(document, query.getOffset(), query.getLength());
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>125749</refactoring_id><commit_sha>21e47e61f01e24796257076f8d98b43a6e37258d</commit_sha><commit_link>https://github.com/i2p/i2p.i2p/commit/21e47e61f01e24796257076f8d98b43a6e37258d</commit_link><file_path>apps/routerconsole/java/src/net/i2p/router/web/SummaryListener.java</file_path><description>Extract Method public renderPng(out OutputStream, width int, height int, hideLegend boolean, hideGrid boolean, hideTitle boolean, showEvents boolean, periodCount int, end int, showCredit boolean, lsnr2 SummaryListener, titleOverride String) : void extracted from public renderPng(out OutputStream, width int, height int, hideLegend boolean, hideGrid boolean, hideTitle boolean, showEvents boolean, periodCount int, end int, showCredit boolean) : void in class net.i2p.router.web.SummaryListener</description><code_before>@@ -187,14 +187,31 @@ public void stopListening() {
     }
 
     /**
      *  @param end number of periods before now
      */
     public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,
                           boolean hideTitle, boolean showEvents, int periodCount,
                           int end, boolean showCredit) throws IOException {
         if (_renderer == null || _db == null)
             throw new IOException("No RRD, check logs for previous errors");
-        _renderer.render(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount, end, showCredit); 
     }
 
     public void renderPng(OutputStream out) throws IOException {
</code_before><code_after>@@ -187,14 +187,31 @@ public void stopListening() {
     }
 
     /**
+     *  Single graph.
+     *
      *  @param end number of periods before now
      */
     public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,
                           boolean hideTitle, boolean showEvents, int periodCount,
                           int end, boolean showCredit) throws IOException {
+        renderPng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount,
+                  end, showCredit, null, null); 
+    }
+
+    /**
+     *  Single or two-data-source graph.
+     *
+     *  @param lsnr2 2nd data source to plot on same graph, or null. Not recommended for events.
+     *  @param titleOverride If non-null, overrides the title
+     *  @since 0.9.6
+     */
+    public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,
+                          boolean hideTitle, boolean showEvents, int periodCount,
+                          int end, boolean showCredit, SummaryListener lsnr2, String titleOverride) throws IOException {
         if (_renderer == null || _db == null)
             throw new IOException("No RRD, check logs for previous errors");
+        _renderer.render(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount,
+                         end, showCredit, lsnr2, titleOverride); 
     }
 
     public void renderPng(OutputStream out) throws IOException {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>37816</refactoring_id><commit_sha>b92e405df37328c515d9357072d27d7904a921b8</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/b92e405df37328c515d9357072d27d7904a921b8</commit_link><file_path>OsmAnd/src/net/osmand/plus/views/layers/MapQuickActionLayer.java</file_path><description>Extract Method private createContextMarker() : void extracted from public initLayer(view OsmandMapTileView) : void in class net.osmand.plus.views.layers.MapQuickActionLayer</description><code_before>@@ -78,7 +78,10 @@ public MapQuickActionLayer(@NonNull Context context) {
 	@Override
 	public void initLayer(@NonNull OsmandMapTileView view) {
 		super.initLayer(view);
 
 		Context context = AndroidUtils.createDisplayContext(getContext());
 		contextMarker = new ImageView(context);
 		contextMarker.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
@@ -89,6 +92,12 @@ public void initLayer(@NonNull OsmandMapTileView view) {
 		contextMarker.layout(0, 0, width, height);
 	}
 
 	@SuppressLint("ClickableViewAccessibility")
 	@Override
 	public void setMapActivity(@Nullable MapActivity mapActivity) {
</code_before><code_after>@@ -78,7 +78,10 @@ public MapQuickActionLayer(@NonNull Context context) {
 	@Override
 	public void initLayer(@NonNull OsmandMapTileView view) {
 		super.initLayer(view);
+		createContextMarker();
+	}
 
+	private void createContextMarker() {
 		Context context = AndroidUtils.createDisplayContext(getContext());
 		contextMarker = new ImageView(context);
 		contextMarker.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
@@ -89,6 +92,12 @@ public void initLayer(@NonNull OsmandMapTileView view) {
 		contextMarker.layout(0, 0, width, height);
 	}
 
+	@Override
+	protected void updateResources() {
+		super.updateResources();
+		createContextMarker();
+	}
+
 	@SuppressLint("ClickableViewAccessibility")
 	@Override
 	public void setMapActivity(@Nullable MapActivity mapActivity) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>81657</refactoring_id><commit_sha>0a7745bc03c93709e178c578a4649eb534e8a9e0</commit_sha><commit_link>https://github.com/androidx/media/commit/0a7745bc03c93709e178c578a4649eb534e8a9e0</commit_link><file_path>library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java</file_path><description>Extract Method public performClick() : boolean extracted from public onTouchEvent(ev MotionEvent) : boolean in class com.google.android.exoplayer2.ui.PlayerView</description><code_before>@@ -1032,6 +1032,12 @@ public boolean onTouchEvent(MotionEvent ev) {
     if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
       return false;
     }
     return toggleControllerVisibility();
   }
 
</code_before><code_after>@@ -1032,6 +1032,12 @@ public boolean onTouchEvent(MotionEvent ev) {
     if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
       return false;
     }
+    return performClick();
+  }
+
+  @Override
+  public boolean performClick() {
+    super.performClick();
     return toggleControllerVisibility();
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>19305</refactoring_id><commit_sha>47f4db81b0b9626ce415890e1a7df9fba3ca4087</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/47f4db81b0b9626ce415890e1a7df9fba3ca4087</commit_link><file_path>advanced/main/java/org/neo4j/index/impl/PrimitiveUtils.java</file_path><description>Extract Method private readAndFlip(channel ReadableByteChannel, buffer ByteBuffer, bytes int) : boolean extracted from public readInt(channel ReadableByteChannel, buffer ByteBuffer) : Integer in class org.neo4j.index.impl.PrimitiveUtils</description><code_before>@@ -56,30 +56,38 @@ private static char[] readCharArray( ReadableByteChannel channel,
         return charArray;
     }
 
-    public static Integer readInt( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException
     {
         buffer.clear();
-        buffer.limit( 4 );
         int read = channel.read( buffer );
-        if ( read &lt; 4 )
         {
-            return null;
         }
         buffer.flip();
-        return buffer.getInt();
     }
 
     public static Long readLong( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException
     {
-        buffer.clear();
-        buffer.limit( 8 );
-        int read = channel.read( buffer );
-        if ( read &lt; 8 )
-        {
-            return null;
-        }
-        buffer.flip();
-        return buffer.getLong();
     }
     
     public static void writeLengthAndString( FileChannel channel, ByteBuffer buffer, String value )
</code_before><code_after>@@ -56,30 +56,38 @@ private static char[] readCharArray( ReadableByteChannel channel,
         return charArray;
     }
 
+    private static boolean readAndFlip( ReadableByteChannel channel, ByteBuffer buffer, int bytes )
+            throws IOException
     {
         buffer.clear();
+        buffer.limit( bytes );
         int read = channel.read( buffer );
+        if ( read &lt; bytes )
         {
+            return false;
         }
         buffer.flip();
+        return true;
+    }
+
+    public static Integer readInt( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException
+    {
+        return readAndFlip( channel, buffer, 4 ) ? buffer.getInt() : null;
     }
 
     public static Long readLong( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException
     {
+        return readAndFlip( channel, buffer, 8 ) ? buffer.getLong() : null;
+    }
+    
+    public static Float readFloat( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException
+    {
+        return readAndFlip( channel, buffer, 4 ) ? buffer.getFloat() : null;
+    }
+    
+    public static Double readDouble( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException
+    {
+        return readAndFlip( channel, buffer, 8 ) ? buffer.getDouble() : null;
     }
     
     public static void writeLengthAndString( FileChannel channel, ByteBuffer buffer, String value )
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>104855</refactoring_id><commit_sha>a0dd25a5fa613d5bb20afa2b51b568f15139b495</commit_sha><commit_link>https://github.com/freeplane/freeplane/commit/a0dd25a5fa613d5bb20afa2b51b568f15139b495</commit_link><file_path>freeplane/src/main/java/org/freeplane/features/map/NodeModel.java</file_path><description>Extract Method private attachClones() : void extracted from package attach() : void in class org.freeplane.features.map.NodeModel</description><code_before>@@ -509,19 +509,27 @@ else if(parent != null &amp;&amp; parent.isAttached() &amp;&amp;  (newParent == null || !newPare
 	}
 
 	void attach() {
-		for(Clones clonesGroup : clones)
-			clonesGroup.attach();
 	    for(NodeModel child : children)
 	    	child.attach();
     }
 
-	private void detach() {
 		for(Clones clonesGroup : clones)
-			clonesGroup.detach(this);
 	    for(NodeModel child : children)
 	    	child.detach();
     }
 
 
 	boolean isAttached() {
 	    return clones[0].size() != 0;
@@ -689,4 +697,20 @@ public int getIndex() {
 		final NodeModel parentNode = getParentNode();
 		return parentNode != null ? parentNode.getIndex(this) : -1;
 	}
 }
</code_before><code_after>@@ -509,19 +509,27 @@ else if(parent != null &amp;&amp; parent.isAttached() &amp;&amp;  (newParent == null || !newPare
 	}
 
 	void attach() {
+		attachClones();
 	    for(NodeModel child : children)
 	    	child.attach();
     }
 
+	private void attachClones() {
 		for(Clones clonesGroup : clones)
+			clonesGroup.attach();
+	}
+
+	private void detach() {
+		detachClones();
 	    for(NodeModel child : children)
 	    	child.detach();
     }
 
+	private void detachClones() {
+		for(Clones clonesGroup : clones)
+			clonesGroup.detach(this);
+	}
+
 
 	boolean isAttached() {
 	    return clones[0].size() != 0;
@@ -689,4 +697,20 @@ public int getIndex() {
 		final NodeModel parentNode = getParentNode();
 		return parentNode != null ? parentNode.getIndex(this) : -1;
 	}
+
+	public void swapData(NodeModel duplicate) {
+		this.detachClones();
+		SharedNodeData sharedDataSwap = sharedData;
+		this.sharedData = duplicate.sharedData;
+		duplicate.sharedData = sharedDataSwap;
+		Clones[] clonesSwap = clones;
+		this.clones = duplicate.clones;
+		duplicate.clones = clonesSwap;
+		for(CloneType cloneType : CloneType.values()) {
+			final DetachedNodeList detachedClone = (DetachedNodeList) clones[cloneType.ordinal()];
+			clones[cloneType.ordinal()] = detachedClone.forClone(this);
+		} 
+
+		this.attachClones();
+	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>30485</refactoring_id><commit_sha>8da314d23c65aecc1ba0439e8bc66d022523aefa</commit_sha><commit_link>https://github.com/igniterealtime/openfire/commit/8da314d23c65aecc1ba0439e8bc66d022523aefa</commit_link><file_path>src/java/org/jivesoftware/openfire/ldap/LdapVCardProvider.java</file_path><description>Extract Method public LdapVCardProvider(ldapManager LdapManager, vCardManager VCardManager) extracted from public LdapVCardProvider() in class org.jivesoftware.openfire.ldap.LdapVCardProvider</description><code_before>@@ -2,7 +2,7 @@
  * $Revision: 1217 $
  * $Date: 2005-04-11 14:11:06 -0700 (Mon, 11 Apr 2005) $
  *
- * Copyright (C) 2005 Jive Software. All rights reserved.
  *
  * This software is published under the terms of the GNU Public License (GPL),
  * a copy of which is included in this distribution.
@@ -17,6 +17,7 @@
 import org.jivesoftware.util.*;
 import org.jivesoftware.openfire.vcard.VCardManager;
 import org.jivesoftware.openfire.vcard.VCardProvider;
 import org.xmpp.packet.JID;
 
 import javax.naming.directory.Attributes;
@@ -99,11 +100,17 @@
  */
 public class LdapVCardProvider implements VCardProvider, PropertyEventListener {
 
-    private LdapManager manager;
     private VCardTemplate template;
 
     public LdapVCardProvider() {
-        manager = LdapManager.getInstance();
         initTemplate();
         // Listen to property events so that the template is always up to date
         PropertyEventDispatcher.addListener(this);
@@ -188,6 +195,11 @@ public void updateVCard(String username, Element vCardElement) throws NotFoundEx
         throw new UnsupportedOperationException();
     }
 
     public void deleteVCard(String username) {
         throw new UnsupportedOperationException();
     }
@@ -209,7 +221,7 @@ public void xmlPropertySet(String property, Map params) {
         if ("ldap.vcard-mapping".equals(property)) {
             initTemplate();
             // Reset cache of vCards
-            VCardManager.getInstance().reset();
         }
     }
 
</code_before><code_after>@@ -2,7 +2,7 @@
  * $Revision: 1217 $
  * $Date: 2005-04-11 14:11:06 -0700 (Mon, 11 Apr 2005) $
  *
+ * Copyright (C) 2007 Jive Software. All rights reserved.
  *
  * This software is published under the terms of the GNU Public License (GPL),
  * a copy of which is included in this distribution.
@@ -17,6 +17,7 @@
 import org.jivesoftware.util.*;
 import org.jivesoftware.openfire.vcard.VCardManager;
 import org.jivesoftware.openfire.vcard.VCardProvider;
+import org.jivesoftware.openfire.XMPPServer;
 import org.xmpp.packet.JID;
 
 import javax.naming.directory.Attributes;
@@ -99,11 +100,17 @@
  */
 public class LdapVCardProvider implements VCardProvider, PropertyEventListener {
 
+    private final LdapManager manager;
+    private final VCardManager vCardManager;
     private VCardTemplate template;
 
     public LdapVCardProvider() {
+        this(LdapManager.getInstance(), XMPPServer.getInstance().getVCardManager());
+    }
+
+    public LdapVCardProvider(LdapManager ldapManager, VCardManager vCardManager) {
+        manager = ldapManager;
+        this.vCardManager = vCardManager;
         initTemplate();
         // Listen to property events so that the template is always up to date
         PropertyEventDispatcher.addListener(this);
@@ -188,6 +195,11 @@ public void updateVCard(String username, Element vCardElement) throws NotFoundEx
         throw new UnsupportedOperationException();
     }
 
+
+    public void setVCard(String username, Element vCardElement) {
+        throw new UnsupportedOperationException();
+    }
+
     public void deleteVCard(String username) {
         throw new UnsupportedOperationException();
     }
@@ -209,7 +221,7 @@ public void xmlPropertySet(String property, Map params) {
         if ("ldap.vcard-mapping".equals(property)) {
             initTemplate();
             // Reset cache of vCards
+            vCardManager.reset();
         }
     }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>33305</refactoring_id><commit_sha>c190f8b3cf398d513ac3085de38436320843edb7</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/c190f8b3cf398d513ac3085de38436320843edb7</commit_link><file_path>core/src/main/java/org/infinispan/eviction/impl/PassivationManagerImpl.java</file_path><description>Extract Method private doPassivate(key Object, entry InternalCacheEntry) : boolean extracted from public passivate(entry InternalCacheEntry) : void in class org.infinispan.eviction.impl.PassivationManagerImpl</description><code_before>@@ -3,6 +3,7 @@
 import static org.infinispan.commons.util.Util.toStr;
 import static org.infinispan.persistence.manager.PersistenceManager.AccessMode.BOTH;
 
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
@@ -20,10 +21,12 @@
 import org.infinispan.factories.annotations.Inject;
 import org.infinispan.factories.annotations.Start;
 import org.infinispan.notifications.cachelistener.CacheNotifier;
 import org.infinispan.persistence.manager.PersistenceManager;
 import org.infinispan.persistence.spi.MarshallableEntry;
 import org.infinispan.persistence.spi.MarshallableEntryFactory;
 import org.infinispan.persistence.spi.PersistenceException;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 
@@ -64,25 +67,38 @@ private boolean isL1Key(Object key) {
       return distributionManager != null &amp;&amp; !distributionManager.getCacheTopology().isWriteOwner(key);
    }
 
    @Override
-   public void passivate(InternalCacheEntry entry) {
       Object key;
       if (enabled &amp;&amp; entry != null &amp;&amp; !isL1Key(key = entry.getKey())) {
-         // notify listeners that this entry is about to be passivated
-         notifier.notifyCacheEntryPassivated(key, entry.getValue(), true,
-               ImmutableContext.INSTANCE, null);
-         if (trace) log.tracef("Passivating entry %s", toStr(key));
-         try {
-            MarshallableEntry marshalledEntry = marshalledEntryFactory.create(key, entry.getValue(), entry.getMetadata(),
-                  entry.getExpiryTime(), entry.getLastUsed());
-            persistenceManager.writeToAllNonTxStores(marshalledEntry, keyPartitioner.getSegment(key), BOTH);
-            if (statsEnabled) passivations.getAndIncrement();
-         } catch (CacheException e) {
-            log.unableToPassivateEntry(key, e);
          }
-         notifier.notifyCacheEntryPassivated(key, null, false,
-               ImmutableContext.INSTANCE, null);
       }
    }
 
    @Override
</code_before><code_after>@@ -3,6 +3,7 @@
 import static org.infinispan.commons.util.Util.toStr;
 import static org.infinispan.persistence.manager.PersistenceManager.AccessMode.BOTH;
 
+import java.util.concurrent.CompletionStage;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
@@ -20,10 +21,12 @@
 import org.infinispan.factories.annotations.Inject;
 import org.infinispan.factories.annotations.Start;
 import org.infinispan.notifications.cachelistener.CacheNotifier;
+import org.infinispan.notifications.cachelistener.annotation.CacheEntryPassivated;
 import org.infinispan.persistence.manager.PersistenceManager;
 import org.infinispan.persistence.spi.MarshallableEntry;
 import org.infinispan.persistence.spi.MarshallableEntryFactory;
 import org.infinispan.persistence.spi.PersistenceException;
+import org.infinispan.util.concurrent.CompletableFutures;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 
@@ -64,25 +67,38 @@ private boolean isL1Key(Object key) {
       return distributionManager != null &amp;&amp; !distributionManager.getCacheTopology().isWriteOwner(key);
    }
 
+   private boolean doPassivate(Object key, InternalCacheEntry entry) {
+      if (trace) log.tracef("Passivating entry %s", toStr(key));
+      try {
+         MarshallableEntry marshalledEntry = marshalledEntryFactory.create(key, entry.getValue(), entry.getMetadata(),
+               entry.getExpiryTime(), entry.getLastUsed());
+         persistenceManager.writeToAllNonTxStores(marshalledEntry, keyPartitioner.getSegment(key), BOTH);
+         if (statsEnabled) passivations.getAndIncrement();
+      } catch (CacheException e) {
+         log.unableToPassivateEntry(key, e);
+         return false;
+      }
+      return true;
+   }
+
    @Override
+   public CompletionStage&lt;Void&gt; passivateAsync(InternalCacheEntry entry) {
       Object key;
       if (enabled &amp;&amp; entry != null &amp;&amp; !isL1Key(key = entry.getKey())) {
+         if (notifier.hasListener(CacheEntryPassivated.class)) {
+            return notifier.notifyCacheEntryPassivated(key, entry.getValue(), true, ImmutableContext.INSTANCE, null)
+                  .thenCompose(v -&gt; {
+                     if (doPassivate(key, entry)) {
+                        return notifier.notifyCacheEntryPassivated(key, null, false, ImmutableContext.INSTANCE, null);
+                     }
+                     return CompletableFutures.completedNull();
+                  });
+         } else {
+            // Ignore result
+            doPassivate(key, entry);
          }
       }
+      return CompletableFutures.completedNull();
    }
 
    @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>107370</refactoring_id><commit_sha>7bccd9f50242907bc3c50e7ef20e533d2a2f40d4</commit_sha><commit_link>https://github.com/metersphere/metersphere/commit/7bccd9f50242907bc3c50e7ef20e533d2a2f40d4</commit_link><file_path>backend/src/main/java/io/metersphere/track/service/TestCaseNodeService.java</file_path><description>Extract Method public createNodes(nodePaths List&lt;String&gt;, projectId String) : Map&lt;String,String&gt; extracted from public createNodeByTestCases(testCases List&lt;TestCaseWithBLOBs&gt;, projectId String) : Map&lt;String,String&gt; in class io.metersphere.track.service.TestCaseNodeService</description><code_before>@@ -230,7 +230,7 @@ public List&lt;TestCaseNodeDTO&gt; getNodeByReviewId(String reviewId) {
         return list;
 
     }
-    
     private List&lt;TestCaseNodeDTO&gt; getNodeDTO(String projectId, String planId) {
         TestPlanTestCaseExample testPlanTestCaseExample = new TestPlanTestCaseExample();
         testPlanTestCaseExample.createCriteria().andPlanIdEqualTo(planId);
@@ -355,50 +355,45 @@ public List&lt;TestCaseNodeDTO&gt; getAllNodeByReviewId(QueryNodeRequest request) {
     }
 
     public Map&lt;String, String&gt; createNodeByTestCases(List&lt;TestCaseWithBLOBs&gt; testCases, String projectId) {
-
-        List&lt;TestCaseNodeDTO&gt; nodeTrees = getNodeTreeByProjectId(projectId);
-
-        Map&lt;String, String&gt; pathMap = new HashMap&lt;&gt;();
-
         List&lt;String&gt; nodePaths = testCases.stream()
                 .map(TestCase::getNodePath)
                 .collect(Collectors.toList());
 
-        nodePaths.forEach(path -&gt; {
 
-            if (path == null) {
                 throw new ExcelException(Translator.get("test_case_module_not_null"));
             }
-            List&lt;String&gt; nodeNameList = new ArrayList&lt;&gt;(Arrays.asList(path.split("/")));
-            Iterator&lt;String&gt; pathIterator = nodeNameList.iterator();
-
             Boolean hasNode = false;
             String rootNodeName = null;
 
             if (nodeNameList.size() &lt;= 1) {
-                throw new ExcelException(Translator.get("test_case_create_module_fail") + ":" + path);
             } else {
-                pathIterator.next();
-                pathIterator.remove();
-
-                rootNodeName = pathIterator.next().trim();
                 //&#x539F;&#x6765;&#x6CA1;&#x6709;&#xFF0C;&#x65B0;&#x5EFA;&#x7684;&#x6811;nodeTrees&#x4E5F;&#x4E0D;&#x5305;&#x542B;
                 for (TestCaseNodeDTO nodeTree : nodeTrees) {
                     if (StringUtils.equals(rootNodeName, nodeTree.getName())) {
                         hasNode = true;
-                        createNodeByPathIterator(pathIterator, "/" + rootNodeName, nodeTree,
                                 pathMap, projectId, 2);
                     }
                     ;
                 }
             }
-
-
             if (!hasNode) {
-                createNodeByPath(pathIterator, rootNodeName, null, projectId, 1, "", pathMap);
             }
-        });
-
         return pathMap;
 
     }
</code_before><code_after>@@ -230,7 +230,7 @@ public List&lt;TestCaseNodeDTO&gt; getNodeByReviewId(String reviewId) {
         return list;
 
     }
+
     private List&lt;TestCaseNodeDTO&gt; getNodeDTO(String projectId, String planId) {
         TestPlanTestCaseExample testPlanTestCaseExample = new TestPlanTestCaseExample();
         testPlanTestCaseExample.createCriteria().andPlanIdEqualTo(planId);
@@ -355,50 +355,45 @@ public List&lt;TestCaseNodeDTO&gt; getAllNodeByReviewId(QueryNodeRequest request) {
     }
 
     public Map&lt;String, String&gt; createNodeByTestCases(List&lt;TestCaseWithBLOBs&gt; testCases, String projectId) {
         List&lt;String&gt; nodePaths = testCases.stream()
                 .map(TestCase::getNodePath)
                 .collect(Collectors.toList());
 
+        return this.createNodes(nodePaths, projectId);
+    }
 
+    public Map&lt;String, String&gt; createNodes(List&lt;String&gt; nodePaths, String projectId) {
+        List&lt;TestCaseNodeDTO&gt; nodeTrees = getNodeTreeByProjectId(projectId);
+        Map&lt;String, String&gt; pathMap = new HashMap&lt;&gt;();
+        for(String item : nodePaths){
+            if (item == null) {
                 throw new ExcelException(Translator.get("test_case_module_not_null"));
             }
+            List&lt;String&gt; nodeNameList = new ArrayList&lt;&gt;(Arrays.asList(item.split("/")));
+            Iterator&lt;String&gt; itemIterator = nodeNameList.iterator();
             Boolean hasNode = false;
             String rootNodeName = null;
 
             if (nodeNameList.size() &lt;= 1) {
+                throw new ExcelException(Translator.get("test_case_create_module_fail") + ":" + item);
             } else {
+                itemIterator.next();
+                itemIterator.remove();
+                rootNodeName = itemIterator.next().trim();
                 //&#x539F;&#x6765;&#x6CA1;&#x6709;&#xFF0C;&#x65B0;&#x5EFA;&#x7684;&#x6811;nodeTrees&#x4E5F;&#x4E0D;&#x5305;&#x542B;
                 for (TestCaseNodeDTO nodeTree : nodeTrees) {
                     if (StringUtils.equals(rootNodeName, nodeTree.getName())) {
                         hasNode = true;
+                        createNodeByPathIterator(itemIterator, "/" + rootNodeName, nodeTree,
                                 pathMap, projectId, 2);
                     }
                     ;
                 }
             }
             if (!hasNode) {
+                createNodeByPath(itemIterator, rootNodeName, null, projectId, 1, "", pathMap);
             }
+        }
         return pathMap;
 
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>109334</refactoring_id><commit_sha>f537faeb1befbb1b356a9934aa2ceea822ce39f3</commit_sha><commit_link>https://github.com/tibcosoftware/jasperreports/commit/f537faeb1befbb1b356a9934aa2ceea822ce39f3</commit_link><file_path>jasperreports/src/net/sf/jasperreports/engine/base/JRBaseImage.java</file_path><description>Extract Method public getOwnScaleImageValue() : ScaleImageEnum extracted from public getOwnScaleImage() : Byte in class net.sf.jasperreports.engine.base.JRBaseImage</description><code_before>@@ -42,6 +42,7 @@
 import net.sf.jasperreports.engine.JRVisitor;
 import net.sf.jasperreports.engine.type.HorizontalAlignEnum;
 import net.sf.jasperreports.engine.type.ModeEnum;
 import net.sf.jasperreports.engine.type.VerticalAlignEnum;
 import net.sf.jasperreports.engine.util.JRBoxUtil;
 import net.sf.jasperreports.engine.util.JRPenUtil;
@@ -77,7 +78,7 @@ public class JRBaseImage extends JRBaseGraphicElement implements JRImage
 	/**
 	 *
 	 */
-	protected Byte scaleImage;
 	protected HorizontalAlignEnum horizontalAlignmentValue;
 	protected VerticalAlignEnum verticalAlignmentValue;
 	protected Boolean isUsingCache = null;
@@ -131,7 +132,7 @@ protected JRBaseImage(JRImage image, JRBaseObjectFactory factory)
 	{
 		super(image, factory);
 		
-		scaleImage = image.getOwnScaleImage();
 		horizontalAlignmentValue = image.getOwnHorizontalAlignmentValue();
 		verticalAlignmentValue = image.getOwnVerticalAlignmentValue();
 		isUsingCache = image.isOwnUsingCache();
@@ -164,36 +165,64 @@ public ModeEnum getModeValue()
 	}
 
 	/**
-	 *
 	 */
 	public byte getScaleImage()
 	{
-		return JRStyleResolver.getScaleImage(this);
 	}
 
 	public Byte getOwnScaleImage()
 	{
-		return scaleImage;
 	}
 
 	/**
-	 *
 	 */
 	public void setScaleImage(byte scaleImage)
 	{
-		setScaleImage(new Byte(scaleImage));
 	}
 
 	/**
-	 *
 	 */
 	public void setScaleImage(Byte scaleImage)
 	{
-		Object old = this.scaleImage;
-		this.scaleImage = scaleImage;
-		getEventSupport().firePropertyChange(JRBaseStyle.PROPERTY_SCALE_IMAGE, old, this.scaleImage);
 	}
 
 	/**
 	 * @deprecated Replaced by {@link #getHorizontalAlignmentValue()}.
 	 */
@@ -1054,6 +1083,7 @@ public Object clone()
 	private Integer rightPadding = null;
 	private byte hyperlinkType = JRHyperlink.HYPERLINK_TYPE_NULL;
 	private byte hyperlinkTarget = JRHyperlink.HYPERLINK_TARGET_SELF;
 	
 	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
 	{
@@ -1063,9 +1093,11 @@ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundE
 		{
 			horizontalAlignmentValue = HorizontalAlignEnum.getByValue(horizontalAlignment);
 			verticalAlignmentValue = VerticalAlignEnum.getByValue(verticalAlignment);
 
 			horizontalAlignment = null;
 			verticalAlignment = null;
 		}
 		
 		if (lineBox == null)
</code_before><code_after>@@ -42,6 +42,7 @@
 import net.sf.jasperreports.engine.JRVisitor;
 import net.sf.jasperreports.engine.type.HorizontalAlignEnum;
 import net.sf.jasperreports.engine.type.ModeEnum;
+import net.sf.jasperreports.engine.type.ScaleImageEnum;
 import net.sf.jasperreports.engine.type.VerticalAlignEnum;
 import net.sf.jasperreports.engine.util.JRBoxUtil;
 import net.sf.jasperreports.engine.util.JRPenUtil;
@@ -77,7 +78,7 @@ public class JRBaseImage extends JRBaseGraphicElement implements JRImage
 	/**
 	 *
 	 */
+	protected ScaleImageEnum scaleImageValue;
 	protected HorizontalAlignEnum horizontalAlignmentValue;
 	protected VerticalAlignEnum verticalAlignmentValue;
 	protected Boolean isUsingCache = null;
@@ -131,7 +132,7 @@ protected JRBaseImage(JRImage image, JRBaseObjectFactory factory)
 	{
 		super(image, factory);
 		
+		scaleImageValue = image.getOwnScaleImageValue();
 		horizontalAlignmentValue = image.getOwnHorizontalAlignmentValue();
 		verticalAlignmentValue = image.getOwnVerticalAlignmentValue();
 		isUsingCache = image.isOwnUsingCache();
@@ -164,36 +165,64 @@ public ModeEnum getModeValue()
 	}
 
 	/**
+	 * @deprecated Replaced by {@link #getScaleImageValue()}.
 	 */
 	public byte getScaleImage()
 	{
+		return getScaleImageValue().getValue();
 	}
 
+	/**
+	 * @deprecated Replaced by {@link #getOwnScaleImageValue()}.
+	 */
 	public Byte getOwnScaleImage()
 	{
+		return getOwnScaleImageValue().getValueByte();
 	}
 
 	/**
+	 * @deprecated Replaced by {@link #setScaleImage(ScaleImageEnum)}.
 	 */
 	public void setScaleImage(byte scaleImage)
 	{
+		setScaleImage(ScaleImageEnum.getByValue(scaleImage));
 	}
 
 	/**
+	 * @deprecated Replaced by {@link #setScaleImage(ScaleImageEnum)}.
 	 */
 	public void setScaleImage(Byte scaleImage)
 	{
+		setScaleImage(ScaleImageEnum.getByValue(scaleImage));
+	}
+
+	/**
+	 * 
+	 */
+	public ScaleImageEnum getScaleImageValue()
+	{
+		return JRStyleResolver.getScaleImageValue(this);
+	}
+
+	/**
+	 * 
+	 */
+	public ScaleImageEnum getOwnScaleImageValue()
+	{
+		return this.scaleImageValue;
+	}
+
+	/**
+	 * 
+	 */
+	public void setScaleImage(ScaleImageEnum scaleImageValue)
+	{
+		Object old = this.scaleImageValue;
+		this.scaleImageValue = scaleImageValue;
+		getEventSupport().firePropertyChange(JRBaseStyle.PROPERTY_SCALE_IMAGE, old, this.scaleImageValue);
 	}
 
+
 	/**
 	 * @deprecated Replaced by {@link #getHorizontalAlignmentValue()}.
 	 */
@@ -1054,6 +1083,7 @@ public Object clone()
 	private Integer rightPadding = null;
 	private byte hyperlinkType = JRHyperlink.HYPERLINK_TYPE_NULL;
 	private byte hyperlinkTarget = JRHyperlink.HYPERLINK_TARGET_SELF;
+	private Byte scaleImage;
 	
 	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
 	{
@@ -1063,9 +1093,11 @@ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundE
 		{
 			horizontalAlignmentValue = HorizontalAlignEnum.getByValue(horizontalAlignment);
 			verticalAlignmentValue = VerticalAlignEnum.getByValue(verticalAlignment);
+			scaleImageValue = ScaleImageEnum.getByValue(scaleImage);
 
 			horizontalAlignment = null;
 			verticalAlignment = null;
+			scaleImage = null;
 		}
 		
 		if (lineBox == null)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>24582</refactoring_id><commit_sha>259a194cf3ae7b95f77b8411f2080c4cf2aa7f80</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/259a194cf3ae7b95f77b8411f2080c4cf2aa7f80</commit_link><file_path>qa/integration-tests/src/test/java/io/camunda/zeebe/it/client/SecurityTest.java</file_path><description>Extract Method private getResource(name String) : URL extracted from private configureGatewayForTls(gatewayCfg GatewayCfg) : void in class io.camunda.zeebe.it.client.SecurityTest</description><code_before>@@ -9,14 +9,16 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 import io.camunda.zeebe.client.ZeebeClientBuilder;
 import io.camunda.zeebe.client.api.response.Topology;
 import io.camunda.zeebe.gateway.impl.configuration.GatewayCfg;
 import io.camunda.zeebe.it.clustering.ClusteringRule;
-import io.camunda.zeebe.it.clustering.DeploymentClusteredTest;
-import io.camunda.zeebe.it.util.GrpcClientRule;
 import io.netty.util.NetUtil;
 import java.io.File;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.RuleChain;
@@ -29,44 +31,62 @@ public final class SecurityTest {
       new ClusteringRule(
           1, 1, 1, brokerCfg -&gt; {}, this::configureGatewayForTls, this::configureClientForTls);
 
-  public final GrpcClientRule clientRule =
-      new GrpcClientRule(
-          cfg -&gt;
-              configureClientForTls(
-                  cfg.gatewayAddress(
-                      NetUtil.toSocketAddressString(clusteringRule.getGatewayAddress()))));
-
-  @Rule
-  public RuleChain ruleChain =
-      RuleChain.outerRule(testTimeout).around(clusteringRule).around(clientRule);
 
   @Test
   public void shouldEstablishSecureConnection() {
     // when
-    final Topology topology = clientRule.getClient().newTopologyRequest().send().join();
 
     // then
     assertThat(topology.getBrokers().size()).isEqualTo(1);
   }
 
   private ZeebeClientBuilder configureClientForTls(final ZeebeClientBuilder clientBuilder) {
-    return clientBuilder.caCertificatePath(
-        DeploymentClusteredTest.class
-            .getClassLoader()
-            .getResource("security/test-chain.cert.pem")
-            .getPath());
   }
 
   private void configureGatewayForTls(final GatewayCfg gatewayCfg) {
-    final String certificatePath =
-        getClass().getClassLoader().getResource("security/test-chain.cert.pem").getFile();
-    final String privateKeyPath =
-        getClass().getClassLoader().getResource("security/test-server.key.pem").getFile();
 
     gatewayCfg
         .getSecurity()
         .setEnabled(true)
         .setCertificateChainPath(new File(certificatePath))
         .setPrivateKeyPath(new File(privateKeyPath));
   }
 }
</code_before><code_after>@@ -9,14 +9,16 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import io.camunda.zeebe.client.ZeebeClient;
 import io.camunda.zeebe.client.ZeebeClientBuilder;
 import io.camunda.zeebe.client.api.response.Topology;
 import io.camunda.zeebe.gateway.impl.configuration.GatewayCfg;
 import io.camunda.zeebe.it.clustering.ClusteringRule;
 import io.netty.util.NetUtil;
 import java.io.File;
+import java.net.URL;
+import java.security.cert.CertificateException;
+import org.assertj.core.api.Assertions;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.RuleChain;
@@ -29,44 +31,62 @@ public final class SecurityTest {
       new ClusteringRule(
           1, 1, 1, brokerCfg -&gt; {}, this::configureGatewayForTls, this::configureClientForTls);
 
+  @Rule public RuleChain ruleChain = RuleChain.outerRule(testTimeout).around(clusteringRule);
 
   @Test
   public void shouldEstablishSecureConnection() {
+    final var client = newSecureClient().build();
+
+    // when
+    final Topology topology = client.newTopologyRequest().send().join();
+
+    // then
+    assertThat(topology.getBrokers().size()).isEqualTo(1);
+  }
+
+  @Test
+  public void shouldAllowToOverrideAuthority() {
+    final var client = newSecureClient().overrideAuthority("localhost").build();
+
     // when
+    final Topology topology = client.newTopologyRequest().send().join();
 
     // then
     assertThat(topology.getBrokers().size()).isEqualTo(1);
   }
 
+  @Test
+  public void shouldRejectDifferentAuthority() {
+    // given
+    final var client = newSecureClient().overrideAuthority("virtualhost").build();
+
+    // when, then
+    Assertions.assertThatThrownBy(() -&gt; client.newTopologyRequest().send().join())
+        .hasRootCauseInstanceOf(CertificateException.class)
+        .hasRootCauseMessage("No name matching virtualhost found");
+  }
+
+  private ZeebeClientBuilder newSecureClient() {
+    return configureClientForTls(ZeebeClient.newClientBuilder())
+        .gatewayAddress(NetUtil.toSocketAddressString(clusteringRule.getGatewayAddress()));
+  }
+
   private ZeebeClientBuilder configureClientForTls(final ZeebeClientBuilder clientBuilder) {
+    return clientBuilder.caCertificatePath(getResource("security/test-chain.cert.pem").getPath());
   }
 
   private void configureGatewayForTls(final GatewayCfg gatewayCfg) {
+    final String certificatePath = getResource("security/test-chain.cert.pem").getFile();
+    final String privateKeyPath = getResource("security/test-server.key.pem").getFile();
 
     gatewayCfg
         .getSecurity()
         .setEnabled(true)
         .setCertificateChainPath(new File(certificatePath))
         .setPrivateKeyPath(new File(privateKeyPath));
   }
+
+  private URL getResource(final String name) {
+    return getClass().getClassLoader().getResource(name);
+  }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>110354</refactoring_id><commit_sha>abbbc0881caf4caf42dbfbab385333b1e03ba44a</commit_sha><commit_link>https://github.com/apereo/cas/commit/abbbc0881caf4caf42dbfbab385333b1e03ba44a</commit_link><file_path>support/cas-server-support-oauth-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20RequestParameterResolver.java</file_path><description>Extract Method public isAuthorizedGrantTypeForService(grantType String, registeredService OAuthRegisteredService, rejectUndefined boolean) : boolean extracted from public isAuthorizedGrantTypeForService(grantType String, registeredService OAuthRegisteredService) : boolean in class org.apereo.cas.support.oauth.web.OAuth20RequestParameterResolver</description><code_before>@@ -42,6 +42,20 @@ public interface OAuth20RequestParameterResolver {
      */
     static boolean isAuthorizedGrantTypeForService(final String grantType,
                                                    final OAuthRegisteredService registeredService) {
         if (registeredService.getSupportedGrantTypes() != null &amp;&amp; !registeredService.getSupportedGrantTypes().isEmpty()) {
             LOGGER.debug("Checking grant type [{}] against supported grant types [{}]", grantType, registeredService.getSupportedGrantTypes());
             return registeredService.getSupportedGrantTypes().stream().anyMatch(s -&gt; s.equalsIgnoreCase(grantType));
@@ -50,7 +64,7 @@ static boolean isAuthorizedGrantTypeForService(final String grantType,
         LOGGER.warn("Registered service [{}] does not define any authorized/supported grant types. "
                     + "It is STRONGLY recommended that you authorize and assign grant types to the service definition. "
                     + "While just a warning for now, this behavior will be enforced by CAS in future versions.", registeredService.getName());
-        return true;
     }
 
     /**
@@ -121,7 +135,7 @@ &lt;T&gt; T resolveJwtRequestParameter(WebContext context, String jwtRequest,
      * @param context    the context
      * @return the map
      */
-    Map&lt;String, Object&gt; resolveRequestParameters(Collection&lt;String&gt; attributes,
                                                  WebContext context);
 
     /**
</code_before><code_after>@@ -42,6 +42,20 @@ public interface OAuth20RequestParameterResolver {
      */
     static boolean isAuthorizedGrantTypeForService(final String grantType,
                                                    final OAuthRegisteredService registeredService) {
+        return isAuthorizedGrantTypeForService(grantType, registeredService, false);
+    }
+
+    /**
+     * Is authorized grant type for service?
+     *
+     * @param grantType         the grant type
+     * @param registeredService the registered service
+     * @param rejectUndefined   the reject undefined
+     * @return true /false
+     */
+    static boolean isAuthorizedGrantTypeForService(final String grantType,
+                                                   final OAuthRegisteredService registeredService,
+                                                   final boolean rejectUndefined) {
         if (registeredService.getSupportedGrantTypes() != null &amp;&amp; !registeredService.getSupportedGrantTypes().isEmpty()) {
             LOGGER.debug("Checking grant type [{}] against supported grant types [{}]", grantType, registeredService.getSupportedGrantTypes());
             return registeredService.getSupportedGrantTypes().stream().anyMatch(s -&gt; s.equalsIgnoreCase(grantType));
@@ -50,7 +64,7 @@ static boolean isAuthorizedGrantTypeForService(final String grantType,
         LOGGER.warn("Registered service [{}] does not define any authorized/supported grant types. "
                     + "It is STRONGLY recommended that you authorize and assign grant types to the service definition. "
                     + "While just a warning for now, this behavior will be enforced by CAS in future versions.", registeredService.getName());
+        return !rejectUndefined;
     }
 
     /**
@@ -121,7 +135,7 @@ &lt;T&gt; T resolveJwtRequestParameter(WebContext context, String jwtRequest,
      * @param context    the context
      * @return the map
      */
+    Map&lt;String, Set&lt;String&gt;&gt; resolveRequestParameters(Collection&lt;String&gt; attributes,
                                                  WebContext context);
 
     /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>23587</refactoring_id><commit_sha>4a849112584906b3b0130681c0406b24757b0859</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/4a849112584906b3b0130681c0406b24757b0859</commit_link><file_path>community/id-generator/src/main/java/org/neo4j/internal/id/indexed/IdRangeMarker.java</file_path><description>Extract Method private idRangeIndex(id long) : long extracted from private prepareRange(id long, addition boolean) : void in class org.neo4j.internal.id.indexed.IdRangeMarker</description><code_before>@@ -184,10 +184,15 @@ public void markFree( long id )
 
     private void prepareRange( long id, boolean addition )
     {
-        key.setIdRangeIdx( id / idsPerEntry );
         value.clear( generation, addition );
     }
 
     private int idOffset( long id )
     {
         return toIntExact( id % idsPerEntry );
@@ -204,20 +209,35 @@ private void bridgeGapBetweenHighestWrittenIdAndThisId( long id )
         long highestWrittenId = this.highestWrittenId.get();
         if ( bridgeIdGaps &amp;&amp; highestWrittenId &lt; id )
         {
             while ( highestWrittenId &lt; id - 1 )
             {
                 long bridgeId = ++highestWrittenId;
                 if ( !isReservedId( bridgeId ) )
                 {
-                    prepareRange( bridgeId, true );
                     value.setCommitBit( idOffset( bridgeId ) );
                     if ( !started ) // i.e. in recovery mode
                     {
                         value.setReuseBit( idOffset( bridgeId ) );
                     }
-                    writer.merge( key, value, merger );
                 }
             }
             // Well, we bridged the gap up and including id - 1, but we know that right after this the actual id will be written
             // so to try to isolate updates to highestWrittenId to this method we can might as well do that right here.
             this.highestWrittenId.set( id );
</code_before><code_after>@@ -184,10 +184,15 @@ public void markFree( long id )
 
     private void prepareRange( long id, boolean addition )
     {
+        key.setIdRangeIdx( idRangeIndex( id ) );
         value.clear( generation, addition );
     }
 
+    private long idRangeIndex( long id )
+    {
+        return id / idsPerEntry;
+    }
+
     private int idOffset( long id )
     {
         return toIntExact( id % idsPerEntry );
@@ -204,20 +209,35 @@ private void bridgeGapBetweenHighestWrittenIdAndThisId( long id )
         long highestWrittenId = this.highestWrittenId.get();
         if ( bridgeIdGaps &amp;&amp; highestWrittenId &lt; id )
         {
+            key.setIdRangeIdx( -1 );
+            boolean dirty = false;
             while ( highestWrittenId &lt; id - 1 )
             {
                 long bridgeId = ++highestWrittenId;
                 if ( !isReservedId( bridgeId ) )
                 {
+                    if ( idRangeIndex( bridgeId ) != key.getIdRangeIdx() )
+                    {
+                        if ( key.getIdRangeIdx() != -1 )
+                        {
+                            writer.merge( key, value, merger );
+                        }
+                        prepareRange( bridgeId, true );
+                    }
                     value.setCommitBit( idOffset( bridgeId ) );
                     if ( !started ) // i.e. in recovery mode
                     {
                         value.setReuseBit( idOffset( bridgeId ) );
                     }
+                    dirty = true;
                 }
             }
+
+            if ( dirty )
+            {
+                writer.merge( key, value, merger );
+            }
+
             // Well, we bridged the gap up and including id - 1, but we know that right after this the actual id will be written
             // so to try to isolate updates to highestWrittenId to this method we can might as well do that right here.
             this.highestWrittenId.set( id );
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>102768</refactoring_id><commit_sha>c6f43f359973f7ee8826c4ed250f38668e94e5dc</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/c6f43f359973f7ee8826c4ed250f38668e94e5dc</commit_link><file_path>jdk/src/share/classes/java/util/logging/LogManager.java</file_path><description>Extract Method package checkPermission() : void extracted from public checkAccess() : void in class java.util.logging.LogManager</description><code_before>@@ -314,7 +314,7 @@ public Object run() throws Exception {
      */
     public void addPropertyChangeListener(PropertyChangeListener l) throws SecurityException {
         PropertyChangeListener listener = Objects.requireNonNull(l);
-        checkAccess();
         synchronized (listenerMap) {
             // increment the registration count if already registered
             Integer value = listenerMap.get(listener);
@@ -338,7 +338,7 @@ public void addPropertyChangeListener(PropertyChangeListener l) throws SecurityE
      *             the caller does not have LoggingPermission("control").
      */
     public void removePropertyChangeListener(PropertyChangeListener l) throws SecurityException {
-        checkAccess();
         if (l != null) {
             PropertyChangeListener listener = l;
             synchronized (listenerMap) {
@@ -793,7 +793,7 @@ public synchronized Enumeration&lt;String&gt; getLoggerNames() {
      * @exception  IOException if there are IO problems reading the configuration.
      */
     public void readConfiguration() throws IOException, SecurityException {
-        checkAccess();
 
         // if a configuration class is specified, load it and use it.
         String cname = System.getProperty("java.util.logging.config.class");
@@ -851,7 +851,7 @@ public void readConfiguration() throws IOException, SecurityException {
      */
 
     public void reset() throws SecurityException {
-        checkAccess();
         synchronized (this) {
             props = new Properties();
             // Since we are doing a reset we no longer want to initialize
@@ -936,7 +936,7 @@ private String[] parseClassNames(String propertyName) {
      * @exception  IOException if there are problems reading from the stream.
      */
     public void readConfiguration(InputStream ins) throws IOException, SecurityException {
-        checkAccess();
         reset();
 
         // Load the properties
@@ -1113,8 +1113,13 @@ private synchronized void initializeGlobalHandlers() {
         loadLoggerHandlers(rootLogger, null, "handlers");
     }
 
 
-    private Permission ourPermission = new LoggingPermission("control", null);
 
     /**
      * Check that the current context is trusted to modify the logging
@@ -1127,11 +1132,7 @@ private synchronized void initializeGlobalHandlers() {
      *             the caller does not have LoggingPermission("control").
      */
     public void checkAccess() throws SecurityException {
-        SecurityManager sm = System.getSecurityManager();
-        if (sm == null) {
-            return;
-        }
-        sm.checkPermission(ourPermission);
     }
 
     // Nested class to represent a node in our tree of named loggers.
</code_before><code_after>@@ -314,7 +314,7 @@ public Object run() throws Exception {
      */
     public void addPropertyChangeListener(PropertyChangeListener l) throws SecurityException {
         PropertyChangeListener listener = Objects.requireNonNull(l);
+        checkPermission();
         synchronized (listenerMap) {
             // increment the registration count if already registered
             Integer value = listenerMap.get(listener);
@@ -338,7 +338,7 @@ public void addPropertyChangeListener(PropertyChangeListener l) throws SecurityE
      *             the caller does not have LoggingPermission("control").
      */
     public void removePropertyChangeListener(PropertyChangeListener l) throws SecurityException {
+        checkPermission();
         if (l != null) {
             PropertyChangeListener listener = l;
             synchronized (listenerMap) {
@@ -793,7 +793,7 @@ public synchronized Enumeration&lt;String&gt; getLoggerNames() {
      * @exception  IOException if there are IO problems reading the configuration.
      */
     public void readConfiguration() throws IOException, SecurityException {
+        checkPermission();
 
         // if a configuration class is specified, load it and use it.
         String cname = System.getProperty("java.util.logging.config.class");
@@ -851,7 +851,7 @@ public void readConfiguration() throws IOException, SecurityException {
      */
 
     public void reset() throws SecurityException {
+        checkPermission();
         synchronized (this) {
             props = new Properties();
             // Since we are doing a reset we no longer want to initialize
@@ -936,7 +936,7 @@ private String[] parseClassNames(String propertyName) {
      * @exception  IOException if there are problems reading from the stream.
      */
     public void readConfiguration(InputStream ins) throws IOException, SecurityException {
+        checkPermission();
         reset();
 
         // Load the properties
@@ -1113,8 +1113,13 @@ private synchronized void initializeGlobalHandlers() {
         loadLoggerHandlers(rootLogger, null, "handlers");
     }
 
+    private final Permission controlPermission = new LoggingPermission("control", null);
 
+    void checkPermission() {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null)
+            sm.checkPermission(controlPermission);
+    }
 
     /**
      * Check that the current context is trusted to modify the logging
@@ -1127,11 +1132,7 @@ private synchronized void initializeGlobalHandlers() {
      *             the caller does not have LoggingPermission("control").
      */
     public void checkAccess() throws SecurityException {
+        checkPermission();
     }
 
     // Nested class to represent a node in our tree of named loggers.
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>71448</refactoring_id><commit_sha>6091254ba26b51fbad9884e3b90b387fc6b956eb</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/6091254ba26b51fbad9884e3b90b387fc6b956eb</commit_link><file_path>src/edu/stanford/nlp/dcoref/RuleBasedCorefMentionFinder.java</file_path><description>Extract Method protected assignMentionIDs(predictedMentions List&lt;List&lt;Mention&gt;&gt;, maxID int) : void extracted from public extractPredictedMentions(doc Annotation, _maxID int, dict Dictionaries) : List&lt;List&lt;Mention&gt;&gt; in class edu.stanford.nlp.dcoref.RuleBasedCorefMentionFinder</description><code_before>@@ -32,7 +32,7 @@
 public class RuleBasedCorefMentionFinder implements CorefMentionFinder {
 
   protected boolean assignIds = true;
-  protected int maxID = -1;
   private final HeadFinder headFinder;
   protected Annotator parserProcessor;
 
@@ -73,8 +73,8 @@ public List&lt;List&lt;Mention&gt;&gt; filterPredictedMentions(List&lt;List&lt;Mention&gt;&gt; allGoldMe
    *  Extract all NP, PRP or NE, and filter out by manually written patterns.
    */
   @Override
-  public List&lt;List&lt;Mention&gt;&gt; extractPredictedMentions(Annotation doc, int _maxID, Dictionaries dict){
-    this.maxID = _maxID;
     List&lt;List&lt;Mention&gt;&gt; predictedMentions = new ArrayList&lt;List&lt;Mention&gt;&gt;();
     for(CoreMap s : doc.get(CoreAnnotations.SentencesAnnotation.class)) {
 
@@ -91,9 +91,21 @@ public List&lt;List&lt;Mention&gt;&gt; extractPredictedMentions(Annotation doc, int _maxID,
       setBarePlural(mentions);
       removeSpuriousMentions(s, mentions, dict);
     }
     return predictedMentions;
   }
 
   protected static void setBarePlural(List&lt;Mention&gt; mentions) {
     for (Mention m : mentions) {
       String pos = m.headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class);
@@ -118,8 +130,8 @@ protected void extractPremarkedEntityMentions(CoreMap s, List&lt;Mention&gt; mentions,
           int endIndex = w.get(CoreAnnotations.IndexAnnotation.class);
           if (beginIndex &gt;= 0) {
             IntPair mSpan = new IntPair(beginIndex, endIndex);
-            int mentionId = assignIds? ++maxID:-1;
-            Mention m = new Mention(mentionId, beginIndex, endIndex, dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIndex, endIndex)));
             mentions.add(m);
             mentionSpanSet.add(mSpan);
             beginIndex = -1;
@@ -142,15 +154,15 @@ protected void extractNamedEntityMentions(CoreMap s, List&lt;Mention&gt; mentions, Set
       String nerString = w.get(CoreAnnotations.NamedEntityTagAnnotation.class);
       if(!nerString.equals(preNE)) {
         int endIndex = w.get(CoreAnnotations.IndexAnnotation.class) - 1;
-        if(!preNE.equals("O") &amp;&amp; !preNE.equals("QUANTITY") &amp;&amp; !preNE.equals("CARDINAL") &amp;&amp; !preNE.equals("PERCENT")) {
           if(w.get(CoreAnnotations.TextAnnotation.class).equals("'s")) endIndex++;
           IntPair mSpan = new IntPair(beginIndex, endIndex);
           // Need to check if beginIndex &lt; endIndex because, for
           // example, there could be a 's mislabeled by the NER and
           // attached to the previous NER by the earlier heuristic
           if(beginIndex &lt; endIndex &amp;&amp; !mentionSpanSet.contains(mSpan)) {
-            int mentionId = assignIds? ++maxID:-1;
-            Mention m = new Mention(mentionId, beginIndex, endIndex, dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIndex, endIndex)));
             mentions.add(m);
             mentionSpanSet.add(mSpan);
             namedEntitySpanSet.add(mSpan);
@@ -161,11 +173,11 @@ protected void extractNamedEntityMentions(CoreMap s, List&lt;Mention&gt; mentions, Set
       }
     }
     // NE at the end of sentence
-    if(!preNE.equals("O") &amp;&amp; !preNE.equals("QUANTITY") &amp;&amp; !preNE.equals("CARDINAL") &amp;&amp; !preNE.equals("PERCENT")) {
       IntPair mSpan = new IntPair(beginIndex, sent.size());
       if(!mentionSpanSet.contains(mSpan)) {
-        int mentionId = assignIds? ++maxID:-1;
-        Mention m = new Mention(mentionId, beginIndex, sent.size(), dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIndex, sent.size())));
         mentions.add(m);
         mentionSpanSet.add(mSpan);
         namedEntitySpanSet.add(mSpan);
@@ -190,8 +202,8 @@ protected void extractNPorPRP(CoreMap s, List&lt;Mention&gt; mentions, Set&lt;IntPair&gt; me
       if (",".equals(sent.get(endIdx-1).word())) { endIdx--; } // try not to have span that ends with ,
       IntPair mSpan = new IntPair(beginIdx, endIdx);
       if(!mentionSpanSet.contains(mSpan) &amp;&amp; !insideNE(mSpan, namedEntitySpanSet)) {
-        int mentionID = assignIds? ++maxID:-1;
-        Mention m = new Mention(mentionID, beginIdx, endIdx, dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIdx, endIdx)), t);
         mentions.add(m);
         mentionSpanSet.add(mSpan);
       }
@@ -225,8 +237,8 @@ protected void extractEnumerations(CoreMap s, List&lt;Mention&gt; mentions, Set&lt;IntPai
 
     for(IntPair mSpan : spanToMentionSubTree.keySet()){
       if(!mentionSpanSet.contains(mSpan) &amp;&amp; !insideNE(mSpan, namedEntitySpanSet)) {
-        int mentionID = assignIds? ++maxID:-1;
-        Mention m = new Mention(mentionID, mSpan.get(0), mSpan.get(1), dependency,
                                 new ArrayList&lt;CoreLabel&gt;(sent.subList(mSpan.get(0), mSpan.get(1))), spanToMentionSubTree.get(mSpan));
         mentions.add(m);
         mentionSpanSet.add(mSpan);
</code_before><code_after>@@ -32,7 +32,7 @@
 public class RuleBasedCorefMentionFinder implements CorefMentionFinder {
 
   protected boolean assignIds = true;
+//  protected int maxID = -1;
   private final HeadFinder headFinder;
   protected Annotator parserProcessor;
 
@@ -73,8 +73,8 @@ public List&lt;List&lt;Mention&gt;&gt; filterPredictedMentions(List&lt;List&lt;Mention&gt;&gt; allGoldMe
    *  Extract all NP, PRP or NE, and filter out by manually written patterns.
    */
   @Override
+  public List&lt;List&lt;Mention&gt;&gt; extractPredictedMentions(Annotation doc, int maxID, Dictionaries dict){
+//    this.maxID = _maxID;
     List&lt;List&lt;Mention&gt;&gt; predictedMentions = new ArrayList&lt;List&lt;Mention&gt;&gt;();
     for(CoreMap s : doc.get(CoreAnnotations.SentencesAnnotation.class)) {
 
@@ -91,9 +91,21 @@ public List&lt;List&lt;Mention&gt;&gt; extractPredictedMentions(Annotation doc, int _maxID,
       setBarePlural(mentions);
       removeSpuriousMentions(s, mentions, dict);
     }
+    
+    // assign mention IDs
+    if(assignIds) assignMentionIDs(predictedMentions, maxID);
+    
     return predictedMentions;
   }
 
+  protected void assignMentionIDs(List&lt;List&lt;Mention&gt;&gt; predictedMentions, int maxID) {
+    for(List&lt;Mention&gt; mentions : predictedMentions) {
+      for(Mention m : mentions) {
+        m.mentionID = (++maxID);
+      }
+    }
+  }
+
   protected static void setBarePlural(List&lt;Mention&gt; mentions) {
     for (Mention m : mentions) {
       String pos = m.headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class);
@@ -118,8 +130,8 @@ protected void extractPremarkedEntityMentions(CoreMap s, List&lt;Mention&gt; mentions,
           int endIndex = w.get(CoreAnnotations.IndexAnnotation.class);
           if (beginIndex &gt;= 0) {
             IntPair mSpan = new IntPair(beginIndex, endIndex);
+            int dummyMentionId = -1;
+            Mention m = new Mention(dummyMentionId, beginIndex, endIndex, dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIndex, endIndex)));
             mentions.add(m);
             mentionSpanSet.add(mSpan);
             beginIndex = -1;
@@ -142,15 +154,15 @@ protected void extractNamedEntityMentions(CoreMap s, List&lt;Mention&gt; mentions, Set
       String nerString = w.get(CoreAnnotations.NamedEntityTagAnnotation.class);
       if(!nerString.equals(preNE)) {
         int endIndex = w.get(CoreAnnotations.IndexAnnotation.class) - 1;
+        if(!preNE.matches("O|QUANTITY|CARDINAL|PERCENT|DATE|DURATION|TIME|SET")){
           if(w.get(CoreAnnotations.TextAnnotation.class).equals("'s")) endIndex++;
           IntPair mSpan = new IntPair(beginIndex, endIndex);
           // Need to check if beginIndex &lt; endIndex because, for
           // example, there could be a 's mislabeled by the NER and
           // attached to the previous NER by the earlier heuristic
           if(beginIndex &lt; endIndex &amp;&amp; !mentionSpanSet.contains(mSpan)) {
+            int dummyMentionId = -1;
+            Mention m = new Mention(dummyMentionId, beginIndex, endIndex, dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIndex, endIndex)));
             mentions.add(m);
             mentionSpanSet.add(mSpan);
             namedEntitySpanSet.add(mSpan);
@@ -161,11 +173,11 @@ protected void extractNamedEntityMentions(CoreMap s, List&lt;Mention&gt; mentions, Set
       }
     }
     // NE at the end of sentence
+    if(!preNE.matches("O|QUANTITY|CARDINAL|PERCENT|DATE|DURATION|TIME|SET")) {
       IntPair mSpan = new IntPair(beginIndex, sent.size());
       if(!mentionSpanSet.contains(mSpan)) {
+        int dummyMentionId = -1;
+        Mention m = new Mention(dummyMentionId, beginIndex, sent.size(), dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIndex, sent.size())));
         mentions.add(m);
         mentionSpanSet.add(mSpan);
         namedEntitySpanSet.add(mSpan);
@@ -190,8 +202,8 @@ protected void extractNPorPRP(CoreMap s, List&lt;Mention&gt; mentions, Set&lt;IntPair&gt; me
       if (",".equals(sent.get(endIdx-1).word())) { endIdx--; } // try not to have span that ends with ,
       IntPair mSpan = new IntPair(beginIdx, endIdx);
       if(!mentionSpanSet.contains(mSpan) &amp;&amp; !insideNE(mSpan, namedEntitySpanSet)) {
+        int dummyMentionId = -1;
+        Mention m = new Mention(dummyMentionId, beginIdx, endIdx, dependency, new ArrayList&lt;CoreLabel&gt;(sent.subList(beginIdx, endIdx)), t);
         mentions.add(m);
         mentionSpanSet.add(mSpan);
       }
@@ -225,8 +237,8 @@ protected void extractEnumerations(CoreMap s, List&lt;Mention&gt; mentions, Set&lt;IntPai
 
     for(IntPair mSpan : spanToMentionSubTree.keySet()){
       if(!mentionSpanSet.contains(mSpan) &amp;&amp; !insideNE(mSpan, namedEntitySpanSet)) {
+        int dummyMentionId = -1;
+        Mention m = new Mention(dummyMentionId, mSpan.get(0), mSpan.get(1), dependency,
                                 new ArrayList&lt;CoreLabel&gt;(sent.subList(mSpan.get(0), mSpan.get(1))), spanToMentionSubTree.get(mSpan));
         mentions.add(m);
         mentionSpanSet.add(mSpan);
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>99972</refactoring_id><commit_sha>cfdacc4ae86630f9ec0e498d60507f7527c81d59</commit_sha><commit_link>https://github.com/AutoMQ/automq/commit/cfdacc4ae86630f9ec0e498d60507f7527c81d59</commit_link><file_path>s3stream/src/main/java/com/automq/stream/s3/wal/util/WALBlockDeviceChannel.java</file_path><description>Extract Method public WALBlockDeviceChannel(blockDevicePath String, blockDeviceCapacityWant long, initTempBufferSize int, maxTempBufferSize int) extracted from public WALBlockDeviceChannel(blockDevicePath String, blockDeviceCapacityWant long) in class com.automq.stream.s3.wal.util.WALBlockDeviceChannel</description><code_before>@@ -29,36 +29,54 @@
 
 public class WALBlockDeviceChannel implements WALChannel {
     // TODO: move these to config
     private static final int PRE_ALLOCATED_BYTE_BUFFER_SIZE = Integer.parseInt(System.getProperty(
             "automq.ebswal.preAllocatedByteBufferSize",
             String.valueOf(1024 * 1024 * 2)
     ));
     private static final int PRE_ALLOCATED_BYTE_BUFFER_MAX_SIZE = Integer.parseInt(System.getProperty(
             "automq.ebswal.preAllocatedByteBufferMaxSize",
             String.valueOf(1024 * 1024 * 16)
     ));
 
     final String blockDevicePath;
-    final long capacityWant;
     final DirectIOLib directIOLib;
-
-    long capacityFact = 0;
 
     DirectRandomAccessFile randomAccessFile;
 
     ThreadLocal&lt;ByteBuffer&gt; threadLocalByteBuffer = new ThreadLocal&lt;&gt;() {
         @Override
         protected ByteBuffer initialValue() {
-            return DirectIOUtils.allocateForDirectIO(directIOLib, PRE_ALLOCATED_BYTE_BUFFER_SIZE);
         }
     };
 
     public WALBlockDeviceChannel(String blockDevicePath, long blockDeviceCapacityWant) {
         this.blockDevicePath = blockDevicePath;
-        this.capacityWant = blockDeviceCapacityWant;
-        if (blockDeviceCapacityWant != WALUtil.alignSmallByBlockSize(blockDeviceCapacityWant)) {
             throw new RuntimeException("wal capacity must be aligned by block size when using block device");
         }
         DirectIOLib lib = DirectIOLib.getLibForPath(blockDevicePath);
         if (null == lib || !DirectIOLib.binit) {
             throw new RuntimeException("O_DIRECT not supported");
@@ -73,14 +91,11 @@ public void open() throws IOException {
             // If the block device path is not a device, we create a file with the capacity we want
             // This is ONLY for test purpose, so we don't check the capacity of the file
             try (RandomAccessFile raf = new RandomAccessFile(blockDevicePath, "rw")) {
-                raf.setLength(capacityWant);
             }
         }
 
         randomAccessFile = new DirectRandomAccessFile(new File(blockDevicePath), "rw");
-        // We cannot get the actual capacity of the block device here, so we just use the capacity we want
-        // And it's the caller's responsibility to make sure the capacity is right
-        capacityFact = capacityWant;
     }
 
     @Override
@@ -95,30 +110,34 @@ public void close() {
 
     @Override
     public long capacity() {
-        // FIXME: check the capacity outside
-        return capacityFact;
     }
 
     private ByteBuffer getBuffer(int alignedSize) {
-        assert alignedSize % WALUtil.BLOCK_SIZE == 0;
 
         ByteBuffer currentBuf = threadLocalByteBuffer.get();
-        if (alignedSize &gt; currentBuf.capacity()) {
-            if (alignedSize &lt;= PRE_ALLOCATED_BYTE_BUFFER_MAX_SIZE) {
-                ByteBuffer newBuf = DirectIOUtils.allocateForDirectIO(directIOLib, alignedSize);
-                threadLocalByteBuffer.set(newBuf);
-                DirectIOUtils.release(currentBuf);
-                return newBuf;
-            } else {
-                throw new RuntimeException("too large write size");
-            }
         }
-        return currentBuf;
     }
 
     @Override
     public void write(ByteBuf src, long position) throws IOException {
-        assert position % WALUtil.BLOCK_SIZE == 0;
 
         int alignedSize = (int) WALUtil.alignLargeByBlockSize(src.readableBytes());
         assert position + alignedSize &lt;= capacity();
@@ -134,7 +153,7 @@ public void write(ByteBuf src, long position) throws IOException {
     }
 
     private int write(ByteBuffer src, long position) throws IOException {
-        assert src.remaining() % WALUtil.BLOCK_SIZE == 0;
 
         int bytesWritten = 0;
         while (src.hasRemaining()) {
</code_before><code_after>@@ -29,36 +29,54 @@
 
 public class WALBlockDeviceChannel implements WALChannel {
     // TODO: move these to config
+    @Deprecated
     private static final int PRE_ALLOCATED_BYTE_BUFFER_SIZE = Integer.parseInt(System.getProperty(
             "automq.ebswal.preAllocatedByteBufferSize",
             String.valueOf(1024 * 1024 * 2)
     ));
+    @Deprecated
     private static final int PRE_ALLOCATED_BYTE_BUFFER_MAX_SIZE = Integer.parseInt(System.getProperty(
             "automq.ebswal.preAllocatedByteBufferMaxSize",
             String.valueOf(1024 * 1024 * 16)
     ));
 
     final String blockDevicePath;
+    final long capacity;
     final DirectIOLib directIOLib;
+    /**
+     * 0 means allocate on demand
+     */
+    final int initTempBufferSize;
+    /**
+     * 0 means no limit
+     */
+    final int maxTempBufferSize;
 
     DirectRandomAccessFile randomAccessFile;
 
     ThreadLocal&lt;ByteBuffer&gt; threadLocalByteBuffer = new ThreadLocal&lt;&gt;() {
         @Override
         protected ByteBuffer initialValue() {
+            return DirectIOUtils.allocateForDirectIO(directIOLib, initTempBufferSize);
         }
     };
 
     public WALBlockDeviceChannel(String blockDevicePath, long blockDeviceCapacityWant) {
+        this(blockDevicePath, blockDeviceCapacityWant, 0, 0);
+    }
+
+    public WALBlockDeviceChannel(String blockDevicePath, long blockDeviceCapacityWant, int initTempBufferSize, int maxTempBufferSize) {
         this.blockDevicePath = blockDevicePath;
+        // We cannot get the actual capacity of the block device here, so we just use the capacity we want
+        // And it's the caller's responsibility to make sure the capacity is right
+        // FIXME: in recovery mode, `capacity` will be set to CAPACITY_NOT_SET here. It should be corrected after recovery.
+        this.capacity = blockDeviceCapacityWant;
+        if (!WALUtil.isAligned(blockDeviceCapacityWant)) {
             throw new RuntimeException("wal capacity must be aligned by block size when using block device");
         }
+        this.initTempBufferSize = initTempBufferSize;
+        this.maxTempBufferSize = maxTempBufferSize;
+
         DirectIOLib lib = DirectIOLib.getLibForPath(blockDevicePath);
         if (null == lib || !DirectIOLib.binit) {
             throw new RuntimeException("O_DIRECT not supported");
@@ -73,14 +91,11 @@ public void open() throws IOException {
             // If the block device path is not a device, we create a file with the capacity we want
             // This is ONLY for test purpose, so we don't check the capacity of the file
             try (RandomAccessFile raf = new RandomAccessFile(blockDevicePath, "rw")) {
+                raf.setLength(capacity);
             }
         }
 
         randomAccessFile = new DirectRandomAccessFile(new File(blockDevicePath), "rw");
     }
 
     @Override
@@ -95,30 +110,34 @@ public void close() {
 
     @Override
     public long capacity() {
+        return capacity;
+    }
+
+    @Override
+    public String path() {
+        return blockDevicePath;
     }
 
     private ByteBuffer getBuffer(int alignedSize) {
+        assert WALUtil.isAligned(alignedSize);
 
         ByteBuffer currentBuf = threadLocalByteBuffer.get();
+        if (alignedSize &lt;= currentBuf.capacity()) {
+            return currentBuf;
+        }
+        if (maxTempBufferSize &gt; 0 &amp;&amp; alignedSize &gt; maxTempBufferSize) {
+            throw new RuntimeException("too large write size");
         }
+
+        ByteBuffer newBuf = DirectIOUtils.allocateForDirectIO(directIOLib, alignedSize);
+        threadLocalByteBuffer.set(newBuf);
+        DirectIOUtils.releaseDirectBuffer(currentBuf);
+        return newBuf;
     }
 
     @Override
     public void write(ByteBuf src, long position) throws IOException {
+        assert WALUtil.isAligned(position);
 
         int alignedSize = (int) WALUtil.alignLargeByBlockSize(src.readableBytes());
         assert position + alignedSize &lt;= capacity();
@@ -134,7 +153,7 @@ public void write(ByteBuf src, long position) throws IOException {
     }
 
     private int write(ByteBuffer src, long position) throws IOException {
+        assert WALUtil.isAligned(src.remaining());
 
         int bytesWritten = 0;
         while (src.hasRemaining()) {
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>24046</refactoring_id><commit_sha>05866a685f5989435402d08cc07175035ebfb01d</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/05866a685f5989435402d08cc07175035ebfb01d</commit_link><file_path>backend/src/main/develop/java/org/camunda/operate/util/ZeebeDemoDataGenerator.java</file_path><description>Extract Method private shutdownScheduler() : void extracted from private progressWorkflowInstances() : void in class org.camunda.operate.util.ZeebeDemoDataGenerator</description><code_before>@@ -1,6 +1,7 @@
 package org.camunda.operate.util;
 
 import javax.annotation.PostConstruct;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
@@ -39,12 +40,17 @@ public class ZeebeDemoDataGenerator {
 
   private Random random = new Random();
 
   @PostConstruct
   private void createZeebeData() {
     this.createZeebeData(false);
   }
 
   public void createZeebeData(boolean manuallyCalled) {
     try {
       createTopic();
     } catch (ClientCommandRejectedException ex) {
@@ -93,7 +99,7 @@ private void progressWorkflowInstances() {
     //    final TopicSubscription updateRetriesIncidentSubscription = updateRetries();
 
     //start more instances after 1 minute
-    ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
     scheduler.schedule(() -&gt;
       startWorkflowInstances(1)
     , 1, TimeUnit.MINUTES);
@@ -109,6 +115,13 @@ private void progressWorkflowInstances() {
       logger.info("Subscriptions for demo data generation were canceled");
     }, 2, TimeUnit.MINUTES);
 
     scheduler.shutdown();
     try {
       if (!scheduler.awaitTermination(3, TimeUnit.MINUTES)) {
</code_before><code_after>@@ -1,6 +1,7 @@
 package org.camunda.operate.util;
 
 import javax.annotation.PostConstruct;
+import javax.annotation.PreDestroy;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
@@ -39,12 +40,17 @@ public class ZeebeDemoDataGenerator {
 
   private Random random = new Random();
 
+  private boolean manuallyCalled = false;
+
+  private ScheduledExecutorService scheduler;
+
   @PostConstruct
   private void createZeebeData() {
     this.createZeebeData(false);
   }
 
   public void createZeebeData(boolean manuallyCalled) {
+    this.manuallyCalled = manuallyCalled;
     try {
       createTopic();
     } catch (ClientCommandRejectedException ex) {
@@ -93,7 +99,7 @@ private void progressWorkflowInstances() {
     //    final TopicSubscription updateRetriesIncidentSubscription = updateRetries();
 
     //start more instances after 1 minute
+    scheduler = Executors.newScheduledThreadPool(1);
     scheduler.schedule(() -&gt;
       startWorkflowInstances(1)
     , 1, TimeUnit.MINUTES);
@@ -109,6 +115,13 @@ private void progressWorkflowInstances() {
       logger.info("Subscriptions for demo data generation were canceled");
     }, 2, TimeUnit.MINUTES);
 
+    if (manuallyCalled) {
+      shutdownScheduler();
+    }
+  }
+
+  @PreDestroy
+  private void shutdownScheduler() {
     scheduler.shutdown();
     try {
       if (!scheduler.awaitTermination(3, TimeUnit.MINUTES)) {
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>27499</refactoring_id><commit_sha>cd5fe2040bc96821b20964202d2150dc530a44e6</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/cd5fe2040bc96821b20964202d2150dc530a44e6</commit_link><file_path>src/main/java/mekanism/client/gui/GuiThermalEvaporationController.java</file_path><description>Extract Method protected getGuiLocation() : ResourceLocation extracted from public GuiThermalEvaporationController(inventory InventoryPlayer, tentity TileEntityThermalEvaporationController) in class mekanism.client.gui.GuiThermalEvaporationController</description><code_before>@@ -1,6 +1,6 @@
 package mekanism.client.gui;
 
-import java.util.Arrays;
 import mekanism.client.gui.element.GuiFluidGauge;
 import mekanism.client.gui.element.GuiGauge;
 import mekanism.client.gui.element.GuiHeatInfo;
@@ -13,65 +13,55 @@
 import mekanism.common.util.UnitDisplayUtils;
 import mekanism.common.util.UnitDisplayUtils.TemperatureUnit;
 import net.minecraft.entity.player.InventoryPlayer;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
 import org.lwjgl.opengl.GL11;
 
 @SideOnly(Side.CLIENT)
-public class GuiThermalEvaporationController extends GuiMekanism {
-
-    public TileEntityThermalEvaporationController tileEntity;
-
-    public GuiThermalEvaporationController(InventoryPlayer inventory, TileEntityThermalEvaporationController tentity) {
-        super(tentity, new ContainerThermalEvaporationController(inventory, tentity));
-        tileEntity = tentity;
-
-        guiElements.add(new GuiFluidGauge(() -&gt; tileEntity.inputTank, GuiGauge.Type.STANDARD, this,
-              MekanismUtils.getResource(ResourceType.GUI, "GuiThermalEvaporationController.png"), 6, 13));
-        guiElements.add(new GuiFluidGauge(() -&gt; tileEntity.outputTank, GuiGauge.Type.STANDARD, this,
-              MekanismUtils.getResource(ResourceType.GUI, "GuiThermalEvaporationController.png"), 152, 13));
-        guiElements.add(new GuiHeatInfo(() -&gt;
-        {
             TemperatureUnit unit = TemperatureUnit.values()[general.tempUnit.ordinal()];
             String environment = UnitDisplayUtils
                   .getDisplayShort(tileEntity.totalLoss * unit.intervalSize, false, unit);
-            return Arrays.asList(LangUtils.localize("gui.dissipated") + ": " + environment + "/t");
-        }, this, MekanismUtils.getResource(ResourceType.GUI, "GuiThermalEvaporationController.png")));
     }
 
     @Override
     protected void drawGuiContainerForegroundLayer(int mouseX, int mouseY) {
-        int xAxis = (mouseX - (width - xSize) / 2);
-        int yAxis = (mouseY - (height - ySize) / 2);
-
         fontRenderer.drawString(LangUtils.localize("container.inventory"), 8, (ySize - 96) + 4, 0x404040);
         fontRenderer
               .drawString(tileEntity.getName(), (xSize / 2) - (fontRenderer.getStringWidth(tileEntity.getName()) / 2),
                     4, 0x404040);
-
         fontRenderer.drawString(getStruct(), 50, 21, 0x00CD00);
         fontRenderer.drawString(LangUtils.localize("gui.height") + ": " + tileEntity.height, 50, 30, 0x00CD00);
         fontRenderer.drawString(LangUtils.localize("gui.temp") + ": " + getTemp(), 50, 39, 0x00CD00);
         renderScaledText(
               LangUtils.localize("gui.production") + ": " + Math.round(tileEntity.lastGain * 100D) / 100D + " mB/t", 50,
               48, 0x00CD00, 76);
-
         if (xAxis &gt;= 7 &amp;&amp; xAxis &lt;= 23 &amp;&amp; yAxis &gt;= 14 &amp;&amp; yAxis &lt;= 72) {
             drawHoveringText(tileEntity.inputTank.getFluid() != null ?
                   LangUtils.localizeFluidStack(tileEntity.inputTank.getFluid()) + ": " + tileEntity.inputTank
                         .getFluidAmount() : LangUtils.localize("gui.empty"), xAxis, yAxis);
         }
-
         if (xAxis &gt;= 153 &amp;&amp; xAxis &lt;= 169 &amp;&amp; yAxis &gt;= 14 &amp;&amp; yAxis &lt;= 72) {
             drawHoveringText(tileEntity.outputTank.getFluid() != null ?
                   LangUtils.localizeFluidStack(tileEntity.outputTank.getFluid()) + ": " + tileEntity.outputTank
                         .getFluidAmount() : LangUtils.localize("gui.empty"), xAxis, yAxis);
         }
-
         if (xAxis &gt;= 49 &amp;&amp; xAxis &lt;= 127 &amp;&amp; yAxis &gt;= 64 &amp;&amp; yAxis &lt;= 72) {
             drawHoveringText(getTemp(), xAxis, yAxis);
         }
-
         super.drawGuiContainerForegroundLayer(mouseX, mouseY);
     }
 
@@ -88,22 +78,23 @@ private String getStruct() {
     }
 
     private String getTemp() {
-        float temp = tileEntity.getTemperature();
-
-        return MekanismUtils.getTemperatureDisplay(temp, TemperatureUnit.AMBIENT);
     }
 
     @Override
     protected void drawGuiContainerBackgroundLayer(float partialTick, int mouseX, int mouseY) {
-        mc.renderEngine.bindTexture(MekanismUtils.getResource(ResourceType.GUI, "GuiThermalEvaporationController.png"));
         GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
         int guiWidth = (width - xSize) / 2;
         int guiHeight = (height - ySize) / 2;
         drawTexturedModalRect(guiWidth, guiHeight, 0, 0, xSize, ySize);
-
         int displayInt = tileEntity.getScaledTempLevel(78);
         drawTexturedModalRect(guiWidth + 49, guiHeight + 64, 176, 59, displayInt, 8);
-
         super.drawGuiContainerBackgroundLayer(partialTick, mouseX, mouseY);
     }
-}
\ No newline at end of file
</code_before><code_after>@@ -1,6 +1,6 @@
 package mekanism.client.gui;
 
+import java.util.Collections;
 import mekanism.client.gui.element.GuiFluidGauge;
 import mekanism.client.gui.element.GuiGauge;
 import mekanism.client.gui.element.GuiHeatInfo;
@@ -13,65 +13,55 @@
 import mekanism.common.util.UnitDisplayUtils;
 import mekanism.common.util.UnitDisplayUtils.TemperatureUnit;
 import net.minecraft.entity.player.InventoryPlayer;
+import net.minecraft.util.ResourceLocation;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
 import org.lwjgl.opengl.GL11;
 
 @SideOnly(Side.CLIENT)
+public class GuiThermalEvaporationController extends GuiMekanismTile&lt;TileEntityThermalEvaporationController&gt; {
+
+    public GuiThermalEvaporationController(InventoryPlayer inventory, TileEntityThermalEvaporationController tile) {
+        super(tile, new ContainerThermalEvaporationController(inventory, tile));
+        ResourceLocation resource = getGuiLocation();
+        addGuiElement(new GuiFluidGauge(() -&gt; tileEntity.inputTank, GuiGauge.Type.STANDARD, this, resource, 6, 13));
+        addGuiElement(new GuiFluidGauge(() -&gt;
+              tileEntity.outputTank, GuiGauge.Type.STANDARD, this, resource, 152, 13));
+        addGuiElement(new GuiHeatInfo(() -&gt; {
             TemperatureUnit unit = TemperatureUnit.values()[general.tempUnit.ordinal()];
             String environment = UnitDisplayUtils
                   .getDisplayShort(tileEntity.totalLoss * unit.intervalSize, false, unit);
+            return Collections.singletonList(LangUtils.localize("gui.dissipated") + ": " + environment + "/t");
+        }, this, resource));
     }
 
     @Override
     protected void drawGuiContainerForegroundLayer(int mouseX, int mouseY) {
         fontRenderer.drawString(LangUtils.localize("container.inventory"), 8, (ySize - 96) + 4, 0x404040);
         fontRenderer
               .drawString(tileEntity.getName(), (xSize / 2) - (fontRenderer.getStringWidth(tileEntity.getName()) / 2),
                     4, 0x404040);
         fontRenderer.drawString(getStruct(), 50, 21, 0x00CD00);
         fontRenderer.drawString(LangUtils.localize("gui.height") + ": " + tileEntity.height, 50, 30, 0x00CD00);
         fontRenderer.drawString(LangUtils.localize("gui.temp") + ": " + getTemp(), 50, 39, 0x00CD00);
         renderScaledText(
               LangUtils.localize("gui.production") + ": " + Math.round(tileEntity.lastGain * 100D) / 100D + " mB/t", 50,
               48, 0x00CD00, 76);
+        int xAxis = (mouseX - (width - xSize) / 2);
+        int yAxis = (mouseY - (height - ySize) / 2);
         if (xAxis &gt;= 7 &amp;&amp; xAxis &lt;= 23 &amp;&amp; yAxis &gt;= 14 &amp;&amp; yAxis &lt;= 72) {
             drawHoveringText(tileEntity.inputTank.getFluid() != null ?
                   LangUtils.localizeFluidStack(tileEntity.inputTank.getFluid()) + ": " + tileEntity.inputTank
                         .getFluidAmount() : LangUtils.localize("gui.empty"), xAxis, yAxis);
         }
         if (xAxis &gt;= 153 &amp;&amp; xAxis &lt;= 169 &amp;&amp; yAxis &gt;= 14 &amp;&amp; yAxis &lt;= 72) {
             drawHoveringText(tileEntity.outputTank.getFluid() != null ?
                   LangUtils.localizeFluidStack(tileEntity.outputTank.getFluid()) + ": " + tileEntity.outputTank
                         .getFluidAmount() : LangUtils.localize("gui.empty"), xAxis, yAxis);
         }
         if (xAxis &gt;= 49 &amp;&amp; xAxis &lt;= 127 &amp;&amp; yAxis &gt;= 64 &amp;&amp; yAxis &lt;= 72) {
             drawHoveringText(getTemp(), xAxis, yAxis);
         }
         super.drawGuiContainerForegroundLayer(mouseX, mouseY);
     }
 
@@ -88,22 +78,23 @@ private String getStruct() {
     }
 
     private String getTemp() {
+        return MekanismUtils.getTemperatureDisplay(tileEntity.getTemperature(), TemperatureUnit.AMBIENT);
     }
 
     @Override
     protected void drawGuiContainerBackgroundLayer(float partialTick, int mouseX, int mouseY) {
+        mc.renderEngine.bindTexture(getGuiLocation());
         GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
         int guiWidth = (width - xSize) / 2;
         int guiHeight = (height - ySize) / 2;
         drawTexturedModalRect(guiWidth, guiHeight, 0, 0, xSize, ySize);
         int displayInt = tileEntity.getScaledTempLevel(78);
         drawTexturedModalRect(guiWidth + 49, guiHeight + 64, 176, 59, displayInt, 8);
         super.drawGuiContainerBackgroundLayer(partialTick, mouseX, mouseY);
     }
+
+    @Override
+    protected ResourceLocation getGuiLocation() {
+        return MekanismUtils.getResource(ResourceType.GUI, "GuiThermalEvaporationController.png");
+    }
+}
\ No newline at end of file
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>66145</refactoring_id><commit_sha>a2f52db452721dd08bf06d656929921326e9bce7</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/a2f52db452721dd08bf06d656929921326e9bce7</commit_link><file_path>spring-test/src/test/java/org/springframework/test/context/env/InlinedPropertiesTestPropertySourceTests.java</file_path><description>Extract Method private assertEnvironmentProperty(name String, value Object) : void extracted from package propertiesAreAvailableInEnvironment() : void in class org.springframework.test.context.env.InlinedPropertiesTestPropertySourceTests</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2019 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,6 +36,7 @@
  *
  * @author Sam Brannen
  * @since 4.1
  */
 @ExtendWith(SpringExtension.class)
 @ContextConfiguration
@@ -44,40 +45,37 @@
 class InlinedPropertiesTestPropertySourceTests {
 
 	@Autowired
-	private ConfigurableEnvironment env;
 
 
-	private String property(String key) {
-		return env.getProperty(key);
-	}
-
 	@Test
 	void propertiesAreAvailableInEnvironment() {
 		// Simple key/value pairs
-		assertThat(property("foo")).isEqualTo("bar");
-		assertThat(property("baz")).isEqualTo("quux");
-		assertThat(property("enigma")).isEqualTo("42");
 
 		// Values containing key/value delimiters (":", "=", " ")
-		assertThat(property("x.y.z")).isEqualTo("a=b=c");
-		assertThat(property("server.url")).isEqualTo("https://example.com");
-		assertThat(property("key.value.1")).isEqualTo("key=value");
-		assertThat(property("key.value.2")).isEqualTo("key=value");
-		assertThat(property("key.value.3")).isEqualTo("key:value");
 	}
 
 	@Test
 	@SuppressWarnings("rawtypes")
 	void propertyNameOrderingIsPreservedInEnvironment() {
-		final String[] expectedPropertyNames = new String[] { "foo", "baz", "enigma", "x.y.z", "server.url",
-			"key.value.1", "key.value.2", "key.value.3" };
 		EnumerablePropertySource eps = (EnumerablePropertySource) env.getPropertySources().get(
 			INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);
-		assertThat(eps.getPropertyNames()).isEqualTo(expectedPropertyNames);
 	}
 
 
-	// -------------------------------------------------------------------
 
 	@Configuration
 	static class Config {
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright 2002-2023 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,6 +36,7 @@
  *
  * @author Sam Brannen
  * @since 4.1
+ * @see InlinedPropertiesWithTextBlockTestPropertySourceTests
  */
 @ExtendWith(SpringExtension.class)
 @ContextConfiguration
@@ -44,40 +45,37 @@
 class InlinedPropertiesTestPropertySourceTests {
 
 	@Autowired
+	ConfigurableEnvironment env;
 
 
 	@Test
 	void propertiesAreAvailableInEnvironment() {
 		// Simple key/value pairs
+		assertEnvironmentProperty("foo", "bar");
+		assertEnvironmentProperty("baz", "quux");
+		assertEnvironmentProperty("enigma", "42");
 
 		// Values containing key/value delimiters (":", "=", " ")
+		assertEnvironmentProperty("x.y.z", "a=b=c");
+		assertEnvironmentProperty("server.url", "https://example.com");
+		assertEnvironmentProperty("key.value.1", "key=value");
+		assertEnvironmentProperty("key.value.2", "key=value");
+		assertEnvironmentProperty("key.value.3", "key:value");
 	}
 
 	@Test
 	@SuppressWarnings("rawtypes")
 	void propertyNameOrderingIsPreservedInEnvironment() {
 		EnumerablePropertySource eps = (EnumerablePropertySource) env.getPropertySources().get(
 			INLINED_PROPERTIES_PROPERTY_SOURCE_NAME);
+		assertThat(eps.getPropertyNames()).containsExactly("foo", "baz", "enigma", "x.y.z", "server.url",
+				"key.value.1", "key.value.2", "key.value.3" );
 	}
 
+	private void assertEnvironmentProperty(String name, Object value) {
+		assertThat(this.env.getProperty(name)).as("environment property '%s'", name).isEqualTo(value);
+	}
 
 
 	@Configuration
 	static class Config {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>75244</refactoring_id><commit_sha>e5a3d844b45c26abdc79daea156bf084c46b2ecd</commit_sha><commit_link>https://github.com/micronaut-projects/micronaut-core/commit/e5a3d844b45c26abdc79daea156bf084c46b2ecd</commit_link><file_path>inject/src/main/java/io/micronaut/inject/writer/AbstractClassFileWriter.java</file_path><description>Extract Method protected pushNewArray(methodVisitor GeneratorAdapter, arrayType Type, size int) : void extracted from protected pushNewArray(methodVisitor GeneratorAdapter, arrayType Class&lt;?&gt;, size int) : void in class io.micronaut.inject.writer.AbstractClassFileWriter</description><code_before>@@ -947,10 +947,20 @@ protected static void pushMethodNameAndTypesArguments(GeneratorAdapter methodVis
      * @param size          The size
      */
     protected static void pushNewArray(GeneratorAdapter methodVisitor, Class&lt;?&gt; arrayType, int size) {
         // the size of the array
         methodVisitor.push(size);
         // define the array
-        methodVisitor.newArray(Type.getType(arrayType));
         // add a reference to the array on the stack
         if (size &gt; 0) {
             methodVisitor.visitInsn(DUP);
</code_before><code_after>@@ -947,10 +947,20 @@ protected static void pushMethodNameAndTypesArguments(GeneratorAdapter methodVis
      * @param size          The size
      */
     protected static void pushNewArray(GeneratorAdapter methodVisitor, Class&lt;?&gt; arrayType, int size) {
+        final Type t = Type.getType(arrayType);
+        pushNewArray(methodVisitor, t, size);
+    }
+
+    /**
+     * @param methodVisitor The method visitor as {@link org.objectweb.asm.commons.GeneratorAdapter}
+     * @param arrayType     The array class
+     * @param size          The size
+     */
+    protected static void pushNewArray(GeneratorAdapter methodVisitor, Type arrayType, int size) {
         // the size of the array
         methodVisitor.push(size);
         // define the array
+        methodVisitor.newArray(arrayType);
         // add a reference to the array on the stack
         if (size &gt; 0) {
             methodVisitor.visitInsn(DUP);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>82594</refactoring_id><commit_sha>6c7c763c3ad1c58439054590e11e19fce085a5c3</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/6c7c763c3ad1c58439054590e11e19fce085a5c3</commit_link><file_path>src/com/google/javascript/jscomp/DefinitionsRemover.java</file_path><description>Extract Method private getLValue(name Node) : Node extracted from public getLValue() : Node in class com.google.javascript.jscomp.DefinitionsRemover.ObjectLiteralPropertyDefinition</description><code_before>@@ -130,9 +130,11 @@ static boolean isDefinitionNode(Node n) {
   abstract static class Definition {
 
     private final boolean isExtern;
 
-    Definition(boolean isExtern) {
       this.isExtern = isExtern;
     }
 
     /**
@@ -154,6 +156,10 @@ public void remove(AbstractCompiler compiler) {
      */
     protected abstract void performRemove(AbstractCompiler compiler);
 
     /**
      * Variable or property name represented by this definition.
      * For example, in the case of assignments this method would
@@ -194,7 +200,7 @@ abstract static class IncompleteDefinition extends Definition {
     private final Node lValue;
 
     IncompleteDefinition(Node lValue, boolean inExterns) {
-      super(inExterns);
       checkNotNull(lValue);
 
       Preconditions.checkArgument(
@@ -273,7 +279,7 @@ abstract static class FunctionDefinition extends Definition {
     protected final Node function;
 
     FunctionDefinition(Node node, boolean inExterns) {
-      super(inExterns);
       checkArgument(node.isFunction());
       function = node;
     }
@@ -357,7 +363,7 @@ abstract static class ClassDefinition extends Definition {
     protected final Node c;
 
     ClassDefinition(Node node, boolean inExterns) {
-      super(inExterns);
       Preconditions.checkArgument(node.isClass());
       c = node;
     }
@@ -414,7 +420,7 @@ static final class AssignmentDefinition extends Definition {
     private final Node assignment;
 
     AssignmentDefinition(Node node, boolean inExterns) {
-      super(inExterns);
       checkArgument(node.isAssign());
       assignment = node;
     }
@@ -470,7 +476,7 @@ static final class ObjectLiteralPropertyDefinition extends Definition {
 
     ObjectLiteralPropertyDefinition(Node lit, Node name, Node value,
           boolean isExtern) {
-      super(isExtern);
 
       this.literal = lit;
       this.name = name;
@@ -485,6 +491,10 @@ public void performRemove(AbstractCompiler compiler) {
 
     @Override
     public Node getLValue() {
       // TODO(user) revisit: object literal definitions are an example
       // of definitions whose LHS doesn't correspond to a node that
       // exists in the AST.  We will have to change the return type of
@@ -516,7 +526,7 @@ public Node getRValue() {
   static final class VarDefinition extends Definition {
     private final Node name;
     VarDefinition(Node node, boolean inExterns) {
-      super(inExterns);
       checkArgument(NodeUtil.isVarDeclaration(node));
       Preconditions.checkArgument(inExterns || node.hasChildren(),
           "VAR Declaration of %s must be assigned a value.", node.getString());
</code_before><code_after>@@ -130,9 +130,11 @@ static boolean isDefinitionNode(Node n) {
   abstract static class Definition {
 
     private final boolean isExtern;
+    private final String simplifiedName;
 
+    Definition(boolean isExtern, String simplifiedName) {
       this.isExtern = isExtern;
+      this.simplifiedName = simplifiedName;
     }
 
     /**
@@ -154,6 +156,10 @@ public void remove(AbstractCompiler compiler) {
      */
     protected abstract void performRemove(AbstractCompiler compiler);
 
+    public String getSimplifiedName() {
+      return simplifiedName;
+    }
+
     /**
      * Variable or property name represented by this definition.
      * For example, in the case of assignments this method would
@@ -194,7 +200,7 @@ abstract static class IncompleteDefinition extends Definition {
     private final Node lValue;
 
     IncompleteDefinition(Node lValue, boolean inExterns) {
+      super(inExterns, NameBasedDefinitionProvider.getSimplifiedName(lValue));
       checkNotNull(lValue);
 
       Preconditions.checkArgument(
@@ -273,7 +279,7 @@ abstract static class FunctionDefinition extends Definition {
     protected final Node function;
 
     FunctionDefinition(Node node, boolean inExterns) {
+      super(inExterns, NameBasedDefinitionProvider.getSimplifiedName(node.getFirstChild()));
       checkArgument(node.isFunction());
       function = node;
     }
@@ -357,7 +363,7 @@ abstract static class ClassDefinition extends Definition {
     protected final Node c;
 
     ClassDefinition(Node node, boolean inExterns) {
+      super(inExterns, NameBasedDefinitionProvider.getSimplifiedName(node.getFirstChild()));
       Preconditions.checkArgument(node.isClass());
       c = node;
     }
@@ -414,7 +420,7 @@ static final class AssignmentDefinition extends Definition {
     private final Node assignment;
 
     AssignmentDefinition(Node node, boolean inExterns) {
+      super(inExterns, NameBasedDefinitionProvider.getSimplifiedName(node.getFirstChild()));
       checkArgument(node.isAssign());
       assignment = node;
     }
@@ -470,7 +476,7 @@ static final class ObjectLiteralPropertyDefinition extends Definition {
 
     ObjectLiteralPropertyDefinition(Node lit, Node name, Node value,
           boolean isExtern) {
+      super(isExtern, NameBasedDefinitionProvider.getSimplifiedName(getLValue(name)));
 
       this.literal = lit;
       this.name = name;
@@ -485,6 +491,10 @@ public void performRemove(AbstractCompiler compiler) {
 
     @Override
     public Node getLValue() {
+      return getLValue(name);
+    }
+
+    private static Node getLValue(Node name) {
       // TODO(user) revisit: object literal definitions are an example
       // of definitions whose LHS doesn't correspond to a node that
       // exists in the AST.  We will have to change the return type of
@@ -516,7 +526,7 @@ public Node getRValue() {
   static final class VarDefinition extends Definition {
     private final Node name;
     VarDefinition(Node node, boolean inExterns) {
+      super(inExterns, NameBasedDefinitionProvider.getSimplifiedName(node));
       checkArgument(NodeUtil.isVarDeclaration(node));
       Preconditions.checkArgument(inExterns || node.hasChildren(),
           "VAR Declaration of %s must be assigned a value.", node.getString());
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>60652</refactoring_id><commit_sha>42fad079ff136302566fcfb86a47a702f18c2082</commit_sha><commit_link>https://github.com/groovy/groovy-core/commit/42fad079ff136302566fcfb86a47a702f18c2082</commit_link><file_path>src/main/org/codehaus/groovy/runtime/ProcessGroovyMethods.java</file_path><description>Extract Method public closeStreams(self Process) : void extracted from public getText(self Process) : String in class org.codehaus.groovy.runtime.ProcessGroovyMethods</description><code_before>@@ -70,9 +70,7 @@ public static InputStream getIn(Process self) {
      */
     public static String getText(Process self) throws IOException {
         String text = IOGroovyMethods.getText(new BufferedReader(new InputStreamReader(self.getInputStream())));
-        try { self.getErrorStream().close(); } catch (IOException ignore) {}
-        try { self.getInputStream().close(); } catch (IOException ignore) {}
-        try { self.getOutputStream().close(); } catch (IOException ignore) {}
         return text;
     }
 
@@ -142,6 +140,18 @@ public static void waitForOrKill(Process self, long numberOfMillis) {
         runnable.waitForOrKill(numberOfMillis);
     }
 
     /**
      * Gets the output and error streams from a process and reads them
      * to keep the process from blocking due to a full output buffer.
</code_before><code_after>@@ -70,9 +70,7 @@ public static InputStream getIn(Process self) {
      */
     public static String getText(Process self) throws IOException {
         String text = IOGroovyMethods.getText(new BufferedReader(new InputStreamReader(self.getInputStream())));
+        closeStreams(self);
         return text;
     }
 
@@ -142,6 +140,18 @@ public static void waitForOrKill(Process self, long numberOfMillis) {
         runnable.waitForOrKill(numberOfMillis);
     }
 
+    /**
+     * Closes all the streams associated with the process (ignoring any IOExceptions).
+     *
+     * @param self a Process
+     * @since 2.1
+     */
+    public static void closeStreams(Process self) {
+        try { self.getErrorStream().close(); } catch (IOException ignore) {}
+        try { self.getInputStream().close(); } catch (IOException ignore) {}
+        try { self.getOutputStream().close(); } catch (IOException ignore) {}
+    }
+
     /**
      * Gets the output and error streams from a process and reads them
      * to keep the process from blocking due to a full output buffer.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>57053</refactoring_id><commit_sha>e7555f299a578069a72828a7e520413def7863a8</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/e7555f299a578069a72828a7e520413def7863a8</commit_link><file_path>Dart/src/com/jetbrains/lang/dart/ide/runner/server/ui/DartCommandLineConfigurationEditorForm.java</file_path><description>Extract Method public initDartFileTextWithBrowse(project Project, textWithBrowse TextFieldWithBrowseButton) : void extracted from public DartCommandLineConfigurationEditorForm(project Project) in class com.jetbrains.lang.dart.ide.runner.server.ui.DartCommandLineConfigurationEditorForm</description><code_before>@@ -10,11 +10,14 @@
 import com.intellij.openapi.ui.TextFieldWithBrowseButton;
 import com.intellij.openapi.util.io.FileUtil;
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.openapi.vfs.VirtualFile;
 import com.intellij.psi.PsiFile;
 import com.intellij.ui.RawCommandLineEditor;
 import com.jetbrains.lang.dart.DartBundle;
 import com.jetbrains.lang.dart.DartFileType;
 import com.jetbrains.lang.dart.ide.runner.server.DartCommandLineRunConfiguration;
 import org.jetbrains.annotations.NotNull;
 
@@ -30,35 +33,44 @@ public class DartCommandLineConfigurationEditorForm extends SettingsEditor&lt;DartC
   private TextFieldWithBrowseButton myWorkingDirectory;
 
   public DartCommandLineConfigurationEditorForm(final Project project) {
-    myFileField.getButton().addActionListener(new ActionListener() {
       public void actionPerformed(ActionEvent e) {
         TreeFileChooser fileChooser = TreeFileChooserFactory.getInstance(project).createFileChooser(
           DartBundle.message("choose.dart.main.file"),
-          null,
           DartFileType.INSTANCE,
           new TreeFileChooser.PsiFileFilter() {
             public boolean accept(PsiFile file) {
-              return true;
             }
           }
         );
 
         fileChooser.showDialog();
 
-        PsiFile selectedFile = fileChooser.getSelectedFile();
         final VirtualFile virtualFile = selectedFile == null ? null : selectedFile.getVirtualFile();
         if (virtualFile != null) {
           final String path = FileUtil.toSystemDependentName(virtualFile.getPath());
-          myFileField.setText(path);
         }
       }
     });
-
-    myWorkingDirectory.addBrowseFolderListener(ExecutionBundle.message("select.working.directory.message"), null, project,
-                                               FileChooserDescriptorFactory.createSingleFolderDescriptor());
-
-    myVMOptions.setDialogCaption(DartBundle.message("config.vmoptions.caption"));
-    myArguments.setDialogCaption(DartBundle.message("config.progargs.caption"));
   }
 
   @Override
</code_before><code_after>@@ -10,11 +10,14 @@
 import com.intellij.openapi.ui.TextFieldWithBrowseButton;
 import com.intellij.openapi.util.io.FileUtil;
 import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.LocalFileSystem;
 import com.intellij.openapi.vfs.VirtualFile;
 import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiManager;
 import com.intellij.ui.RawCommandLineEditor;
 import com.jetbrains.lang.dart.DartBundle;
 import com.jetbrains.lang.dart.DartFileType;
+import com.jetbrains.lang.dart.ide.DartWritingAccessProvider;
 import com.jetbrains.lang.dart.ide.runner.server.DartCommandLineRunConfiguration;
 import org.jetbrains.annotations.NotNull;
 
@@ -30,35 +33,44 @@ public class DartCommandLineConfigurationEditorForm extends SettingsEditor&lt;DartC
   private TextFieldWithBrowseButton myWorkingDirectory;
 
   public DartCommandLineConfigurationEditorForm(final Project project) {
+    initDartFileTextWithBrowse(project, myFileField);
+
+    myWorkingDirectory.addBrowseFolderListener(ExecutionBundle.message("select.working.directory.message"), null, project,
+                                               FileChooserDescriptorFactory.createSingleFolderDescriptor());
+
+    myVMOptions.setDialogCaption(DartBundle.message("config.vmoptions.caption"));
+    myArguments.setDialogCaption(DartBundle.message("config.progargs.caption"));
+  }
+
+  public static void initDartFileTextWithBrowse(final @NotNull Project project,
+                                                final @NotNull TextFieldWithBrowseButton textWithBrowse) {
+    textWithBrowse.getButton().addActionListener(new ActionListener() {
       public void actionPerformed(ActionEvent e) {
+        final String initialPath = FileUtil.toSystemIndependentName(textWithBrowse.getText().trim());
+        final VirtualFile initialFile = initialPath.isEmpty() ? null : LocalFileSystem.getInstance().findFileByPath(initialPath);
+        final PsiFile initialPsiFile = initialFile == null ? null : PsiManager.getInstance(project).findFile(initialFile);
+
         TreeFileChooser fileChooser = TreeFileChooserFactory.getInstance(project).createFileChooser(
           DartBundle.message("choose.dart.main.file"),
+          initialPsiFile,
           DartFileType.INSTANCE,
           new TreeFileChooser.PsiFileFilter() {
             public boolean accept(PsiFile file) {
+              return !DartWritingAccessProvider.isInDartSdkOrDartPackagesFolder(file);
             }
           }
         );
 
         fileChooser.showDialog();
 
+        final PsiFile selectedFile = fileChooser.getSelectedFile();
         final VirtualFile virtualFile = selectedFile == null ? null : selectedFile.getVirtualFile();
         if (virtualFile != null) {
           final String path = FileUtil.toSystemDependentName(virtualFile.getPath());
+          textWithBrowse.setText(path);
         }
       }
     });
   }
 
   @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>5199</refactoring_id><commit_sha>009ee203c4275b912866678d7d41bdbdab5721f7</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/009ee203c4275b912866678d7d41bdbdab5721f7</commit_link><file_path>clients/java/client/src/main/java/org/camunda/bpm/client/impl/variable/mapper/serializable/XmlValueMapper.java</file_path><description>Extract Method public XmlValueMapper(dataFormat DataFormat&lt;SpinXmlElement&gt;) extracted from public XmlValueMapper() in class org.camunda.bpm.client.impl.variable.mapper.serializable.XmlValueMapper</description><code_before>@@ -1,9 +1,9 @@
 /* Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
  *      http://www.apache.org/licenses/LICENSE-2.0
- *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -12,13 +12,38 @@
  */
 package org.camunda.bpm.client.impl.variable.mapper.serializable;
 
-/**
- * @author Tassilo Weidner
- */
-public class XmlValueMapper extends SpinValueMapper {
 
   public XmlValueMapper() {
-    super("xml");
   }
 
 }
</code_before><code_after>@@ -1,9 +1,9 @@
 /* Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
+ * 
  *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -12,13 +12,38 @@
  */
 package org.camunda.bpm.client.impl.variable.mapper.serializable;
 
+import org.camunda.bpm.client.impl.variable.TypedValueField;
+import org.camunda.bpm.engine.variable.impl.value.UntypedValueImpl;
+import org.camunda.spin.DataFormats;
+import org.camunda.spin.plugin.variable.SpinValues;
+import org.camunda.spin.plugin.variable.type.SpinValueType;
+import org.camunda.spin.plugin.variable.type.XmlValueType;
+import org.camunda.spin.plugin.variable.value.XmlValue;
+import org.camunda.spin.plugin.variable.value.impl.XmlValueImpl;
+import org.camunda.spin.spi.DataFormat;
+import org.camunda.spin.xml.SpinXmlElement;
+
+public class XmlValueMapper extends SpinValueMapper&lt;XmlValue&gt; {
+
+  public XmlValueMapper(DataFormat&lt;SpinXmlElement&gt; dataFormat) {
+    super(SpinValueType.XML, dataFormat, XmlValueType.TYPE_NAME);
+  }
 
   public XmlValueMapper() {
+    this(DataFormats.xml());
+  }
+
+  public XmlValue convertToTypedValue(UntypedValueImpl untypedValue) {
+    return SpinValues.xmlValue((SpinXmlElement) untypedValue.getValue()).create();
+  }
+
+  protected XmlValue createDeserializedValue(Object deserializedObject, String serializedValue, TypedValueField typedValueField) {
+    SpinXmlElement value = (SpinXmlElement) deserializedObject;
+    return new XmlValueImpl(value, serializedValue, value.getDataFormatName(), true);
+  }
+
+  protected XmlValue createSerializedValue(String serializedValue, TypedValueField typedValueField) {
+    return new XmlValueImpl(serializedValue, serializationDataFormat);
   }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>123614</refactoring_id><commit_sha>f4172beb80ff43884e5cf74702b97f48d371f00c</commit_sha><commit_link>https://github.com/oracle/graal/commit/f4172beb80ff43884e5cf74702b97f48d371f00c</commit_link><file_path>sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMContext.java</file_path><description>Extract Method private isDefaultLibrary(lib ExternalLibrary) : boolean extracted from public isInternalLibrary(lib ExternalLibrary) : boolean in class com.oracle.truffle.llvm.runtime.LLVMContext</description><code_before>@@ -570,8 +570,8 @@ public ExternalLibrary addExternalLibraryDefaultLocator(String lib, Object reaso
     public ExternalLibrary addExternalLibrary(String lib, Object reason, LibraryLocator locator) {
         CompilerAsserts.neverPartOfCompilation();
         ExternalLibrary newLib = createExternalLibrary(lib, reason, locator);
-        if (isInternalLibrary(newLib)) {
-            // Disallow loading internal libraries explicitly.
             return null;
         }
         ExternalLibrary existingLib = getOrAddExternalLibrary(newLib);
@@ -616,8 +616,8 @@ private ExternalLibrary createExternalLibrary(String lib, Object reason, Library
      */
     public boolean ensureExternalLibraryAdded(ExternalLibrary newLib) {
         CompilerAsserts.neverPartOfCompilation();
-        if (isInternalLibrary(newLib)) {
-            // Disallow loading internal libraries explicitly.
             return false;
         }
         ExternalLibrary existingLib = getOrAddExternalLibrary(newLib);
@@ -635,6 +635,10 @@ public boolean isInternalLibrary(ExternalLibrary lib) {
         if (lib.getPath() != null) {
             return isInternalLibraryPath(lib.getPath());
         }
         return internalLibraryNames.contains(lib.getName());
     }
 
</code_before><code_after>@@ -570,8 +570,8 @@ public ExternalLibrary addExternalLibraryDefaultLocator(String lib, Object reaso
     public ExternalLibrary addExternalLibrary(String lib, Object reason, LibraryLocator locator) {
         CompilerAsserts.neverPartOfCompilation();
         ExternalLibrary newLib = createExternalLibrary(lib, reason, locator);
+        if (isDefaultLibrary(newLib)) {
+            // Disallow loading default libraries explicitly.
             return null;
         }
         ExternalLibrary existingLib = getOrAddExternalLibrary(newLib);
@@ -616,8 +616,8 @@ private ExternalLibrary createExternalLibrary(String lib, Object reason, Library
      */
     public boolean ensureExternalLibraryAdded(ExternalLibrary newLib) {
         CompilerAsserts.neverPartOfCompilation();
+        if (isDefaultLibrary(newLib)) {
+            // Disallow loading default libraries explicitly.
             return false;
         }
         ExternalLibrary existingLib = getOrAddExternalLibrary(newLib);
@@ -635,6 +635,10 @@ public boolean isInternalLibrary(ExternalLibrary lib) {
         if (lib.getPath() != null) {
             return isInternalLibraryPath(lib.getPath());
         }
+        return isDefaultLibrary(lib);
+    }
+
+    private boolean isDefaultLibrary(ExternalLibrary lib) {
         return internalLibraryNames.contains(lib.getName());
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>107111</refactoring_id><commit_sha>7a453643ad382ba036e3ae49a061dc98b035e0e1</commit_sha><commit_link>https://github.com/metersphere/metersphere/commit/7a453643ad382ba036e3ae49a061dc98b035e0e1</commit_link><file_path>backend/services/project-management/src/main/java/io/metersphere/project/api/processor/ScriptProcessor.java</file_path><description>Extract Method public isEnableCommonScript() : boolean extracted from public isValid() : boolean in class io.metersphere.project.api.processor.ScriptProcessor</description><code_before>@@ -2,16 +2,15 @@
 
 import com.fasterxml.jackson.annotation.JsonTypeName;
 import io.metersphere.project.constants.ScriptLanguageType;
-import io.metersphere.project.api.KeyValueParam;
 import io.metersphere.system.valid.EnumValue;
 import jakarta.validation.Valid;
 import jakarta.validation.constraints.Size;
 import lombok.Data;
 import org.apache.commons.lang3.BooleanUtils;
 import org.apache.commons.lang3.StringUtils;
 
-import java.util.List;
-
 
 /**
  * @Author: jianxing
@@ -29,6 +28,7 @@ public class ScriptProcessor extends MsProcessor {
      * {@link ScriptLanguageType}
      */
     @Size(max = 20)
     @EnumValue(enumClass = ScriptLanguageType.class)
     private String scriptLanguage;
     /**
@@ -38,20 +38,22 @@ public class ScriptProcessor extends MsProcessor {
      */
     private Boolean enableCommonScript = false;
     /**
-     * &#x516C;&#x5171;&#x811A;&#x672C;ID
-     */
-    @Size(max = 50)
-    private String scriptId;
-    /**
-     * &#x516C;&#x5171;&#x811A;&#x672C;&#x5165;&#x53C2;
      */
     @Valid
-    private List&lt;KeyValueParam&gt; params;
 
     public boolean isValid() {
-        if (BooleanUtils.isTrue(enableCommonScript) &amp;&amp; StringUtils.isBlank(scriptId)) {
-            return false;
         }
-        return StringUtils.isNotBlank(script);
     }
 }
</code_before><code_after>@@ -2,16 +2,15 @@
 
 import com.fasterxml.jackson.annotation.JsonTypeName;
 import io.metersphere.project.constants.ScriptLanguageType;
+import io.metersphere.project.dto.CommonScriptInfo;
 import io.metersphere.system.valid.EnumValue;
 import jakarta.validation.Valid;
+import jakarta.validation.constraints.NotBlank;
 import jakarta.validation.constraints.Size;
 import lombok.Data;
 import org.apache.commons.lang3.BooleanUtils;
 import org.apache.commons.lang3.StringUtils;
 
 
 /**
  * @Author: jianxing
@@ -29,6 +28,7 @@ public class ScriptProcessor extends MsProcessor {
      * {@link ScriptLanguageType}
      */
     @Size(max = 20)
+    @NotBlank
     @EnumValue(enumClass = ScriptLanguageType.class)
     private String scriptLanguage;
     /**
@@ -38,20 +38,22 @@ public class ScriptProcessor extends MsProcessor {
      */
     private Boolean enableCommonScript = false;
     /**
+     * &#x516C;&#x5171;&#x811A;&#x672C;&#x4FE1;&#x606F;
+     * {@link CommonScriptInfo}
      */
     @Valid
+    private CommonScriptInfo commonScriptInfo;
+
 
     public boolean isValid() {
+        if (isEnableCommonScript()) {
+            return commonScriptInfo != null &amp;&amp; StringUtils.isNotBlank(commonScriptInfo.getId());
+        } else {
+            return StringUtils.isNotBlank(script);
         }
+    }
+
+    public boolean isEnableCommonScript() {
+        return BooleanUtils.isTrue(enableCommonScript);
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>36639</refactoring_id><commit_sha>b2e4043be53f3162a87964274de660a7e8f56666</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/b2e4043be53f3162a87964274de660a7e8f56666</commit_link><file_path>OsmAnd/src/net/osmand/plus/myplaces/tracks/dialogs/TrackFolderFragment.java</file_path><description>Extract Method private isRootFolder() : boolean extracted from private onBackPressed() : void in class net.osmand.plus.myplaces.tracks.dialogs.TrackFolderFragment</description><code_before>@@ -52,6 +52,11 @@ public String getFragmentTag() {
 		return TAG;
 	}
 
 	@Override
 	public void onCreate(@Nullable Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
@@ -104,18 +109,27 @@ public boolean onOptionsItemSelected(MenuItem item) {
 			FragmentActivity activity = getActivity();
 			if (activity != null) {
 				FragmentManager manager = activity.getSupportFragmentManager();
-				SearchMyPlacesTracksFragment.showInstance(manager, getTargetFragment(), false, isUsedOnMap());
 				return true;
 			}
 		}
 		if (itemId == R.id.action_folder_menu) {
-			FragmentActivity activity = getActivity();
-			TrackFoldersHelper foldersHelper = getTrackFoldersHelper();
-			if (foldersHelper != null &amp;&amp; activity != null) {
-				View view = activity.findViewById(R.id.action_folder_menu);
-				foldersHelper.showFolderOptionsMenu(selectedFolder, view, this);
-				return true;
-			}
 		}
 		return false;
 	}
@@ -127,23 +141,31 @@ public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflat
 		requireMyActivity().setToolbarVisibility(false);
 	}
 
-	private void onBackPressed() {
-		if (rootFolder.equals(selectedFolder)) {
 			dismiss();
 		} else {
 			selectedFolder = selectedFolder.getParentFolder();
 			updateContent();
 		}
 	}
 
 	@Override
 	public void updateContent() {
 		super.updateContent();
 
 		MyPlacesActivity activity = getMyActivity();
 		ActionBar actionBar = activity != null ? activity.getSupportActionBar() : null;
 		if (actionBar != null) {
-			actionBar.setTitle(selectedFolder.getName(app));
 		}
 	}
 
@@ -195,9 +217,14 @@ public void onTracksGroupLongClick(@NonNull View view, @NonNull TracksGroup grou
 	private void showTracksSelection(@Nullable TrackItem trackItem, @Nullable TracksGroup tracksGroup) {
 		TrackFoldersHelper foldersHelper = getTrackFoldersHelper();
 		if (foldersHelper != null) {
-			Set&lt;TrackItem&gt; trackItems = trackItem != null ? Collections.singleton(trackItem) : null;
-			Set&lt;TracksGroup&gt; tracksGroups = tracksGroup != null ? Collections.singleton(tracksGroup) : null;
-			foldersHelper.showTracksSelection(selectedFolder, this, trackItems, tracksGroups);
 		}
 	}
 
@@ -213,7 +240,7 @@ public void onTracksGroupSelected(@NonNull TracksGroup group, boolean selected)
 	public void restoreState(Bundle bundle) {
 		super.restoreState(bundle);
 
-		if (!Algorithms.isEmpty(selectedItemPath)) {
 			TrackItem trackItem = geTrackItem(rootFolder, selectedItemPath);
 			if (trackItem != null) {
 				int index = adapter.getItemPosition(trackItem);
</code_before><code_after>@@ -52,6 +52,11 @@ public String getFragmentTag() {
 		return TAG;
 	}
 
+	@NonNull
+	protected TracksGroup getCurrentTrackGroup() {
+		return selectedFolder;
+	}
+
 	@Override
 	public void onCreate(@Nullable Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
@@ -104,18 +109,27 @@ public boolean onOptionsItemSelected(MenuItem item) {
 			FragmentActivity activity = getActivity();
 			if (activity != null) {
 				FragmentManager manager = activity.getSupportFragmentManager();
+				SearchMyPlacesTracksFragment.showInstance(manager,
+						getTargetFragment(),
+						false,
+						isUsedOnMap(),
+						null);
 				return true;
 			}
 		}
 		if (itemId == R.id.action_folder_menu) {
+			if (showFolderOptionMenu()) return true;
+		}
+		return false;
+	}
+
+	protected boolean showFolderOptionMenu() {
+		FragmentActivity activity = getActivity();
+		TrackFoldersHelper foldersHelper = getTrackFoldersHelper();
+		if (foldersHelper != null &amp;&amp; activity != null) {
+			View view = activity.findViewById(R.id.action_folder_menu);
+			foldersHelper.showFolderOptionsMenu(selectedFolder, view, this, isRootFolder());
+			return true;
 		}
 		return false;
 	}
@@ -127,23 +141,31 @@ public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflat
 		requireMyActivity().setToolbarVisibility(false);
 	}
 
+	protected void onBackPressed() {
+		if (isRootFolder()) {
 			dismiss();
+			updateTitle();
 		} else {
 			selectedFolder = selectedFolder.getParentFolder();
 			updateContent();
 		}
 	}
 
+	private boolean isRootFolder() {
+		return rootFolder.equals(selectedFolder);
+	}
+
 	@Override
 	public void updateContent() {
 		super.updateContent();
+		updateTitle();
+	}
 
+	private void updateTitle() {
 		MyPlacesActivity activity = getMyActivity();
 		ActionBar actionBar = activity != null ? activity.getSupportActionBar() : null;
 		if (actionBar != null) {
+			actionBar.setTitle(getCurrentTrackGroup().getName(app));
 		}
 	}
 
@@ -195,9 +217,14 @@ public void onTracksGroupLongClick(@NonNull View view, @NonNull TracksGroup grou
 	private void showTracksSelection(@Nullable TrackItem trackItem, @Nullable TracksGroup tracksGroup) {
 		TrackFoldersHelper foldersHelper = getTrackFoldersHelper();
 		if (foldersHelper != null) {
+			if (selectedFolder != null &amp;&amp; selectedFolder instanceof TrackFolder) {
+				Set&lt;TrackItem&gt; trackItems = trackItem != null ? Collections.singleton(trackItem) : null;
+				Set&lt;TracksGroup&gt; tracksGroups = tracksGroup != null ? Collections.singleton(tracksGroup) : null;
+				foldersHelper.showTracksSelection(selectedFolder, this, trackItems, tracksGroups);
+			} else if (smartFolder != null) {
+				Set&lt;TrackItem&gt; trackItems = trackItem != null ? Collections.singleton(trackItem) : null;
+				foldersHelper.showTracksSelection(smartFolder, this, trackItems, null);
+			}
 		}
 	}
 
@@ -213,7 +240,7 @@ public void onTracksGroupSelected(@NonNull TracksGroup group, boolean selected)
 	public void restoreState(Bundle bundle) {
 		super.restoreState(bundle);
 
+		if (rootFolder != null &amp;&amp; !Algorithms.isEmpty(selectedItemPath)) {
 			TrackItem trackItem = geTrackItem(rootFolder, selectedItemPath);
 			if (trackItem != null) {
 				int index = adapter.getItemPosition(trackItem);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>68426</refactoring_id><commit_sha>fd37039ca3c6ca7073bcb0e0dfef3a8b69302c1f</commit_sha><commit_link>https://github.com/apache/jena/commit/fd37039ca3c6ca7073bcb0e0dfef3a8b69302c1f</commit_link><file_path>jena-core/src/main/java/org/apache/jena/rdfxml/xmlinput/states/WantPropertyElement.java</file_path><description>Extract Method package makeRDF_i(i int) : URIReference extracted from private rdf_n(i int) : URIReference in class org.apache.jena.rdfxml.xmlinput.states.WantPropertyElement</description><code_before>@@ -108,7 +108,7 @@ public FrameI startElement(String uri, String localName, String rawName,
                 if (object != null) {
                     if (!badStateCode(nextStateCode))
                         // otherwise warning already given
-                        warning(ERR_SYNTAX_ERROR, 
                                 "On a property element, only one of the attributes rdf:nodeID or rdf:resource is permitted.");
                 } else
                     object = URIReference.resolve(this, x, ap.resource);
@@ -223,25 +223,47 @@ private void clearObject() {
         object = null;
     }
 
-    static private URIReference _rdf_n[] = new URIReference[0];
 
     static private URIReference rdf_n(int i) {
-        if (i &gt;= _rdf_n.length) {
-            int newLength = (i + 10) * 3 / 2;
-            URIReference new_rdf_n[] = new URIReference[newLength];
-            System.arraycopy(_rdf_n, 0, new_rdf_n, 0, _rdf_n.length);
-            for (int j = _rdf_n.length; j &lt; newLength; j++) {
-                new_rdf_n[j] = URIReference.createNoChecks(rdfns + "_" + j);
-            }
-            _rdf_n = new_rdf_n;
-        }
-        return _rdf_n[i];
     }
 
     /***************************************************************************
-     * 
      * ERROR HANDLING CODE
-     * 
      **************************************************************************/
 
     // Error detection
@@ -269,9 +291,9 @@ private int errorNumber(int nextStateCode) {
     }
 
     /***************************************************************************
-     * 
      * ERROR MESSAGES
-     * 
      **************************************************************************/
    private String descriptionOfCases(AttributeLexer ap, int nextStateCode,
             String propAttrs) {
@@ -369,14 +391,14 @@ private String complicatedErrorMessage(int nextStateCode,
         if (ap.type != null &amp;&amp; propAttrs != null) {
             if (nodeIDResource == null)
                 otherAtts += "the attribute rdf:type and the " + propAttrs;
-            else 
                 otherAtts += "the attribute rdf:type, the " + propAttrs;
         } else if (ap.type != null) {
             otherAtts += "the attribute rdf:type";
         } else {
             otherAtts = "the " + propAttrs;
         }
-        
         if (nodeIDResource != null)
             otherAtts += " and "+nodeIDResource;
 
</code_before><code_after>@@ -108,7 +108,7 @@ public FrameI startElement(String uri, String localName, String rawName,
                 if (object != null) {
                     if (!badStateCode(nextStateCode))
                         // otherwise warning already given
+                        warning(ERR_SYNTAX_ERROR,
                                 "On a property element, only one of the attributes rdf:nodeID or rdf:resource is permitted.");
                 } else
                     object = URIReference.resolve(this, x, ap.resource);
@@ -223,25 +223,47 @@ private void clearObject() {
         object = null;
     }
 
+    // Allocate the first 20 rdf:_i ; calculate at run time any others.
+    static private final int RDF_N = 20;
+    static private URIReference _rdf_n_uri[] = new URIReference[RDF_N];
+    static {
+        for ( int i = 0 ; i &lt; RDF_N; i++) {
+            _rdf_n_uri[i] = makeRDF_i(i);
+        }
+    }
 
     static private URIReference rdf_n(int i) {
+        if ( i &lt; 0 )
+            throw new IllegalStateException("Negative rdf:_i");
+        if (i &lt; _rdf_n_uri.length)
+            return _rdf_n_uri[i];
+        return makeRDF_i(i);
     }
 
+    static URIReference makeRDF_i(int i) {
+        return URIReference.createNoChecks(rdfns + "_" + i);
+    }
+
+    // Not thread safe. JENA-2172
+//    static private URIReference _rdf_n[] = new URIReference[0];
+//
+//    static private URIReference rdf_n(int i) {
+//        if (i &gt;= _rdf_n.length) {
+//            int newLength = (i + 10) * 3 / 2;
+//            URIReference new_rdf_n[] = new URIReference[newLength];
+//            System.arraycopy(_rdf_n, 0, new_rdf_n, 0, _rdf_n.length);
+//            for (int j = _rdf_n.length; j &lt; newLength; j++) {
+//                new_rdf_n[j] = URIReference.createNoChecks(rdfns + "_" + j);
+//            }
+//            _rdf_n = new_rdf_n;
+//        }
+//        return _rdf_n[i];
+//    }
+
     /***************************************************************************
+     *
      * ERROR HANDLING CODE
+     *
      **************************************************************************/
 
     // Error detection
@@ -269,9 +291,9 @@ private int errorNumber(int nextStateCode) {
     }
 
     /***************************************************************************
+     *
      * ERROR MESSAGES
+     *
      **************************************************************************/
    private String descriptionOfCases(AttributeLexer ap, int nextStateCode,
             String propAttrs) {
@@ -369,14 +391,14 @@ private String complicatedErrorMessage(int nextStateCode,
         if (ap.type != null &amp;&amp; propAttrs != null) {
             if (nodeIDResource == null)
                 otherAtts += "the attribute rdf:type and the " + propAttrs;
+            else
                 otherAtts += "the attribute rdf:type, the " + propAttrs;
         } else if (ap.type != null) {
             otherAtts += "the attribute rdf:type";
         } else {
             otherAtts = "the " + propAttrs;
         }
+
         if (nodeIDResource != null)
             otherAtts += " and "+nodeIDResource;
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>95740</refactoring_id><commit_sha>afc3031513feb77fc7a239fbf333de975dfa1f4f</commit_sha><commit_link>https://github.com/apache/cassandra/commit/afc3031513feb77fc7a239fbf333de975dfa1f4f</commit_link><file_path>src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java</file_path><description>Extract Method private read(sstable SSTableReader, file FileDataInput) : void extracted from public SSTableNamesIterator(sstable SSTableReader, file FileDataInput, key DecoratedKey, columnNames SortedSet&lt;byte[]&gt;) in class org.apache.cassandra.db.columniterator.SSTableNamesIterator</description><code_before>@@ -46,85 +46,91 @@ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement
     private ColumnFamily cf;
     private Iterator&lt;IColumn&gt; iter;
     public final SortedSet&lt;byte[]&gt; columns;
-    public final DecoratedKey decoratedKey;
 
-    public SSTableNamesIterator(SSTableReader ssTable, DecoratedKey key, SortedSet&lt;byte[]&gt; columnNames)
     {
-        this (ssTable, null, key, columnNames);
-    }
 
-    public SSTableNamesIterator(SSTableReader sstable, FileDataInput file, DecoratedKey key, SortedSet&lt;byte[]&gt; columnNames)
-    {
-        boolean closeFileWhenDone = file == null;
-        
         try
         {
-            assert columnNames != null;
-
-            this.columns = columnNames;
-            this.decoratedKey = key;
-
-            // open the sstable file, if we don't have one passed to use from range scan
-            if (file == null)
             {
-                file = sstable.getFileDataInput(decoratedKey, DatabaseDescriptor.getIndexedReadBufferSizeInKB() * 1024);
-                if (file == null)
-                    return;
-                DecoratedKey keyInDisk = SSTableReader.decodeKey(sstable.getPartitioner(),
-                                                                 sstable.getDescriptor(),
-                                                                 FBUtilities.readShortByteArray(file));
-                assert keyInDisk.equals(decoratedKey)
-                       : String.format("%s != %s in %s", keyInDisk, decoratedKey, file.getPath());
-                SSTableReader.readRowSize(file, sstable.getDescriptor());
             }
-
-            // read the requested columns into `cf`
-            /* Read the bloom filter summarizing the columns */
-            BloomFilter bf = IndexHelper.defreezeBloomFilter(file);
-            List&lt;IndexHelper.IndexInfo&gt; indexList = IndexHelper.deserializeIndex(file);
-
-            // we can stop early if bloom filter says none of the columns actually exist -- but,
-            // we can't stop before initializing the cf above, in case there's a relevant tombstone
-            cf = ColumnFamily.serializer().deserializeFromSSTableNoColumns(sstable.createColumnFamily(), file);
-
-            List&lt;byte[]&gt; filteredColumnNames1 = new ArrayList&lt;byte[]&gt;(columnNames.size());
-            for (byte[] name : columnNames)
             {
-                if (bf.isPresent(name))
-                {
-                    filteredColumnNames1.add(name);
-                }
             }
-            List&lt;byte[]&gt; filteredColumnNames = filteredColumnNames1;
-            if (filteredColumnNames.isEmpty())
-                return;
 
-            if (indexList == null)
-                readSimpleColumns(file, columnNames, filteredColumnNames);
-            else
-                readIndexedColumns(sstable, file, columnNames, filteredColumnNames, indexList);
 
-            // create an iterator view of the columns we read
-            iter = cf.getSortedColumns().iterator();
         }
         catch (IOException ioe)
         {
             throw new IOError(ioe);
         }
-        finally
         {
-            if (closeFileWhenDone &amp;&amp; file != null)
             {
-                try
-                {
-                    file.close();
-                }
-                catch (IOException ioe)
-                {
-                    logger.warn("error closing " + file.getPath());
-                }
             }
         }
     }
 
     private void readSimpleColumns(FileDataInput file, SortedSet&lt;byte[]&gt; columnNames, List&lt;byte[]&gt; filteredColumnNames) throws IOException
@@ -183,7 +189,7 @@ private void readIndexedColumns(SSTableReader sstable, FileDataInput file, Sorte
 
     public DecoratedKey getKey()
     {
-        return decoratedKey;
     }
 
     public ColumnFamily getColumnFamily()
</code_before><code_after>@@ -46,85 +46,91 @@ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement
     private ColumnFamily cf;
     private Iterator&lt;IColumn&gt; iter;
     public final SortedSet&lt;byte[]&gt; columns;
+    public final DecoratedKey key;
 
+    public SSTableNamesIterator(SSTableReader sstable, DecoratedKey key, SortedSet&lt;byte[]&gt; columns)
     {
+        assert columns != null;
+        this.columns = columns;
+        this.key = key;
+
+        FileDataInput file = sstable.getFileDataInput(key, DatabaseDescriptor.getIndexedReadBufferSizeInKB() * 1024);
+        if (file == null)
+            return;
 
         try
         {
+            DecoratedKey keyInDisk = SSTableReader.decodeKey(sstable.getPartitioner(),
+                                                             sstable.getDescriptor(),
+                                                             FBUtilities.readShortByteArray(file));
+            assert keyInDisk.equals(key) : String.format("%s != %s in %s", keyInDisk, key, file.getPath());
+            SSTableReader.readRowSize(file, sstable.getDescriptor());
+            read(sstable, file);
+        }
+        catch (IOException e)
+        {
+            throw new IOError(e);
+        }
+        finally
+        {
+            try
             {
+                file.close();
             }
+            catch (IOException ioe)
             {
+                logger.warn("error closing " + file.getPath());
             }
+        }
+    }
 
+    public SSTableNamesIterator(SSTableReader sstable, FileDataInput file, DecoratedKey key, SortedSet&lt;byte[]&gt; columns)
+    {
+        assert columns != null;
+        this.columns = columns;
+        this.key = key;
 
+        try
+        {
+            read(sstable, file);
         }
         catch (IOException ioe)
         {
             throw new IOError(ioe);
         }
+    }
+
+    private void read(SSTableReader sstable, FileDataInput file)
+    throws IOException
+    {
+
+        // read the requested columns into `cf`
+        /* Read the bloom filter summarizing the columns */
+        BloomFilter bf = IndexHelper.defreezeBloomFilter(file);
+        List&lt;IndexHelper.IndexInfo&gt; indexList = IndexHelper.deserializeIndex(file);
+
+        // we can stop early if bloom filter says none of the columns actually exist -- but,
+        // we can't stop before initializing the cf above, in case there's a relevant tombstone
+        cf = ColumnFamily.serializer().deserializeFromSSTableNoColumns(sstable.createColumnFamily(), file);
+
+        List&lt;byte[]&gt; filteredColumnNames = new ArrayList&lt;byte[]&gt;(columns.size());
+        for (byte[] name : columns)
         {
+            if (bf.isPresent(name))
             {
+                filteredColumnNames.add(name);
             }
         }
+        if (filteredColumnNames.isEmpty())
+            return;
+
+        if (indexList == null)
+            readSimpleColumns(file, columns, filteredColumnNames);
+        else
+            readIndexedColumns(sstable, file, columns, filteredColumnNames, indexList);
+
+        // create an iterator view of the columns we read
+        iter = cf.getSortedColumns().iterator();
     }
 
     private void readSimpleColumns(FileDataInput file, SortedSet&lt;byte[]&gt; columnNames, List&lt;byte[]&gt; filteredColumnNames) throws IOException
@@ -183,7 +189,7 @@ private void readIndexedColumns(SSTableReader sstable, FileDataInput file, Sorte
 
     public DecoratedKey getKey()
     {
+        return key;
     }
 
     public ColumnFamily getColumnFamily()
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>28458</refactoring_id><commit_sha>28fd4cceac93ccb2a3652ec143e865f97750c278</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/28fd4cceac93ccb2a3652ec143e865f97750c278</commit_link><file_path>jetty-client/src/main/java/org/eclipse/jetty/client/util/InputStreamContentProvider.java</file_path><description>Extract Method protected onRead(buffer byte[], offset int, length int) : ByteBuffer extracted from public iterator() : Iterator&lt;ByteBuffer&gt; in class org.eclipse.jetty.client.util.InputStreamContentProvider</description><code_before>@@ -49,6 +49,13 @@ public long getLength()
         return -1;
     }
 
     @Override
     public Iterator&lt;ByteBuffer&gt; iterator()
     {
@@ -71,18 +78,18 @@ public ByteBuffer next()
                     int read = stream.read(buffer);
                     if (read &gt; 0)
                     {
-                        return ByteBuffer.wrap(buffer, 0, read);
                     }
                     else if (read &lt; 0)
                     {
                         if (eof)
                             throw new NoSuchElementException();
                         eof = true;
-                        return BufferUtil.EMPTY_BUFFER;
                     }
                     else
                     {
-                        return BufferUtil.EMPTY_BUFFER;
                     }
                 }
                 catch (IOException x)
</code_before><code_after>@@ -49,6 +49,13 @@ public long getLength()
         return -1;
     }
 
+    protected ByteBuffer onRead(byte[] buffer, int offset, int length)
+    {
+        if (length &lt;= 0)
+            return BufferUtil.EMPTY_BUFFER;
+        return ByteBuffer.wrap(buffer, offset, length);
+    }
+
     @Override
     public Iterator&lt;ByteBuffer&gt; iterator()
     {
@@ -71,18 +78,18 @@ public ByteBuffer next()
                     int read = stream.read(buffer);
                     if (read &gt; 0)
                     {
+                        return onRead(buffer, 0, read);
                     }
                     else if (read &lt; 0)
                     {
                         if (eof)
                             throw new NoSuchElementException();
                         eof = true;
+                        return onRead(buffer, 0, -1);
                     }
                     else
                     {
+                        return onRead(buffer, 0, 0);
                     }
                 }
                 catch (IOException x)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>48967</refactoring_id><commit_sha>01f5fccf96c320b8780e23dac82f35b477d21389</commit_sha><commit_link>https://github.com/anuken/mindustry/commit/01f5fccf96c320b8780e23dac82f35b477d21389</commit_link><file_path>core/src/io/anuke/mindustry/world/blocks/types/defense/Turret.java</file_path><description>Extract Method public hasAmmo(tile Tile) : boolean extracted from public update(tile Tile) : void in class io.anuke.mindustry.world.blocks.types.defense.Turret</description><code_before>@@ -35,7 +35,7 @@ public class Turret extends Block{
 	protected int ammoMultiplier = 20;
 	protected int maxammo = 400;
 	protected float rotatespeed = 0.2f;
-	protected float shootCone = 2f;
 
 	public Turret(String name) {
 		super(name);
@@ -112,7 +112,7 @@ public void update(Tile tile){
 		if(entity.target != null &amp;&amp; entity.target.isDead())
 			entity.target = null;
 		
-		if(entity.ammo &gt; 0){
 			
 			if(Timers.get(entity, "target", targetInterval)){
 				entity.target = (Enemy)Entities.getClosest(tile.worldx(), tile.worldy(), range, e-&gt;{
@@ -132,12 +132,23 @@ public void update(Tile tile){
 				if(Angles.angleDist(entity.rotation, targetRot) &lt; shootCone &amp;&amp; Timers.get(tile, "reload", reload)){
 					Effects.sound(shootsound, entity);
 					shoot(tile);
 					entity.ammo --;
 				}
 			}
 		}
 	}
 	
 	@Override
 	public TileEntity getEntity(){
 		return new TurretEntity();
</code_before><code_after>@@ -35,7 +35,7 @@ public class Turret extends Block{
 	protected int ammoMultiplier = 20;
 	protected int maxammo = 400;
 	protected float rotatespeed = 0.2f;
+	protected float shootCone = 5f;
 
 	public Turret(String name) {
 		super(name);
@@ -112,7 +112,7 @@ public void update(Tile tile){
 		if(entity.target != null &amp;&amp; entity.target.isDead())
 			entity.target = null;
 		
+		if(hasAmmo(tile)){
 			
 			if(Timers.get(entity, "target", targetInterval)){
 				entity.target = (Enemy)Entities.getClosest(tile.worldx(), tile.worldy(), range, e-&gt;{
@@ -132,12 +132,23 @@ public void update(Tile tile){
 				if(Angles.angleDist(entity.rotation, targetRot) &lt; shootCone &amp;&amp; Timers.get(tile, "reload", reload)){
 					Effects.sound(shootsound, entity);
 					shoot(tile);
+					consumeAmmo(tile);
 					entity.ammo --;
 				}
 			}
 		}
 	}
 	
+	public boolean hasAmmo(Tile tile){
+		TurretEntity entity = tile.entity();
+		return entity.ammo &gt; 0;
+	}
+	
+	public void consumeAmmo(Tile tile){
+		TurretEntity entity = tile.entity();
+		entity.ammo --;
+	}
+	
 	@Override
 	public TileEntity getEntity(){
 		return new TurretEntity();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>74315</refactoring_id><commit_sha>a1f732f6576c663926076acc995a48f962f917d0</commit_sha><commit_link>https://github.com/typetools/checker-framework/commit/a1f732f6576c663926076acc995a48f962f917d0</commit_link><file_path>framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java</file_path><description>Extract Method public processMethodTree(tree MethodTree) : void extracted from public visitMethod(tree MethodTree, p Void) : Void in class org.checkerframework.common.basetype.BaseTypeVisitor</description><code_before>@@ -958,7 +958,23 @@ protected void checkDefaultConstructor(ClassTree tree) {}
    * Also, it issues a "missing.this" error for static method annotated receivers.
    */
   @Override
-  public Void visitMethod(MethodTree tree, Void p) {
     // We copy the result from getAnnotatedType to ensure that circular types (e.g. K extends
     // Comparable&lt;K&gt;) are represented by circular AnnotatedTypeMirrors, which avoids problems
     // with later checks.
@@ -983,7 +999,7 @@ public Void visitMethod(MethodTree tree, Void p) {
     try {
       if (TreeUtils.isAnonymousConstructor(tree)) {
         // We shouldn't dig deeper
-        return null;
       }
 
       if (TreeUtils.isConstructor(tree)) {
@@ -1051,7 +1067,7 @@ public Void visitMethod(MethodTree tree, Void p) {
 
       warnInvalidPolymorphicQualifier(tree.getTypeParameters());
 
-      return super.visitMethod(tree, p);
     } finally {
       methodTree = preMT;
     }
</code_before><code_after>@@ -958,7 +958,23 @@ protected void checkDefaultConstructor(ClassTree tree) {}
    * Also, it issues a "missing.this" error for static method annotated receivers.
    */
   @Override
+  public final Void visitMethod(MethodTree tree, Void p) {
+    ClassTree enclosingClass = TreePathUtil.enclosingClass(getCurrentPath());
+    if (checker.shouldSkipDefs(enclosingClass, tree)) {
+      return null;
+    }
+    processMethodTree(tree);
+    return null;
+  }
+
+  /**
+   * Type-check {@literal methodTree}. Subclasses should override this method instead of {@link
+   * #visitMethod(MethodTree, Void)}.
+   *
+   * @param tree the method to type-check
+   */
+  public void processMethodTree(MethodTree tree) {
+
     // We copy the result from getAnnotatedType to ensure that circular types (e.g. K extends
     // Comparable&lt;K&gt;) are represented by circular AnnotatedTypeMirrors, which avoids problems
     // with later checks.
@@ -983,7 +999,7 @@ public Void visitMethod(MethodTree tree, Void p) {
     try {
       if (TreeUtils.isAnonymousConstructor(tree)) {
         // We shouldn't dig deeper
+        return;
       }
 
       if (TreeUtils.isConstructor(tree)) {
@@ -1051,7 +1067,7 @@ public Void visitMethod(MethodTree tree, Void p) {
 
       warnInvalidPolymorphicQualifier(tree.getTypeParameters());
 
+      super.visitMethod(tree, null);
     } finally {
       methodTree = preMT;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>105558</refactoring_id><commit_sha>91a8db535a911120e698ec310529ddad5656afc4</commit_sha><commit_link>https://github.com/hyphanet/fred/commit/91a8db535a911120e698ec310529ddad5656afc4</commit_link><file_path>src/freenet/node/fcp/FCPServer.java</file_path><description>Extract Method public maybeStart() : void extracted from public FCPServer(ipToBindTo String, allowedHosts String, port int, node Node, persistentDownloadsEnabled boolean, persistentDownloadsDir String, persistenceInterval long, isEnabled boolean) in class freenet.node.fcp.FCPServer</description><code_before>@@ -40,7 +40,7 @@
  */
 public class FCPServer implements Runnable {
 
-	final NetworkInterface networkInterface;
 	final Node node;
 	final int port;
 	public final boolean enabled;
@@ -82,21 +82,24 @@ public FCPServer(String ipToBindTo, String allowedHosts, int port, Node node, bo
 		this.enabled = isEnabled;
 		this.enablePersistentDownloads = persistentDownloadsEnabled;
 		setPersistentDownloadsFile(new File(persistentDownloadsDir));
 		
 		if (this.enabled) {
-			this.node = node;
-			clientsByName = new WeakHashMap();
-			
-			
-			// This one is only used to get the default settings. Individual FCP conns
-			// will make their own.
-			HighLevelSimpleClient client = node.makeClient((short)0);
-			defaultFetchContext = client.getFetcherContext();
-			defaultInsertContext = client.getInserterContext();
-			
-			
-			globalClient = new FCPClient("Global Queue", this, null, true);
-			
 			
 			if(enablePersistentDownloads) {
 				loadPersistentRequests();
@@ -124,12 +127,7 @@ public FCPServer(String ipToBindTo, String allowedHosts, int port, Node node, bo
 			Logger.normal(this, "Not starting FCP server as it's disabled");
 			System.out.println("Not starting FCP server as it's disabled");
 			this.networkInterface = null;
-			this.node = null;
-			this.clientsByName = null;
-			this.globalClient = null;
-			this.defaultFetchContext = null;
 		}
-		
 	}
 	
 	public void run() {
@@ -147,7 +145,8 @@ public void run() {
 	private void realRun() throws IOException {
 		// Accept a connection
 		Socket s = networkInterface.accept();
-		new FCPConnectionHandler(s, this);
 	}
 
 	static class FCPPortNumberCallback implements IntCallback {
@@ -317,6 +316,9 @@ public static FCPServer maybeCreate(Node node, Config config) throws IOException
 		
 	
 		fcpConfig.finishedInitialization();
 		return fcp;
 	}
 
</code_before><code_after>@@ -40,7 +40,7 @@
  */
 public class FCPServer implements Runnable {
 
+	NetworkInterface networkInterface;
 	final Node node;
 	final int port;
 	public final boolean enabled;
@@ -82,21 +82,24 @@ public FCPServer(String ipToBindTo, String allowedHosts, int port, Node node, bo
 		this.enabled = isEnabled;
 		this.enablePersistentDownloads = persistentDownloadsEnabled;
 		setPersistentDownloadsFile(new File(persistentDownloadsDir));
+		this.node = node;
+		clientsByName = new WeakHashMap();
 		
+		
+		// This one is only used to get the default settings. Individual FCP conns
+		// will make their own.
+		HighLevelSimpleClient client = node.makeClient((short)0);
+		defaultFetchContext = client.getFetcherContext();
+		defaultInsertContext = client.getInserterContext();
+		
+		
+		globalClient = new FCPClient("Global Queue", this, null, true);
+		
+		
+	}
+	
+	public void maybeStart() throws IOException, InvalidConfigValueException {
 		if (this.enabled) {
 			
 			if(enablePersistentDownloads) {
 				loadPersistentRequests();
@@ -124,12 +127,7 @@ public FCPServer(String ipToBindTo, String allowedHosts, int port, Node node, bo
 			Logger.normal(this, "Not starting FCP server as it's disabled");
 			System.out.println("Not starting FCP server as it's disabled");
 			this.networkInterface = null;
 		}
 	}
 	
 	public void run() {
@@ -147,7 +145,8 @@ public void run() {
 	private void realRun() throws IOException {
 		// Accept a connection
 		Socket s = networkInterface.accept();
+		FCPConnectionHandler ch = new FCPConnectionHandler(s, this);
+		ch.start();
 	}
 
 	static class FCPPortNumberCallback implements IntCallback {
@@ -317,6 +316,9 @@ public static FCPServer maybeCreate(Node node, Config config) throws IOException
 		
 	
 		fcpConfig.finishedInitialization();
+		if(fcp != null)
+			fcp.maybeStart();
+
 		return fcp;
 	}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>114557</refactoring_id><commit_sha>a60de4688e1d92eea3b612d6c89345518ea6f6b2</commit_sha><commit_link>https://github.com/cloudfoundry/uaa/commit/a60de4688e1d92eea3b612d6c89345518ea6f6b2</commit_link><file_path>uaa/src/test/java/org/cloudfoundry/identity/uaa/login/ResetPasswordControllerMockMvcTests.java</file_path><description>Extract Method private createChangePasswordRequest(user ScimUser, code ExpiringCode, useCSRF boolean, password String, passwordConfirmation String) : MockHttpServletRequestBuilder extracted from public testResettingAPasswordUsingTimestampForUserModification() : void in class org.cloudfoundry.identity.uaa.login.ResetPasswordControllerMockMvcTests</description><code_before>@@ -40,8 +40,10 @@
 import static org.junit.Assert.assertThat;
 import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
 import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
 import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.redirectedUrl;
 import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
 
 public class ResetPasswordControllerMockMvcTests extends InjectedMockContextTest {
 
@@ -60,16 +62,9 @@ public void testResettingAPasswordUsingUsernameToEnsureNoModification() throws E
         assertEquals(1, users.size());
         PasswordChange change = new PasswordChange(users.get(0).getId(), users.get(0).getUserName());
 
-        ExpiringCode code = codeStore.generateCode(JsonUtils.writeValueAsString(change), new Timestamp(System.currentTimeMillis()+ UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
-        MockHttpServletRequestBuilder post = post("/reset_password.do")
-            .with(csrf())
-            .param("code", code.getCode())
-            .param("email", users.get(0).getPrimaryEmail())
-            .param("password", "newpassw0rD")
-            .param("password_confirmation", "newpassw0rD");
-
-        MvcResult mvcResult = getMockMvc().perform(post)
             .andExpect(status().isFound())
             .andExpect(redirectedUrl("home"))
             .andReturn();
@@ -100,14 +95,7 @@ public void testResettingAPasswordFailsWhenUsernameChanged() throws Exception {
         user.setUserName("newusername");
         user = userProvisioning.update(user.getId(), user);
         try {
-            MockHttpServletRequestBuilder post = post("/reset_password.do")
-                .with(csrf())
-                .param("code", code.getCode())
-                .param("email", user.getPrimaryEmail())
-                .param("password", "newpassw0rD")
-                .param("password_confirmation", "newpassw0rD");
-
-            getMockMvc().perform(post)
                 .andExpect(status().isUnprocessableEntity());
         } finally {
             user.setUserName(formerUsername);
@@ -122,13 +110,7 @@ public void testResettingAPasswordNoCsrfParameter() throws Exception {
         assertEquals(1, users.size());
         ExpiringCode code = codeStore.generateCode(users.get(0).getId(), new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
-        MockHttpServletRequestBuilder post = post("/reset_password.do")
-            .param("code", code.getCode())
-            .param("email", users.get(0).getPrimaryEmail())
-            .param("password", "newpassw0rDl")
-            .param("password_confirmation", "newpassw0rDl");
-
-        getMockMvc().perform(post)
             .andExpect(status().isFound())
             .andExpect(redirectedUrl("http://localhost/invalid_request"));
     }
@@ -140,12 +122,8 @@ public void testResettingAPasswordUsingTimestampForUserModification() throws Exc
         assertEquals(1, users.size());
         ExpiringCode code = codeStore.generateCode(users.get(0).getId(), new Timestamp(System.currentTimeMillis()+ UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
-        MockHttpServletRequestBuilder post = post("/reset_password.do")
-            .with(csrf())
-            .param("code", code.getCode())
-            .param("email", users.get(0).getPrimaryEmail())
-            .param("password", "newpassw0rDl")
-            .param("password_confirmation", "newpassw0rDl");
 
         MvcResult mvcResult = getMockMvc().perform(post)
             .andExpect(status().isFound())
@@ -171,12 +149,7 @@ public void testResettingAPasswordUsingTimestampUserModified() throws Exception
         ScimUser user = users.get(0);
         ExpiringCode code = codeStore.generateCode(user.getId(), new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
-        MockHttpServletRequestBuilder post = post("/reset_password.do")
-            .with(csrf())
-            .param("code", code.getCode())
-            .param("email", user.getPrimaryEmail())
-            .param("password", "newpassw0rDl")
-            .param("password_confirmation", "newpassw0rDl");
 
         if (Arrays.asList(getWebApplicationContext().getEnvironment().getActiveProfiles()).contains("mysql")) {
             Thread.sleep(1050);
@@ -188,7 +161,39 @@ public void testResettingAPasswordUsingTimestampUserModified() throws Exception
 
         getMockMvc().perform(post)
             .andExpect(status().isUnprocessableEntity());
 
 
     }
 }
</code_before><code_after>@@ -40,8 +40,10 @@
 import static org.junit.Assert.assertThat;
 import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
 import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.model;
 import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.redirectedUrl;
 import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;
 
 public class ResetPasswordControllerMockMvcTests extends InjectedMockContextTest {
 
@@ -60,16 +62,9 @@ public void testResettingAPasswordUsingUsernameToEnsureNoModification() throws E
         assertEquals(1, users.size());
         PasswordChange change = new PasswordChange(users.get(0).getId(), users.get(0).getUserName());
 
+        ExpiringCode code = codeStore.generateCode(JsonUtils.writeValueAsString(change), new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
+        MvcResult mvcResult = getMockMvc().perform(createChangePasswordRequest(users.get(0), code, true))
             .andExpect(status().isFound())
             .andExpect(redirectedUrl("home"))
             .andReturn();
@@ -100,14 +95,7 @@ public void testResettingAPasswordFailsWhenUsernameChanged() throws Exception {
         user.setUserName("newusername");
         user = userProvisioning.update(user.getId(), user);
         try {
+            getMockMvc().perform(createChangePasswordRequest(users.get(0), code, true))
                 .andExpect(status().isUnprocessableEntity());
         } finally {
             user.setUserName(formerUsername);
@@ -122,13 +110,7 @@ public void testResettingAPasswordNoCsrfParameter() throws Exception {
         assertEquals(1, users.size());
         ExpiringCode code = codeStore.generateCode(users.get(0).getId(), new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
+        getMockMvc().perform(createChangePasswordRequest(users.get(0), code, false))
             .andExpect(status().isFound())
             .andExpect(redirectedUrl("http://localhost/invalid_request"));
     }
@@ -140,12 +122,8 @@ public void testResettingAPasswordUsingTimestampForUserModification() throws Exc
         assertEquals(1, users.size());
         ExpiringCode code = codeStore.generateCode(users.get(0).getId(), new Timestamp(System.currentTimeMillis()+ UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
+        MockHttpServletRequestBuilder post = createChangePasswordRequest(users.get(0), code,
+            true, "newpassw0rD", "newpassw0rD");
 
         MvcResult mvcResult = getMockMvc().perform(post)
             .andExpect(status().isFound())
@@ -171,12 +149,7 @@ public void testResettingAPasswordUsingTimestampUserModified() throws Exception
         ScimUser user = users.get(0);
         ExpiringCode code = codeStore.generateCode(user.getId(), new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
 
+        MockHttpServletRequestBuilder post = createChangePasswordRequest(user, code, true);
 
         if (Arrays.asList(getWebApplicationContext().getEnvironment().getActiveProfiles()).contains("mysql")) {
             Thread.sleep(1050);
@@ -188,7 +161,39 @@ public void testResettingAPasswordUsingTimestampUserModified() throws Exception
 
         getMockMvc().perform(post)
             .andExpect(status().isUnprocessableEntity());
+    }
+
+    @Test
+    public void resetPassword_ReturnsUnprocessableEntity_NewPasswordSameAsOld() throws Exception {
+        ScimUserProvisioning userProvisioning = getWebApplicationContext().getBean(ScimUserProvisioning.class);
+        List&lt;ScimUser&gt; users = userProvisioning.query("username eq \"marissa\"");
+        assertNotNull(users);
+        assertEquals(1, users.size());
+        ScimUser user = users.get(0);
+
+        ExpiringCode code = codeStore.generateCode(user.getId(), new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
+        getMockMvc().perform(createChangePasswordRequest(user, code, true, "d3faultPasswd", "d3faultPasswd"));
 
+        code = codeStore.generateCode(user.getId(), new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME));
+        getMockMvc().perform(createChangePasswordRequest(user, code, true, "d3faultPasswd", "d3faultPasswd"))
+            .andExpect(status().isUnprocessableEntity())
+            .andExpect(view().name("forgot_password"))
+            .andExpect(model().attribute("message", "Your new password cannot be the same as the old password."));
+    }
+
+    private MockHttpServletRequestBuilder createChangePasswordRequest(ScimUser user, ExpiringCode code, boolean useCSRF) throws Exception {
+        return createChangePasswordRequest(user, code, useCSRF, "newpassw0rDl", "newpassw0rDl");
+    }
 
+    private MockHttpServletRequestBuilder createChangePasswordRequest(ScimUser user, ExpiringCode code, boolean useCSRF, String password, String passwordConfirmation) throws Exception {
+        MockHttpServletRequestBuilder post = post("/reset_password.do");
+        if (useCSRF) {
+            post.with(csrf());
+        }
+        post.param("code", code.getCode())
+            .param("email", user.getPrimaryEmail())
+            .param("password", password)
+            .param("password_confirmation", passwordConfirmation);
+        return post;
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>117908</refactoring_id><commit_sha>00d703d44c1b20efdbe7722873f6e216a8ef2dd3</commit_sha><commit_link>https://github.com/StarRocks/starrocks/commit/00d703d44c1b20efdbe7722873f6e216a8ef2dd3</commit_link><file_path>fe/fe-core/src/main/java/com/starrocks/sql/optimizer/OutputPropertyDeriver.java</file_path><description>Extract Method public visitPhysicalJoin(node PhysicalJoinOperator, context ExpressionContext) : PhysicalPropertySet extracted from public visitPhysicalHashJoin(node PhysicalHashJoinOperator, context ExpressionContext) : PhysicalPropertySet in class com.starrocks.sql.optimizer.OutputPropertyDeriver</description><code_before>@@ -25,7 +25,9 @@
 import com.starrocks.sql.optimizer.operator.physical.PhysicalFilterOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalHashAggregateOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalHashJoinOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalLimitOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalNoCTEOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalOlapScanOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalProjectOperator;
@@ -105,7 +107,7 @@ private PhysicalPropertySet computeColocateJoinOutputProperty(HashDistributionSp
     }
 
     // compute the distribution property info, just compute the nullable columns now
-    private PhysicalPropertySet computeHashJoinDistributionPropertyInfo(PhysicalHashJoinOperator node,
                                                                         PhysicalPropertySet physicalPropertySet,
                                                                         List&lt;Integer&gt; leftOnPredicateColumns,
                                                                         List&lt;Integer&gt; rightOnPredicateColumns,
@@ -137,6 +139,15 @@ private PhysicalPropertySet computeHashJoinDistributionPropertyInfo(PhysicalHash
 
     @Override
     public PhysicalPropertySet visitPhysicalHashJoin(PhysicalHashJoinOperator node, ExpressionContext context) {
         Preconditions.checkState(childrenOutputProperties.size() == 2);
         PhysicalPropertySet leftChildOutputProperty = childrenOutputProperties.get(0);
         PhysicalPropertySet rightChildOutputProperty = childrenOutputProperties.get(1);
</code_before><code_after>@@ -25,7 +25,9 @@
 import com.starrocks.sql.optimizer.operator.physical.PhysicalFilterOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalHashAggregateOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalHashJoinOperator;
+import com.starrocks.sql.optimizer.operator.physical.PhysicalJoinOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalLimitOperator;
+import com.starrocks.sql.optimizer.operator.physical.PhysicalMergeJoinOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalNoCTEOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalOlapScanOperator;
 import com.starrocks.sql.optimizer.operator.physical.PhysicalProjectOperator;
@@ -105,7 +107,7 @@ private PhysicalPropertySet computeColocateJoinOutputProperty(HashDistributionSp
     }
 
     // compute the distribution property info, just compute the nullable columns now
+    private PhysicalPropertySet computeHashJoinDistributionPropertyInfo(PhysicalJoinOperator node,
                                                                         PhysicalPropertySet physicalPropertySet,
                                                                         List&lt;Integer&gt; leftOnPredicateColumns,
                                                                         List&lt;Integer&gt; rightOnPredicateColumns,
@@ -137,6 +139,15 @@ private PhysicalPropertySet computeHashJoinDistributionPropertyInfo(PhysicalHash
 
     @Override
     public PhysicalPropertySet visitPhysicalHashJoin(PhysicalHashJoinOperator node, ExpressionContext context) {
+        return visitPhysicalJoin(node, context);
+    }
+
+    @Override
+    public PhysicalPropertySet visitPhysicalMergeJoin(PhysicalMergeJoinOperator node, ExpressionContext context) {
+        return visitPhysicalJoin(node, context);
+    }
+
+    public PhysicalPropertySet visitPhysicalJoin(PhysicalJoinOperator node, ExpressionContext context) {
         Preconditions.checkState(childrenOutputProperties.size() == 2);
         PhysicalPropertySet leftChildOutputProperty = childrenOutputProperties.get(0);
         PhysicalPropertySet rightChildOutputProperty = childrenOutputProperties.get(1);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>105541</refactoring_id><commit_sha>1b8afc12dc81f35240b4e185c4dc460a63bb5dfd</commit_sha><commit_link>https://github.com/hyphanet/fred/commit/1b8afc12dc81f35240b4e185c4dc460a63bb5dfd</commit_link><file_path>test/freenet/store/CachingFreenetStoreTest.java</file_path><description>Extract Method private checkOnCollisionsSSK(useSlotFilter boolean) : void extracted from public testOnCollisionsSSK() : void in class freenet.store.CachingFreenetStoreTest</description><code_before>@@ -352,9 +352,16 @@ public void testTimeExpireSSK() throws IOException, SSKEncodeException, InvalidC
 		
 		cachingStore.close();
 	}
 	
 	/* Test collisions on SSK */
-	public void testOnCollisionsSSK() throws IOException, SSKEncodeException, InvalidCompressionCodecException, SSKVerifyException, KeyDecodeException, KeyCollisionException {
 		File f = new File(tempDir, "saltstore");
 		FileUtil.removeAll(f);
 
@@ -363,7 +370,7 @@ public void testOnCollisionsSSK() throws IOException, SSKEncodeException, Invali
 		new RAMFreenetStore&lt;DSAPublicKey&gt;(pk, keys);
 		GetPubkey pubkeyCache = new SimpleGetPubkey(pk);
 		SSKStore store = new SSKStore(pubkeyCache);
-		SaltedHashFreenetStore&lt;SSKBlock&gt; saltStore = SaltedHashFreenetStore.construct(f, "testCachingFreenetStoreOnCloseSSK", store, weakPRNG, 10, false, SemiOrderedShutdownHook.get(), true, true, ticker, null);
 		CachingFreenetStore&lt;SSKBlock&gt; cachingStore = new CachingFreenetStore&lt;SSKBlock&gt;(store, cachingFreenetStoreMaxSize, cachingFreenetStorePeriod, saltStore, ticker);
 		cachingStore.start(null, true);
 		RandomSource random = new DummyRandomSource(12345);
</code_before><code_after>@@ -352,9 +352,16 @@ public void testTimeExpireSSK() throws IOException, SSKEncodeException, InvalidC
 		
 		cachingStore.close();
 	}
+
+	public void testOnCollisionsSSK() throws IOException, SSKEncodeException, InvalidCompressionCodecException, SSKVerifyException, KeyDecodeException, KeyCollisionException {
+		// With slot filters turned off, it goes straight to disk, because probablyInStore() always returns true.
+		checkOnCollisionsSSK(false);
+		// With slot filters turned on, it should be cached, it should compare it, and still not throw if it's the same block.
+		checkOnCollisionsSSK(true);
+	}
 	
 	/* Test collisions on SSK */
+	private void checkOnCollisionsSSK(boolean useSlotFilter) throws IOException, SSKEncodeException, InvalidCompressionCodecException, SSKVerifyException, KeyDecodeException, KeyCollisionException {
 		File f = new File(tempDir, "saltstore");
 		FileUtil.removeAll(f);
 
@@ -363,7 +370,7 @@ public void testOnCollisionsSSK() throws IOException, SSKEncodeException, Invali
 		new RAMFreenetStore&lt;DSAPublicKey&gt;(pk, keys);
 		GetPubkey pubkeyCache = new SimpleGetPubkey(pk);
 		SSKStore store = new SSKStore(pubkeyCache);
+		SaltedHashFreenetStore&lt;SSKBlock&gt; saltStore = SaltedHashFreenetStore.construct(f, "testCachingFreenetStoreOnCloseSSK", store, weakPRNG, 10, true, SemiOrderedShutdownHook.get(), true, true, ticker, null);
 		CachingFreenetStore&lt;SSKBlock&gt; cachingStore = new CachingFreenetStore&lt;SSKBlock&gt;(store, cachingFreenetStoreMaxSize, cachingFreenetStorePeriod, saltStore, ticker);
 		cachingStore.start(null, true);
 		RandomSource random = new DummyRandomSource(12345);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>41236</refactoring_id><commit_sha>0b52a94c99c7e624a03381ad22884a002cbb6766</commit_sha><commit_link>https://github.com/pmd/pmd/commit/0b52a94c99c7e624a03381ad22884a002cbb6766</commit_link><file_path>pmd-ui/src/main/java/net/sourceforge/pmd/util/fxdesigner/model/EventLogger.java</file_path><description>Extract Method private filterOnCategory(input EventStream&lt;LogEntry&gt;, complement boolean, first Category, selection Category...) : EventStream&lt;LogEntry&gt; extracted from public EventLogger() in class net.sourceforge.pmd.util.fxdesigner.model.EventLogger</description><code_before>@@ -6,11 +6,15 @@
 
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.PARSE_EXCEPTION;
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.PARSE_OK;
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.XPATH_EVALUATION_EXCEPTION;
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.XPATH_OK;
 
 import java.time.Duration;
 import java.util.EnumSet;
 
 import org.reactfx.EventSource;
 import org.reactfx.EventStream;
@@ -20,7 +24,9 @@
 import org.reactfx.value.Val;
 
 import net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category;
 import net.sourceforge.pmd.util.fxdesigner.util.DesignerUtil;
 
 
 /**
@@ -35,37 +41,52 @@ public class EventLogger {
      * Exceptions from XPath evaluation or parsing are never emitted
      * within less than that time interval to keep them from flooding the tableview.
      */
-    private static final Duration PARSE_EXCEPTION_DELAY = Duration.ofMillis(3000);
     private final EventSource&lt;LogEntry&gt; latestEvent = new EventSource&lt;&gt;();
     private final LiveList&lt;LogEntry&gt; fullLog = new LiveArrayList&lt;&gt;();
 
 
     public EventLogger() {
 
-        EventStream&lt;LogEntry&gt; onlyParseException =
-            latestEvent.filter(x -&gt; x.getCategory() == PARSE_EXCEPTION || x.getCategory() == PARSE_OK)
-                       .successionEnds(PARSE_EXCEPTION_DELAY)
-                       // don't output anything when the last state recorded was OK
-                       .filter(x -&gt; x.getCategory() != PARSE_OK);
 
-        EventStream&lt;LogEntry&gt; onlyXPathException =
-            latestEvent.filter(x -&gt; x.getCategory() == XPATH_EVALUATION_EXCEPTION || x.getCategory() == XPATH_OK)
-                       .successionEnds(PARSE_EXCEPTION_DELAY)
-                       // don't output anything when the last state recorded was OK
-                       .filter(x -&gt; x.getCategory() != XPATH_OK);
 
-        EnumSet&lt;Category&gt; otherExceptionSet = EnumSet.complementOf(EnumSet.of(PARSE_EXCEPTION, XPATH_EVALUATION_EXCEPTION, PARSE_OK, XPATH_OK));
 
-        EventStream&lt;LogEntry&gt; otherExceptions = latestEvent.filter(x -&gt; otherExceptionSet.contains(x.getCategory()));
-
-        EventStreams.merge(onlyParseException, otherExceptions, onlyXPathException)
                     .subscribe(fullLog::add);
     }
 
 
     /** Number of log entries that were not yet examined by the user. */
     public Val&lt;Integer&gt; numNewLogEntriesProperty() {
-        return DesignerUtil.countNotMatching(fullLog.map(LogEntry::wasExaminedProperty));
     }
 
 
</code_before><code_after>@@ -6,11 +6,15 @@
 
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.PARSE_EXCEPTION;
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.PARSE_OK;
+import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.SELECTION_EVENT_TRACING;
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.XPATH_EVALUATION_EXCEPTION;
 import static net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category.XPATH_OK;
+import static net.sourceforge.pmd.util.fxdesigner.util.DesignerUtil.countNotMatching;
+import static net.sourceforge.pmd.util.fxdesigner.util.DesignerUtil.reduceIfPossible;
 
 import java.time.Duration;
 import java.util.EnumSet;
+import java.util.Objects;
 
 import org.reactfx.EventSource;
 import org.reactfx.EventStream;
@@ -20,7 +24,9 @@
 import org.reactfx.value.Val;
 
 import net.sourceforge.pmd.util.fxdesigner.model.LogEntry.Category;
+import net.sourceforge.pmd.util.fxdesigner.model.LogEntry.LogEntryWithData;
 import net.sourceforge.pmd.util.fxdesigner.util.DesignerUtil;
+import net.sourceforge.pmd.util.fxdesigner.util.NodeSelectionSource.NodeSelectionEvent;
 
 
 /**
@@ -35,37 +41,52 @@ public class EventLogger {
      * Exceptions from XPath evaluation or parsing are never emitted
      * within less than that time interval to keep them from flooding the tableview.
      */
+    private static final Duration PARSE_EXCEPTION_REDUCTION_DELAY = Duration.ofMillis(3000);
+    private static final Duration EVENT_TRACING_REDUCTION_DELAY = Duration.ofMillis(200);
     private final EventSource&lt;LogEntry&gt; latestEvent = new EventSource&lt;&gt;();
     private final LiveList&lt;LogEntry&gt; fullLog = new LiveArrayList&lt;&gt;();
 
 
     public EventLogger() {
 
+        EventStream&lt;LogEntryWithData&lt;NodeSelectionEvent&gt;&gt; eventTraces =
+            reduceIfPossible(filterOnCategory(latestEvent, false, SELECTION_EVENT_TRACING).map(t -&gt; (LogEntryWithData&lt;NodeSelectionEvent&gt;) t),
+                             // the user data for those is the event
+                             // if they're the same event we reduce them together
+                             (lastEv, newEv) -&gt; Objects.equals(lastEv.getUserData(), newEv.getUserData()),
+                             LogEntryWithData::reduceEventTrace,
+                             EVENT_TRACING_REDUCTION_DELAY);
 
+        EventStream&lt;LogEntry&gt; onlyParseException = deleteOnSignal(latestEvent, PARSE_EXCEPTION, PARSE_OK);
+        EventStream&lt;LogEntry&gt; onlyXPathException = deleteOnSignal(latestEvent, XPATH_EVALUATION_EXCEPTION, XPATH_OK);
 
+        EventStream&lt;LogEntry&gt; otherExceptions =
+            filterOnCategory(latestEvent, true, PARSE_EXCEPTION, XPATH_EVALUATION_EXCEPTION, SELECTION_EVENT_TRACING)
+                .filter(it -&gt; !it.getCategory().isFlag());
 
+        EventStreams.merge(eventTraces, onlyParseException, otherExceptions, onlyXPathException)
                     .subscribe(fullLog::add);
     }
 
 
     /** Number of log entries that were not yet examined by the user. */
     public Val&lt;Integer&gt; numNewLogEntriesProperty() {
+        return countNotMatching(fullLog.map(LogEntry::wasExaminedProperty));
+    }
+
+
+    private static EventStream&lt;LogEntry&gt; deleteOnSignal(EventStream&lt;LogEntry&gt; input, Category normal, Category deleteSignal) {
+        return DesignerUtil.deleteOnSignal(filterOnCategory(input, false, normal, deleteSignal),
+                                           x -&gt; x.getCategory() == deleteSignal,
+                                           PARSE_EXCEPTION_REDUCTION_DELAY);
+    }
+
+
+    private static EventStream&lt;LogEntry&gt; filterOnCategory(EventStream&lt;LogEntry&gt; input, boolean complement, Category first, Category... selection) {
+        EnumSet&lt;Category&gt; considered = EnumSet.of(first, selection);
+        EnumSet&lt;Category&gt; complemented = complement ? EnumSet.complementOf(considered) : considered;
+
+        return input.filter(e -&gt; complemented.contains(e.getCategory()));
     }
 
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>81907</refactoring_id><commit_sha>44b21f2e3b65787aa6b5b547d5ac67e97a924a61</commit_sha><commit_link>https://github.com/androidx/media/commit/44b21f2e3b65787aa6b5b547d5ac67e97a924a61</commit_link><file_path>library/src/main/java/com/google/android/exoplayer2/text/Cue.java</file_path><description>Extract Method private Cue(text CharSequence, textAlignment Alignment, line float, lineType int, lineAnchor int, position float, positionAnchor int, size float, size_height float, bitmap Bitmap) extracted from public Cue(text CharSequence, textAlignment Alignment, line float, lineType int, lineAnchor int, position float, positionAnchor int, size float) in class com.google.android.exoplayer2.text.Cue</description><code_before>@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -78,13 +79,19 @@ public class Cue {
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
    * the value depends on the value of {@link #lineType}.
    * &lt;p&gt;
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
    */
   public final float line;
   /**
@@ -119,6 +126,8 @@ public class Cue {
    * For horizontal text, this is the horizontal position relative to the left of the viewport. Note
    * that positioning is relative to the left of the viewport even in the case of right-to-left
    * text.
    */
   public final float position;
   /**
@@ -134,9 +143,25 @@ public class Cue {
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
    */
   public final float size;
 
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -159,6 +184,24 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -167,6 +210,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
   }
 
 }
</code_before><code_after>@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.graphics.Bitmap;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -78,13 +79,19 @@ public class Cue {
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
+  /**
+   * The cue image.
+   */
+  public final Bitmap bitmap;
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
    * the value depends on the value of {@link #lineType}.
    * &lt;p&gt;
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
+   * &lt;p&gt;
+   * If {@link #bitmap} is not null then this value is used to indicate the top position
    */
   public final float line;
   /**
@@ -119,6 +126,8 @@ public class Cue {
    * For horizontal text, this is the horizontal position relative to the left of the viewport. Note
    * that positioning is relative to the left of the viewport even in the case of right-to-left
    * text.
+   * &lt;p&gt;
+   * If {@link #bitmap} is not null then this value is used to indicate the left position
    */
   public final float position;
   /**
@@ -134,9 +143,25 @@ public class Cue {
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
+   * &lt;p&gt;
+   * If {@link #bitmap} is not null then this value is used to indicate the width
    */
   public final float size;
 
+  /**
+   * The height size of the cue box when a {@link #bitmap} is set specified as a fraction of the
+   * viewport size in that direction, or {@link #DIMEN_UNSET}.
+   */
+  public final float size_height;
+
+  /**
+   *
+   */
+  public Cue(Bitmap bitmap, float left, float top, float size, float size_height) {
+    this(null, null, top, LINE_TYPE_FRACTION, TYPE_UNSET, left, TYPE_UNSET, size, size_height,
+     bitmap);
+  }
+
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -159,6 +184,24 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
+    this(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size,
+     DIMEN_UNSET, null);
+  }
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param size_height See {@link #size_height}.
+   * @param bitmap See {@link #bitmap}.
+   */
+  private Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+    @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+    float size_height, Bitmap bitmap) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -167,6 +210,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
+    this.size_height = size_height;
+    this.bitmap = bitmap;
   }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>108564</refactoring_id><commit_sha>a12bab37c96c55c4605e756c3f725088d95e87cc</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/a12bab37c96c55c4605e756c3f725088d95e87cc</commit_link><file_path>engine/src/main/java/org/terasology/rendering/dag/stateChanges/SetViewportToSizeOf.java</file_path><description>Extract Method public getWidth() : int extracted from public update() : void in class org.terasology.rendering.dag.stateChanges.SetViewportToSizeOf</description><code_before>@@ -19,12 +19,16 @@
 import org.terasology.rendering.opengl.BaseFBOsManager;
 import org.terasology.rendering.opengl.DefaultDynamicFBOs;
 import org.terasology.rendering.opengl.FBOManagerSubscriber;
 import java.util.Objects;
 import org.terasology.rendering.dag.RenderPipelineTask;
 import org.terasology.rendering.dag.StateChange;
 import org.terasology.rendering.dag.tasks.SetViewportToSizeOfTask;
 import org.terasology.rendering.opengl.FBO;
 import static org.terasology.rendering.opengl.DefaultDynamicFBOs.READ_ONLY_GBUFFER;
 /**
  * TODO: Add javadocs
  */
@@ -63,14 +67,23 @@ public RenderPipelineTask generateTask() {
         return task;
     }
 
     @Override
     public int hashCode() {
-        return Objects.hashCode(fboName);
     }
 
     @Override
     public boolean equals(Object obj) {
-        return (obj instanceof SetViewportToSizeOf) &amp;&amp; this.fboName.equals(((SetViewportToSizeOf) obj).getFboName());
     }
 
     @Override
@@ -80,19 +93,32 @@ public boolean isTheDefaultInstance() {
 
     @Override
     public void update() {
-        if (defaultDynamicFBO == null) {
-            FBO fbo = frameBuffersManager.get(fboName);
-            task.setDimensions(fbo.width(), fbo.height());
-        } else {
-            task.setDimensions(defaultDynamicFBO.width(), defaultDynamicFBO.height());
-        }
     }
 
     @Override
     public String toString() { // TODO: used for logging purposes at the moment, investigate different methods
         return String.format("%30s: %s", this.getClass().getSimpleName(), fboName);
     }
 
     public ResourceUrn getFboName() {
         return fboName;
     }
</code_before><code_after>@@ -19,12 +19,16 @@
 import org.terasology.rendering.opengl.BaseFBOsManager;
 import org.terasology.rendering.opengl.DefaultDynamicFBOs;
 import org.terasology.rendering.opengl.FBOManagerSubscriber;
+
 import java.util.Objects;
+
 import org.terasology.rendering.dag.RenderPipelineTask;
 import org.terasology.rendering.dag.StateChange;
 import org.terasology.rendering.dag.tasks.SetViewportToSizeOfTask;
 import org.terasology.rendering.opengl.FBO;
+
 import static org.terasology.rendering.opengl.DefaultDynamicFBOs.READ_ONLY_GBUFFER;
+
 /**
  * TODO: Add javadocs
  */
@@ -63,14 +67,23 @@ public RenderPipelineTask generateTask() {
         return task;
     }
 
+    // TODO: change equals and hashCode to use dimensions instead.
     @Override
     public int hashCode() {
+        // Generates a unique 32 bit signed integer from two integers.
+        // This will return unique values for the following reasonable ranges:
+        // width &lt; (1 &lt;&lt; 16) (65536) and height &lt; (1 &lt;&lt; 15) (32768)
+        return getWidth() &lt;&lt; 15 | getHeight();
     }
 
     @Override
     public boolean equals(Object obj) {
+        if (!(obj instanceof SetViewportToSizeOf))
+            return false;
+
+        SetViewportToSizeOf other = (SetViewportToSizeOf) obj;
+
+        return getWidth() == other.getWidth() &amp;&amp; getHeight() == other.getHeight();
     }
 
     @Override
@@ -80,19 +93,32 @@ public boolean isTheDefaultInstance() {
 
     @Override
     public void update() {
+        task.setDimensions(getWidth(), getHeight());
     }
 
     @Override
     public String toString() { // TODO: used for logging purposes at the moment, investigate different methods
         return String.format("%30s: %s", this.getClass().getSimpleName(), fboName);
     }
 
+    public int getWidth() {
+        FBO fbo = getFbo();
+        return fbo.width();
+    }
+
+    public int getHeight() {
+        FBO fbo = getFbo();
+        return fbo.height();
+    }
+
+    private FBO getFbo() {
+        if (defaultDynamicFBO == null)
+            return frameBuffersManager.get(fboName);
+
+        return defaultDynamicFBO.getFbo();
+    }
+
+    // TODO: Remove
     public ResourceUrn getFboName() {
         return fboName;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>61784</refactoring_id><commit_sha>003e071140520ffc2d02b4b1cee75e647352b2b6</commit_sha><commit_link>https://github.com/apache/tomcat/commit/003e071140520ffc2d02b4b1cee75e647352b2b6</commit_link><file_path>java/org/apache/catalina/core/StandardContext.java</file_path><description>Extract Method public createInstanceManager() : InstanceManager extracted from protected startInternal() : void in class org.apache.catalina.core.StandardContext</description><code_before>@@ -5109,14 +5109,7 @@ public String mutate(String inputCredentials) {
 
             if (ok ) {
                 if (getInstanceManager() == null) {
-                    javax.naming.Context context = null;
-                    if (isUseNaming() &amp;&amp; getNamingContextListener() != null) {
-                        context = getNamingContextListener().getEnvContext();
-                    }
-                    Map&lt;String, Map&lt;String, String&gt;&gt; injectionMap = buildInjectionMap(
-                            getIgnoreAnnotations() ? new NamingResourcesImpl(): getNamingResources());
-                    setInstanceManager(new DefaultInstanceManager(context,
-                            injectionMap, this, this.getClass().getClassLoader()));
                 }
                 getServletContext().setAttribute(
                         InstanceManager.class.getName(), getInstanceManager());
@@ -5248,6 +5241,18 @@ private void setClassLoaderProperty(String name, boolean value) {
         }
     }
 
     private Map&lt;String, Map&lt;String, String&gt;&gt; buildInjectionMap(NamingResourcesImpl namingResources) {
         Map&lt;String, Map&lt;String, String&gt;&gt; injectionMap = new HashMap&lt;&gt;();
         for (Injectable resource: namingResources.findLocalEjbs()) {
</code_before><code_after>@@ -5109,14 +5109,7 @@ public String mutate(String inputCredentials) {
 
             if (ok ) {
                 if (getInstanceManager() == null) {
+                    setInstanceManager(createInstanceManager());
                 }
                 getServletContext().setAttribute(
                         InstanceManager.class.getName(), getInstanceManager());
@@ -5248,6 +5241,18 @@ private void setClassLoaderProperty(String name, boolean value) {
         }
     }
 
+    @Override
+    public InstanceManager createInstanceManager() {
+        javax.naming.Context context = null;
+        if (isUseNaming() &amp;&amp; getNamingContextListener() != null) {
+            context = getNamingContextListener().getEnvContext();
+        }
+        Map&lt;String, Map&lt;String, String&gt;&gt; injectionMap = buildInjectionMap(
+                getIgnoreAnnotations() ? new NamingResourcesImpl(): getNamingResources());
+       return new DefaultInstanceManager(context, injectionMap,
+               this, this.getClass().getClassLoader());
+    }
+
     private Map&lt;String, Map&lt;String, String&gt;&gt; buildInjectionMap(NamingResourcesImpl namingResources) {
         Map&lt;String, Map&lt;String, String&gt;&gt; injectionMap = new HashMap&lt;&gt;();
         for (Injectable resource: namingResources.findLocalEjbs()) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>35525</refactoring_id><commit_sha>3abbffa491dd4556aaa5ac284a2b0868a0ce4a34</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/3abbffa491dd4556aaa5ac284a2b0868a0ce4a34</commit_link><file_path>OsmAnd/src/net/osmand/plus/settings/fragments/BaseSettingsFragment.java</file_path><description>Extract Method public showInstance(activity FragmentActivity, screenType SettingsScreenType, appMode ApplicationMode, args Bundle) : boolean extracted from public showInstance(activity FragmentActivity, screenType SettingsScreenType, appMode ApplicationMode) : boolean in class net.osmand.plus.settings.fragments.BaseSettingsFragment</description><code_before>@@ -899,9 +899,13 @@ public static boolean showInstance(FragmentActivity activity, SettingsScreenType
 	}
 
 	public static boolean showInstance(FragmentActivity activity, SettingsScreenType screenType, @Nullable ApplicationMode appMode) {
 		try {
 			Fragment fragment = Fragment.instantiate(activity, screenType.fragmentName);
-			Bundle args = new Bundle();
 			if (appMode != null) {
 				args.putString(APP_MODE_KEY, appMode.getStringKey());
 			}
</code_before><code_after>@@ -899,9 +899,13 @@ public static boolean showInstance(FragmentActivity activity, SettingsScreenType
 	}
 
 	public static boolean showInstance(FragmentActivity activity, SettingsScreenType screenType, @Nullable ApplicationMode appMode) {
+		return showInstance(activity, screenType, null, new Bundle());
+	}
+
+	public static boolean showInstance(FragmentActivity activity, SettingsScreenType screenType,
+									   @Nullable ApplicationMode appMode, @NonNull Bundle args) {
 		try {
 			Fragment fragment = Fragment.instantiate(activity, screenType.fragmentName);
 			if (appMode != null) {
 				args.putString(APP_MODE_KEY, appMode.getStringKey());
 			}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>102694</refactoring_id><commit_sha>786ee781aed38db8b76780742f77835b6ef4da2e</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/786ee781aed38db8b76780742f77835b6ef4da2e</commit_link><file_path>jdk/src/share/classes/java/awt/MediaTracker.java</file_path><description>Extract Method private removeImageImpl(image Image) : void extracted from public removeImage(image Image) : void in class java.awt.MediaTracker</description><code_before>@@ -28,6 +28,7 @@
 import java.awt.Component;
 import java.awt.Image;
 import java.awt.image.ImageObserver;
 
 /**
  * The &lt;code&gt;MediaTracker&lt;/code&gt; class is a utility class to track
@@ -222,10 +223,17 @@ public void addImage(Image image, int id) {
      * @param     h    the height at which the image is rendered
      */
     public synchronized void addImage(Image image, int id, int w, int h) {
         head = MediaEntry.insert(head,
                                  new ImageMediaEntry(this, image, id, w, h));
     }
-
     /**
      * Flag indicating that media is currently being loaded.
      * @see         java.awt.MediaTracker#statusAll
@@ -719,6 +727,15 @@ private synchronized int statusID(int id, boolean load, boolean verify) {
      * @since   JDK1.1
      */
     public synchronized void removeImage(Image image) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -735,7 +752,6 @@ public synchronized void removeImage(Image image) {
             }
             cur = next;
         }
-        notifyAll();    // Notify in case remaining images are "done".
     }
 
     /**
@@ -750,6 +766,15 @@ public synchronized void removeImage(Image image) {
      * @since      JDK1.1
      */
     public synchronized void removeImage(Image image, int id) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -766,7 +791,6 @@ public synchronized void removeImage(Image image, int id) {
             }
             cur = next;
         }
-        notifyAll();    // Notify in case remaining images are "done".
     }
 
     /**
@@ -783,6 +807,16 @@ public synchronized void removeImage(Image image, int id) {
      */
     public synchronized void removeImage(Image image, int id,
                                          int width, int height) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -801,12 +835,18 @@ public synchronized void removeImage(Image image, int id,
             }
             cur = next;
         }
-        notifyAll();    // Notify in case remaining images are "done".
     }
 
     synchronized void setDone() {
         notifyAll();
     }
 }
 
 abstract class MediaEntry {
</code_before><code_after>@@ -28,6 +28,7 @@
 import java.awt.Component;
 import java.awt.Image;
 import java.awt.image.ImageObserver;
+import sun.awt.image.MultiResolutionToolkitImage;
 
 /**
  * The &lt;code&gt;MediaTracker&lt;/code&gt; class is a utility class to track
@@ -222,10 +223,17 @@ public void addImage(Image image, int id) {
      * @param     h    the height at which the image is rendered
      */
     public synchronized void addImage(Image image, int id, int w, int h) {
+        addImageImpl(image, id, w, h);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            addImageImpl(rvImage, id, 2 * w, 2 * h);
+        }
+    }
+
+    private void addImageImpl(Image image, int id, int w, int h) {
         head = MediaEntry.insert(head,
                                  new ImageMediaEntry(this, image, id, w, h));
     }
     /**
      * Flag indicating that media is currently being loaded.
      * @see         java.awt.MediaTracker#statusAll
@@ -719,6 +727,15 @@ private synchronized int statusID(int id, boolean load, boolean verify) {
      * @since   JDK1.1
      */
     public synchronized void removeImage(Image image) {
+        removeImageImpl(image);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            removeImageImpl(rvImage);
+        }
+        notifyAll();    // Notify in case remaining images are "done".
+    }
+
+    private void removeImageImpl(Image image) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -735,7 +752,6 @@ public synchronized void removeImage(Image image) {
             }
             cur = next;
         }
     }
 
     /**
@@ -750,6 +766,15 @@ public synchronized void removeImage(Image image) {
      * @since      JDK1.1
      */
     public synchronized void removeImage(Image image, int id) {
+        removeImageImpl(image, id);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            removeImageImpl(rvImage, id);
+        }
+        notifyAll();    // Notify in case remaining images are "done".
+    }
+
+    private void removeImageImpl(Image image, int id) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -766,7 +791,6 @@ public synchronized void removeImage(Image image, int id) {
             }
             cur = next;
         }
     }
 
     /**
@@ -783,6 +807,16 @@ public synchronized void removeImage(Image image, int id) {
      */
     public synchronized void removeImage(Image image, int id,
                                          int width, int height) {
+        removeImageImpl(image, id, width, height);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            removeImageImpl(rvImage, id, 2 * width, 2 * height);
+
+        }
+        notifyAll();    // Notify in case remaining images are "done".
+    }
+
+    private void removeImageImpl(Image image, int id, int width, int height) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -801,12 +835,18 @@ public synchronized void removeImage(Image image, int id,
             }
             cur = next;
         }
     }
 
     synchronized void setDone() {
         notifyAll();
     }
+
+    private static Image getResolutionVariant(Image image) {
+        if (image instanceof MultiResolutionToolkitImage) {
+            return ((MultiResolutionToolkitImage) image).getResolutionVariant();
+        }
+        return null;
+    }
 }
 
 abstract class MediaEntry {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>118363</refactoring_id><commit_sha>0a194be29b0b643c773c294999cd8f4a7ad479f3</commit_sha><commit_link>https://github.com/StarRocks/starrocks/commit/0a194be29b0b643c773c294999cd8f4a7ad479f3</commit_link><file_path>fe/fe-core/src/main/java/com/starrocks/sql/ast/CreateAnalyzeJobStmt.java</file_path><description>Extract Method public CreateAnalyzeJobStmt(tbl TableName, columnNames List&lt;String&gt;, isSample boolean, properties Map&lt;String,String&gt;, pos NodePosition) extracted from public CreateAnalyzeJobStmt(tbl TableName, columnNames List&lt;String&gt;, isSample boolean, properties Map&lt;String,String&gt;) in class com.starrocks.sql.ast.CreateAnalyzeJobStmt</description><code_before>@@ -17,6 +17,7 @@
 
 import com.google.common.collect.Lists;
 import com.starrocks.analysis.TableName;
 import com.starrocks.statistic.StatsConstants;
 
 import java.util.List;
@@ -31,15 +32,20 @@ public class CreateAnalyzeJobStmt extends DdlStmt {
     private Map&lt;String, String&gt; properties;
 
     public CreateAnalyzeJobStmt(boolean isSample, Map&lt;String, String&gt; properties) {
-        this(null, Lists.newArrayList(), isSample, properties);
     }
 
     public CreateAnalyzeJobStmt(String db, boolean isSample, Map&lt;String, String&gt; properties) {
-        this(new TableName(db, null), Lists.newArrayList(), isSample, properties);
     }
 
     public CreateAnalyzeJobStmt(TableName tbl, List&lt;String&gt; columnNames, boolean isSample,
                                 Map&lt;String, String&gt; properties) {
         this.tbl = tbl;
         this.dbId = StatsConstants.DEFAULT_ALL_ID;
         this.tableId = StatsConstants.DEFAULT_ALL_ID;
</code_before><code_after>@@ -17,6 +17,7 @@
 
 import com.google.common.collect.Lists;
 import com.starrocks.analysis.TableName;
+import com.starrocks.sql.parser.NodePosition;
 import com.starrocks.statistic.StatsConstants;
 
 import java.util.List;
@@ -31,15 +32,20 @@ public class CreateAnalyzeJobStmt extends DdlStmt {
     private Map&lt;String, String&gt; properties;
 
     public CreateAnalyzeJobStmt(boolean isSample, Map&lt;String, String&gt; properties) {
+        this(null, Lists.newArrayList(), isSample, properties, NodePosition.ZERO);
     }
 
     public CreateAnalyzeJobStmt(String db, boolean isSample, Map&lt;String, String&gt; properties) {
+        this(new TableName(db, null), Lists.newArrayList(), isSample, properties, NodePosition.ZERO);
     }
 
     public CreateAnalyzeJobStmt(TableName tbl, List&lt;String&gt; columnNames, boolean isSample,
                                 Map&lt;String, String&gt; properties) {
+        this(tbl, columnNames, isSample, properties, NodePosition.ZERO);
+    }
+    public CreateAnalyzeJobStmt(TableName tbl, List&lt;String&gt; columnNames, boolean isSample,
+                                Map&lt;String, String&gt; properties, NodePosition pos) {
+        super(pos);
         this.tbl = tbl;
         this.dbId = StatsConstants.DEFAULT_ALL_ID;
         this.tableId = StatsConstants.DEFAULT_ALL_ID;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>6096</refactoring_id><commit_sha>1f4356c84b96a68dd7bb4244c43902e650a11387</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/1f4356c84b96a68dd7bb4244c43902e650a11387</commit_link><file_path>engine/src/main/java/org/camunda/bpm/engine/impl/db/sql/DbSqlSession.java</file_path><description>Extract Method protected configureFailedDbEntityOperation(operation DbEntityOperation, failure Exception) : void extracted from protected entityInsertPerformed(operation DbEntityOperation, rowsAffected int, failure Exception) : void in class org.camunda.bpm.engine.impl.db.sql.DbSqlSession</description><code_before>@@ -142,14 +142,7 @@ protected void entityUpdatePerformed(DbEntityOperation operation,
                                        int rowsAffected,
                                        Exception failure) {
     if (failure != null) {
-      operation.setRowsAffected(0);
-      operation.setFailure(failure);
-
-      if (isConcurrentModificationException(operation, failure)) {
-        operation.setState(State.FAILED_CONCURRENT_MODIFICATION);
-      } else {
-        operation.setState(State.FAILED_ERROR);
-      }
     } else {
       DbEntity dbEntity = operation.getEntity();
 
@@ -189,7 +182,13 @@ protected void bulkOperationPerformed(DbBulkOperation operation,
 
     if (failure != null) {
       operation.setFailure(failure);
-      operation.setState(State.FAILED_ERROR);
     } else {
       operation.setRowsAffected(rowsAffected);
       operation.setState(State.APPLIED);
@@ -201,20 +200,7 @@ protected void entityDeletePerformed(DbEntityOperation operation,
                                        Exception failure) {
     
     if (failure != null) {
-      operation.setRowsAffected(0);
-      operation.setFailure(failure);
-
-      DbOperation dependencyOperation = operation.getDependentOperation();
-
-      if (isConcurrentModificationException(operation, failure)) {
-        operation.setState(State.FAILED_CONCURRENT_MODIFICATION);
-      } else if (dependencyOperation != null &amp;&amp; dependencyOperation.getState() != null &amp;&amp; dependencyOperation.getState() != State.APPLIED) {
-        // the owning operation was not successful, so the prerequisite for this operation was not given
-        LOG.ignoreFailureDuePreconditionNotMet(operation, "Parent database operation failed", dependencyOperation);
-        operation.setState(State.NOT_APPLIED);
-      } else {
-        operation.setState(State.FAILED_ERROR);
-      }
     } else {
       operation.setRowsAffected(rowsAffected);
 
@@ -229,6 +215,36 @@ protected void entityDeletePerformed(DbEntityOperation operation,
     }
   }
 
   protected boolean isConcurrentModificationException(DbOperation failedOperation,
                                                       Exception cause) {
 
@@ -259,6 +275,30 @@ protected boolean isConcurrentModificationException(DbOperation failedOperation,
     return false;
   }
 
   // insert //////////////////////////////////////////
 
   @Override
@@ -291,14 +331,7 @@ protected void entityInsertPerformed(DbEntityOperation operation,
     DbEntity entity = operation.getEntity();
 
     if (failure != null) {
-      operation.setRowsAffected(0);
-      operation.setFailure(failure);
-
-      if (isConcurrentModificationException(operation, failure)) {
-        operation.setState(State.FAILED_CONCURRENT_MODIFICATION);
-      } else {
-        operation.setState(State.FAILED_ERROR);
-      }
     } else {
       // set revision of our copy to 1
       if (entity instanceof HasDbRevision) {
</code_before><code_after>@@ -142,14 +142,7 @@ protected void entityUpdatePerformed(DbEntityOperation operation,
                                        int rowsAffected,
                                        Exception failure) {
     if (failure != null) {
+      configureFailedDbEntityOperation(operation, failure);
     } else {
       DbEntity dbEntity = operation.getEntity();
 
@@ -189,7 +182,13 @@ protected void bulkOperationPerformed(DbBulkOperation operation,
 
     if (failure != null) {
       operation.setFailure(failure);
+
+      State failedState = State.FAILED_ERROR;
+      if (isCrdbTransactionRetryException(failure)) {
+        failedState = State.FAILED_CONCURRENT_MODIFICATION;
+        operation.setFatalFailure(true);
+      }
+      operation.setState(failedState);
     } else {
       operation.setRowsAffected(rowsAffected);
       operation.setState(State.APPLIED);
@@ -201,20 +200,7 @@ protected void entityDeletePerformed(DbEntityOperation operation,
                                        Exception failure) {
     
     if (failure != null) {
+      configureFailedDbEntityOperation(operation, failure);
     } else {
       operation.setRowsAffected(rowsAffected);
 
@@ -229,6 +215,36 @@ protected void entityDeletePerformed(DbEntityOperation operation,
     }
   }
 
+  protected void configureFailedDbEntityOperation(DbEntityOperation operation, Exception failure) {
+    operation.setRowsAffected(0);
+    operation.setFailure(failure);
+
+    DbOperationType operationType = operation.getOperationType();
+    DbOperation dependencyOperation = operation.getDependentOperation();
+
+    State failedState;
+    if (isCrdbTransactionRetryException(failure)) {
+
+      operation.setFatalFailure(true);
+      failedState = State.FAILED_CONCURRENT_MODIFICATION;
+    } else if (isConcurrentModificationException(operation, failure)) {
+
+      failedState = State.FAILED_CONCURRENT_MODIFICATION;
+    } else if (DbOperationType.DELETE.equals(operationType)
+              &amp;&amp; dependencyOperation != null
+              &amp;&amp; dependencyOperation.getState() != null
+              &amp;&amp; dependencyOperation.getState() != State.APPLIED) {
+
+      // the owning operation was not successful, so the prerequisite for this operation was not given
+      LOG.ignoreFailureDuePreconditionNotMet(operation, "Parent database operation failed", dependencyOperation);
+      failedState = State.NOT_APPLIED;
+    } else {
+
+      failedState = State.FAILED_ERROR;
+    }
+    operation.setState(failedState);
+  }
+
   protected boolean isConcurrentModificationException(DbOperation failedOperation,
                                                       Exception cause) {
 
@@ -259,6 +275,30 @@ protected boolean isConcurrentModificationException(DbOperation failedOperation,
     return false;
   }
 
+  /**
+   * In cases where CockroachDB is used, and a failed operation is detected,
+   * the method checks if the exception was caused by a CockroachDB
+   * &lt;code&gt;TransactionRetryException&lt;/code&gt;.
+   *
+   * @param cause for which an operation failed
+   * @return true if the failure was due to a CRDB &lt;code&gt;TransactionRetryException&lt;/code&gt;.
+   *          Otherwise, it's false.
+   */
+  protected boolean isCrdbTransactionRetryException(Throwable cause) {
+    // only check when CRDB is used
+    String databaseType = Context.getProcessEngineConfiguration().getDatabaseType();
+    if (DbSqlSessionFactory.CRDB.equals(databaseType)) {
+      boolean isCrdbTxRetryException = ExceptionUtil.checkCrdbTransactionRetryException(cause);
+      if (isCrdbTxRetryException) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+
+
   // insert //////////////////////////////////////////
 
   @Override
@@ -291,14 +331,7 @@ protected void entityInsertPerformed(DbEntityOperation operation,
     DbEntity entity = operation.getEntity();
 
     if (failure != null) {
+      configureFailedDbEntityOperation(operation, failure);
     } else {
       // set revision of our copy to 1
       if (entity instanceof HasDbRevision) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>112719</refactoring_id><commit_sha>f384b32877979d1118c0478bacae622ac7e0b330</commit_sha><commit_link>https://github.com/apache/flink/commit/f384b32877979d1118c0478bacae622ac7e0b330</commit_link><file_path>flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java</file_path><description>Extract Method public stopCheckpointScheduler() : void extracted from public triggerSavepoint(targetDirectory String, cancelJob boolean) : CompletableFuture&lt;String&gt; in class org.apache.flink.runtime.scheduler.SchedulerBase</description><code_before>@@ -35,6 +35,7 @@
 import org.apache.flink.runtime.checkpoint.CheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.CheckpointMetrics;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
@@ -81,6 +82,8 @@
 import org.apache.flink.runtime.operators.coordination.OperatorEvent;
 import org.apache.flink.runtime.query.KvStateLocation;
 import org.apache.flink.runtime.query.UnknownKvStateLocation;
 import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;
@@ -112,12 +115,13 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
 
 /** Base class which can be used to implement {@link SchedulerNG}. */
-public abstract class SchedulerBase implements SchedulerNG {
 
     private final Logger log;
 
@@ -858,7 +862,7 @@ public CompletableFuture&lt;String&gt; triggerSavepoint(
                 jobGraph.getJobID());
 
         if (cancelJob) {
-            checkpointCoordinator.stopCheckpointScheduler();
         }
 
         return checkpointCoordinator
@@ -868,7 +872,7 @@ public CompletableFuture&lt;String&gt; triggerSavepoint(
                         (path, throwable) -&gt; {
                             if (throwable != null) {
                                 if (cancelJob) {
-                                    startCheckpointScheduler(checkpointCoordinator);
                                 }
                                 throw new CompletionException(throwable);
                             } else if (cancelJob) {
@@ -883,10 +887,26 @@ public CompletableFuture&lt;String&gt; triggerSavepoint(
                         mainThreadExecutor);
     }
 
-    private void startCheckpointScheduler(final CheckpointCoordinator checkpointCoordinator) {
         mainThreadExecutor.assertRunningInMainThread();
 
-        if (checkpointCoordinator.isPeriodicCheckpointingConfigured()) {
             try {
                 checkpointCoordinator.startCheckpointScheduler();
             } catch (IllegalStateException ignored) {
@@ -954,51 +974,36 @@ public CompletableFuture&lt;String&gt; stopWithSavepoint(
         // to have only the data of the synchronous savepoint committed.
         // in case of failure, and if the job restarts, the coordinator
         // will be restarted by the CheckpointCoordinatorDeActivator.
-        checkpointCoordinator.stopCheckpointScheduler();
-
-        final CompletableFuture&lt;String&gt; savepointFuture =
-                checkpointCoordinator
-                        .triggerSynchronousSavepoint(terminate, targetDirectory)
-                        .thenApply(CompletedCheckpoint::getExternalPointer);
-
-        final CompletableFuture&lt;JobStatus&gt; terminationFuture =
-                executionGraph
-                        .getTerminationFuture()
-                        .handle(
-                                (jobstatus, throwable) -&gt; {
-                                    if (throwable != null) {
-                                        log.info(
-                                                "Failed during stopping job {} with a savepoint. Reason: {}",
-                                                jobGraph.getJobID(),
-                                                throwable.getMessage());
-                                        throw new CompletionException(throwable);
-                                    } else if (jobstatus != JobStatus.FINISHED) {
-                                        log.info(
-                                                "Failed during stopping job {} with a savepoint. Reason: Reached state {} instead of FINISHED.",
-                                                jobGraph.getJobID(),
-                                                jobstatus);
-                                        throw new CompletionException(
-                                                new FlinkException(
-                                                        "Reached state "
-                                                                + jobstatus
-                                                                + " instead of FINISHED."));
-                                    }
-                                    return jobstatus;
-                                });
-
-        return savepointFuture
-                .thenCompose((path) -&gt; terminationFuture.thenApply((jobStatus -&gt; path)))
-                .handleAsync(
-                        (path, throwable) -&gt; {
-                            if (throwable != null) {
-                                // restart the checkpoint coordinator if stopWithSavepoint failed.
-                                startCheckpointScheduler(checkpointCoordinator);
-                                throw new CompletionException(throwable);
-                            }
 
-                            return path;
-                        },
-                        mainThreadExecutor);
     }
 
     // ------------------------------------------------------------------------
</code_before><code_after>@@ -35,6 +35,7 @@
 import org.apache.flink.runtime.checkpoint.CheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.CheckpointMetrics;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointScheduling;
 import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
@@ -81,6 +82,8 @@
 import org.apache.flink.runtime.operators.coordination.OperatorEvent;
 import org.apache.flink.runtime.query.KvStateLocation;
 import org.apache.flink.runtime.query.UnknownKvStateLocation;
+import org.apache.flink.runtime.scheduler.stopwithsavepoint.StopWithSavepointTerminationHandlerImpl;
+import org.apache.flink.runtime.scheduler.stopwithsavepoint.StopWithSavepointTerminationManager;
 import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;
@@ -112,12 +115,13 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
 
 /** Base class which can be used to implement {@link SchedulerNG}. */
+public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling {
 
     private final Logger log;
 
@@ -858,7 +862,7 @@ public CompletableFuture&lt;String&gt; triggerSavepoint(
                 jobGraph.getJobID());
 
         if (cancelJob) {
+            stopCheckpointScheduler();
         }
 
         return checkpointCoordinator
@@ -868,7 +872,7 @@ public CompletableFuture&lt;String&gt; triggerSavepoint(
                         (path, throwable) -&gt; {
                             if (throwable != null) {
                                 if (cancelJob) {
+                                    startCheckpointScheduler();
                                 }
                                 throw new CompletionException(throwable);
                             } else if (cancelJob) {
@@ -883,10 +887,26 @@ public CompletableFuture&lt;String&gt; triggerSavepoint(
                         mainThreadExecutor);
     }
 
+    @Override
+    public void stopCheckpointScheduler() {
+        final CheckpointCoordinator checkpointCoordinator = getCheckpointCoordinator();
+        if (checkpointCoordinator == null) {
+            log.info(
+                    "Periodic checkpoint scheduling could not be stopped due to the CheckpointCoordinator being shutdown.");
+        } else {
+            checkpointCoordinator.stopCheckpointScheduler();
+        }
+    }
+
+    @Override
+    public void startCheckpointScheduler() {
         mainThreadExecutor.assertRunningInMainThread();
+        final CheckpointCoordinator checkpointCoordinator = getCheckpointCoordinator();
 
+        if (checkpointCoordinator == null) {
+            log.info(
+                    "Periodic checkpoint scheduling could not be started due to the CheckpointCoordinator being shutdown.");
+        } else if (checkpointCoordinator.isPeriodicCheckpointingConfigured()) {
             try {
                 checkpointCoordinator.startCheckpointScheduler();
             } catch (IllegalStateException ignored) {
@@ -954,51 +974,36 @@ public CompletableFuture&lt;String&gt; stopWithSavepoint(
         // to have only the data of the synchronous savepoint committed.
         // in case of failure, and if the job restarts, the coordinator
         // will be restarted by the CheckpointCoordinatorDeActivator.
+        stopCheckpointScheduler();
 
+        final CompletableFuture&lt;Collection&lt;ExecutionState&gt;&gt; executionTerminationsFuture =
+                getCombinedExecutionTerminationFuture();
+
+        final CompletableFuture&lt;CompletedCheckpoint&gt; savepointFuture =
+                checkpointCoordinator.triggerSynchronousSavepoint(terminate, targetDirectory);
+
+        final StopWithSavepointTerminationManager stopWithSavepointTerminationManager =
+                new StopWithSavepointTerminationManager(
+                        new StopWithSavepointTerminationHandlerImpl(
+                                jobGraph.getJobID(), this, log));
+
+        return stopWithSavepointTerminationManager.stopWithSavepoint(
+                savepointFuture, executionTerminationsFuture, mainThreadExecutor);
+    }
+
+    /**
+     * Returns a {@code CompletableFuture} collecting the termination states of all {@link Execution
+     * Executions} of the underlying {@link ExecutionGraph}.
+     *
+     * @return a {@code CompletableFuture} that completes after all underlying {@code Executions}
+     *     have been terminated.
+     */
+    private CompletableFuture&lt;Collection&lt;ExecutionState&gt;&gt; getCombinedExecutionTerminationFuture() {
+        return FutureUtils.combineAll(
+                StreamSupport.stream(executionGraph.getAllExecutionVertices().spliterator(), false)
+                        .map(ExecutionVertex::getCurrentExecutionAttempt)
+                        .map(Execution::getTerminalStateFuture)
+                        .collect(Collectors.toList()));
     }
 
     // ------------------------------------------------------------------------
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>97056</refactoring_id><commit_sha>b1a6ec0e4e66b68b35ac9c165ce92561afad21cb</commit_sha><commit_link>https://github.com/h2database/h2database/commit/b1a6ec0e4e66b68b35ac9c165ce92561afad21cb</commit_link><file_path>h2/src/main/org/h2/command/Parser.java</file_path><description>Extract Method private readStringOrIdentifier() : String extracted from private parseCreateFunctionAlias(force boolean) : CreateFunctionAlias in class org.h2.command.Parser</description><code_before>@@ -7940,7 +7940,7 @@ private CreateAggregate parseCreateAggregate(boolean force) {
         command.setName(name);
         command.setIfNotExists(ifNotExists);
         read(FOR);
-        command.setJavaClassMethod(readUniqueIdentifier());
         return command;
     }
 
@@ -8062,7 +8062,7 @@ private CreateTrigger parseCreateTrigger(boolean force) {
             command.setTriggerSource(readString());
         } else {
             read("CALL");
-            command.setTriggerClassName(readUniqueIdentifier());
         }
         return command;
     }
@@ -8117,11 +8117,15 @@ private CreateFunctionAlias parseCreateFunctionAlias(boolean force) {
             command.setSource(readString());
         } else {
             read(FOR);
-            command.setJavaClassMethod(readUniqueIdentifier());
         }
         return command;
     }
 
     private boolean isReservedFunctionName(String name) {
         int tokenType = ParserUtil.getTokenType(name, false, 0, name.length(), false);
         if (tokenType != ParserUtil.IDENTIFIER) {
</code_before><code_after>@@ -7940,7 +7940,7 @@ private CreateAggregate parseCreateAggregate(boolean force) {
         command.setName(name);
         command.setIfNotExists(ifNotExists);
         read(FOR);
+        command.setJavaClassMethod(readStringOrIdentifier());
         return command;
     }
 
@@ -8062,7 +8062,7 @@ private CreateTrigger parseCreateTrigger(boolean force) {
             command.setTriggerSource(readString());
         } else {
             read("CALL");
+            command.setTriggerClassName(readStringOrIdentifier());
         }
         return command;
     }
@@ -8117,11 +8117,15 @@ private CreateFunctionAlias parseCreateFunctionAlias(boolean force) {
             command.setSource(readString());
         } else {
             read(FOR);
+            command.setJavaClassMethod(readStringOrIdentifier());
         }
         return command;
     }
 
+    private String readStringOrIdentifier() {
+        return currentTokenType != IDENTIFIER ? readString() : readUniqueIdentifier();
+    }
+
     private boolean isReservedFunctionName(String name) {
         int tokenType = ParserUtil.getTokenType(name, false, 0, name.length(), false);
         if (tokenType != ParserUtil.IDENTIFIER) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>112976</refactoring_id><commit_sha>d8fd04a7e72ecee4fe5b06f42ee9530aa292e644</commit_sha><commit_link>https://github.com/apache/flink/commit/d8fd04a7e72ecee4fe5b06f42ee9530aa292e644</commit_link><file_path>flink-runtime/src/test/java/org/apache/flink/runtime/query/netty/message/KvStateRequestSerializerTest.java</file_path><description>Extract Method public testListSerialization(key long, listState ListState&lt;Long&gt;) : void extracted from public testListSerialization() : void in class org.apache.flink.runtime.query.netty.message.KvStateRequestSerializerTest</description><code_before>@@ -21,11 +21,19 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.UnpooledByteBufAllocator;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.common.typeutils.base.LongSerializer;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.query.KvStateID;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -34,6 +42,7 @@
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
 public class KvStateRequestSerializerTest {
 
@@ -228,17 +237,62 @@ public void testValueSerialization() throws Exception {
 	 */
 	@Test
 	public void testListSerialization() throws Exception {
 		TypeSerializer&lt;Long&gt; valueSerializer = LongSerializer.INSTANCE;
 
 		// List
-		int numElements = 10;
 
-		List&lt;Long&gt; expectedValues = new ArrayList&lt;&gt;();
 		for (int i = 0; i &lt; numElements; i++) {
-			expectedValues.add(ThreadLocalRandom.current().nextLong());
 		}
 
-		byte[] serializedValues = KvStateRequestSerializer.serializeList(expectedValues, valueSerializer);
 		List&lt;Long&gt; actualValues = KvStateRequestSerializer.deserializeList(serializedValues, valueSerializer);
 		assertEquals(expectedValues, actualValues);
 
</code_before><code_after>@@ -21,11 +21,19 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.UnpooledByteBufAllocator;
+import org.apache.flink.api.common.state.ListState;
+import org.apache.flink.api.common.state.ListStateDescriptor;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.common.typeutils.base.LongSerializer;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.query.KvStateID;
+import org.apache.flink.runtime.query.TaskKvStateRegistry;
+import org.apache.flink.runtime.state.KeyGroupRange;
+import org.apache.flink.runtime.state.KvState;
+import org.apache.flink.runtime.state.VoidNamespace;
+import org.apache.flink.runtime.state.VoidNamespaceSerializer;
+import org.apache.flink.runtime.state.heap.HeapKeyedStateBackend;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -34,6 +42,7 @@
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
 
 public class KvStateRequestSerializerTest {
 
@@ -228,17 +237,62 @@ public void testValueSerialization() throws Exception {
 	 */
 	@Test
 	public void testListSerialization() throws Exception {
+		final long key = 0l;
+
+		// objects for heap state list serialisation
+		final HeapKeyedStateBackend&lt;Long&gt; longHeapKeyedStateBackend =
+			new HeapKeyedStateBackend&lt;&gt;(
+				mock(TaskKvStateRegistry.class),
+				LongSerializer.INSTANCE,
+				ClassLoader.getSystemClassLoader(),
+				1, new KeyGroupRange(0, 0)
+			);
+		longHeapKeyedStateBackend.setCurrentKey(key);
+
+		final ListState&lt;Long&gt; listState = longHeapKeyedStateBackend
+			.createListState(VoidNamespaceSerializer.INSTANCE,
+				new ListStateDescriptor&lt;&gt;("test", LongSerializer.INSTANCE));
+		testListSerialization(key, listState);
+	}
+
+	/**
+	 * Verifies that the serialization of a list using the given list state
+	 * matches the deserialization with {@link KvStateRequestSerializer#deserializeList}.
+	 *
+	 * @param key
+	 * 		key of the list state
+	 * @param listState
+	 * 		list state using the {@link VoidNamespace}, must also be a {@link
+	 * 		KvState} instance
+	 *
+	 * @throws Exception
+	 */
+	public static void testListSerialization(final long key,
+		final ListState&lt;Long&gt; listState) throws Exception {
+
 		TypeSerializer&lt;Long&gt; valueSerializer = LongSerializer.INSTANCE;
 
+		final KvState&lt;VoidNamespace&gt; listKvState =
+			(KvState&lt;VoidNamespace&gt;) listState;
+		listKvState.setCurrentNamespace(VoidNamespace.INSTANCE);
+
 		// List
+		final int numElements = 10;
 
+		final List&lt;Long&gt; expectedValues = new ArrayList&lt;&gt;();
 		for (int i = 0; i &lt; numElements; i++) {
+			final long value = ThreadLocalRandom.current().nextLong();
+			expectedValues.add(value);
+			listState.add(value);
 		}
 
+		final byte[] serializedKey =
+			KvStateRequestSerializer.serializeKeyAndNamespace(
+				key, LongSerializer.INSTANCE,
+				VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE);
+		final byte[] serializedValues =
+			listKvState.getSerializedValue(serializedKey);
+
 		List&lt;Long&gt; actualValues = KvStateRequestSerializer.deserializeList(serializedValues, valueSerializer);
 		assertEquals(expectedValues, actualValues);
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>108039</refactoring_id><commit_sha>592038a30424713a731ede43000a169762b074dd</commit_sha><commit_link>https://github.com/apache/cloudstack/commit/592038a30424713a731ede43000a169762b074dd</commit_link><file_path>engine/schema/src/main/java/com/cloud/configuration/ResourceLimitVO.java</file_path><description>Extract Method public ResourceLimitVO(type ResourceCount.ResourceType, max Long, ownerId long, ownerType ResourceOwnerType, tag String) extracted from public ResourceLimitVO(type ResourceCount.ResourceType, max Long, ownerId long, ownerType ResourceOwnerType) in class com.cloud.configuration.ResourceLimitVO</description><code_before>@@ -47,10 +47,13 @@ public class ResourceLimitVO implements ResourceLimit {
     @Column(name = "max")
     private Long max;
 
     public ResourceLimitVO() {
     }
 
-    public ResourceLimitVO(ResourceCount.ResourceType type, Long max, long ownerId, ResourceOwnerType ownerType) {
         this.type = type;
         this.max = max;
 
@@ -59,6 +62,11 @@ public ResourceLimitVO(ResourceCount.ResourceType type, Long max, long ownerId,
         } else if (ownerType == ResourceOwnerType.Domain) {
             this.domainId = ownerId;
         }
     }
 
     @Override
@@ -123,4 +131,12 @@ public void setAccountId(Long accountId) {
         this.accountId = accountId;
     }
 
 }
</code_before><code_after>@@ -47,10 +47,13 @@ public class ResourceLimitVO implements ResourceLimit {
     @Column(name = "max")
     private Long max;
 
+    @Column(name = "tag")
+    private String tag;
+
     public ResourceLimitVO() {
     }
 
+    public ResourceLimitVO(ResourceCount.ResourceType type, Long max, long ownerId, ResourceOwnerType ownerType, String tag) {
         this.type = type;
         this.max = max;
 
@@ -59,6 +62,11 @@ public ResourceLimitVO(ResourceCount.ResourceType type, Long max, long ownerId,
         } else if (ownerType == ResourceOwnerType.Domain) {
             this.domainId = ownerId;
         }
+        this.tag = tag;
+    }
+
+    public ResourceLimitVO(ResourceCount.ResourceType type, Long max, long ownerId, ResourceOwnerType ownerType) {
+        this(type, max, ownerId, ownerType, null);
     }
 
     @Override
@@ -123,4 +131,12 @@ public void setAccountId(Long accountId) {
         this.accountId = accountId;
     }
 
+    @Override
+    public String getTag() {
+        return tag;
+    }
+
+    public void setTag(String tag) {
+        this.tag = tag;
+    }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>111754</refactoring_id><commit_sha>70a3f661c467e670b0769abd1d0a03d77a45b910</commit_sha><commit_link>https://github.com/apache/flink/commit/70a3f661c467e670b0769abd1d0a03d77a45b910</commit_link><file_path>flink-state-backends/flink-statebackend-changelog/src/test/java/org/apache/flink/state/changelog/ChangelogStateBackendTestUtils.java</file_path><description>Extract Method private materialize(keyedBackend ChangelogKeyedStateBackend&lt;Integer&gt;, periodicMaterializationManager PeriodicMaterializationManager) : void extracted from public testMaterializedRestore(stateBackend StateBackend, stateTtlConfig StateTtlConfig, env Environment, streamFactory CheckpointStreamFactory) : void in class org.apache.flink.state.changelog.ChangelogStateBackendTestUtils</description><code_before>@@ -51,6 +51,9 @@
 import org.apache.flink.runtime.state.TestTaskStateManager;
 import org.apache.flink.runtime.state.VoidNamespace;
 import org.apache.flink.runtime.state.VoidNamespaceSerializer;
 import org.apache.flink.runtime.state.ttl.TtlTimeProvider;
 import org.apache.flink.runtime.testutils.statemigration.TestType;
 import org.apache.flink.util.CloseableIterator;
@@ -173,19 +176,15 @@ public static void testMaterializedRestore(
             keyedBackend.setCurrentKey(2);
             state.update(new StateBackendTestBase.TestPojo("u2", 2));
 
-            // In this test, every materialization is triggered explicitly by calling
-            // triggerMaterialization.
-            // Automatic/periodic triggering is disabled by NOT starting the
-            // periodicMaterializationManager
-            periodicMaterializationManager.triggerMaterialization();
 
             keyedBackend.setCurrentKey(2);
             state.update(new StateBackendTestBase.TestPojo("u2", 22));
 
             keyedBackend.setCurrentKey(3);
             state.update(new StateBackendTestBase.TestPojo("u3", 3));
 
-            periodicMaterializationManager.triggerMaterialization();
 
             keyedBackend.setCurrentKey(4);
             state.update(new StateBackendTestBase.TestPojo("u4", 4));
@@ -237,6 +236,24 @@ public static void testMaterializedRestore(
         }
     }
 
     public static void testMaterializedRestoreForPriorityQueue(
             StateBackend stateBackend, Environment env, CheckpointStreamFactory streamFactory)
             throws Exception {
@@ -269,12 +286,12 @@ public static void testMaterializedRestoreForPriorityQueue(
 
             assertThat(actualList, containsInAnyOrder(elementA100, elementA10, elementA20));
 
-            periodicMaterializationManager.triggerMaterialization();
 
             TestType elementB9 = new TestType("b", 9);
             assertTrue(priorityQueue.add(elementB9));
 
-            periodicMaterializationManager.triggerMaterialization();
 
             TestType elementC9 = new TestType("c", 9);
             TestType elementC8 = new TestType("c", 8);
</code_before><code_after>@@ -51,6 +51,9 @@
 import org.apache.flink.runtime.state.TestTaskStateManager;
 import org.apache.flink.runtime.state.VoidNamespace;
 import org.apache.flink.runtime.state.VoidNamespaceSerializer;
+import org.apache.flink.runtime.state.changelog.ChangelogStateHandle;
+import org.apache.flink.runtime.state.changelog.SequenceNumber;
+import org.apache.flink.runtime.state.changelog.StateChangelogWriter;
 import org.apache.flink.runtime.state.ttl.TtlTimeProvider;
 import org.apache.flink.runtime.testutils.statemigration.TestType;
 import org.apache.flink.util.CloseableIterator;
@@ -173,19 +176,15 @@ public static void testMaterializedRestore(
             keyedBackend.setCurrentKey(2);
             state.update(new StateBackendTestBase.TestPojo("u2", 2));
 
+            materialize(keyedBackend, periodicMaterializationManager);
 
             keyedBackend.setCurrentKey(2);
             state.update(new StateBackendTestBase.TestPojo("u2", 22));
 
             keyedBackend.setCurrentKey(3);
             state.update(new StateBackendTestBase.TestPojo("u3", 3));
 
+            materialize(keyedBackend, periodicMaterializationManager);
 
             keyedBackend.setCurrentKey(4);
             state.update(new StateBackendTestBase.TestPojo("u4", 4));
@@ -237,6 +236,24 @@ public static void testMaterializedRestore(
         }
     }
 
+    /**
+     * Explicitly trigger materialization. Materialization is expected to complete before returning
+     * from this method by the use of direct executor when constructing materializer.
+     * Automatic/periodic triggering is disabled by NOT starting the periodicMaterializationManager.
+     *
+     * &lt;p&gt;Additionally, verify changelog truncation happened upon completion.
+     */
+    private static void materialize(
+            ChangelogKeyedStateBackend&lt;Integer&gt; keyedBackend,
+            PeriodicMaterializationManager periodicMaterializationManager) {
+        StateChangelogWriter&lt;ChangelogStateHandle&gt; writer = keyedBackend.getChangelogWriter();
+        SequenceNumber sqnBefore = writer.lastAppendedSequenceNumber();
+        periodicMaterializationManager.triggerMaterialization();
+        assertTrue(
+                "Materialization didn't truncate the changelog",
+                sqnBefore.compareTo(writer.getLowestSequenceNumber()) &lt;= 0);
+    }
+
     public static void testMaterializedRestoreForPriorityQueue(
             StateBackend stateBackend, Environment env, CheckpointStreamFactory streamFactory)
             throws Exception {
@@ -269,12 +286,12 @@ public static void testMaterializedRestoreForPriorityQueue(
 
             assertThat(actualList, containsInAnyOrder(elementA100, elementA10, elementA20));
 
+            materialize(keyedBackend, periodicMaterializationManager);
 
             TestType elementB9 = new TestType("b", 9);
             assertTrue(priorityQueue.add(elementB9));
 
+            materialize(keyedBackend, periodicMaterializationManager);
 
             TestType elementC9 = new TestType("c", 9);
             TestType elementC8 = new TestType("c", 8);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>56876</refactoring_id><commit_sha>054d9548bce3fa432fc72792844427fa6cd48865</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/054d9548bce3fa432fc72792844427fa6cd48865</commit_link><file_path>osmorc/src_test/org/osmorc/TestUtil.java</file_path><description>Extract Method public createOsmorcFacetForModule(module Module, isManifestGenerated boolean) : void extracted from public createOsmorcFacetForModule(project Project, moduleName String) : void in class org.osmorc.TestUtil</description><code_before>@@ -43,27 +43,25 @@
 import com.intellij.openapi.vfs.VirtualFileManager;
 import com.intellij.psi.*;
 import com.intellij.testFramework.fixtures.IdeaProjectTestFixture;
-import com.intellij.testFramework.fixtures.IdeaTestFixtureFactory;
 import com.intellij.testFramework.fixtures.TestFixtureBuilder;
 import com.intellij.util.io.ZipUtil;
 import org.jdom.JDOMException;
 import org.osmorc.facet.OsmorcFacet;
 
 import java.io.File;
 import java.io.FileFilter;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 
 /**
  * @author Robert F. Beeger (robert@beeger.net)
  */
 public class TestUtil {
     public static IdeaProjectTestFixture createTestFixture() {
-        TestFixtureBuilder&lt;IdeaProjectTestFixture&gt; fixtureBuilder =
-                IdeaTestFixtureFactory.getFixtureFactory().createFixtureBuilder();
 
         return fixtureBuilder.getFixture();
     }
@@ -133,21 +131,36 @@ public void run() {
         });
     }
 
-    public static void createOsmorcFacetForModule(final Project project, final String moduleName) {
         ApplicationManager.getApplication().runWriteAction(new Runnable() {
             public void run() {
-                final Module module = ModuleManager.getInstance(project).findModuleByName(moduleName);
                 final ModifiableFacetModel modifiableFacetModel = FacetManager.getInstance(module).createModifiableModel();
                 final OsmorcFacet facet = new OsmorcFacet(module);
                 facet.getConfiguration().setUseProjectDefaultManifestFileLocation(false);
                 facet.getConfiguration().setManifestLocation("META-INF");
-                facet.getConfiguration().setOsmorcControlsManifest(false);
                 modifiableFacetModel.addFacet(facet);
                 modifiableFacetModel.commit();
             }
         });
     }
 
     public static void createModuleDependency(final Project project, final String fromModuleName, final String toModuleName) {
         ApplicationManager.getApplication().runWriteAction(new Runnable() {
             public void run() {
</code_before><code_after>@@ -43,27 +43,25 @@
 import com.intellij.openapi.vfs.VirtualFileManager;
 import com.intellij.psi.*;
 import com.intellij.testFramework.fixtures.IdeaProjectTestFixture;
+import com.intellij.testFramework.fixtures.JavaTestFixtureFactory;
 import com.intellij.testFramework.fixtures.TestFixtureBuilder;
 import com.intellij.util.io.ZipUtil;
 import org.jdom.JDOMException;
 import org.osmorc.facet.OsmorcFacet;
+import org.osmorc.facet.OsmorcFacetType;
 
 import java.io.File;
 import java.io.FileFilter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * @author Robert F. Beeger (robert@beeger.net)
  */
 public class TestUtil {
     public static IdeaProjectTestFixture createTestFixture() {
+        TestFixtureBuilder&lt;IdeaProjectTestFixture&gt; fixtureBuilder = JavaTestFixtureFactory.createFixtureBuilder();
 
         return fixtureBuilder.getFixture();
     }
@@ -133,21 +131,36 @@ public void run() {
         });
     }
 
+    public static void createOsmorcFacetForModule(final Project project, final String moduleName, boolean isManifestGenerated) {
+        final Module module = ModuleManager.getInstance(project).findModuleByName(moduleName);
+        createOsmorcFacetForModule(module, isManifestGenerated);
+    }
+
+    public static void createOsmorcFacetForModule(final Module module, final boolean isManifestGenerated) {
         ApplicationManager.getApplication().runWriteAction(new Runnable() {
             public void run() {
                 final ModifiableFacetModel modifiableFacetModel = FacetManager.getInstance(module).createModifiableModel();
                 final OsmorcFacet facet = new OsmorcFacet(module);
                 facet.getConfiguration().setUseProjectDefaultManifestFileLocation(false);
                 facet.getConfiguration().setManifestLocation("META-INF");
+                facet.getConfiguration().setOsmorcControlsManifest(isManifestGenerated);
                 modifiableFacetModel.addFacet(facet);
                 modifiableFacetModel.commit();
             }
         });
     }
 
+    public static void removeOsmorcFacetOfModule(final Module module) {
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            public void run() {
+                final ModifiableFacetModel modifiableFacetModel = FacetManager.getInstance(module).createModifiableModel();
+                OsmorcFacet facet = modifiableFacetModel.getFacetByType(OsmorcFacetType.ID);
+                modifiableFacetModel.removeFacet(facet);
+                modifiableFacetModel.commit();
+            }
+        });
+    }
+
     public static void createModuleDependency(final Project project, final String fromModuleName, final String toModuleName) {
         ApplicationManager.getApplication().runWriteAction(new Runnable() {
             public void run() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>90309</refactoring_id><commit_sha>a9e2f5abb3c21d9721939c625ffb0caabb34e8d9</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/a9e2f5abb3c21d9721939c625ffb0caabb34e8d9</commit_link><file_path>src/com/android/launcher3/model/GridSizeMigrationTask.java</file_path><description>Extract Method protected queryWorkspace(columns String[], where String) : Cursor extracted from private loadWorkspaceEntries(screen long) : ArrayList&lt;DbEntry&gt; in class com.android.launcher3.model.GridSizeMigrationTask</description><code_before>@@ -7,6 +7,7 @@
 import android.content.Intent;
 import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
 import android.database.Cursor;
 import android.graphics.Point;
 import android.net.Uri;
@@ -26,6 +27,7 @@
 import com.android.launcher3.backup.nano.BackupProtos;
 import com.android.launcher3.compat.AppWidgetManagerCompat;
 import com.android.launcher3.compat.PackageInstallerCompat;
 import com.android.launcher3.util.GridOccupancy;
 import com.android.launcher3.util.LongArrayMap;
 
@@ -66,9 +68,9 @@ public class GridSizeMigrationTask {
 
     private final HashMap&lt;String, Point&gt; mWidgetMinSize = new HashMap&lt;&gt;();
     private final ContentValues mTempValues = new ContentValues();
-    private final ArrayList&lt;Long&gt; mEntryToRemove = new ArrayList&lt;&gt;();
     private final ArrayList&lt;ContentProviderOperation&gt; mUpdateOperations = new ArrayList&lt;&gt;();
-    private final ArrayList&lt;DbEntry&gt; mCarryOver = new ArrayList&lt;&gt;();
     private final HashSet&lt;String&gt; mValidPackages;
 
     private final int mSrcX, mSrcY;
@@ -269,9 +271,10 @@ protected boolean migrateWorkspace() throws Exception {
      *   3) If all those items from the above list can be placed on this screen, place them
      *      (otherwise they are placed on a new screen).
      */
-    private void migrateScreen(long screenId) {
         // If we are migrating the first screen, do not touch the first row.
-        int startY = screenId == Workspace.FIRST_SCREEN_ID ? 1 : 0;
 
         ArrayList&lt;DbEntry&gt; items = loadWorkspaceEntries(screenId);
 
@@ -366,7 +369,7 @@ private void migrateScreen(long screenId) {
     /**
      * Updates an item in the DB.
      */
-    private void update(DbEntry item) {
         mTempValues.clear();
         item.addToContentValues(mTempValues);
         mUpdateOperations.add(ContentProviderOperation
@@ -677,8 +680,8 @@ private ArrayList&lt;DbEntry&gt; loadHotseatEntries() {
     /**
      * Loads entries for a particular screen id.
      */
-    private ArrayList&lt;DbEntry&gt; loadWorkspaceEntries(long screen) {
-        Cursor c =  mContext.getContentResolver().query(LauncherSettings.Favorites.CONTENT_URI,
                 new String[]{
                         Favorites._ID,                  // 0
                         Favorites.ITEM_TYPE,            // 1
@@ -690,7 +693,7 @@ private ArrayList&lt;DbEntry&gt; loadWorkspaceEntries(long screen) {
                         Favorites.APPWIDGET_PROVIDER,   // 7
                         Favorites.APPWIDGET_ID},        // 8
                 Favorites.CONTAINER + " = " + Favorites.CONTAINER_DESKTOP
-                        + " AND " + Favorites.SCREEN + " = " + screen, null, null, null);
 
         final int indexId = c.getColumnIndexOrThrow(Favorites._ID);
         final int indexItemType = c.getColumnIndexOrThrow(Favorites.ITEM_TYPE);
@@ -776,9 +779,9 @@ private ArrayList&lt;DbEntry&gt; loadWorkspaceEntries(long screen) {
      * @return the number of valid items in the folder.
      */
     private int getFolderItemsCount(long folderId) {
-        Cursor c =  mContext.getContentResolver().query(LauncherSettings.Favorites.CONTENT_URI,
                 new String[]{Favorites._ID, Favorites.INTENT},
-                Favorites.CONTAINER + " = " + folderId, null, null, null);
 
         int total = 0;
         while (c.moveToNext()) {
@@ -793,6 +796,11 @@ private int getFolderItemsCount(long folderId) {
         return total;
     }
 
     /**
      * Verifies if the intent should be restored.
      */
@@ -815,7 +823,7 @@ private void verifyPackage(String packageName) throws Exception {
         }
     }
 
-    private static class DbEntry extends ItemInfo implements Comparable&lt;DbEntry&gt; {
 
         public float weight;
 
@@ -913,18 +921,7 @@ public static boolean migrateGridIfNeeded(Context context) {
         try {
             boolean dbChanged = false;
 
-            // Initialize list of valid packages. This contain all the packages which are already on
-            // the device and packages which are being installed. Any item which doesn't belong to
-            // this set is removed.
-            // Since the loader removes such items anyway, removing these items here doesn't cause
-            // any extra data loss and gives us more free space on the grid for better migration.
-            HashSet validPackages = new HashSet&lt;&gt;();
-            for (PackageInfo info : context.getPackageManager().getInstalledPackages(0)) {
-                validPackages.add(info.packageName);
-            }
-            validPackages.addAll(PackageInstallerCompat.getInstance(context)
-                    .updateAndGetActiveSessionCache().keySet());
-
             // Hotseat
             Point srcHotseatSize = parsePoint(prefs.getString(
                     KEY_MIGRATION_SRC_HOTSEAT_SIZE, hotseatSizeString));
@@ -1022,4 +1019,20 @@ public static boolean migrateGridIfNeeded(Context context) {
                     .apply();
         }
     }
 }
</code_before><code_after>@@ -7,6 +7,7 @@
 import android.content.Intent;
 import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.graphics.Point;
 import android.net.Uri;
@@ -26,6 +27,7 @@
 import com.android.launcher3.backup.nano.BackupProtos;
 import com.android.launcher3.compat.AppWidgetManagerCompat;
 import com.android.launcher3.compat.PackageInstallerCompat;
+import com.android.launcher3.config.FeatureFlags;
 import com.android.launcher3.util.GridOccupancy;
 import com.android.launcher3.util.LongArrayMap;
 
@@ -66,9 +68,9 @@ public class GridSizeMigrationTask {
 
     private final HashMap&lt;String, Point&gt; mWidgetMinSize = new HashMap&lt;&gt;();
     private final ContentValues mTempValues = new ContentValues();
+    protected final ArrayList&lt;Long&gt; mEntryToRemove = new ArrayList&lt;&gt;();
     private final ArrayList&lt;ContentProviderOperation&gt; mUpdateOperations = new ArrayList&lt;&gt;();
+    protected final ArrayList&lt;DbEntry&gt; mCarryOver = new ArrayList&lt;&gt;();
     private final HashSet&lt;String&gt; mValidPackages;
 
     private final int mSrcX, mSrcY;
@@ -269,9 +271,10 @@ protected boolean migrateWorkspace() throws Exception {
      *   3) If all those items from the above list can be placed on this screen, place them
      *      (otherwise they are placed on a new screen).
      */
+    protected void migrateScreen(long screenId) {
         // If we are migrating the first screen, do not touch the first row.
+        int startY = (FeatureFlags.QSB_ON_FIRST_SCREEN &amp;&amp; screenId == Workspace.FIRST_SCREEN_ID)
+                ? 1 : 0;
 
         ArrayList&lt;DbEntry&gt; items = loadWorkspaceEntries(screenId);
 
@@ -366,7 +369,7 @@ private void migrateScreen(long screenId) {
     /**
      * Updates an item in the DB.
      */
+    protected void update(DbEntry item) {
         mTempValues.clear();
         item.addToContentValues(mTempValues);
         mUpdateOperations.add(ContentProviderOperation
@@ -677,8 +680,8 @@ private ArrayList&lt;DbEntry&gt; loadHotseatEntries() {
     /**
      * Loads entries for a particular screen id.
      */
+    protected ArrayList&lt;DbEntry&gt; loadWorkspaceEntries(long screen) {
+        Cursor c = queryWorkspace(
                 new String[]{
                         Favorites._ID,                  // 0
                         Favorites.ITEM_TYPE,            // 1
@@ -690,7 +693,7 @@ private ArrayList&lt;DbEntry&gt; loadWorkspaceEntries(long screen) {
                         Favorites.APPWIDGET_PROVIDER,   // 7
                         Favorites.APPWIDGET_ID},        // 8
                 Favorites.CONTAINER + " = " + Favorites.CONTAINER_DESKTOP
+                        + " AND " + Favorites.SCREEN + " = " + screen);
 
         final int indexId = c.getColumnIndexOrThrow(Favorites._ID);
         final int indexItemType = c.getColumnIndexOrThrow(Favorites.ITEM_TYPE);
@@ -776,9 +779,9 @@ private ArrayList&lt;DbEntry&gt; loadWorkspaceEntries(long screen) {
      * @return the number of valid items in the folder.
      */
     private int getFolderItemsCount(long folderId) {
+        Cursor c = queryWorkspace(
                 new String[]{Favorites._ID, Favorites.INTENT},
+                Favorites.CONTAINER + " = " + folderId);
 
         int total = 0;
         while (c.moveToNext()) {
@@ -793,6 +796,11 @@ private int getFolderItemsCount(long folderId) {
         return total;
     }
 
+    protected Cursor queryWorkspace(String[] columns, String where) {
+        return mContext.getContentResolver().query(LauncherSettings.Favorites.CONTENT_URI,
+                columns, where, null, null, null);
+    }
+
     /**
      * Verifies if the intent should be restored.
      */
@@ -815,7 +823,7 @@ private void verifyPackage(String packageName) throws Exception {
         }
     }
 
+    protected static class DbEntry extends ItemInfo implements Comparable&lt;DbEntry&gt; {
 
         public float weight;
 
@@ -913,18 +921,7 @@ public static boolean migrateGridIfNeeded(Context context) {
         try {
             boolean dbChanged = false;
 
+            HashSet validPackages = getValidPackages(context);
             // Hotseat
             Point srcHotseatSize = parsePoint(prefs.getString(
                     KEY_MIGRATION_SRC_HOTSEAT_SIZE, hotseatSizeString));
@@ -1022,4 +1019,20 @@ public static boolean migrateGridIfNeeded(Context context) {
                     .apply();
         }
     }
+
+    protected static HashSet&lt;String&gt; getValidPackages(Context context) {
+        // Initialize list of valid packages. This contain all the packages which are already on
+        // the device and packages which are being installed. Any item which doesn't belong to
+        // this set is removed.
+        // Since the loader removes such items anyway, removing these items here doesn't cause
+        // any extra data loss and gives us more free space on the grid for better migration.
+        HashSet validPackages = new HashSet&lt;&gt;();
+        for (PackageInfo info : context.getPackageManager()
+                .getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES)) {
+            validPackages.add(info.packageName);
+        }
+        validPackages.addAll(PackageInstallerCompat.getInstance(context)
+                .updateAndGetActiveSessionCache().keySet());
+        return validPackages;
+    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>22049</refactoring_id><commit_sha>5a6d48c017324ae9df8767dfd940b489d9452adb</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/5a6d48c017324ae9df8767dfd940b489d9452adb</commit_link><file_path>enterprise/runtime/neole/src/test/java/org/neo4j/impl/store/prototype/neole/PropertyCursorTest.java</file_path><description>Extract Method private createNodeWithProperty(graphDb GraphDatabaseService, propertyKey String, value Object) : long extracted from protected create(graphDb GraphDatabaseService) : void in class org.neo4j.impl.store.prototype.neole.PropertyCursorTest.graph.withConfig.new GraphSetup</description><code_before>@@ -35,7 +35,8 @@
 
 public class PropertyCursorTest
 {
-    private static long bare, intProp;
 
     @ClassRule
     public static final GraphSetup graph = new GraphSetup()
@@ -47,13 +48,27 @@ protected void create( GraphDatabaseService graphDb )
             {
                 bare = graphDb.createNode().getId();
 
-                Node p = graphDb.createNode();
-                p.setProperty( "intProp", 1 );
-                intProp = p.getId();
 
                 tx.success();
             }
         }
     }
             .withConfig( dense_node_threshold, "1" );
 
@@ -81,24 +96,35 @@ public void shouldNotAccessNonExistentProperties() throws Exception
 
     @Test
     public void shouldAccessIntProperty() throws Exception
     {
         // given
         try ( NodeCursor node = graph.allocateNodeCursor();
                 PropertyCursor props = graph.allocatePropertyCursor() )
         {
             // when
-            graph.singleNode( intProp, node );
             assertTrue( "node by reference", node.next() );
             assertTrue( "has properties", node.hasProperties() );
 
             node.properties( props );
             assertTrue( "has properties by direct method", props.next() );
-            assertEquals( "correct value", 1, props.propertyValue() );
             assertFalse( "single property", props.next() );
 
             graph.nodeProperties( node.propertiesReference(), props );
             assertTrue( "has properties via property ref", props.next() );
-            assertEquals( "correct value", 1, props.propertyValue() );
             assertFalse( "single property", props.next() );
         }
     }
</code_before><code_after>@@ -35,7 +35,8 @@
 
 public class PropertyCursorTest
 {
+    private static long bare, byteProp, shortProp, intProp, inlineLongProp, longProp,
+            floatProp, doubleProp, trueProp, falseProp;
 
     @ClassRule
     public static final GraphSetup graph = new GraphSetup()
@@ -47,13 +48,27 @@ protected void create( GraphDatabaseService graphDb )
             {
                 bare = graphDb.createNode().getId();
 
+                byteProp = createNodeWithProperty( graphDb, "byteProp", (byte)13 );
+                shortProp = createNodeWithProperty( graphDb, "shortProp", (short)13 );
+                intProp = createNodeWithProperty( graphDb, "intProp", 13 );
+                inlineLongProp = createNodeWithProperty( graphDb, "inlineLongProp", 13L );
+
+                floatProp = createNodeWithProperty( graphDb, "floatProp", 13.0f );
+                doubleProp = createNodeWithProperty( graphDb, "doubleProp", 13.0 );
+
+                trueProp = createNodeWithProperty( graphDb, "trueProp", true );
+                falseProp = createNodeWithProperty( graphDb, "falseProp", false );
 
                 tx.success();
             }
         }
+
+        private long createNodeWithProperty( GraphDatabaseService graphDb, String propertyKey, Object value )
+        {
+            Node p = graphDb.createNode();
+            p.setProperty( propertyKey, value );
+            return p.getId();
+        }
     }
             .withConfig( dense_node_threshold, "1" );
 
@@ -81,24 +96,35 @@ public void shouldNotAccessNonExistentProperties() throws Exception
 
     @Test
     public void shouldAccessIntProperty() throws Exception
+    {
+        assertAccessSingleProperty( byteProp, (byte)13 );
+        assertAccessSingleProperty( shortProp, (short)13 );
+        assertAccessSingleProperty( intProp, 13 );
+        assertAccessSingleProperty( inlineLongProp, 13L );
+        assertAccessSingleProperty( floatProp, 13.0f );
+        assertAccessSingleProperty( trueProp, true );
+        assertAccessSingleProperty( falseProp, false );
+    }
+
+    private void assertAccessSingleProperty( long nodeId, Object expectedValue )
     {
         // given
         try ( NodeCursor node = graph.allocateNodeCursor();
                 PropertyCursor props = graph.allocatePropertyCursor() )
         {
             // when
+            graph.singleNode( nodeId, node );
             assertTrue( "node by reference", node.next() );
             assertTrue( "has properties", node.hasProperties() );
 
             node.properties( props );
             assertTrue( "has properties by direct method", props.next() );
+            assertEquals( "correct value", expectedValue, props.propertyValue() );
             assertFalse( "single property", props.next() );
 
             graph.nodeProperties( node.propertiesReference(), props );
             assertTrue( "has properties via property ref", props.next() );
+            assertEquals( "correct value", expectedValue, props.propertyValue() );
             assertFalse( "single property", props.next() );
         }
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>77940</refactoring_id><commit_sha>6141b9b40ca0f5b953bedd9522e43c631623a44c</commit_sha><commit_link>https://github.com/apache/poi/commit/6141b9b40ca0f5b953bedd9522e43c631623a44c</commit_link><file_path>src/scratchpad/src/org/apache/poi/hwmf/draw/HwmfSLImageRenderer.java</file_path><description>Extract Method public getImage(dim Dimension) : BufferedImage extracted from public getImage() : BufferedImage in class org.apache.poi.hwmf.draw.HwmfSLImageRenderer</description><code_before>@@ -72,18 +72,22 @@ public void setAlpha(double alpha) {
 
     @Override
     public BufferedImage getImage() {
         if (image == null) {
             return new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB); 
         }
         
-        Dimension dim = getDimension();
         BufferedImage bufImg = new BufferedImage((int)dim.getWidth(), (int)dim.getHeight(), BufferedImage.TYPE_INT_ARGB);
         Graphics2D g = bufImg.createGraphics();
         g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
         g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
         g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
-        image.draw(g);
         g.dispose();
         
         if (alpha != 0) {
@@ -97,7 +101,7 @@ public BufferedImage getImage() {
         
         return bufImg;
     }
-
     @Override
     public boolean drawImage(Graphics2D graphics, Rectangle2D anchor) {
         return drawImage(graphics, anchor, null);
</code_before><code_after>@@ -72,18 +72,22 @@ public void setAlpha(double alpha) {
 
     @Override
     public BufferedImage getImage() {
+        return getImage(getDimension());
+    }
+
+    @Override
+    public BufferedImage getImage(Dimension dim) {
         if (image == null) {
             return new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB); 
         }
         
         BufferedImage bufImg = new BufferedImage((int)dim.getWidth(), (int)dim.getHeight(), BufferedImage.TYPE_INT_ARGB);
         Graphics2D g = bufImg.createGraphics();
         g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
         g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
         g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
+        image.draw(g, new Rectangle2D.Double(0,0,dim.getWidth(),dim.getHeight()));
         g.dispose();
         
         if (alpha != 0) {
@@ -97,7 +101,7 @@ public BufferedImage getImage() {
         
         return bufImg;
     }
+    
     @Override
     public boolean drawImage(Graphics2D graphics, Rectangle2D anchor) {
         return drawImage(graphics, anchor, null);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>111264</refactoring_id><commit_sha>65a0a67beeea7a451821fa86dda49e1cde849672</commit_sha><commit_link>https://github.com/apereo/cas/commit/65a0a67beeea7a451821fa86dda49e1cde849672</commit_link><file_path>support/cas-server-support-throttle-jdbc/src/main/java/org/apereo/cas/web/support/InspektrThrottledSubmissionByIpAddressAndUsernameHandlerInterceptorAdapter.java</file_path><description>Extract Method protected recordAnyAction(request HttpServletRequest, actionName String, methodName String) : void extracted from protected recordThrottle(request HttpServletRequest) : void in class org.apereo.cas.web.support.InspektrThrottledSubmissionByIpAddressAndUsernameHandlerInterceptorAdapter</description><code_before>@@ -35,7 +35,8 @@ public class InspektrThrottledSubmissionByIpAddressAndUsernameHandlerInterceptor
     
     private static final double NUMBER_OF_MILLISECONDS_IN_SECOND = 1000.0;
 
-    private static final String INSPEKTR_ACTION = "THROTTLED_LOGIN_ATTEMPT";
     
     private final AuditTrailManager auditTrailManager;
     private final DataSource dataSource;
@@ -103,27 +104,39 @@ public boolean exceedsThreshold(final HttpServletRequest request) {
 
     @Override
     public void recordSubmissionFailure(final HttpServletRequest request) {
-        recordThrottle(request);
     }
 
     @Override
     protected void recordThrottle(final HttpServletRequest request) {
         if (this.dataSource != null &amp;&amp; this.jdbcTemplate != null) {
-            super.recordThrottle(request);
             final String userToUse = constructUsername(request, getUsernameParameter());
             final ClientInfo clientInfo = ClientInfoHolder.getClientInfo();
             final AuditPointRuntimeInfo auditPointRuntimeInfo = new AuditPointRuntimeInfo() {
                 private static final long serialVersionUID = 1L;
 
                 @Override
                 public String asString() {
-                    return String.format("%s.recordThrottle()", this.getClass().getName());
                 }
             };
             final AuditActionContext context = new AuditActionContext(
                     userToUse,
                     userToUse,
-                    INSPEKTR_ACTION,
                     this.applicationCode,
                     DateTimeUtils.dateOf(ZonedDateTime.now(ZoneOffset.UTC)),
                     clientInfo.getClientIpAddress(),
</code_before><code_after>@@ -35,7 +35,8 @@ public class InspektrThrottledSubmissionByIpAddressAndUsernameHandlerInterceptor
     
     private static final double NUMBER_OF_MILLISECONDS_IN_SECOND = 1000.0;
 
+    private static final String INSPEKTR_ACTION_THROTTLED = "THROTTLED_LOGIN_ATTEMPT";
+    private static final String INSPEKTR_ACTION_FAILED = "FAILED_LOGIN_ATTEMPT";
     
     private final AuditTrailManager auditTrailManager;
     private final DataSource dataSource;
@@ -103,27 +104,39 @@ public boolean exceedsThreshold(final HttpServletRequest request) {
 
     @Override
     public void recordSubmissionFailure(final HttpServletRequest request) {
+        super.recordSubmissionFailure(request);
+        recordAnyAction(request, INSPEKTR_ACTION_FAILED, "recordSubmissionFailure()");
     }
 
     @Override
     protected void recordThrottle(final HttpServletRequest request) {
+        super.recordThrottle(request);
+        recordAnyAction(request, INSPEKTR_ACTION_THROTTLED, "recordThrottle()");
+    }
+
+    /**
+     * Records an audit action.
+     * 
+     * @param request The current HTTP request.
+     * @param actionName Name of the action to be recorded.
+     * @param methodName Name of the method where the action occurred.
+     */
+    protected void recordAnyAction(final HttpServletRequest request, final String actionName, final String methodName) {
         if (this.dataSource != null &amp;&amp; this.jdbcTemplate != null) {
             final String userToUse = constructUsername(request, getUsernameParameter());
             final ClientInfo clientInfo = ClientInfoHolder.getClientInfo();
             final AuditPointRuntimeInfo auditPointRuntimeInfo = new AuditPointRuntimeInfo() {
                 private static final long serialVersionUID = 1L;
 
                 @Override
                 public String asString() {
+                    return String.format("%s.%s", this.getClass().getName(), methodName);
                 }
             };
             final AuditActionContext context = new AuditActionContext(
                     userToUse,
                     userToUse,
+                    actionName,
                     this.applicationCode,
                     DateTimeUtils.dateOf(ZonedDateTime.now(ZoneOffset.UTC)),
                     clientInfo.getClientIpAddress(),
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>29178</refactoring_id><commit_sha>83c5105e715fe84ffdc145c088f0541a22226d31</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/83c5105e715fe84ffdc145c088f0541a22226d31</commit_link><file_path>jetty-http2/http2-common/src/main/java/org/eclipse/jetty/http2/generator/PriorityGenerator.java</file_path><description>Extract Method public generatePriorityBody(header ByteBuffer, streamId int, parentStreamId int, weight int, exclusive boolean) : void extracted from public generatePriority(lease ByteBufferPool.Lease, streamId int, parentStreamId int, weight int, exclusive boolean) : void in class org.eclipse.jetty.http2.generator.PriorityGenerator</description><code_before>@@ -42,22 +42,27 @@ public void generate(ByteBufferPool.Lease lease, Frame frame)
     }
 
     public void generatePriority(ByteBufferPool.Lease lease, int streamId, int parentStreamId, int weight, boolean exclusive)
     {
         if (streamId &lt; 0)
             throw new IllegalArgumentException("Invalid stream id: " + streamId);
         if (parentStreamId &lt; 0)
             throw new IllegalArgumentException("Invalid parent stream id: " + parentStreamId);
-
-        ByteBuffer header = generateHeader(lease, FrameType.PRIORITY, 5, Flags.NONE, streamId);
 
         if (exclusive)
             parentStreamId |= 0x80_00_00_00;
-
         header.putInt(parentStreamId);
-
-        header.put((byte)weight);
-
-        BufferUtil.flipToFlush(header, 0);
-        lease.append(header, true);
     }
 }
</code_before><code_after>@@ -42,22 +42,27 @@ public void generate(ByteBufferPool.Lease lease, Frame frame)
     }
 
     public void generatePriority(ByteBufferPool.Lease lease, int streamId, int parentStreamId, int weight, boolean exclusive)
+    {
+        ByteBuffer header = generateHeader(lease, FrameType.PRIORITY, PriorityFrame.PRIORITY_LENGTH, Flags.NONE, streamId);
+        generatePriorityBody(header, streamId, parentStreamId, weight, exclusive);
+        BufferUtil.flipToFlush(header, 0);
+        lease.append(header, true);
+    }
+
+    public void generatePriorityBody(ByteBuffer header, int streamId, int parentStreamId, int weight, boolean exclusive)
     {
         if (streamId &lt; 0)
             throw new IllegalArgumentException("Invalid stream id: " + streamId);
         if (parentStreamId &lt; 0)
             throw new IllegalArgumentException("Invalid parent stream id: " + parentStreamId);
+        if (parentStreamId == streamId)
+            throw new IllegalArgumentException("Stream " + streamId + " cannot depend on stream " + parentStreamId);
+        if (weight &lt; 1 || weight &gt; 256)
+            throw new IllegalArgumentException("Invalid weight: " + weight);
 
         if (exclusive)
             parentStreamId |= 0x80_00_00_00;
         header.putInt(parentStreamId);
+        header.put((byte)(weight - 1));
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>123696</refactoring_id><commit_sha>a448094b3a91c62ef6da00429e8d7c207858a056</commit_sha><commit_link>https://github.com/oracle/graal/commit/a448094b3a91c62ef6da00429e8d7c207858a056</commit_link><file_path>projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/scope/LLVMSourceLocation.java</file_path><description>Extract Method private getSourceSection(context LazyContext) : SourceSection extracted from public getSourceSection() : SourceSection in class com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation</description><code_before>@@ -32,8 +32,10 @@
 import com.oracle.truffle.api.CompilerAsserts;
 import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
 import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
 import com.oracle.truffle.api.source.Source;
 import com.oracle.truffle.api.source.SourceSection;
 import com.oracle.truffle.llvm.runtime.global.LLVMGlobal;
 
 import java.nio.file.InvalidPathException;
@@ -47,8 +49,14 @@
 
 public abstract class LLVMSourceLocation {
 
     public abstract static class LazySourceSection {
-        public abstract SourceSection get();
 
         public abstract String getPath();
 
@@ -106,10 +114,26 @@ private LLVMSourceLocation(LLVMSourceLocation parent, Kind kind, String name, So
         this.sourceSection = sourceSection;
     }
 
-    public synchronized SourceSection getSourceSection() {
         CompilerAsserts.neverPartOfCompilation();
         if (sourceSection == null &amp;&amp; lazySourceSection != null) {
-            sourceSection = lazySourceSection.get();
         }
         return sourceSection != null ? sourceSection : UNAVAILABLE_SECTION;
     }
</code_before><code_after>@@ -32,8 +32,10 @@
 import com.oracle.truffle.api.CompilerAsserts;
 import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
 import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
+import com.oracle.truffle.api.TruffleLanguage.ContextReference;
 import com.oracle.truffle.api.source.Source;
 import com.oracle.truffle.api.source.SourceSection;
+import com.oracle.truffle.llvm.runtime.LLVMContext;
 import com.oracle.truffle.llvm.runtime.global.LLVMGlobal;
 
 import java.nio.file.InvalidPathException;
@@ -47,8 +49,14 @@
 
 public abstract class LLVMSourceLocation {
 
+    @FunctionalInterface
+    public interface LazyContext {
+
+        LLVMContext get();
+    }
+
     public abstract static class LazySourceSection {
+        public abstract SourceSection get(LazyContext context);
 
         public abstract String getPath();
 
@@ -106,10 +114,26 @@ private LLVMSourceLocation(LLVMSourceLocation parent, Kind kind, String name, So
         this.sourceSection = sourceSection;
     }
 
+    public synchronized SourceSection getSourceSection(ContextReference&lt;LLVMContext&gt; ctxRef) {
+        CompilerAsserts.neverPartOfCompilation();
+        return getSourceSection(() -&gt; {
+            try {
+                return ctxRef.get();
+            } catch (Throwable t) {
+                return null;
+            }
+        });
+    }
+
+    public SourceSection getSourceSection(LLVMContext context) {
+        CompilerAsserts.neverPartOfCompilation();
+        return getSourceSection(() -&gt; context);
+    }
+
+    private synchronized SourceSection getSourceSection(LazyContext context) {
         CompilerAsserts.neverPartOfCompilation();
         if (sourceSection == null &amp;&amp; lazySourceSection != null) {
+            sourceSection = lazySourceSection.get(context);
         }
         return sourceSection != null ? sourceSection : UNAVAILABLE_SECTION;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>19796</refactoring_id><commit_sha>dedfab09e95d6e917b52b2e22dbc88b367ed1195</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/dedfab09e95d6e917b52b2e22dbc88b367ed1195</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/newapi/Operations.java</file_path><description>Extract Method private assertIndexExistsForDrop(index IndexDescriptor) : void extracted from public indexDrop(index IndexDescriptor) : void in class org.neo4j.kernel.impl.newapi.Operations</description><code_before>@@ -904,14 +904,7 @@ public void indexDrop( IndexDescriptor index ) throws SchemaKernelException
         }
         exclusiveSchemaLock( index.schema() );
         exclusiveSchemaNameLock( index.getName() );
-        try
-        {
-            allStoreHolder.assertIndexExists( index );
-        }
-        catch ( IndexNotFoundKernelException e )
-        {
-            throw new DropIndexFailureException( "Unable to drop index: " + e.getUserMessage( tokenNameLookup ), e );
-        }
         if ( index.isUnique() )
         {
             if ( allStoreHolder.indexGetOwningUniquenessConstraintId( index ) != null )
@@ -923,6 +916,18 @@ public void indexDrop( IndexDescriptor index ) throws SchemaKernelException
         ktx.txState().indexDoDrop( index );
     }
 
     @Override
     public void indexDrop( SchemaDescriptor schema ) throws SchemaKernelException
     {
@@ -954,7 +959,17 @@ public void indexDrop( String indexName ) throws SchemaKernelException
         {
             throw new DropIndexFailureException( "Unable to drop index called `" + indexName + "`. There is no such index." );
         }
-        indexDrop( index );
     }
 
     @Override
@@ -1193,10 +1208,11 @@ private ConstraintDescriptor lockAndValidatePropertyExistenceConstraint( SchemaD
     }
 
     @Override
-    public void constraintDrop( SchemaDescriptor schema ) throws SchemaKernelException
     {
         ktx.assertOpen();
         Iterator&lt;ConstraintDescriptor&gt; constraints = ktx.schemaRead().constraintsGetForSchema( schema );
         if ( constraints.hasNext() )
         {
             ConstraintDescriptor constraint = constraints.next();
@@ -1209,7 +1225,7 @@ public void constraintDrop( SchemaDescriptor schema ) throws SchemaKernelExcepti
                 String schemaDescription = schema.userDescription( tokenNameLookup );
                 String constraintDescription = constraints.next().userDescription( tokenNameLookup );
                 throw new DropConstraintFailureException( constraint, new IllegalArgumentException(
-                        "More than one constraint was found with the '" + schemaDescription + "' schema: " + constraintDescription ) );
             }
         }
         else
</code_before><code_after>@@ -904,14 +904,7 @@ public void indexDrop( IndexDescriptor index ) throws SchemaKernelException
         }
         exclusiveSchemaLock( index.schema() );
         exclusiveSchemaNameLock( index.getName() );
+        assertIndexExistsForDrop( index );
         if ( index.isUnique() )
         {
             if ( allStoreHolder.indexGetOwningUniquenessConstraintId( index ) != null )
@@ -923,6 +916,18 @@ public void indexDrop( IndexDescriptor index ) throws SchemaKernelException
         ktx.txState().indexDoDrop( index );
     }
 
+    private void assertIndexExistsForDrop( IndexDescriptor index ) throws DropIndexFailureException
+    {
+        try
+        {
+            allStoreHolder.assertIndexExists( index );
+        }
+        catch ( IndexNotFoundKernelException e )
+        {
+            throw new DropIndexFailureException( "Unable to drop index: " + e.getUserMessage( tokenNameLookup ), e );
+        }
+    }
+
     @Override
     public void indexDrop( SchemaDescriptor schema ) throws SchemaKernelException
     {
@@ -954,7 +959,17 @@ public void indexDrop( String indexName ) throws SchemaKernelException
         {
             throw new DropIndexFailureException( "Unable to drop index called `" + indexName + "`. There is no such index." );
         }
+        exclusiveSchemaLock( index.schema() );
+        assertIndexExistsForDrop( index );
+        if ( index.isUnique() )
+        {
+            if ( allStoreHolder.indexGetOwningUniquenessConstraintId( index ) != null )
+            {
+                IndexBelongsToConstraintException cause = new IndexBelongsToConstraintException( indexName, index.schema() );
+                throw new DropIndexFailureException( "Unable to drop index: " + cause.getUserMessage( tokenNameLookup ), cause );
+            }
+        }
+        ktx.txState().indexDoDrop( index );
     }
 
     @Override
@@ -1193,10 +1208,11 @@ private ConstraintDescriptor lockAndValidatePropertyExistenceConstraint( SchemaD
     }
 
     @Override
+    public void constraintDrop( SchemaDescriptor schema, ConstraintType type ) throws SchemaKernelException
     {
         ktx.assertOpen();
         Iterator&lt;ConstraintDescriptor&gt; constraints = ktx.schemaRead().constraintsGetForSchema( schema );
+        constraints = Iterators.filter( constraint -&gt; constraint.type() == type, constraints );
         if ( constraints.hasNext() )
         {
             ConstraintDescriptor constraint = constraints.next();
@@ -1209,7 +1225,7 @@ public void constraintDrop( SchemaDescriptor schema ) throws SchemaKernelExcepti
                 String schemaDescription = schema.userDescription( tokenNameLookup );
                 String constraintDescription = constraints.next().userDescription( tokenNameLookup );
                 throw new DropConstraintFailureException( constraint, new IllegalArgumentException(
+                        "More than one " + type + " constraint was found with the '" + schemaDescription + "' schema: " + constraintDescription ) );
             }
         }
         else
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>28975</refactoring_id><commit_sha>ffe10f3cf8c956ac6961e22d5bd956fea9fad072</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/ffe10f3cf8c956ac6961e22d5bd956fea9fad072</commit_link><file_path>src/test/java/org/eclipse/jetty/spdy/SPDYTest.java</file_path><description>Extract Method protected newSPDYServerConnector(listener ServerSessionFrameListener) : Connector extracted from protected startServer(listener ServerSessionFrameListener) : InetSocketAddress in class org.eclipse.jetty.spdy.SPDYTest</description><code_before>@@ -8,35 +8,58 @@
 import org.eclipse.jetty.spdy.api.server.ServerSessionFrameListener;
 import org.eclipse.jetty.spdy.nio.SPDYClient;
 import org.eclipse.jetty.spdy.nio.SPDYServerConnector;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
 import org.junit.After;
 
-public class SPDYTest
 {
     private Server server;
     private SPDYClient.Factory clientFactory;
 
     protected InetSocketAddress startServer(ServerSessionFrameListener listener) throws Exception
     {
         server = new Server();
-        Connector connector = new SPDYServerConnector(listener);
         server.addConnector(connector);
         server.start();
         return new InetSocketAddress(connector.getLocalPort());
     }
 
     protected Session startClient(InetSocketAddress socketAddress, Session.FrameListener frameListener) throws Exception
     {
         if (clientFactory == null)
         {
             QueuedThreadPool threadPool = new QueuedThreadPool();
             threadPool.setName(threadPool.getName() + "-client");
-            clientFactory = new SPDYClient.Factory(threadPool);
             clientFactory.start();
         }
         return clientFactory.newSPDYClient().connect(socketAddress, frameListener).get();
     }
 
     @After
     public void destroy() throws Exception
     {
</code_before><code_after>@@ -8,35 +8,58 @@
 import org.eclipse.jetty.spdy.api.server.ServerSessionFrameListener;
 import org.eclipse.jetty.spdy.nio.SPDYClient;
 import org.eclipse.jetty.spdy.nio.SPDYServerConnector;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
+import org.eclipse.jetty.util.thread.ThreadPool;
 import org.junit.After;
 
+public abstract class SPDYTest
 {
     private Server server;
     private SPDYClient.Factory clientFactory;
 
     protected InetSocketAddress startServer(ServerSessionFrameListener listener) throws Exception
     {
         server = new Server();
+        Connector connector = newSPDYServerConnector(listener);
         server.addConnector(connector);
         server.start();
         return new InetSocketAddress(connector.getLocalPort());
     }
 
+    protected Connector newSPDYServerConnector(ServerSessionFrameListener listener)
+    {
+        return new SPDYServerConnector(listener);
+    }
+
     protected Session startClient(InetSocketAddress socketAddress, Session.FrameListener frameListener) throws Exception
     {
         if (clientFactory == null)
         {
             QueuedThreadPool threadPool = new QueuedThreadPool();
             threadPool.setName(threadPool.getName() + "-client");
+            clientFactory = newSPDYClientFactory(threadPool);
             clientFactory.start();
         }
         return clientFactory.newSPDYClient().connect(socketAddress, frameListener).get();
     }
 
+    protected SPDYClient.Factory newSPDYClientFactory(ThreadPool threadPool)
+    {
+        return new SPDYClient.Factory(threadPool);
+    }
+
+    protected SslContextFactory newSslContextFactory()
+    {
+        SslContextFactory sslContextFactory = new SslContextFactory();
+        sslContextFactory.setKeyStorePath("src/test/resources/keystore.jks");
+        sslContextFactory.setKeyStorePassword("storepwd");
+        sslContextFactory.setTrustStore("src/test/resources/truststore.jks");
+        sslContextFactory.setTrustStorePassword("storepwd");
+        sslContextFactory.setProtocol("TLSv1");
+        return sslContextFactory;
+    }
+
     @After
     public void destroy() throws Exception
     {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>77945</refactoring_id><commit_sha>a1718ca9ac52cd1b80c238faf229141608500d91</commit_sha><commit_link>https://github.com/apache/poi/commit/a1718ca9ac52cd1b80c238faf229141608500d91</commit_link><file_path>src/java/org/apache/poi/util/SystemOutLogger.java</file_path><description>Extract Method public log(level int, obj1 Object, exception Throwable) : void extracted from public log(level int, obj1 Object) : void in class org.apache.poi.util.SystemOutLogger</description><code_before>@@ -49,8 +49,24 @@ public void initialize(final String cat)
 
     public void log(final int level, final Object obj1)
     {
-        if (check(level))
             System.out.println("["+cat+"] "+obj1);
     }
 
     /**
</code_before><code_after>@@ -49,8 +49,24 @@ public void initialize(final String cat)
 
     public void log(final int level, final Object obj1)
     {
+    	log(level, obj1, null);
+    }
+    
+    /**
+     * Log a message
+     *
+     * @param level One of DEBUG, INFO, WARN, ERROR, FATAL
+     * @param obj1 The object to log.  This is converted to a string.
+     * @param exception An exception to be logged
+     */
+    public void log(final int level, final Object obj1,
+                    final Throwable exception) {
+        if (check(level)) {
             System.out.println("["+cat+"] "+obj1);
+            if(exception != null) {
+            	exception.printStackTrace(System.out);
+            }
+        }
     }
 
     /**
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>123529</refactoring_id><commit_sha>32494311b61882d58b499a0534f6bcde380a1b0e</commit_sha><commit_link>https://github.com/oracle/graal/commit/32494311b61882d58b499a0534f6bcde380a1b0e</commit_link><file_path>graal/com.oracle.graal.asm.amd64/src/com/oracle/graal/asm/amd64/AMD64Assembler.java</file_path><description>Extract Method private prefix(adr AMD64Address, reg Register, byteinst boolean) : void extracted from private prefix(adr AMD64Address, reg Register) : void in class com.oracle.graal.asm.amd64.AMD64Assembler</description><code_before>@@ -917,7 +917,7 @@ public final void movb(AMD64Address dst, int imm8) {
 
     public final void movb(AMD64Address dst, Register src) {
         assert src.getRegisterCategory() == AMD64.CPU : "must have byte register";
-        prefix(dst, src); // , true)
         emitByte(0x88);
         emitOperandHelper(src, dst);
     }
@@ -1895,6 +1895,10 @@ private void prefixq(AMD64Address adr) {
     }
 
     private void prefix(AMD64Address adr, Register reg) {
         if (reg.encoding &lt; 8) {
             if (needsRex(adr.getBase())) {
                 if (needsRex(adr.getIndex())) {
@@ -1905,7 +1909,7 @@ private void prefix(AMD64Address adr, Register reg) {
             } else {
                 if (needsRex(adr.getIndex())) {
                     emitByte(Prefix.REXX);
-                } else if (reg.encoding &gt;= 4) {
                     emitByte(Prefix.REX);
                 }
             }
</code_before><code_after>@@ -917,7 +917,7 @@ public final void movb(AMD64Address dst, int imm8) {
 
     public final void movb(AMD64Address dst, Register src) {
         assert src.getRegisterCategory() == AMD64.CPU : "must have byte register";
+        prefix(dst, src, true);
         emitByte(0x88);
         emitOperandHelper(src, dst);
     }
@@ -1895,6 +1895,10 @@ private void prefixq(AMD64Address adr) {
     }
 
     private void prefix(AMD64Address adr, Register reg) {
+        prefix(adr, reg, false);
+    }
+
+    private void prefix(AMD64Address adr, Register reg, boolean byteinst) {
         if (reg.encoding &lt; 8) {
             if (needsRex(adr.getBase())) {
                 if (needsRex(adr.getIndex())) {
@@ -1905,7 +1909,7 @@ private void prefix(AMD64Address adr, Register reg) {
             } else {
                 if (needsRex(adr.getIndex())) {
                     emitByte(Prefix.REXX);
+                } else if (byteinst &amp;&amp; reg.encoding &gt;= 4) {
                     emitByte(Prefix.REX);
                 }
             }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>62757</refactoring_id><commit_sha>d56e09a1fcea52922554620b8c367d4f355ffd05</commit_sha><commit_link>https://github.com/yuliskov/SmartTube/commit/d56e09a1fcea52922554620b8c367d4f355ffd05</commit_link><file_path>common/src/main/java/com/liskovsoft/smartyoutubetv2/common/app/models/playback/managers/RemoteControlManager.java</file_path><description>Extract Method private movePlayerToForeground() : void extracted from private processCommand(command Command) : void in class com.liskovsoft.smartyoutubetv2.common.app.models.playback.managers.RemoteControlManager</description><code_before>@@ -8,6 +8,7 @@
 import com.liskovsoft.mediaserviceinterfaces.data.Command;
 import com.liskovsoft.sharedutils.helpers.MessageHelpers;
 import com.liskovsoft.sharedutils.mylogger.Log;
 import com.liskovsoft.smartyoutubetv2.common.R;
 import com.liskovsoft.smartyoutubetv2.common.app.models.data.Video;
 import com.liskovsoft.smartyoutubetv2.common.app.models.playback.PlayerEventListenerHelper;
@@ -16,7 +17,6 @@
 import com.liskovsoft.smartyoutubetv2.common.app.views.ViewManager;
 import com.liskovsoft.smartyoutubetv2.common.prefs.PlayerData;
 import com.liskovsoft.smartyoutubetv2.common.prefs.RemoteControlData;
-import com.liskovsoft.sharedutils.rx.RxUtils;
 import com.liskovsoft.smartyoutubetv2.common.utils.Utils;
 import com.liskovsoft.youtubeapi.service.YouTubeMediaService;
 import io.reactivex.android.schedulers.AndroidSchedulers;
@@ -239,7 +239,7 @@ private void processCommand(Command command) {
                 if (getController() != null) {
                     getController().showOverlay(false);
                 }
-                Utils.movePlayerToForeground(getActivity());
                 Video newVideo = Video.from(command.getVideoId());
                 newVideo.remotePlaylistId = command.getPlaylistId();
                 newVideo.playlistIndex = command.getPlaylistIndex();
@@ -261,7 +261,7 @@ private void processCommand(Command command) {
             case Command.TYPE_SEEK:
                 if (getController() != null) {
                     getController().showOverlay(false);
-                    Utils.movePlayerToForeground(getActivity());
                     getController().setPositionMs(command.getCurrentTimeMs());
                     postSeek(command.getCurrentTimeMs());
                 } else {
@@ -270,7 +270,7 @@ private void processCommand(Command command) {
                 break;
             case Command.TYPE_PLAY:
                 if (getController() != null) {
-                    Utils.movePlayerToForeground(getActivity());
                     getController().setPlay(true);
                     //postStartPlaying(getController().getVideo(), true);
                     postPlay(true);
@@ -280,7 +280,7 @@ private void processCommand(Command command) {
                 break;
             case Command.TYPE_PAUSE:
                 if (getController() != null) {
-                    Utils.movePlayerToForeground(getActivity());
                     getController().setPlay(false);
                     //postStartPlaying(getController().getVideo(), false);
                     postPlay(false);
@@ -290,15 +290,15 @@ private void processCommand(Command command) {
                 break;
             case Command.TYPE_NEXT:
                 if (getBridge() != null) {
-                    Utils.movePlayerToForeground(getActivity());
                     mVideoLoader.loadNext();
                 } else {
                     openNewVideo(mVideo);
                 }
                 break;
             case Command.TYPE_PREVIOUS:
                 if (getBridge() != null &amp;&amp; getController() != null) {
-                    Utils.movePlayerToForeground(getActivity());
                     // Switch immediately. Skip position reset logic.
                     mVideoLoader.loadPrevious();
                 } else {
@@ -435,4 +435,11 @@ private void setVolume(int volume) {
             MessageHelpers.showMessageThrottled(getActivity(), getActivity().getString(R.string.volume, Utils.getGlobalVolume(getActivity())));
         }
     }
 }
</code_before><code_after>@@ -8,6 +8,7 @@
 import com.liskovsoft.mediaserviceinterfaces.data.Command;
 import com.liskovsoft.sharedutils.helpers.MessageHelpers;
 import com.liskovsoft.sharedutils.mylogger.Log;
+import com.liskovsoft.sharedutils.rx.RxUtils;
 import com.liskovsoft.smartyoutubetv2.common.R;
 import com.liskovsoft.smartyoutubetv2.common.app.models.data.Video;
 import com.liskovsoft.smartyoutubetv2.common.app.models.playback.PlayerEventListenerHelper;
@@ -16,7 +17,6 @@
 import com.liskovsoft.smartyoutubetv2.common.app.views.ViewManager;
 import com.liskovsoft.smartyoutubetv2.common.prefs.PlayerData;
 import com.liskovsoft.smartyoutubetv2.common.prefs.RemoteControlData;
 import com.liskovsoft.smartyoutubetv2.common.utils.Utils;
 import com.liskovsoft.youtubeapi.service.YouTubeMediaService;
 import io.reactivex.android.schedulers.AndroidSchedulers;
@@ -239,7 +239,7 @@ private void processCommand(Command command) {
                 if (getController() != null) {
                     getController().showOverlay(false);
                 }
+                movePlayerToForeground();
                 Video newVideo = Video.from(command.getVideoId());
                 newVideo.remotePlaylistId = command.getPlaylistId();
                 newVideo.playlistIndex = command.getPlaylistIndex();
@@ -261,7 +261,7 @@ private void processCommand(Command command) {
             case Command.TYPE_SEEK:
                 if (getController() != null) {
                     getController().showOverlay(false);
+                    movePlayerToForeground();
                     getController().setPositionMs(command.getCurrentTimeMs());
                     postSeek(command.getCurrentTimeMs());
                 } else {
@@ -270,7 +270,7 @@ private void processCommand(Command command) {
                 break;
             case Command.TYPE_PLAY:
                 if (getController() != null) {
+                    movePlayerToForeground();
                     getController().setPlay(true);
                     //postStartPlaying(getController().getVideo(), true);
                     postPlay(true);
@@ -280,7 +280,7 @@ private void processCommand(Command command) {
                 break;
             case Command.TYPE_PAUSE:
                 if (getController() != null) {
+                    movePlayerToForeground();
                     getController().setPlay(false);
                     //postStartPlaying(getController().getVideo(), false);
                     postPlay(false);
@@ -290,15 +290,15 @@ private void processCommand(Command command) {
                 break;
             case Command.TYPE_NEXT:
                 if (getBridge() != null) {
+                    movePlayerToForeground();
                     mVideoLoader.loadNext();
                 } else {
                     openNewVideo(mVideo);
                 }
                 break;
             case Command.TYPE_PREVIOUS:
                 if (getBridge() != null &amp;&amp; getController() != null) {
+                    movePlayerToForeground();
                     // Switch immediately. Skip position reset logic.
                     mVideoLoader.loadPrevious();
                 } else {
@@ -435,4 +435,11 @@ private void setVolume(int volume) {
             MessageHelpers.showMessageThrottled(getActivity(), getActivity().getString(R.string.volume, Utils.getGlobalVolume(getActivity())));
         }
     }
+
+    private void movePlayerToForeground() {
+        Utils.movePlayerToForeground(getActivity());
+        if (getController() == null || !Utils.checkActivity(getActivity())) { // player isn't started yet or closed
+            RxUtils.runAsync(() -&gt; Utils.movePlayerToForeground(getActivity()), 5_000);
+        }
+    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>5489</refactoring_id><commit_sha>017faa0811a8154420d6e4269a2805630e35bf4a</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/017faa0811a8154420d6e4269a2805630e35bf4a</commit_link><file_path>engine/src/main/java/org/camunda/bpm/engine/impl/persistence/entity/ExecutionEntity.java</file_path><description>Extract Method public initializeTimerDeclarations() : void extracted from public initialize() : void in class org.camunda.bpm.engine.impl.persistence.entity.ExecutionEntity</description><code_before>@@ -332,17 +332,22 @@ public void initialize() {
       }
     }
 
     List&lt;TimerDeclarationImpl&gt; timerDeclarations = (List&lt;TimerDeclarationImpl&gt;) scope.getProperty(BpmnParse.PROPERTYNAME_TIMER_DECLARATION);
     if (timerDeclarations!=null) {
       for (TimerDeclarationImpl timerDeclaration : timerDeclarations) {
         timerDeclaration.createTimerInstance(this);
       }
     }
-
-    // create event subscriptions for the current scope
-    for (EventSubscriptionDeclaration declaration : EventSubscriptionDeclaration.getDeclarationsForScope(scope)) {
-      declaration.createSubscription(this);
-    }
   }
 
   protected static void initializeAssociations(ExecutionEntity execution) {
@@ -370,6 +375,7 @@ public void startWithFormProperties(VariableMap properties) {
       startContext = formPropertyStartContext;
 
       initialize();
       fireProcessStartEvent();
     }
     performOperation(PvmAtomicOperation.PROCESS_START);
</code_before><code_after>@@ -332,17 +332,22 @@ public void initialize() {
       }
     }
 
+    // create event subscriptions for the current scope
+    for (EventSubscriptionDeclaration declaration : EventSubscriptionDeclaration.getDeclarationsForScope(scope)) {
+      declaration.createSubscription(this);
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  public void initializeTimerDeclarations() {
+    log.fine("initializing timer declaration"+this);
+    ScopeImpl scope = getScopeActivity();
     List&lt;TimerDeclarationImpl&gt; timerDeclarations = (List&lt;TimerDeclarationImpl&gt;) scope.getProperty(BpmnParse.PROPERTYNAME_TIMER_DECLARATION);
     if (timerDeclarations!=null) {
       for (TimerDeclarationImpl timerDeclaration : timerDeclarations) {
         timerDeclaration.createTimerInstance(this);
       }
     }
   }
 
   protected static void initializeAssociations(ExecutionEntity execution) {
@@ -370,6 +375,7 @@ public void startWithFormProperties(VariableMap properties) {
       startContext = formPropertyStartContext;
 
       initialize();
+      initializeTimerDeclarations();
       fireProcessStartEvent();
     }
     performOperation(PvmAtomicOperation.PROCESS_START);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>52251</refactoring_id><commit_sha>3a16bd50517b303281a5c4a082c441770a8a4fe2</commit_sha><commit_link>https://github.com/apache/iotdb/commit/3a16bd50517b303281a5c4a082c441770a8a4fe2</commit_link><file_path>iotdb/src/main/java/org/apache/iotdb/db/monitor/collector/FileSize.java</file_path><description>Extract Method private collectSeqFileSize(fileSizes EnumMap&lt;FileSizeConstants,Long&gt;, kinds FileSizeConstants) : long extracted from public getFileSizesInByte() : Map&lt;FileSizeConstants,Long&gt; in class org.apache.iotdb.db.monitor.collector.FileSize</description><code_before>@@ -30,8 +30,8 @@
 import org.apache.commons.io.FileUtils;
 import org.apache.iotdb.db.conf.IoTDBConfig;
 import org.apache.iotdb.db.conf.IoTDBDescriptor;
-import org.apache.iotdb.db.engine.filenode.FileNodeManager;
-import org.apache.iotdb.db.exception.FileNodeManagerException;
 import org.apache.iotdb.db.monitor.IStatistic;
 import org.apache.iotdb.db.monitor.MonitorConstants;
 import org.apache.iotdb.db.monitor.MonitorConstants.FileSizeConstants;
@@ -51,10 +51,10 @@
 public class FileSize implements IStatistic {
 
   private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();
-  private static final Logger LOGGER = LoggerFactory.getLogger(FileSize.class);
   private static final long ABNORMAL_VALUE = -1L;
   private static final long INIT_VALUE_IF_FILE_NOT_EXIST = 0L;
-  private FileNodeManager fileNodeManager;
 
   @Override
   public Map&lt;String, TSRecord&gt; getAllStatisticsValue() {
@@ -77,11 +77,11 @@ public void registerStatMetadata() {
       hashMap.put(seriesPath, MonitorConstants.DATA_TYPE_INT64);
       Path path = new Path(seriesPath);
       try {
-        fileNodeManager.addTimeSeries(path, TSDataType.valueOf(MonitorConstants.DATA_TYPE_INT64),
             TSEncoding.valueOf("RLE"), CompressionType.valueOf(TSFileConfig.compressor),
             Collections.emptyMap());
-      } catch (FileNodeManagerException e) {
-        LOGGER.error("Register File Size Stats into fileNodeManager Failed.", e);
       }
     }
     StatMonitor.getInstance().registerStatStorageGroup(hashMap);
@@ -114,7 +114,7 @@ private static class FileSizeHolder {
   }
 
   private FileSize() {
-    fileNodeManager = FileNodeManager.getInstance();
     if (config.isEnableStatMonitor()) {
       StatMonitor statMonitor = StatMonitor.getInstance();
       registerStatMetadata();
@@ -135,32 +135,17 @@ public static FileSize getInstance() {
   public Map&lt;FileSizeConstants, Long&gt; getFileSizesInByte() {
     EnumMap&lt;FileSizeConstants, Long&gt; fileSizes = new EnumMap&lt;&gt;(FileSizeConstants.class);
     for (FileSizeConstants kinds : MonitorConstants.FileSizeConstants.values()) {
-      if (kinds.equals(MonitorConstants.FileSizeConstants.SETTLED)) {
-        //sum bufferWriteDirs size
-        long settledSize = INIT_VALUE_IF_FILE_NOT_EXIST;
-        for (String bufferWriteDir : config.getBufferWriteDirs()) {
-          File settledFile = new File(bufferWriteDir);
-          if (settledFile.exists()) {
-            try {
-              settledSize += FileUtils.sizeOfDirectory(settledFile);
-            } catch (Exception e) {
-              LOGGER.error("Meet error while trying to get {} size with dir {} .", kinds,
-                  bufferWriteDir, e);
-              fileSizes.put(kinds, ABNORMAL_VALUE);
-            }
-          }
-        }
-        fileSizes.put(kinds, settledSize);
       } else {
         File file = new File(kinds.getPath());
         if (file.exists()) {
           try {
             fileSizes.put(kinds, FileUtils.sizeOfDirectory(file));
           } catch (Exception e) {
-            LOGGER
-                .error("Meet error while trying to get {} size with dir {} .", kinds,
-                    kinds.getPath(),
-                    e);
             fileSizes.put(kinds, ABNORMAL_VALUE);
           }
         } else {
@@ -170,4 +155,24 @@ public Map&lt;FileSizeConstants, Long&gt; getFileSizesInByte() {
     }
     return fileSizes;
   }
 }
</code_before><code_after>@@ -30,8 +30,8 @@
 import org.apache.commons.io.FileUtils;
 import org.apache.iotdb.db.conf.IoTDBConfig;
 import org.apache.iotdb.db.conf.IoTDBDescriptor;
+import org.apache.iotdb.db.engine.StorageEngine;
+import org.apache.iotdb.db.exception.StorageEngineException;
 import org.apache.iotdb.db.monitor.IStatistic;
 import org.apache.iotdb.db.monitor.MonitorConstants;
 import org.apache.iotdb.db.monitor.MonitorConstants.FileSizeConstants;
@@ -51,10 +51,10 @@
 public class FileSize implements IStatistic {
 
   private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();
+  private static final Logger logger = LoggerFactory.getLogger(FileSize.class);
   private static final long ABNORMAL_VALUE = -1L;
   private static final long INIT_VALUE_IF_FILE_NOT_EXIST = 0L;
+  private StorageEngine storageEngine;
 
   @Override
   public Map&lt;String, TSRecord&gt; getAllStatisticsValue() {
@@ -77,11 +77,11 @@ public void registerStatMetadata() {
       hashMap.put(seriesPath, MonitorConstants.DATA_TYPE_INT64);
       Path path = new Path(seriesPath);
       try {
+        storageEngine.addTimeSeries(path, TSDataType.valueOf(MonitorConstants.DATA_TYPE_INT64),
             TSEncoding.valueOf("RLE"), CompressionType.valueOf(TSFileConfig.compressor),
             Collections.emptyMap());
+      } catch (StorageEngineException e) {
+        logger.error("Register File Size Stats into storageEngine Failed.", e);
       }
     }
     StatMonitor.getInstance().registerStatStorageGroup(hashMap);
@@ -114,7 +114,7 @@ private static class FileSizeHolder {
   }
 
   private FileSize() {
+    storageEngine = StorageEngine.getInstance();
     if (config.isEnableStatMonitor()) {
       StatMonitor statMonitor = StatMonitor.getInstance();
       registerStatMetadata();
@@ -135,32 +135,17 @@ public static FileSize getInstance() {
   public Map&lt;FileSizeConstants, Long&gt; getFileSizesInByte() {
     EnumMap&lt;FileSizeConstants, Long&gt; fileSizes = new EnumMap&lt;&gt;(FileSizeConstants.class);
     for (FileSizeConstants kinds : MonitorConstants.FileSizeConstants.values()) {
+
+      if (kinds.equals(FileSizeConstants.SYS)) {
+        fileSizes.put(kinds, collectSeqFileSize(fileSizes, kinds));
       } else {
         File file = new File(kinds.getPath());
         if (file.exists()) {
           try {
             fileSizes.put(kinds, FileUtils.sizeOfDirectory(file));
           } catch (Exception e) {
+            logger.error("Meet error while trying to get {} size with dir {} .", kinds,
+                    kinds.getPath(), e);
             fileSizes.put(kinds, ABNORMAL_VALUE);
           }
         } else {
@@ -170,4 +155,24 @@ public Map&lt;FileSizeConstants, Long&gt; getFileSizesInByte() {
     }
     return fileSizes;
   }
+
+  private long collectSeqFileSize(EnumMap&lt;FileSizeConstants, Long&gt; fileSizes, FileSizeConstants kinds) {
+    long fileSize = INIT_VALUE_IF_FILE_NOT_EXIST;
+    for (String sequenceDir : config.getDataDirs()) {
+      if (sequenceDir.contains("unsequence")) {
+        continue;
+      }
+      File settledFile = new File(sequenceDir);
+      if (settledFile.exists()) {
+        try {
+          fileSize += FileUtils.sizeOfDirectory(settledFile);
+        } catch (Exception e) {
+          logger.error("Meet error while trying to get {} size with dir {} .", kinds,
+              sequenceDir, e);
+          fileSizes.put(kinds, ABNORMAL_VALUE);
+        }
+      }
+    }
+    return fileSize;
+  }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>103136</refactoring_id><commit_sha>2768d7d67e2a653d244c73ea4175af64060ce0cd</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/2768d7d67e2a653d244c73ea4175af64060ce0cd</commit_link><file_path>jdk/src/share/classes/java/util/ArrayList.java</file_path><description>Extract Method private calculateCapacity(elementData Object[], minCapacity int) : int extracted from private ensureCapacityInternal(minCapacity int) : void in class java.util.ArrayList</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
 
 /**
  * Resizable-array implementation of the &lt;tt&gt;List&lt;/tt&gt; interface.  Implements
@@ -219,12 +220,15 @@ public void ensureCapacity(int minCapacity) {
         }
     }
 
-    private void ensureCapacityInternal(int minCapacity) {
         if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
-            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
         }
 
-        ensureExplicitCapacity(minCapacity);
     }
 
     private void ensureExplicitCapacity(int minCapacity) {
@@ -783,6 +787,8 @@ private void readObject(java.io.ObjectInputStream s)
 
         if (size &gt; 0) {
             // be like clone(), allocate array based upon size not capacity
             ensureCapacityInternal(size);
 
             Object[] a = elementData;
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
+import sun.misc.SharedSecrets;
 
 /**
  * Resizable-array implementation of the &lt;tt&gt;List&lt;/tt&gt; interface.  Implements
@@ -219,12 +220,15 @@ public void ensureCapacity(int minCapacity) {
         }
     }
 
+    private static int calculateCapacity(Object[] elementData, int minCapacity) {
         if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
+            return Math.max(DEFAULT_CAPACITY, minCapacity);
+        }
+        return minCapacity;
         }
 
+    private void ensureCapacityInternal(int minCapacity) {
+        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
     }
 
     private void ensureExplicitCapacity(int minCapacity) {
@@ -783,6 +787,8 @@ private void readObject(java.io.ObjectInputStream s)
 
         if (size &gt; 0) {
             // be like clone(), allocate array based upon size not capacity
+            int capacity = calculateCapacity(elementData, size);
+            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
             ensureCapacityInternal(size);
 
             Object[] a = elementData;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>54301</refactoring_id><commit_sha>a630f619e6b6d7895447af9a04984d6a2593478e</commit_sha><commit_link>https://github.com/languagetool-org/languagetool/commit/a630f619e6b6d7895447af9a04984d6a2593478e</commit_link><file_path>languagetool-core/src/main/java/org/languagetool/rules/CommaWhitespaceRule.java</file_path><description>Extract Method public CommaWhitespaceRule(messages ResourceBundle, incorrectExample IncorrectExample, correctExample String) extracted from public CommaWhitespaceRule(messages ResourceBundle) in class org.languagetool.rules.CommaWhitespaceRule</description><code_before>@@ -36,10 +36,21 @@
  */
 public class CommaWhitespaceRule extends Rule {
 
-  public CommaWhitespaceRule(final ResourceBundle messages) {
     super(messages);
     super.setCategory(Categories.MISC.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Whitespace);
   }
 
   @Override
</code_before><code_after>@@ -36,10 +36,21 @@
  */
 public class CommaWhitespaceRule extends Rule {
 
+  /** @since 3.3 */
+  public CommaWhitespaceRule(ResourceBundle messages, IncorrectExample incorrectExample, String correctExample) {
     super(messages);
     super.setCategory(Categories.MISC.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Whitespace);
+    if (incorrectExample != null &amp;&amp; correctExample != null) {
+      addExamplePair(incorrectExample, correctExample);
+    }
+  }
+
+  /**
+   * @deprecated use {@link #CommaWhitespaceRule(ResourceBundle, IncorrectExample, String)} instead (deprecated since 3.3)
+   */
+  public CommaWhitespaceRule(ResourceBundle messages) {
+    this(messages, null, null);
   }
 
   @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>33058</refactoring_id><commit_sha>6976624228386c25e9ac6dd2b8ef87a9deeb1ad9</commit_sha><commit_link>https://github.com/apache/storm/commit/6976624228386c25e9ac6dd2b8ef87a9deeb1ad9</commit_link><file_path>storm-client/src/jvm/org/apache/storm/executor/Executor.java</file_path><description>Extract Method private processHistograms(taskId int, dataPoints List&lt;IMetricsConsumer.DataPoint&gt;) : void extracted from private addV2Metrics(dataPoints List&lt;IMetricsConsumer.DataPoint&gt;) : void in class org.apache.storm.executor.Executor</description><code_before>@@ -63,7 +63,6 @@
 import org.apache.storm.grouping.LoadMapping;
 import org.apache.storm.metric.api.IMetric;
 import org.apache.storm.metric.api.IMetricsConsumer;
-import org.apache.storm.metrics2.StormMetricRegistry;
 import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;
 import org.apache.storm.shade.com.google.common.collect.Lists;
 import org.apache.storm.shade.org.jctools.queues.MpscChunkedArrayQueue;
@@ -317,7 +316,7 @@ public void metricsTick(Task task, TupleImpl tuple) {
                     }
                 }
             }
-            addV2Metrics(dataPoints);
 
             if (!dataPoints.isEmpty()) {
                 IMetricsConsumer.TaskInfo taskInfo = new IMetricsConsumer.TaskInfo(
@@ -333,51 +332,66 @@ public void metricsTick(Task task, TupleImpl tuple) {
     }
 
     // updates v1 metric dataPoints with v2 metric API data
-    private void addV2Metrics(List&lt;IMetricsConsumer.DataPoint&gt; dataPoints) {
         boolean enableV2MetricsDataPoints = ObjectReader.getBoolean(topoConf.get(Config.TOPOLOGY_ENABLE_V2_METRICS_TICK), false);
         if (!enableV2MetricsDataPoints) {
             return;
         }
-        StormMetricRegistry stormMetricRegistry = workerData.getMetricRegistry();
-        for (Map.Entry&lt;String, Gauge&gt; entry : stormMetricRegistry.registry().getGauges().entrySet()) {
-            String name = entry.getKey();
             Object v = entry.getValue().getValue();
             if (v instanceof Number) {
-                IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(name, v);
                 dataPoints.add(dataPoint);
-            } else {
-                LOG.warn("Cannot report {}, its value is not a Number {}", name, v);
             }
         }
-        for (Map.Entry&lt;String, Counter&gt; entry : stormMetricRegistry.registry().getCounters().entrySet()) {
             Object value = entry.getValue().getCount();
             IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey(), value);
             dataPoints.add(dataPoint);
         }
-        for (Map.Entry&lt;String, Histogram&gt; entry: stormMetricRegistry.registry().getHistograms().entrySet()) {
-            String baseName = entry.getKey();
-            Histogram histogram = entry.getValue();
-            Snapshot snapshot =  histogram.getSnapshot();
-            addSnapshotDatapoints(baseName, snapshot, dataPoints);
-            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(baseName + ".count", histogram.getCount());
             dataPoints.add(dataPoint);
         }
-        for (Map.Entry&lt;String, Meter&gt; entry: stormMetricRegistry.registry().getMeters().entrySet()) {
-            String baseName = entry.getKey();
-            Meter meter = entry.getValue();
-            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(baseName + ".count", meter.getCount());
             dataPoints.add(dataPoint);
-            addConvertedMetric(baseName, ".m1_rate", meter.getOneMinuteRate(), dataPoints);
-            addConvertedMetric(baseName, ".m5_rate", meter.getFiveMinuteRate(), dataPoints);
-            addConvertedMetric(baseName, ".m15_rate", meter.getFifteenMinuteRate(), dataPoints);
-            addConvertedMetric(baseName, ".mean_rate", meter.getMeanRate(), dataPoints);
         }
-        for (Map.Entry&lt;String, Timer&gt; entry : stormMetricRegistry.registry().getTimers().entrySet()) {
-            String baseName = entry.getKey();
-            Timer timer = entry.getValue();
-            Snapshot snapshot =  timer.getSnapshot();
-            addSnapshotDatapoints(baseName, snapshot, dataPoints);
-            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(baseName + ".count", timer.getCount());
             dataPoints.add(dataPoint);
         }
     }
</code_before><code_after>@@ -63,7 +63,6 @@
 import org.apache.storm.grouping.LoadMapping;
 import org.apache.storm.metric.api.IMetric;
 import org.apache.storm.metric.api.IMetricsConsumer;
 import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;
 import org.apache.storm.shade.com.google.common.collect.Lists;
 import org.apache.storm.shade.org.jctools.queues.MpscChunkedArrayQueue;
@@ -317,7 +316,7 @@ public void metricsTick(Task task, TupleImpl tuple) {
                     }
                 }
             }
+            addV2Metrics(taskId, dataPoints);
 
             if (!dataPoints.isEmpty()) {
                 IMetricsConsumer.TaskInfo taskInfo = new IMetricsConsumer.TaskInfo(
@@ -333,51 +332,66 @@ public void metricsTick(Task task, TupleImpl tuple) {
     }
 
     // updates v1 metric dataPoints with v2 metric API data
+    private void addV2Metrics(int taskId, List&lt;IMetricsConsumer.DataPoint&gt; dataPoints) {
         boolean enableV2MetricsDataPoints = ObjectReader.getBoolean(topoConf.get(Config.TOPOLOGY_ENABLE_V2_METRICS_TICK), false);
         if (!enableV2MetricsDataPoints) {
             return;
         }
+        processGauges(taskId, dataPoints);
+        processCounters(taskId, dataPoints);
+        processHistograms(taskId, dataPoints);
+        processMeters(taskId, dataPoints);
+        processTimers(taskId, dataPoints);
+    }
+
+    private void processGauges(int taskId, List&lt;IMetricsConsumer.DataPoint&gt; dataPoints) {
+        Map&lt;String, Gauge&gt; gauges = workerData.getMetricRegistry().getTaskGauges(taskId);
+        for (Map.Entry&lt;String, Gauge&gt; entry : gauges.entrySet()) {
             Object v = entry.getValue().getValue();
             if (v instanceof Number) {
+                IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey(), v);
                 dataPoints.add(dataPoint);
             }
         }
+    }
+
+    private void processCounters(int taskId, List&lt;IMetricsConsumer.DataPoint&gt; dataPoints) {
+        Map&lt;String, Counter&gt; counters = workerData.getMetricRegistry().getTaskCounters(taskId);
+        for (Map.Entry&lt;String, Counter&gt; entry : counters.entrySet()) {
             Object value = entry.getValue().getCount();
             IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey(), value);
             dataPoints.add(dataPoint);
         }
+    }
+
+    private void processHistograms(int taskId, List&lt;IMetricsConsumer.DataPoint&gt; dataPoints) {
+        Map&lt;String, Histogram&gt; histograms = workerData.getMetricRegistry().getTaskHistograms(taskId);
+        for (Map.Entry&lt;String, Histogram&gt; entry : histograms.entrySet()) {
+            Snapshot snapshot =  entry.getValue().getSnapshot();
+            addSnapshotDatapoints(entry.getKey(), snapshot, dataPoints);
+            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey() + ".count", entry.getValue().getCount());
             dataPoints.add(dataPoint);
         }
+    }
+
+    private void processMeters(int taskId, List&lt;IMetricsConsumer.DataPoint&gt; dataPoints) {
+        Map&lt;String, Meter&gt; meters = workerData.getMetricRegistry().getTaskMeters(taskId);
+        for (Map.Entry&lt;String, Meter&gt; entry : meters.entrySet()) {
+            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey() + ".count", entry.getValue().getCount());
             dataPoints.add(dataPoint);
+            addConvertedMetric(entry.getKey(), ".m1_rate", entry.getValue().getOneMinuteRate(), dataPoints);
+            addConvertedMetric(entry.getKey(), ".m5_rate", entry.getValue().getFiveMinuteRate(), dataPoints);
+            addConvertedMetric(entry.getKey(), ".m15_rate", entry.getValue().getFifteenMinuteRate(), dataPoints);
+            addConvertedMetric(entry.getKey(), ".mean_rate", entry.getValue().getMeanRate(), dataPoints);
         }
+    }
+
+    private void processTimers(int taskId, List&lt;IMetricsConsumer.DataPoint&gt; dataPoints) {
+        Map&lt;String, Timer&gt; timers = workerData.getMetricRegistry().getTaskTimers(taskId);
+        for (Map.Entry&lt;String, Timer&gt; entry : timers.entrySet()) {
+            Snapshot snapshot =  entry.getValue().getSnapshot();
+            addSnapshotDatapoints(entry.getKey(), snapshot, dataPoints);
+            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey() + ".count", entry.getValue().getCount());
             dataPoints.add(dataPoint);
         }
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>59763</refactoring_id><commit_sha>cedc2fb891c4e0cfd2e23a8a1d85dc3771c2628d</commit_sha><commit_link>https://github.com/apache/activemq/commit/cedc2fb891c4e0cfd2e23a8a1d85dc3771c2628d</commit_link><file_path>activemq-core/src/main/java/org/apache/activemq/ActiveMQConnectionFactory.java</file_path><description>Extract Method protected createActiveMQConnection() : ActiveMQConnection extracted from public createQueueConnection() : QueueConnection in class org.apache.activemq.ActiveMQConnectionFactory</description><code_before>@@ -153,7 +153,7 @@ public ActiveMQConnectionFactory(String userName, String password, String broker
      * @return Returns the Connection.
      */
     public Connection createConnection() throws JMSException {
-        return createActiveMQConnection(userName, password);
     }
 
     /**
@@ -168,7 +168,7 @@ public Connection createConnection(String userName, String password) throws JMSE
      * @throws JMSException
      */
     public QueueConnection createQueueConnection() throws JMSException {
-        return createActiveMQConnection(userName, password);
     }
 
     /**
@@ -183,7 +183,7 @@ public QueueConnection createQueueConnection(String userName, String password) t
      * @throws JMSException
      */
     public TopicConnection createTopicConnection() throws JMSException {
-        return createActiveMQConnection(userName, password);
     }
 
     /**
@@ -204,17 +204,22 @@ public StatsImpl getStats() {
     //
     // /////////////////////////////////////////////
 
     /**
      * @return Returns the Connection.
      */
-    private ActiveMQConnection createActiveMQConnection(String userName, String password) throws JMSException {
         if (brokerURL == null) {
             throw new ConfigurationException("brokerURL not set.");
         }
         Transport transport;
         try {
             transport = TransportFactory.connect(brokerURL,DEFAULT_CONNECTION_EXECUTOR);
-            ActiveMQConnection connection = new ActiveMQConnection(transport, factoryStats);
 
             connection.setUserName(userName);
             connection.setPassword(password);
@@ -245,6 +250,11 @@ private ActiveMQConnection createActiveMQConnection(String userName, String pass
         }
     }
 
     // /////////////////////////////////////////////
     //
     // Property Accessors
</code_before><code_after>@@ -153,7 +153,7 @@ public ActiveMQConnectionFactory(String userName, String password, String broker
      * @return Returns the Connection.
      */
     public Connection createConnection() throws JMSException {
+        return createActiveMQConnection();
     }
 
     /**
@@ -168,7 +168,7 @@ public Connection createConnection(String userName, String password) throws JMSE
      * @throws JMSException
      */
     public QueueConnection createQueueConnection() throws JMSException {
+        return createActiveMQConnection();
     }
 
     /**
@@ -183,7 +183,7 @@ public QueueConnection createQueueConnection(String userName, String password) t
      * @throws JMSException
      */
     public TopicConnection createTopicConnection() throws JMSException {
+        return createActiveMQConnection();
     }
 
     /**
@@ -204,17 +204,22 @@ public StatsImpl getStats() {
     //
     // /////////////////////////////////////////////
 
+
+    protected ActiveMQConnection createActiveMQConnection() throws JMSException {
+        return createActiveMQConnection(userName, password);
+    }
+
     /**
      * @return Returns the Connection.
      */
+    protected ActiveMQConnection createActiveMQConnection(String userName, String password) throws JMSException {
         if (brokerURL == null) {
             throw new ConfigurationException("brokerURL not set.");
         }
         Transport transport;
         try {
             transport = TransportFactory.connect(brokerURL,DEFAULT_CONNECTION_EXECUTOR);
+            ActiveMQConnection connection = createActiveMQConnection(transport, factoryStats);
 
             connection.setUserName(userName);
             connection.setPassword(password);
@@ -245,6 +250,11 @@ private ActiveMQConnection createActiveMQConnection(String userName, String pass
         }
     }
 
+    protected ActiveMQConnection createActiveMQConnection(Transport transport, JMSStatsImpl stats) throws Exception {
+        ActiveMQConnection connection = new ActiveMQConnection(transport, stats);
+        return connection;
+    }
+
     // /////////////////////////////////////////////
     //
     // Property Accessors
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>77729</refactoring_id><commit_sha>ba6152503eb947266d9d3fc1ee599613acdb2eee</commit_sha><commit_link>https://github.com/apache/poi/commit/ba6152503eb947266d9d3fc1ee599613acdb2eee</commit_link><file_path>src/java/org/apache/poi/hssf/record/chart/DataFormatRecord.java</file_path><description>Extract Method public copy() : DataFormatRecord extracted from public clone() : DataFormatRecord in class org.apache.poi.hssf.record.chart.DataFormatRecord</description><code_before>@@ -23,12 +23,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.poi.util.BitFieldFactory;
 import org.apache.poi.util.HexDump;
 import org.apache.poi.util.LittleEndianOutput;
 
 /**
  * The data format record is used to index into a series.
  */
-public final class DataFormatRecord extends StandardRecord implements Cloneable {
-    public final static short sid = 0x1006;
 
     private static final BitField useExcel4Colors = BitFieldFactory.getInstance(0x1);
 
@@ -37,18 +38,21 @@ public final class DataFormatRecord extends StandardRecord implements Cloneable
     private short field_3_seriesNumber;
     private short field_4_formatFlags;
 
 
-    public DataFormatRecord()
-    {
-
     }
 
-    public DataFormatRecord(RecordInputStream in)
-    {
-        field_1_pointNumber            = in.readShort();
-        field_2_seriesIndex            = in.readShort();
-        field_3_seriesNumber           = in.readShort();
-        field_4_formatFlags            = in.readShort();
     }
 
     public String toString()
@@ -59,20 +63,20 @@ public String toString()
         buffer.append("    .pointNumber          = ")
             .append("0x").append(HexDump.toHex(  getPointNumber ()))
             .append(" (").append( getPointNumber() ).append(" )");
-        buffer.append(System.getProperty("line.separator")); 
         buffer.append("    .seriesIndex          = ")
             .append("0x").append(HexDump.toHex(  getSeriesIndex ()))
             .append(" (").append( getSeriesIndex() ).append(" )");
-        buffer.append(System.getProperty("line.separator")); 
         buffer.append("    .seriesNumber         = ")
             .append("0x").append(HexDump.toHex(  getSeriesNumber ()))
             .append(" (").append( getSeriesNumber() ).append(" )");
-        buffer.append(System.getProperty("line.separator")); 
         buffer.append("    .formatFlags          = ")
             .append("0x").append(HexDump.toHex(  getFormatFlags ()))
             .append(" (").append( getFormatFlags() ).append(" )");
-        buffer.append(System.getProperty("line.separator")); 
-        buffer.append("         .useExcel4Colors          = ").append(isUseExcel4Colors()).append('\n'); 
 
         buffer.append("[/DATAFORMAT]\n");
         return buffer.toString();
@@ -95,18 +99,17 @@ public short getSid()
     }
 
     @Override
     public DataFormatRecord clone() {
-        DataFormatRecord rec = new DataFormatRecord();
-    
-        rec.field_1_pointNumber = field_1_pointNumber;
-        rec.field_2_seriesIndex = field_2_seriesIndex;
-        rec.field_3_seriesNumber = field_3_seriesNumber;
-        rec.field_4_formatFlags = field_4_formatFlags;
-        return rec;
     }
 
-
-
 
     /**
      * Get the point number field for the DataFormat record.
</code_before><code_after>@@ -23,12 +23,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.poi.util.BitFieldFactory;
 import org.apache.poi.util.HexDump;
 import org.apache.poi.util.LittleEndianOutput;
+import org.apache.poi.util.Removal;
 
 /**
  * The data format record is used to index into a series.
  */
+public final class DataFormatRecord extends StandardRecord {
+    public static final short sid = 0x1006;
 
     private static final BitField useExcel4Colors = BitFieldFactory.getInstance(0x1);
 
@@ -37,18 +38,21 @@ public final class DataFormatRecord extends StandardRecord implements Cloneable
     private short field_3_seriesNumber;
     private short field_4_formatFlags;
 
+    public DataFormatRecord() {}
 
+    public DataFormatRecord(DataFormatRecord other) {
+        super(other);
+        field_1_pointNumber = other.field_1_pointNumber;
+        field_2_seriesIndex = other.field_2_seriesIndex;
+        field_3_seriesNumber = other.field_3_seriesNumber;
+        field_4_formatFlags = other.field_4_formatFlags;
     }
 
+    public DataFormatRecord(RecordInputStream in) {
+        field_1_pointNumber = in.readShort();
+        field_2_seriesIndex = in.readShort();
+        field_3_seriesNumber = in.readShort();
+        field_4_formatFlags = in.readShort();
     }
 
     public String toString()
@@ -59,20 +63,20 @@ public String toString()
         buffer.append("    .pointNumber          = ")
             .append("0x").append(HexDump.toHex(  getPointNumber ()))
             .append(" (").append( getPointNumber() ).append(" )");
+        buffer.append(System.getProperty("line.separator"));
         buffer.append("    .seriesIndex          = ")
             .append("0x").append(HexDump.toHex(  getSeriesIndex ()))
             .append(" (").append( getSeriesIndex() ).append(" )");
+        buffer.append(System.getProperty("line.separator"));
         buffer.append("    .seriesNumber         = ")
             .append("0x").append(HexDump.toHex(  getSeriesNumber ()))
             .append(" (").append( getSeriesNumber() ).append(" )");
+        buffer.append(System.getProperty("line.separator"));
         buffer.append("    .formatFlags          = ")
             .append("0x").append(HexDump.toHex(  getFormatFlags ()))
             .append(" (").append( getFormatFlags() ).append(" )");
+        buffer.append(System.getProperty("line.separator"));
+        buffer.append("         .useExcel4Colors          = ").append(isUseExcel4Colors()).append('\n');
 
         buffer.append("[/DATAFORMAT]\n");
         return buffer.toString();
@@ -95,18 +99,17 @@ public short getSid()
     }
 
     @Override
+    @SuppressWarnings("squid:S2975")
+    @Deprecated
+    @Removal(version = "5.0.0")
     public DataFormatRecord clone() {
+        return copy();
     }
 
+    @Override
+    public DataFormatRecord copy() {
+        return new DataFormatRecord(this);
+    }
 
     /**
      * Get the point number field for the DataFormat record.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>40653</refactoring_id><commit_sha>937219cb881675ff0ebc8f88acdf4af513e931fa</commit_sha><commit_link>https://github.com/camunda/camunda/commit/937219cb881675ff0ebc8f88acdf4af513e931fa</commit_link><file_path>backend/src/main/java/org/camunda/optimize/service/variable/ProcessVariableService.java</file_path><description>Extract Method private convertReportsToVariableQuery(mappingFunction Function&lt;ReportDefinitionDto,T&gt;, reportDefinitionDtos List&lt;ReportDefinitionDto&gt;) : List&lt;T&gt; extracted from private convertAuthorizedReportsToVariableQuery(userId String, reportIds List&lt;String&gt;, mappingFunction Function&lt;ReportDefinitionDto,T&gt;) : List&lt;T&gt; in class org.camunda.optimize.service.variable.ProcessVariableService</description><code_before>@@ -28,7 +28,6 @@
 import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static org.camunda.optimize.service.util.ValidationHelper.ensureNotEmpty;
 
@@ -55,7 +54,16 @@ public List&lt;ProcessVariableNameResponseDto&gt; getVariableNames(String userId,
     return processVariableReader.getVariableNames(variableRequestDto);
   }
 
-  public List&lt;ProcessVariableNameResponseDto&gt; getVariableNamesForReports(String userId, List&lt;String&gt; reportIds) {
     final List&lt;ProcessVariableNameRequestDto&gt; processVariableNameRequestDtos = convertAuthorizedReportsToVariableQuery(
       userId,
       reportIds,
@@ -103,25 +111,44 @@ public List&lt;String&gt; getVariableValuesForReports(String userId, ProcessVariableRe
     );
   }
 
   private &lt;T&gt; List&lt;T&gt; convertAuthorizedReportsToVariableQuery(final String userId,
                                                               final List&lt;String&gt; reportIds,
                                                               final Function&lt;ReportDefinitionDto, T&gt; mappingFunction) {
-    final List&lt;? extends ReportDefinitionDto&gt; allAuthorizedReportsForIds = reportService.getAllAuthorizedReportsForIds(
       userId,
       reportIds
     );
-    final Stream&lt;? extends ReportDefinitionDto&gt; reportsFromCombinedReports = allAuthorizedReportsForIds.stream()
-      .filter(reportDefinitionDto -&gt; reportDefinitionDto instanceof CombinedReportDefinitionDto)
-      .flatMap(combinedReport -&gt; {
-        final List&lt;String&gt; reportIdsFromCombined = ((CombinedReportDefinitionDto) combinedReport).getData()
-          .getReportIds();
-        return reportService.getAllAuthorizedReportsForIds(userId, reportIdsFromCombined).stream();
-      });
-
-    return Stream.concat(
-      allAuthorizedReportsForIds.stream(),
-      reportsFromCombinedReports
-    )
       .distinct()
       .filter(SingleProcessReportDefinitionDto.class::isInstance)
       .map(mappingFunction)
</code_before><code_after>@@ -28,7 +28,6 @@
 import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import static org.camunda.optimize.service.util.ValidationHelper.ensureNotEmpty;
 
@@ -55,7 +54,16 @@ public List&lt;ProcessVariableNameResponseDto&gt; getVariableNames(String userId,
     return processVariableReader.getVariableNames(variableRequestDto);
   }
 
+  public List&lt;ProcessVariableNameResponseDto&gt; getVariableNamesForReports(List&lt;String&gt; reportIds) {
+    final List&lt;ProcessVariableNameRequestDto&gt; processVariableNameRequestDtos = convertReportsToVariableQuery(
+      reportIds,
+      definitionDto -&gt; convertToProcessVariableNameRequest((SingleProcessReportDefinitionDto) definitionDto)
+    );
+    return processVariableReader.getVariableNames(processVariableNameRequestDtos);
+  }
+
+  public List&lt;ProcessVariableNameResponseDto&gt; getVariableNamesForAuthorizedReports(String userId,
+                                                                                   List&lt;String&gt; reportIds) {
     final List&lt;ProcessVariableNameRequestDto&gt; processVariableNameRequestDtos = convertAuthorizedReportsToVariableQuery(
       userId,
       reportIds,
@@ -103,25 +111,44 @@ public List&lt;String&gt; getVariableValuesForReports(String userId, ProcessVariableRe
     );
   }
 
+  private &lt;T&gt; List&lt;T&gt; convertReportsToVariableQuery(final List&lt;String&gt; reportIds,
+                                                    final Function&lt;ReportDefinitionDto, T&gt; mappingFunction) {
+    final List&lt;ReportDefinitionDto&gt; allReportsForIds = reportService.getAllReportsForIds(reportIds);
+    allReportsForIds.addAll(
+      allReportsForIds.stream()
+        .filter(reportDefinitionDto -&gt; reportDefinitionDto instanceof CombinedReportDefinitionDto)
+        .flatMap(combinedReport -&gt; {
+          final List&lt;String&gt; reportIdsFromCombined =
+            ((CombinedReportDefinitionDto) combinedReport).getData().getReportIds();
+          return reportService.getAllReportsForIds(reportIdsFromCombined).stream();
+        })
+        .collect(Collectors.toList()));
+
+    return convertReportsToVariableQuery(mappingFunction, allReportsForIds);
+  }
+
   private &lt;T&gt; List&lt;T&gt; convertAuthorizedReportsToVariableQuery(final String userId,
                                                               final List&lt;String&gt; reportIds,
                                                               final Function&lt;ReportDefinitionDto, T&gt; mappingFunction) {
+    final List&lt;ReportDefinitionDto&gt; allAuthorizedReportsForIds = reportService.getAllAuthorizedReportsForIds(
       userId,
       reportIds
     );
+    allAuthorizedReportsForIds.addAll(
+      allAuthorizedReportsForIds.stream()
+        .filter(reportDefinitionDto -&gt; reportDefinitionDto instanceof CombinedReportDefinitionDto)
+        .flatMap(combinedReport -&gt; {
+          final List&lt;String&gt; reportIdsFromCombined = ((CombinedReportDefinitionDto) combinedReport).getData()
+            .getReportIds();
+          return reportService.getAllAuthorizedReportsForIds(userId, reportIdsFromCombined).stream();
+        }).collect(Collectors.toList()));
+    return convertReportsToVariableQuery(mappingFunction, allAuthorizedReportsForIds);
+  }
+
+  private &lt;T&gt; List&lt;T&gt; convertReportsToVariableQuery(final Function&lt;ReportDefinitionDto, T&gt; mappingFunction,
+                                                    final List&lt;ReportDefinitionDto&gt; reportDefinitionDtos) {
+    return reportDefinitionDtos
+      .stream()
       .distinct()
       .filter(SingleProcessReportDefinitionDto.class::isInstance)
       .map(mappingFunction)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>113346</refactoring_id><commit_sha>cd988b615fba0698894d510af8ae42935cedb75c</commit_sha><commit_link>https://github.com/apache/flink/commit/cd988b615fba0698894d510af8ae42935cedb75c</commit_link><file_path>flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/benchmark/StateBackendBenchmarkUtils.java</file_path><description>Extract Method public createKeyedStateBackend(backendType StateBackendType, baseDir File) : KeyedStateBackend&lt;Long&gt; extracted from public createKeyedStateBackend(backendType StateBackendType) : KeyedStateBackend&lt;Long&gt; in class org.apache.flink.contrib.streaming.state.benchmark.StateBackendBenchmarkUtils</description><code_before>@@ -67,14 +67,14 @@ public class StateBackendBenchmarkUtils {
     private static final String dbDirName = "dbPath";
     private static File rootDir;
 
-    public static KeyedStateBackend&lt;Long&gt; createKeyedStateBackend(StateBackendType backendType)
-            throws IOException {
         switch (backendType) {
             case HEAP:
-                rootDir = prepareDirectory(rootDirName, null);
                 return createHeapKeyedStateBackend(rootDir);
             case ROCKSDB:
-                rootDir = prepareDirectory(rootDirName, null);
                 return createRocksDBKeyedStateBackend(rootDir);
             case BATCH_EXECUTION:
                 return createBatchExecutionStateBackend();
@@ -83,6 +83,11 @@ public static KeyedStateBackend&lt;Long&gt; createKeyedStateBackend(StateBackendType b
         }
     }
 
     private static CheckpointableKeyedStateBackend&lt;Long&gt; createBatchExecutionStateBackend() {
         return new BatchExecutionStateBackend()
                 .createKeyedStateBackend(
</code_before><code_after>@@ -67,14 +67,14 @@ public class StateBackendBenchmarkUtils {
     private static final String dbDirName = "dbPath";
     private static File rootDir;
 
+    public static KeyedStateBackend&lt;Long&gt; createKeyedStateBackend(
+            StateBackendType backendType, File baseDir) throws IOException {
         switch (backendType) {
             case HEAP:
+                rootDir = prepareDirectory(rootDirName, baseDir);
                 return createHeapKeyedStateBackend(rootDir);
             case ROCKSDB:
+                rootDir = prepareDirectory(rootDirName, baseDir);
                 return createRocksDBKeyedStateBackend(rootDir);
             case BATCH_EXECUTION:
                 return createBatchExecutionStateBackend();
@@ -83,6 +83,11 @@ public static KeyedStateBackend&lt;Long&gt; createKeyedStateBackend(StateBackendType b
         }
     }
 
+    public static KeyedStateBackend&lt;Long&gt; createKeyedStateBackend(StateBackendType backendType)
+            throws IOException {
+        return createKeyedStateBackend(backendType, null);
+    }
+
     private static CheckpointableKeyedStateBackend&lt;Long&gt; createBatchExecutionStateBackend() {
         return new BatchExecutionStateBackend()
                 .createKeyedStateBackend(
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>72806</refactoring_id><commit_sha>40b16a35242acae05203fc0b8eee4f075acbdff6</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/40b16a35242acae05203fc0b8eee4f075acbdff6</commit_link><file_path>src/edu/stanford/nlp/pipeline/ProtobufAnnotationSerializer.java</file_path><description>Extract Method protected fromProtoNoTokens(proto CoreNLPProtos.Sentence) : CoreMap extracted from public fromProto(proto CoreNLPProtos.Document) : Annotation in class edu.stanford.nlp.pipeline.ProtobufAnnotationSerializer</description><code_before>@@ -92,7 +92,7 @@
  *
  *     &lt;ul&gt;
  *       &lt;li&gt;{@link ProtobufAnnotationSerializer#toProtoBuilder(edu.stanford.nlp.util.CoreMap, java.util.Set)}&lt;/li&gt;
- *       &lt;li&gt;{@link ProtobufAnnotationSerializer#fromProto(edu.stanford.nlp.pipeline.CoreNLPProtos.Sentence)}&lt;/li&gt;
  *     &lt;/ul&gt;
  *
  *     &lt;p&gt;
@@ -309,6 +309,11 @@ protected CoreNLPProtos.Sentence.Builder toProtoBuilder(CoreMap sentence, Set&lt;Cl
     // Required fields
     builder.setTokenOffsetBegin(getAndRegister(sentence, keysToSerialize, TokenBeginAnnotation.class));
     builder.setTokenOffsetEnd(getAndRegister(sentence, keysToSerialize, TokenEndAnnotation.class));
     // Optional fields
     if (sentence.containsKey(SentenceIndexAnnotation.class)) { builder.setSentenceIndex(getAndRegister(sentence, keysToSerialize, SentenceIndexAnnotation.class)); }
     if (sentence.containsKey(CharacterOffsetBeginAnnotation.class)) { builder.setCharacterOffsetBegin(getAndRegister(sentence, keysToSerialize, CharacterOffsetBeginAnnotation.class)); }
@@ -348,6 +353,7 @@ protected CoreNLPProtos.Sentence.Builder toProtoBuilder(CoreMap sentence, Set&lt;Cl
    */
   public CoreNLPProtos.Document toProto(Annotation doc) {
     Set&lt;Class&lt;?&gt;&gt; keysToSerialize = new HashSet&lt;Class&lt;?&gt;&gt;(doc.keySet());
     CoreNLPProtos.Document.Builder builder = toProtoBuilder(doc, keysToSerialize);
     // Completeness Check
     if (enforceLosslessSerialization &amp;&amp; !keysToSerialize.isEmpty()) {
@@ -368,19 +374,17 @@ public CoreNLPProtos.Document toProto(Annotation doc) {
    *                        from this set, as the code tracks annotations to ensure lossless serializationA set tracking which keys have been saved. It's important to remove any keys added to the proto*
    *                        from this set, as the code tracks annotations to ensure lossless serialization.
    */
-  public CoreNLPProtos.Document.Builder toProtoBuilder(Annotation doc, Set&lt;Class&lt;?&gt;&gt; keysToSerialize) {
     CoreNLPProtos.Document.Builder builder = CoreNLPProtos.Document.newBuilder();
     // Required fields
     builder.setText(doc.get(TextAnnotation.class));
     keysToSerialize.remove(TextAnnotation.class);
     // Optional fields
-    if (doc.containsKey(TokensAnnotation.class)) {
-      for (CoreLabel tok : doc.get(TokensAnnotation.class)) { builder.addToken(toProto(tok)); }
-      keysToSerialize.remove(TokensAnnotation.class);
-    }
     if (doc.containsKey(SentencesAnnotation.class)) {
       for (CoreMap sentence : doc.get(SentencesAnnotation.class)) { builder.addSentence(toProto(sentence)); }
       keysToSerialize.remove(SentencesAnnotation.class);
     }
     if (doc.containsKey(DocIDAnnotation.class)) {
       builder.setDocID(doc.get(DocIDAnnotation.class));
@@ -590,14 +594,37 @@ protected CoreLabel fromProto(CoreNLPProtos.Token proto) {
     return word;
   }
 
   /**
    * Create a CoreMap representing a sentence from this protocol buffer.
    * Note that the sentence is very lossy -- most glaringly, the tokens are missing, awaiting a document
    * to be filled in from.
    * @param proto The serialized protobuf to read the sentence from.
    * @return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)
    */
-  protected CoreMap fromProto(CoreNLPProtos.Sentence proto) {
     CoreMap sentence = new ArrayCoreMap();
     // Required fields
     sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin());
@@ -636,20 +663,35 @@ public Annotation fromProto(CoreNLPProtos.Document proto) {
     Annotation ann = new Annotation(proto.getText());
 
     // Add tokens
-    List&lt;CoreLabel&gt; tokens = new ArrayList&lt;CoreLabel&gt;(proto.getTokenCount());
-    for (CoreNLPProtos.Token token : proto.getTokenList()) {
-      CoreLabel coreLabel = fromProto(token);
-      // Set docid
-      if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }
-      tokens.add(coreLabel);
     }
     if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }
 
     // Add sentences
     List&lt;CoreMap&gt; sentences = new ArrayList&lt;CoreMap&gt;(proto.getSentenceCount());
     for (int sentIndex = 0; sentIndex &lt; proto.getSentenceCount(); ++sentIndex) {
       CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);
-      CoreMap map = fromProto(sentence);
       if (!tokens.isEmpty() &amp;&amp; sentence.hasTokenOffsetBegin() &amp;&amp; sentence.hasTokenOffsetEnd()) {
         // Set tokens for sentence
         map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));
</code_before><code_after>@@ -92,7 +92,7 @@
  *
  *     &lt;ul&gt;
  *       &lt;li&gt;{@link ProtobufAnnotationSerializer#toProtoBuilder(edu.stanford.nlp.util.CoreMap, java.util.Set)}&lt;/li&gt;
+ *       &lt;li&gt;{@link ProtobufAnnotationSerializer#fromProtoNoTokens(edu.stanford.nlp.pipeline.CoreNLPProtos.Sentence)}&lt;/li&gt;
  *     &lt;/ul&gt;
  *
  *     &lt;p&gt;
@@ -309,6 +309,11 @@ protected CoreNLPProtos.Sentence.Builder toProtoBuilder(CoreMap sentence, Set&lt;Cl
     // Required fields
     builder.setTokenOffsetBegin(getAndRegister(sentence, keysToSerialize, TokenBeginAnnotation.class));
     builder.setTokenOffsetEnd(getAndRegister(sentence, keysToSerialize, TokenEndAnnotation.class));
+    // Tokens
+    if (sentence.containsKey(TokensAnnotation.class)) {
+      for (CoreLabel tok : sentence.get(TokensAnnotation.class)) { builder.addToken(toProto(tok)); }
+      keysToSerialize.remove(TokensAnnotation.class);
+    }
     // Optional fields
     if (sentence.containsKey(SentenceIndexAnnotation.class)) { builder.setSentenceIndex(getAndRegister(sentence, keysToSerialize, SentenceIndexAnnotation.class)); }
     if (sentence.containsKey(CharacterOffsetBeginAnnotation.class)) { builder.setCharacterOffsetBegin(getAndRegister(sentence, keysToSerialize, CharacterOffsetBeginAnnotation.class)); }
@@ -348,6 +353,7 @@ protected CoreNLPProtos.Sentence.Builder toProtoBuilder(CoreMap sentence, Set&lt;Cl
    */
   public CoreNLPProtos.Document toProto(Annotation doc) {
     Set&lt;Class&lt;?&gt;&gt; keysToSerialize = new HashSet&lt;Class&lt;?&gt;&gt;(doc.keySet());
+    keysToSerialize.remove(TokensAnnotation.class);  // note(gabor): tokens are saved in the sentence
     CoreNLPProtos.Document.Builder builder = toProtoBuilder(doc, keysToSerialize);
     // Completeness Check
     if (enforceLosslessSerialization &amp;&amp; !keysToSerialize.isEmpty()) {
@@ -368,19 +374,17 @@ public CoreNLPProtos.Document toProto(Annotation doc) {
    *                        from this set, as the code tracks annotations to ensure lossless serializationA set tracking which keys have been saved. It's important to remove any keys added to the proto*
    *                        from this set, as the code tracks annotations to ensure lossless serialization.
    */
+  protected CoreNLPProtos.Document.Builder toProtoBuilder(Annotation doc, Set&lt;Class&lt;?&gt;&gt; keysToSerialize) {
     CoreNLPProtos.Document.Builder builder = CoreNLPProtos.Document.newBuilder();
     // Required fields
     builder.setText(doc.get(TextAnnotation.class));
     keysToSerialize.remove(TextAnnotation.class);
     // Optional fields
     if (doc.containsKey(SentencesAnnotation.class)) {
       for (CoreMap sentence : doc.get(SentencesAnnotation.class)) { builder.addSentence(toProto(sentence)); }
       keysToSerialize.remove(SentencesAnnotation.class);
+    } else if (doc.containsKey(TokensAnnotation.class)) {
+      for (CoreLabel token : doc.get(TokensAnnotation.class)) { builder.addSentencelessToken(toProto(token)); }
     }
     if (doc.containsKey(DocIDAnnotation.class)) {
       builder.setDocID(doc.get(DocIDAnnotation.class));
@@ -590,14 +594,37 @@ protected CoreLabel fromProto(CoreNLPProtos.Token proto) {
     return word;
   }
 
+  /**
+   * Create a CoreMap representing a sentence from this protocol buffer.
+   * This should not be used if you are reading a whole document, as it populates the tokens independent of the
+   * document tokens, which is not the behavior an {@link edu.stanford.nlp.pipeline.Annotation} expects.
+   *
+   * @param proto The protocol buffer to read from.
+   * @return A CoreMap representing the sentence.
+   */
+  public CoreMap fromProto(CoreNLPProtos.Sentence proto) {
+    CoreMap lossySentence = fromProtoNoTokens(proto);
+    // Add tokens -- missing by default as they're populated as sublists of the
+    // document tokens
+    List&lt;CoreLabel&gt; tokens = new ArrayList&lt;CoreLabel&gt;();
+    for (CoreNLPProtos.Token token : proto.getTokenList()) {
+      CoreLabel coreLabel = fromProto(token);
+      // Set docid
+      tokens.add(coreLabel);
+    }
+    lossySentence.set(TokensAnnotation.class, tokens);
+    // Return
+    return lossySentence;
+  }
+
   /**
    * Create a CoreMap representing a sentence from this protocol buffer.
    * Note that the sentence is very lossy -- most glaringly, the tokens are missing, awaiting a document
    * to be filled in from.
    * @param proto The serialized protobuf to read the sentence from.
    * @return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)
    */
+  protected CoreMap fromProtoNoTokens(CoreNLPProtos.Sentence proto) {
     CoreMap sentence = new ArrayCoreMap();
     // Required fields
     sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin());
@@ -636,20 +663,35 @@ public Annotation fromProto(CoreNLPProtos.Document proto) {
     Annotation ann = new Annotation(proto.getText());
 
     // Add tokens
+    List&lt;CoreLabel&gt; tokens = new ArrayList&lt;CoreLabel&gt;();
+    if (proto.getSentenceCount() &gt; 0) {
+      // Populate the tokens from the sentence
+      for (CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {
+        for (CoreNLPProtos.Token token : sentence.getTokenList()) {
+          CoreLabel coreLabel = fromProto(token);
+          // Set docid
+          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }
+          tokens.add(coreLabel);
+        }
+      }
+    } else if (proto.getSentencelessTokenCount() &gt; 0) {
+      // Eek -- no sentences. Try to recover tokens directly
+      if (proto.getSentencelessTokenCount() &gt; 0) {
+        for (CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {
+          CoreLabel coreLabel = fromProto(token);
+          // Set docid
+          if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }
+          tokens.add(coreLabel);
+        }
+      }
     }
     if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }
 
     // Add sentences
     List&lt;CoreMap&gt; sentences = new ArrayList&lt;CoreMap&gt;(proto.getSentenceCount());
     for (int sentIndex = 0; sentIndex &lt; proto.getSentenceCount(); ++sentIndex) {
       CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex);
+      CoreMap map = fromProtoNoTokens(sentence);
       if (!tokens.isEmpty() &amp;&amp; sentence.hasTokenOffsetBegin() &amp;&amp; sentence.hasTokenOffsetEnd()) {
         // Set tokens for sentence
         map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>108188</refactoring_id><commit_sha>f28cefc4c3df708ad492a941ea54cd830f5e53a4</commit_sha><commit_link>https://github.com/apache/cloudstack/commit/f28cefc4c3df708ad492a941ea54cd830f5e53a4</commit_link><file_path>server/src/com/cloud/network/NetworkManagerImpl.java</file_path><description>Extract Method protected removeNic(vm VirtualMachineProfile&lt;? extends VMInstanceVO&gt;, nic NicVO) : void extracted from public cleanupNics(vm VirtualMachineProfile&lt;? extends VMInstanceVO&gt;) : void in class com.cloud.network.NetworkManagerImpl</description><code_before>@@ -2022,11 +2022,14 @@ public int compare(NicVO nic1, NicVO nic2) {
     }
 
     @Override
     public NicProfile prepareNic(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vmProfile, DeployDestination 
             dest, ReservationContext context, long nicId, NetworkVO network)
             throws InsufficientVirtualNetworkCapcityException, InsufficientAddressCapacityException, 
             ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {
         
         Integer networkRate = getNetworkRate(network.getId(), vmProfile.getId());
         NetworkGuru guru = _networkGurus.get(network.getGuruName());
         NicVO nic = _nicDao.findById(nicId);
@@ -2090,7 +2093,8 @@ public &lt;T extends VMInstanceVO&gt; void prepareNicForMigration(VirtualMachineProfil
             Integer networkRate = getNetworkRate(network.getId(), vm.getId());
 
             NetworkGuru guru = _networkGurus.get(network.getGuruName());
-            NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), networkRate, isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
             guru.updateNicProfile(profile, network);
             vm.addNic(profile);
         }
@@ -2105,6 +2109,18 @@ public void release(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vmProfile, boo
             releaseNic(vmProfile, nic, network);
         }
     }
 
     protected void releaseNic(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vmProfile, NicVO nic, NetworkVO network) 
             throws ConcurrentOperationException, ResourceUnavailableException {
@@ -2283,15 +2299,27 @@ public void cleanupNics(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vm) {
 
         List&lt;NicVO&gt; nics = _nicDao.listByVmId(vm.getId());
         for (NicVO nic : nics) {
-            nic.setState(Nic.State.Deallocating);
-            _nicDao.update(nic.getId(), nic);
-            NetworkVO network = _networksDao.findById(nic.getNetworkId());
-            NicProfile profile = new NicProfile(nic, network, null, null, null, isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
-            NetworkGuru guru = _networkGurus.get(network.getGuruName());
-            guru.deallocate(network, profile, vm);
-            _nicDao.remove(nic.getId());
         }
     }
 
     @Override
     public void expungeNics(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vm) {
@@ -2629,21 +2657,18 @@ protected Network createVpcGuestNetwork(long ntwkOffId, String name, String disp
             PhysicalNetwork pNtwk, long zoneId, ACLType aclType, Boolean subdomainAccess, long vpcId) 
                     throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {
         
         //1) Validate if network can be created for VPC
-        _vpcMgr.validateGuestNtkwForVpc(_configMgr.getNetworkOffering(ntwkOffId), cidr, networkDomain, owner, 
-                _vpcMgr.getVpc(vpcId));
         
         //2) Create network
         Network guestNetwork = createGuestNetwork(ntwkOffId, name, displayText, gateway, cidr, vlanId, 
                 networkDomain, owner, domainId, pNtwk, zoneId, aclType, subdomainAccess, vpcId);
         
-        //3) Add network to all VPC's routers
-        List&lt;DomainRouterVO&gt; routers = _routerDao.listRoutersByVpcId(vpcId);
-        for (DomainRouterVO router : routers) {
-            s_logger.debug("Adding router " + router + " to network " + guestNetwork);
-            _routerDao.addRouterToNetwork(router, guestNetwork);
-        }
-        
         return guestNetwork;
     }
 
</code_before><code_after>@@ -2022,11 +2022,14 @@ public int compare(NicVO nic1, NicVO nic2) {
     }
 
     @Override
+    @DB
     public NicProfile prepareNic(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vmProfile, DeployDestination 
             dest, ReservationContext context, long nicId, NetworkVO network)
             throws InsufficientVirtualNetworkCapcityException, InsufficientAddressCapacityException, 
             ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {
         
+        
+        
         Integer networkRate = getNetworkRate(network.getId(), vmProfile.getId());
         NetworkGuru guru = _networkGurus.get(network.getGuruName());
         NicVO nic = _nicDao.findById(nicId);
@@ -2090,7 +2093,8 @@ public &lt;T extends VMInstanceVO&gt; void prepareNicForMigration(VirtualMachineProfil
             Integer networkRate = getNetworkRate(network.getId(), vm.getId());
 
             NetworkGuru guru = _networkGurus.get(network.getGuruName());
+            NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), networkRate, 
+                    isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
             guru.updateNicProfile(profile, network);
             vm.addNic(profile);
         }
@@ -2105,6 +2109,18 @@ public void release(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vmProfile, boo
             releaseNic(vmProfile, nic, network);
         }
     }
+    
+    @Override
+    public NicProfile releaseNic(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vmProfile, NetworkVO network) 
+            throws ConcurrentOperationException, ResourceUnavailableException {
+        NicVO nic = _nicDao.findByInstanceIdAndNetworkId(network.getId(), vmProfile.getId());
+        releaseNic(vmProfile, nic, network);
+        
+        NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), null, 
+                isSecurityGroupSupportedInNetwork(network), getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));
+        return profile;
+    }
+    
 
     protected void releaseNic(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vmProfile, NicVO nic, NetworkVO network) 
             throws ConcurrentOperationException, ResourceUnavailableException {
@@ -2283,15 +2299,27 @@ public void cleanupNics(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vm) {
 
         List&lt;NicVO&gt; nics = _nicDao.listByVmId(vm.getId());
         for (NicVO nic : nics) {
+            removeNic(vm, nic);
         }
     }
+    
+    @Override
+    public void removeNic(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vm, Network network) {
+        NicVO nic = _nicDao.findByInstanceIdAndNetworkId(network.getId(), vm.getVirtualMachine().getId());
+        removeNic(vm, nic);
+    }
+
+    protected void removeNic(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vm, NicVO nic) {
+        nic.setState(Nic.State.Deallocating);
+        _nicDao.update(nic.getId(), nic);
+        NetworkVO network = _networksDao.findById(nic.getNetworkId());
+        NicProfile profile = new NicProfile(nic, network, null, null, null,
+                isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
+        NetworkGuru guru = _networkGurus.get(network.getGuruName());
+        guru.deallocate(network, profile, vm);
+        _nicDao.remove(nic.getId());
+        s_logger.debug("Removed nic id=" + nic.getId());
+    }
 
     @Override
     public void expungeNics(VirtualMachineProfile&lt;? extends VMInstanceVO&gt; vm) {
@@ -2629,21 +2657,18 @@ protected Network createVpcGuestNetwork(long ntwkOffId, String name, String disp
             PhysicalNetwork pNtwk, long zoneId, ACLType aclType, Boolean subdomainAccess, long vpcId) 
                     throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {
         
+        Vpc vpc = _vpcMgr.getVpc(vpcId);
         //1) Validate if network can be created for VPC
+        _vpcMgr.validateGuestNtkwForVpc(_configMgr.getNetworkOffering(ntwkOffId), cidr, networkDomain, owner, vpc);
+        
+        if (networkDomain == null) {
+            networkDomain = vpc.getNetworkDomain();
+        }
         
         //2) Create network
         Network guestNetwork = createGuestNetwork(ntwkOffId, name, displayText, gateway, cidr, vlanId, 
                 networkDomain, owner, domainId, pNtwk, zoneId, aclType, subdomainAccess, vpcId);
         
         return guestNetwork;
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>112382</refactoring_id><commit_sha>772135e62ddc31aa4944a8993f0c3c3a28e1c6e1</commit_sha><commit_link>https://github.com/apache/flink/commit/772135e62ddc31aa4944a8993f0c3c3a28e1c6e1</commit_link><file_path>flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/handlers/JarRunRequestBody.java</file_path><description>Extract Method public JarRunRequestBody(entryClassName String, programArguments String, programArgumentsList List&lt;String&gt;, parallelism Integer, jobId JobID, allowNonRestoredState Boolean, savepointPath String, deprecatedRestoreMode RestoreMode, restoreMode RestoreMode, flinkConfiguration Map&lt;String,String&gt;) extracted from public JarRunRequestBody(entryClassName String, programArguments String, programArgumentsList List&lt;String&gt;, parallelism Integer, jobId JobID, allowNonRestoredState Boolean, savepointPath String, restoreMode RestoreMode, flinkConfiguration Map&lt;String,String&gt;) in class org.apache.flink.runtime.webmonitor.handlers.JarRunRequestBody</description><code_before>@@ -18,6 +18,8 @@
 
 package org.apache.flink.runtime.webmonitor.handlers;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.core.execution.RestoreMode;
 import org.apache.flink.runtime.rest.messages.RequestBody;
@@ -36,8 +38,12 @@
 @JsonInclude(JsonInclude.Include.NON_NULL)
 public class JarRunRequestBody extends JarRequestBody {
     private static final String FIELD_NAME_ALLOW_NON_RESTORED_STATE = "allowNonRestoredState";
     private static final String FIELD_NAME_SAVEPOINT_PATH = "savepointPath";
-    private static final String FIELD_NAME_SAVEPOINT_RESTORE_MODE = "restoreMode";
 
     @JsonProperty(FIELD_NAME_ALLOW_NON_RESTORED_STATE)
     @Nullable
@@ -49,10 +55,41 @@ public class JarRunRequestBody extends JarRequestBody {
 
     @JsonProperty(FIELD_NAME_SAVEPOINT_RESTORE_MODE)
     @Nullable
     private RestoreMode restoreMode;
 
     public JarRunRequestBody() {
-        this(null, null, null, null, null, null, null, null, null);
     }
 
     @JsonCreator
@@ -66,7 +103,9 @@ public JarRunRequestBody(
             @Nullable @JsonProperty(FIELD_NAME_ALLOW_NON_RESTORED_STATE)
                     Boolean allowNonRestoredState,
             @Nullable @JsonProperty(FIELD_NAME_SAVEPOINT_PATH) String savepointPath,
-            @Nullable @JsonProperty(FIELD_NAME_SAVEPOINT_RESTORE_MODE) RestoreMode restoreMode,
             @Nullable @JsonProperty(FIELD_NAME_FLINK_CONFIGURATION)
                     Map&lt;String, String&gt; flinkConfiguration) {
         super(
@@ -78,6 +117,7 @@ public JarRunRequestBody(
                 flinkConfiguration);
         this.allowNonRestoredState = allowNonRestoredState;
         this.savepointPath = savepointPath;
         this.restoreMode = restoreMode;
     }
 
@@ -96,6 +136,11 @@ public String getSavepointPath() {
     @Nullable
     @JsonIgnore
     public RestoreMode getRestoreMode() {
-        return restoreMode;
     }
 }
</code_before><code_after>@@ -18,6 +18,8 @@
 
 package org.apache.flink.runtime.webmonitor.handlers;
 
+import org.apache.flink.annotation.VisibleForTesting;
+import org.apache.flink.annotation.docs.Documentation;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.core.execution.RestoreMode;
 import org.apache.flink.runtime.rest.messages.RequestBody;
@@ -36,8 +38,12 @@
 @JsonInclude(JsonInclude.Include.NON_NULL)
 public class JarRunRequestBody extends JarRequestBody {
     private static final String FIELD_NAME_ALLOW_NON_RESTORED_STATE = "allowNonRestoredState";
+
     private static final String FIELD_NAME_SAVEPOINT_PATH = "savepointPath";
+
+    @Deprecated private static final String FIELD_NAME_SAVEPOINT_RESTORE_MODE = "restoreMode";
+
+    private static final String FIELD_NAME_SAVEPOINT_CLAIM_MODE = "claimMode";
 
     @JsonProperty(FIELD_NAME_ALLOW_NON_RESTORED_STATE)
     @Nullable
@@ -49,10 +55,41 @@ public class JarRunRequestBody extends JarRequestBody {
 
     @JsonProperty(FIELD_NAME_SAVEPOINT_RESTORE_MODE)
     @Nullable
+    @Deprecated
+    @Documentation.ExcludeFromDocumentation
+    private RestoreMode deprecatedRestoreMode;
+
+    @JsonProperty(FIELD_NAME_SAVEPOINT_CLAIM_MODE)
+    @Nullable
     private RestoreMode restoreMode;
 
     public JarRunRequestBody() {
+        this(null, null, null, null, null, null, null, null, null, null);
+    }
+
+    /** Fallback constructor ONLY for tests. */
+    @VisibleForTesting
+    public JarRunRequestBody(
+            @Nullable String entryClassName,
+            @Nullable String programArguments,
+            @Nullable List&lt;String&gt; programArgumentsList,
+            @Nullable Integer parallelism,
+            @Nullable JobID jobId,
+            @Nullable Boolean allowNonRestoredState,
+            @Nullable String savepointPath,
+            @Nullable RestoreMode restoreMode,
+            @Nullable Map&lt;String, String&gt; flinkConfiguration) {
+        this(
+                entryClassName,
+                programArguments,
+                programArgumentsList,
+                parallelism,
+                jobId,
+                allowNonRestoredState,
+                savepointPath,
+                null,
+                restoreMode,
+                flinkConfiguration);
     }
 
     @JsonCreator
@@ -66,7 +103,9 @@ public JarRunRequestBody(
             @Nullable @JsonProperty(FIELD_NAME_ALLOW_NON_RESTORED_STATE)
                     Boolean allowNonRestoredState,
             @Nullable @JsonProperty(FIELD_NAME_SAVEPOINT_PATH) String savepointPath,
+            @Nullable @JsonProperty(FIELD_NAME_SAVEPOINT_RESTORE_MODE)
+                    RestoreMode deprecatedRestoreMode,
+            @Nullable @JsonProperty(FIELD_NAME_SAVEPOINT_CLAIM_MODE) RestoreMode restoreMode,
             @Nullable @JsonProperty(FIELD_NAME_FLINK_CONFIGURATION)
                     Map&lt;String, String&gt; flinkConfiguration) {
         super(
@@ -78,6 +117,7 @@ public JarRunRequestBody(
                 flinkConfiguration);
         this.allowNonRestoredState = allowNonRestoredState;
         this.savepointPath = savepointPath;
+        this.deprecatedRestoreMode = deprecatedRestoreMode;
         this.restoreMode = restoreMode;
     }
 
@@ -96,6 +136,11 @@ public String getSavepointPath() {
     @Nullable
     @JsonIgnore
     public RestoreMode getRestoreMode() {
+        return restoreMode == null ? deprecatedRestoreMode : restoreMode;
+    }
+
+    @JsonIgnore
+    public boolean isDeprecatedRestoreModeHasValue() {
+        return deprecatedRestoreMode != null;
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>12344</refactoring_id><commit_sha>b760dc07b67bd9ef129e3f775f8becb872c8d268</commit_sha><commit_link>https://github.com/apache/pinot/commit/b760dc07b67bd9ef129e3f775f8becb872c8d268</commit_link><file_path>pinot-tools/src/main/java/com/linkedin/pinot/tools/admin/command/AbstractBaseCommand.java</file_path><description>Extract Method public AbstractBaseCommand(addShutdownHook boolean) extracted from public AbstractBaseCommand() in class com.linkedin.pinot.tools.admin.command.AbstractBaseCommand</description><code_before>@@ -40,13 +40,19 @@ public class AbstractBaseCommand {
   static final String DEFAULT_ZK_ADDRESS = "localhost:2181";
   static final String DEFAULT_CONTROLLER_PORT = "9000";
 
   public AbstractBaseCommand() {
-    Runtime.getRuntime().addShutdownHook(new Thread() {
-      @Override
-      public void run() {
-        cleanup();
-      }
-    });
   }
 
   public void cleanup() {
</code_before><code_after>@@ -40,13 +40,19 @@ public class AbstractBaseCommand {
   static final String DEFAULT_ZK_ADDRESS = "localhost:2181";
   static final String DEFAULT_CONTROLLER_PORT = "9000";
 
+  public AbstractBaseCommand(boolean addShutdownHook) {
+    if (addShutdownHook) {
+      Runtime.getRuntime().addShutdownHook(new Thread() {
+        @Override
+        public void run() {
+          cleanup();
+        }
+      });
+    }
+  }
+
   public AbstractBaseCommand() {
+    this(true);
   }
 
   public void cleanup() {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>107368</refactoring_id><commit_sha>2727fd2ee2d8d7ed0c498c893c426b7f86ad649b</commit_sha><commit_link>https://github.com/metersphere/metersphere/commit/2727fd2ee2d8d7ed0c498c893c426b7f86ad649b</commit_link><file_path>backend/src/main/java/io/metersphere/api/service/ApiDefinitionService.java</file_path><description>Extract Method private sendFailMessage(request ApiTestImportRequest, project Project) : void extracted from public apiTestImport(file MultipartFile, request ApiTestImportRequest) : ApiDefinitionImport in class io.metersphere.api.service.ApiDefinitionService</description><code_before>@@ -1549,15 +1549,17 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
         }
         ApiImportParser runService = ApiDefinitionImportParserFactory.getApiImportParser(request.getPlatform());
         ApiDefinitionImport apiImport = null;
         if (StringUtils.isNotBlank(request.getSwaggerUrl())) {
             if (!request.getPlatform().equalsIgnoreCase("Swagger2")) {
                 MSException.throwException("&#x6587;&#x4EF6;&#x683C;&#x5F0F;&#x4E0D;&#x7B26;&#x5408;&#x8981;&#x6C42;");
             }
             if (!UrlTestUtils.testUrlWithTimeOut(request.getSwaggerUrl(), 30000)) {
                 MSException.throwException(Translator.get("connection_timeout"));
             }
         }
-        Project project = projectMapper.selectByPrimaryKey(request.getProjectId());
         if (StringUtils.equals(request.getType(), "schedule")) {
             request.setProtocol("HTTP");
         }
@@ -1567,6 +1569,8 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
                 apiImport.setMocks(new ArrayList&lt;&gt;());
             }
         } catch (Exception e) {
             LogUtil.error(e.getMessage(), e);
             String returnThrowException = e.getMessage();
             if (StringUtils.contains(returnThrowException, "&#x6A21;&#x5757;&#x6811;&#x6700;&#x5927;&#x6DF1;&#x5EA6;&#x4E3A;")) {
@@ -1578,23 +1582,6 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
                     MSException.throwException(Translator.get("parse_data_error"));
                 }
             }
-            // &#x53D1;&#x9001;&#x901A;&#x77E5;
-            if (StringUtils.equals(request.getType(), "schedule")) {
-                String scheduleId = scheduleService.getScheduleInfo(request.getResourceId());
-                String context = request.getSwaggerUrl() + "&#x5BFC;&#x5165;&#x5931;&#x8D25;";
-                Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();
-                paramMap.put("url", request.getSwaggerUrl());
-                paramMap.put("projectId", request.getProjectId());
-                NoticeModel noticeModel = NoticeModel.builder()
-                        .operator(project.getCreateUser())
-                        .context(context)
-                        .testId(scheduleId)
-                        .subject(Translator.get("swagger_url_scheduled_import_notification"))
-                        .paramMap(paramMap)
-                        .event(NoticeConstants.Event.IMPORT)
-                        .build();
-                noticeSendService.send(NoticeConstants.TaskType.SWAGGER_TASK, noticeModel);
-            }
         }
         try {
             importApi(request, apiImport);
@@ -1621,12 +1608,32 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
                 noticeSendService.send(NoticeConstants.Mode.SCHEDULE, "", noticeModel);
             }
         } catch (Exception e) {
             LogUtil.error(e);
             MSException.throwException(Translator.get("user_import_format_wrong"));
         }
         return apiImport;
     }
 
     private void checkFileSuffixName(ApiTestImportRequest request, String suffixName) {
         if (suffixName.equalsIgnoreCase("jmx")) {
             if (!request.getPlatform().equalsIgnoreCase("JMeter")) {
</code_before><code_after>@@ -1549,15 +1549,17 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
         }
         ApiImportParser runService = ApiDefinitionImportParserFactory.getApiImportParser(request.getPlatform());
         ApiDefinitionImport apiImport = null;
+        Project project = projectMapper.selectByPrimaryKey(request.getProjectId());
         if (StringUtils.isNotBlank(request.getSwaggerUrl())) {
             if (!request.getPlatform().equalsIgnoreCase("Swagger2")) {
+                this.sendFailMessage(request, project);
                 MSException.throwException("&#x6587;&#x4EF6;&#x683C;&#x5F0F;&#x4E0D;&#x7B26;&#x5408;&#x8981;&#x6C42;");
             }
             if (!UrlTestUtils.testUrlWithTimeOut(request.getSwaggerUrl(), 30000)) {
+                this.sendFailMessage(request, project);
                 MSException.throwException(Translator.get("connection_timeout"));
             }
         }
         if (StringUtils.equals(request.getType(), "schedule")) {
             request.setProtocol("HTTP");
         }
@@ -1567,6 +1569,8 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
                 apiImport.setMocks(new ArrayList&lt;&gt;());
             }
         } catch (Exception e) {
+            // &#x53D1;&#x9001;&#x901A;&#x77E5;
+            this.sendFailMessage(request, project);
             LogUtil.error(e.getMessage(), e);
             String returnThrowException = e.getMessage();
             if (StringUtils.contains(returnThrowException, "&#x6A21;&#x5757;&#x6811;&#x6700;&#x5927;&#x6DF1;&#x5EA6;&#x4E3A;")) {
@@ -1578,23 +1582,6 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
                     MSException.throwException(Translator.get("parse_data_error"));
                 }
             }
         }
         try {
             importApi(request, apiImport);
@@ -1621,12 +1608,32 @@ public ApiDefinitionImport apiTestImport(MultipartFile file, ApiTestImportReques
                 noticeSendService.send(NoticeConstants.Mode.SCHEDULE, "", noticeModel);
             }
         } catch (Exception e) {
+            this.sendFailMessage(request, project);
             LogUtil.error(e);
             MSException.throwException(Translator.get("user_import_format_wrong"));
         }
         return apiImport;
     }
 
+    private void sendFailMessage(ApiTestImportRequest request, Project project) {
+        if (StringUtils.equals(request.getType(), "schedule")) {
+            String scheduleId = scheduleService.getScheduleInfo(request.getResourceId());
+            String context = request.getSwaggerUrl() + "&#x5BFC;&#x5165;&#x5931;&#x8D25;";
+            Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();
+            paramMap.put("url", request.getSwaggerUrl());
+            paramMap.put("projectId", request.getProjectId());
+            NoticeModel noticeModel = NoticeModel.builder()
+                    .operator(project.getCreateUser())
+                    .context(context)
+                    .testId(scheduleId)
+                    .subject(Translator.get("swagger_url_scheduled_import_notification"))
+                    .paramMap(paramMap)
+                    .event(NoticeConstants.Event.EXECUTE_FAILED)
+                    .build();
+            noticeSendService.send(NoticeConstants.Mode.SCHEDULE, "", noticeModel);
+        }
+    }
+
     private void checkFileSuffixName(ApiTestImportRequest request, String suffixName) {
         if (suffixName.equalsIgnoreCase("jmx")) {
             if (!request.getPlatform().equalsIgnoreCase("JMeter")) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>102194</refactoring_id><commit_sha>285aff8cc2e0611a45a9f6ea3717326d9ab054c7</commit_sha><commit_link>https://github.com/cuba-platform/cuba/commit/285aff8cc2e0611a45a9f6ea3717326d9ab054c7</commit_link><file_path>modules/web-war/src/com/vaadin/terminal/gwt/client/ApplicationConnection.java</file_path><description>Extract Method private updateComponentSize(cd ComponentDetail, w String, h String, relativeWidth float, relativeHeight float) : void extracted from private updateComponentSize(cd ComponentDetail, uidl UIDL) : void in class com.vaadin.terminal.gwt.client.ApplicationConnection</description><code_before>@@ -1758,6 +1758,10 @@ private void updateComponentSize(ComponentDetail cd, UIDL uidl) {
         float relativeWidth = Util.parseRelativeSize(w);
         float relativeHeight = Util.parseRelativeSize(h);
 
         // First update maps so they are correct in the setHeight/setWidth calls
         if (relativeHeight &gt;= 0.0 || relativeWidth &gt;= 0.0) {
             // One or both is relative
@@ -1790,7 +1794,6 @@ private void updateComponentSize(ComponentDetail cd, UIDL uidl) {
             // One or both is relative
             handleComponentRelativeSize(cd);
         }
-
     }
 
     /**
@@ -2018,6 +2021,11 @@ public boolean handleComponentRelativeSize(Widget child) {
 
     }
 
     /**
      * Gets the specified Paintables relative size (percent).
      *
</code_before><code_after>@@ -1758,6 +1758,10 @@ private void updateComponentSize(ComponentDetail cd, UIDL uidl) {
         float relativeWidth = Util.parseRelativeSize(w);
         float relativeHeight = Util.parseRelativeSize(h);
 
+        updateComponentSize(cd, w, h, relativeWidth, relativeHeight);
+    }
+
+    private void updateComponentSize(ComponentDetail cd, String w, String h, float relativeWidth, float relativeHeight) {
         // First update maps so they are correct in the setHeight/setWidth calls
         if (relativeHeight &gt;= 0.0 || relativeWidth &gt;= 0.0) {
             // One or both is relative
@@ -1790,7 +1794,6 @@ private void updateComponentSize(ComponentDetail cd, UIDL uidl) {
             // One or both is relative
             handleComponentRelativeSize(cd);
         }
     }
 
     /**
@@ -2018,6 +2021,11 @@ public boolean handleComponentRelativeSize(Widget child) {
 
     }
 
+    public void updateComponentSize(Widget child, String w, String h) {
+        ComponentDetail cd = idToPaintableDetail.get(getPid(child.getElement()));
+        updateComponentSize(cd, w, h, cd.getRelativeSize().getWidth(), cd.getRelativeSize().getHeight());
+    }
+
     /**
      * Gets the specified Paintables relative size (percent).
      *
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>62687</refactoring_id><commit_sha>7c9c14357667ec0dfbea97fffce98da22b16ff0c</commit_sha><commit_link>https://github.com/apache/tomcat/commit/7c9c14357667ec0dfbea97fffce98da22b16ff0c</commit_link><file_path>java/org/apache/tomcat/util/buf/B2CConverter.java</file_path><description>Extract Method public convert(bb ByteChunk, cb CharChunk, limit int) : void extracted from public convert(bb ByteChunk, cb CharChunk) : void in class org.apache.tomcat.util.buf.B2CConverter</description><code_before>@@ -68,22 +68,31 @@ public  void recycle() {
     char result[]=new char[BUFFER_SIZE];
 
     /** Convert a buffer of bytes into a chars
      */
     public  void convert( ByteChunk bb, CharChunk cb )
 	throws IOException
     {
 	// Set the ByteChunk as input to the Intermediate reader
-	iis.setByteChunk( bb );
-	convert(cb);
     }
 
-    private void convert(CharChunk cb)
 	throws IOException
     {
 	try {
 	    // read from the reader
-	    while( iis.available()&gt;0 ) { // conv.ready() ) {
-		int cnt=conv.read( result, 0, BUFFER_SIZE );
 		if( cnt &lt;= 0 ) {
 		    // End of stream ! - we may be in a bad state
 		    if( debug&gt;0)
@@ -96,6 +105,7 @@ private void convert(CharChunk cb)
 
 		// XXX go directly
 		cb.append( result, 0, cnt );
 	    }
 	} catch( IOException ex) {
 	    if( debug&gt;0)
@@ -211,10 +221,6 @@ public  final int read(char cbuf[], int off, int len)
 	return super.read( cbuf, off, len );
     }
     
-    public final int read() throws IOException {
-        return super.read();
-    }
-    
     /** Reset the buffer
      */
     public  final void recycle() {
@@ -229,10 +235,7 @@ public  final void recycle() {
     not be called if recycling the converter and if data was not flushed.
 */
 final class IntermediateInputStream extends InputStream {
-    byte buf[];
-    int pos;
-    int len;
-    int end;
     
     public IntermediateInputStream() {
     }
@@ -243,64 +246,18 @@ public  final void close() throws IOException {
     }
     
     public  final  int read(byte cbuf[], int off, int len) throws IOException {
-	if( pos &gt;= end ) return -1;
-	if (pos + len &gt; end) {
-	    len = end - pos;
-	}
-	if (len &lt;= 0) {
-	    return 0;
-	}
-	System.arraycopy(buf, pos, cbuf, off, len);
-	pos += len;
-	return len;
     }
     
     public  final int read() throws IOException {
-	return (pos &lt; end ) ? (buf[pos++] &amp; 0xff) : -1;
     }
-    
     // -------------------- Internal methods --------------------
 
-    void setBuffer( byte b[], int p, int l ) {
-	buf=b;
-	pos=p;
-	len=l;
-	end=pos+len;
-    }
 
     void setByteChunk( ByteChunk mb ) {
-	buf=mb.getBytes();
-	pos=mb.getStart();
-	len=mb.getLength();
-	end=pos+len;
-    }
-
-    public int available() throws IOException {
-        return end-pos;
-    }
-
-    public boolean markSupported() {
-        return false;
-    }
-
-    public int read(byte[] b) throws IOException {
-        return read(b,0,b.length);
-    }
-
-    /**
-     * Repositions this stream to the position at the time the &lt;code&gt;mark&lt;/code&gt; method was last called on this input
-     * stream.
-     *
-     * @throws IOException if this stream has not been marked or if the mark has been invalidated.
-     * @todo Implement this java.io.InputStream method
-     */
-    public synchronized void reset() throws IOException {
-        //not implemented
-    }
-
-    public long skip(long n) throws IOException {
-        //not implemented
-        return 0L;
     }
 
 }
</code_before><code_after>@@ -68,22 +68,31 @@ public  void recycle() {
     char result[]=new char[BUFFER_SIZE];
 
     /** Convert a buffer of bytes into a chars
+     * @deprecated
      */
     public  void convert( ByteChunk bb, CharChunk cb )
 	throws IOException
     {
 	// Set the ByteChunk as input to the Intermediate reader
+	convert(bb, cb, cb.getBuffer().length - cb.getEnd());
     }
 
+    public void convert( ByteChunk bb, CharChunk cb, int limit) 
+        throws IOException
+    {
+        iis.setByteChunk( bb );
+        convert(cb, limit);
+    }
+
+    private void convert(CharChunk cb, int limit)
 	throws IOException
     {
 	try {
 	    // read from the reader
+            int count = 0;
+	    while( limit &gt; 0 ) { // conv.ready() ) {
+                int size = limit &lt; BUFFER_SIZE ? limit : BUFFER_SIZE;
+		int cnt=conv.read( result, 0, size );
 		if( cnt &lt;= 0 ) {
 		    // End of stream ! - we may be in a bad state
 		    if( debug&gt;0)
@@ -96,6 +105,7 @@ private void convert(CharChunk cb)
 
 		// XXX go directly
 		cb.append( result, 0, cnt );
+                limit -= cnt;
 	    }
 	} catch( IOException ex) {
 	    if( debug&gt;0)
@@ -211,10 +221,6 @@ public  final int read(char cbuf[], int off, int len)
 	return super.read( cbuf, off, len );
     }
     
     /** Reset the buffer
      */
     public  final void recycle() {
@@ -229,10 +235,7 @@ public  final void recycle() {
     not be called if recycling the converter and if data was not flushed.
 */
 final class IntermediateInputStream extends InputStream {
+    ByteChunk bc = null;
     
     public IntermediateInputStream() {
     }
@@ -243,64 +246,18 @@ public  final void close() throws IOException {
     }
     
     public  final  int read(byte cbuf[], int off, int len) throws IOException {
+	return bc.substract(cbuf, off, len);
     }
     
     public  final int read() throws IOException {
+	return bc.substract();
     }
+
     // -------------------- Internal methods --------------------
 
 
     void setByteChunk( ByteChunk mb ) {
+        bc = mb;
     }
 
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>88417</refactoring_id><commit_sha>088ab3eaadb2389b52aedc049b6f1f0d4b5fb989</commit_sha><commit_link>https://github.com/apache/kafka/commit/088ab3eaadb2389b52aedc049b6f1f0d4b5fb989</commit_link><file_path>streams/src/main/java/org/apache/kafka/streams/kstream/internals/KGroupedTableImpl.java</file_path><description>Extract Method private doAggregate(aggregateSupplier ProcessorSupplier&lt;K,Change&lt;V&gt;&gt;, aggValueSerde Serde&lt;T&gt;, functionName String, name String) : KTable&lt;K,T&gt; extracted from public reduce(adder Reducer&lt;V&gt;, subtractor Reducer&lt;V&gt;, name String) : KTable&lt;K,V&gt; in class org.apache.kafka.streams.kstream.internals.KGroupedTableImpl</description><code_before>@@ -67,41 +67,8 @@ public &lt;T&gt; KTable&lt;K, T&gt; aggregate(Initializer&lt;T&gt; initializer,
                                       Serde&lt;T&gt; aggValueSerde,
                                       String name) {
 
-        String sinkName = topology.newName(KStreamImpl.SINK_NAME);
-        String sourceName = topology.newName(KStreamImpl.SOURCE_NAME);
-        String aggregateName = topology.newName(AGGREGATE_NAME);
-
-        String topic = name + REPARTITION_TOPIC_SUFFIX;
-
-        Serializer&lt;K&gt; keySerializer = keySerde == null ? null : keySerde.serializer();
-        Deserializer&lt;K&gt; keyDeserializer = keySerde == null ? null : keySerde.deserializer();
-        Serializer&lt;V&gt; valueSerializer = valSerde == null ? null : valSerde.serializer();
-        Deserializer&lt;V&gt; valueDeserializer = valSerde == null ? null : valSerde.deserializer();
-
-        ChangedSerializer&lt;V&gt; changedValueSerializer = new ChangedSerializer&lt;&gt;(valueSerializer);
-        ChangedDeserializer&lt;V&gt; changedValueDeserializer = new ChangedDeserializer&lt;&gt;(valueDeserializer);
-
         ProcessorSupplier&lt;K, Change&lt;V&gt;&gt; aggregateSupplier = new KTableAggregate&lt;&gt;(name, initializer, adder, subtractor);
-
-        StateStoreSupplier aggregateStore = Stores.create(name)
-                .withKeys(keySerde)
-                .withValues(aggValueSerde)
-                .persistent()
-                .build();
-
-        // send the aggregate key-value pairs to the intermediate topic for partitioning
-        topology.addInternalTopic(topic);
-        topology.addSink(sinkName, topic, keySerializer, changedValueSerializer, this.name);
-
-        // read the intermediate topic
-        topology.addSource(sourceName, keyDeserializer, changedValueDeserializer, topic);
-
-        // aggregate the values with the aggregator and local store
-        topology.addProcessor(aggregateName, aggregateSupplier, sourceName);
-        topology.addStateStore(aggregateStore, aggregateName);
-
-        // return the KTable representation with the intermediate topic as the sources
-        return new KTableImpl&lt;&gt;(topology, aggregateName, aggregateSupplier, Collections.singleton(sourceName));
     }
 
     @Override
@@ -113,14 +80,13 @@ public &lt;T&gt; KTable&lt;K, T&gt; aggregate(Initializer&lt;T&gt; initializer,
         return aggregate(initializer, adder, substractor, null, name);
     }
 
-    @Override
-    public KTable&lt;K, V&gt; reduce(Reducer&lt;V&gt; adder,
-                               Reducer&lt;V&gt; subtractor,
-                               String name) {
-
         String sinkName = topology.newName(KStreamImpl.SINK_NAME);
         String sourceName = topology.newName(KStreamImpl.SOURCE_NAME);
-        String reduceName = topology.newName(REDUCE_NAME);
 
         String topic = name + REPARTITION_TOPIC_SUFFIX;
 
@@ -132,13 +98,11 @@ public KTable&lt;K, V&gt; reduce(Reducer&lt;V&gt; adder,
         ChangedSerializer&lt;V&gt; changedValueSerializer = new ChangedSerializer&lt;&gt;(valueSerializer);
         ChangedDeserializer&lt;V&gt; changedValueDeserializer = new ChangedDeserializer&lt;&gt;(valueDeserializer);
 
-        ProcessorSupplier&lt;K, Change&lt;V&gt;&gt; aggregateSupplier = new KTableReduce&lt;&gt;(name, adder, subtractor);
-
         StateStoreSupplier aggregateStore = Stores.create(name)
-                .withKeys(keySerde)
-                .withValues(valSerde)
-                .persistent()
-                .build();
 
         // send the aggregate key-value pairs to the intermediate topic for partitioning
         topology.addInternalTopic(topic);
@@ -148,11 +112,19 @@ public KTable&lt;K, V&gt; reduce(Reducer&lt;V&gt; adder,
         topology.addSource(sourceName, keyDeserializer, changedValueDeserializer, topic);
 
         // aggregate the values with the aggregator and local store
-        topology.addProcessor(reduceName, aggregateSupplier, sourceName);
-        topology.addStateStore(aggregateStore, reduceName);
 
         // return the KTable representation with the intermediate topic as the sources
-        return new KTableImpl&lt;&gt;(topology, reduceName, aggregateSupplier, Collections.singleton(sourceName));
     }
 
     @Override
@@ -177,4 +149,5 @@ public Long apply(K aggKey, V value, Long aggregate) {
                 },
                 Serdes.Long(), name);
     }
-}
\ No newline at end of file
</code_before><code_after>@@ -67,41 +67,8 @@ public &lt;T&gt; KTable&lt;K, T&gt; aggregate(Initializer&lt;T&gt; initializer,
                                       Serde&lt;T&gt; aggValueSerde,
                                       String name) {
 
         ProcessorSupplier&lt;K, Change&lt;V&gt;&gt; aggregateSupplier = new KTableAggregate&lt;&gt;(name, initializer, adder, subtractor);
+        return doAggregate(aggregateSupplier, aggValueSerde, AGGREGATE_NAME, name);
     }
 
     @Override
@@ -113,14 +80,13 @@ public &lt;T&gt; KTable&lt;K, T&gt; aggregate(Initializer&lt;T&gt; initializer,
         return aggregate(initializer, adder, substractor, null, name);
     }
 
+    private &lt;T&gt; KTable&lt;K, T&gt; doAggregate(ProcessorSupplier&lt;K, Change&lt;V&gt;&gt; aggregateSupplier,
+                                         Serde&lt;T&gt; aggValueSerde,
+                                         String functionName,
+                                         String name) {
         String sinkName = topology.newName(KStreamImpl.SINK_NAME);
         String sourceName = topology.newName(KStreamImpl.SOURCE_NAME);
+        String funcName = topology.newName(functionName);
 
         String topic = name + REPARTITION_TOPIC_SUFFIX;
 
@@ -132,13 +98,11 @@ public KTable&lt;K, V&gt; reduce(Reducer&lt;V&gt; adder,
         ChangedSerializer&lt;V&gt; changedValueSerializer = new ChangedSerializer&lt;&gt;(valueSerializer);
         ChangedDeserializer&lt;V&gt; changedValueDeserializer = new ChangedDeserializer&lt;&gt;(valueDeserializer);
 
         StateStoreSupplier aggregateStore = Stores.create(name)
+            .withKeys(keySerde)
+            .withValues(aggValueSerde)
+            .persistent()
+            .build();
 
         // send the aggregate key-value pairs to the intermediate topic for partitioning
         topology.addInternalTopic(topic);
@@ -148,11 +112,19 @@ public KTable&lt;K, V&gt; reduce(Reducer&lt;V&gt; adder,
         topology.addSource(sourceName, keyDeserializer, changedValueDeserializer, topic);
 
         // aggregate the values with the aggregator and local store
+        topology.addProcessor(funcName, aggregateSupplier, sourceName);
+        topology.addStateStore(aggregateStore, funcName);
 
         // return the KTable representation with the intermediate topic as the sources
+        return new KTableImpl&lt;&gt;(topology, funcName, aggregateSupplier, Collections.singleton(sourceName));
+    }
+
+    @Override
+    public KTable&lt;K, V&gt; reduce(Reducer&lt;V&gt; adder,
+                               Reducer&lt;V&gt; subtractor,
+                               String name) {
+        ProcessorSupplier&lt;K, Change&lt;V&gt;&gt; aggregateSupplier = new KTableReduce&lt;&gt;(name, adder, subtractor);
+        return doAggregate(aggregateSupplier, valSerde, REDUCE_NAME, name);
     }
 
     @Override
@@ -177,4 +149,5 @@ public Long apply(K aggKey, V value, Long aggregate) {
                 },
                 Serdes.Long(), name);
     }
+
+}
\ No newline at end of file
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>77306</refactoring_id><commit_sha>83bb4ddf9f2d9fe6e9ceafeadb1b13a79c0a21a5</commit_sha><commit_link>https://github.com/libgdx/libgdx/commit/83bb4ddf9f2d9fe6e9ceafeadb1b13a79c0a21a5</commit_link><file_path>gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java</file_path><description>Extract Method public invalidateTapSquare() : void extracted from public touchDragged(event InputEvent, x float, y float, pointer int) : void in class com.badlogic.gdx.scenes.scene2d.utils.ClickListener</description><code_before>@@ -61,8 +61,7 @@ public void touchDragged (InputEvent event, float x, float y, int pointer) {
 		if (pressed &amp;&amp; pointer == 0 &amp;&amp; button != -1 &amp;&amp; !Gdx.input.isButtonPressed(button)) pressed = false;
 		if (!pressed) {
 			// Once outside the tap square, don't use the tap square anymore.
-			touchDownX = -1;
-			touchDownY = -1;
 		}
 	}
 
@@ -116,13 +115,21 @@ public void dragStop (InputEvent event, float x, float y, int pointer) {
 	/** Returns true if the specified position is over the specified actor or within the tap square. */
 	public boolean isOver (Actor actor, float x, float y) {
 		Actor hit = actor.hit(x, y, true);
-		if (hit == null || !hit.isDescendantOf(actor)) {
-			if (touchDownX == -1 &amp;&amp; touchDownY == -1) return false;
-			return Math.abs(x - touchDownX) &lt; tapSquareSize &amp;&amp; Math.abs(y - touchDownY) &lt; tapSquareSize;
-		}
 		return true;
 	}
 
 	/** Returns true if a touch is over the actor or within the tap square. */
 	public boolean isPressed () {
 		return pressed;
</code_before><code_after>@@ -61,8 +61,7 @@ public void touchDragged (InputEvent event, float x, float y, int pointer) {
 		if (pressed &amp;&amp; pointer == 0 &amp;&amp; button != -1 &amp;&amp; !Gdx.input.isButtonPressed(button)) pressed = false;
 		if (!pressed) {
 			// Once outside the tap square, don't use the tap square anymore.
+			invalidateTapSquare();
 		}
 	}
 
@@ -116,13 +115,21 @@ public void dragStop (InputEvent event, float x, float y, int pointer) {
 	/** Returns true if the specified position is over the specified actor or within the tap square. */
 	public boolean isOver (Actor actor, float x, float y) {
 		Actor hit = actor.hit(x, y, true);
+		if (hit == null || !hit.isDescendantOf(actor)) return inTapSquare(x, y);
 		return true;
 	}
 
+	public boolean inTapSquare (float x, float y) {
+		if (touchDownX == -1 &amp;&amp; touchDownY == -1) return false;
+		return Math.abs(x - touchDownX) &lt; tapSquareSize &amp;&amp; Math.abs(y - touchDownY) &lt; tapSquareSize;
+	}
+
+	/** The tap square will not longer be used for the current touch. */
+	public void invalidateTapSquare () {
+		touchDownX = -1;
+		touchDownY = -1;
+	}
+
 	/** Returns true if a touch is over the actor or within the tap square. */
 	public boolean isPressed () {
 		return pressed;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>47392</refactoring_id><commit_sha>d67c62dc6654d47d7d8bde39dd670b4bd641a410</commit_sha><commit_link>https://github.com/jenkinsci/jenkins/commit/d67c62dc6654d47d7d8bde39dd670b4bd641a410</commit_link><file_path>core/src/main/java/hudson/tasks/junit/CaseResult.java</file_path><description>Extract Method package CaseResult(parent SuiteResult, testClassName String, testCase Element) extracted from package CaseResult(parent SuiteResult, testCase Element) in class hudson.tasks.junit.CaseResult</description><code_before>@@ -30,8 +30,16 @@ public final class CaseResult extends TestObject implements Comparable&lt;CaseResul
      */
     private /*final*/ int failedSince;
 
     CaseResult(SuiteResult parent, Element testCase) {
-        this(parent,testCase.attributeValue("name"), getError(testCase), parseTime(testCase), isMarkedAsSkipped(testCase));
     }
 
     private static float parseTime(Element testCase) {
@@ -70,11 +78,15 @@ private static float parseTime(Element testCase) {
         skipped = isMarkedAsSkipped(testCase);
     }
 
     CaseResult(SuiteResult parent, String testName, String errorStackTrace) {
-        this( parent, testName, errorStackTrace, 0.0f, false ); 
     }
-    CaseResult(SuiteResult parent, String testName, String errorStackTrace, float duration, boolean skipped) {
-        this.className = parent.getName();
         this.testName = testName;
         this.errorStackTrace = errorStackTrace;
         this.parent = parent;
</code_before><code_after>@@ -30,8 +30,16 @@ public final class CaseResult extends TestObject implements Comparable&lt;CaseResul
      */
     private /*final*/ int failedSince;
 
+    CaseResult(SuiteResult parent, String testClassName, Element testCase) {
+        this(parent,testClassName,testCase.attributeValue("name"), getError(testCase), parseTime(testCase), isMarkedAsSkipped(testCase));
+    }
+
     CaseResult(SuiteResult parent, Element testCase) {
+        // reports in http://www.nabble.com/difference-in-junit-publisher-and-ant-junitreport-tf4308604.html#a12265700
+        // indicates that in certain situations, using the test suite name is better.
+        // note however in other situations, this seems not to be the case
+        // https://hudson.dev.java.net/issues/show_bug.cgi?id=1233
+        this(parent, parent.getName(), testCase);
     }
 
     private static float parseTime(Element testCase) {
@@ -70,11 +78,15 @@ private static float parseTime(Element testCase) {
         skipped = isMarkedAsSkipped(testCase);
     }
 
+    /**
+     * Used to create a fake failure, when Hudson fails to load data from XML files.
+     */
     CaseResult(SuiteResult parent, String testName, String errorStackTrace) {
+        this( parent, parent.getName(), testName, errorStackTrace, 0.0f, false );
     }
+
+    CaseResult(SuiteResult parent, String testClassName, String testName, String errorStackTrace, float duration, boolean skipped) {
+        this.className = testClassName;
         this.testName = testName;
         this.errorStackTrace = errorStackTrace;
         this.parent = parent;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>41639</refactoring_id><commit_sha>cfe720d9be8c2ee8fbe3930f158a7b65b55c5416</commit_sha><commit_link>https://github.com/pmd/pmd/commit/cfe720d9be8c2ee8fbe3930f158a7b65b55c5416</commit_link><file_path>pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/impl/SharingCharSeq.java</file_path><description>Extract Method private SharingCharSeq(str String, offset int, count int) extracted from public SharingCharSeq(str String) in class net.sourceforge.pmd.lang.ast.impl.SharingCharSeq</description><code_before>@@ -24,17 +24,26 @@ public final class SharingCharSeq implements RichCharSequence {
     private final int offset;
     private final int count;
 
-    private String myStr = null;
 
     public SharingCharSeq(String str) {
-        this(null, -1, str.length());
-        myStr = str;
     }
 
-    public SharingCharSeq(char[] value, int offset, int count) {
         this.value = value;
         this.offset = offset;
         this.count = count;
     }
 
 
@@ -45,23 +54,22 @@ public int length() {
 
     @Override
     public char charAt(int index) {
-        if (value == null) {
-            return myStr.charAt(index);
-        }
 
         if (index &lt; 0 || index &gt;= count) {
             throw new IndexOutOfBoundsException("Index out of bounds: " + index + " not in [0," + count + "[");
         }
 
-        return value[offset + index];
     }
 
     @Override
     public RichCharSequence subSequence(int start, int end) {
         if (start &lt; 0 || end &gt; count || start &gt; end) {
             throw new IndexOutOfBoundsException("Invalid range: [" + start + "," + end + "[ not in [0," + count + "[");
         }
-        return start == end ? EMPTY : new SharingCharSeq(value, offset + start, end - start);
     }
 
     @Override
</code_before><code_after>@@ -24,17 +24,26 @@ public final class SharingCharSeq implements RichCharSequence {
     private final int offset;
     private final int count;
 
+    private String myStr;
 
     public SharingCharSeq(String str) {
+        this(str, 0, str.length());
     }
 
+    // those are for subsequences
+
+    private SharingCharSeq(String str, int offset, int count) {
+        this.myStr = str;
+        this.offset = offset;
+        this.count = count;
+        this.value = null;
+    }
+
+    private SharingCharSeq(char[] value, int offset, int count) {
         this.value = value;
         this.offset = offset;
         this.count = count;
+        this.myStr = null;
     }
 
 
@@ -45,23 +54,22 @@ public int length() {
 
     @Override
     public char charAt(int index) {
 
         if (index &lt; 0 || index &gt;= count) {
             throw new IndexOutOfBoundsException("Index out of bounds: " + index + " not in [0," + count + "[");
         }
 
+        return value == null ? myStr.charAt(offset + index) : value[offset + index];
     }
 
     @Override
     public RichCharSequence subSequence(int start, int end) {
         if (start &lt; 0 || end &gt; count || start &gt; end) {
             throw new IndexOutOfBoundsException("Invalid range: [" + start + "," + end + "[ not in [0," + count + "[");
         }
+        return start == end ? EMPTY
+                            : value == null ? new SharingCharSeq(myStr, offset + start, end - start)
+                                            : new SharingCharSeq(value, offset + start, end - start);
     }
 
     @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>111910</refactoring_id><commit_sha>2746e6a4f3f84e05425484ad63ea096c5536c77f</commit_sha><commit_link>https://github.com/apache/flink/commit/2746e6a4f3f84e05425484ad63ea096c5536c77f</commit_link><file_path>flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaInvocationHandler.java</file_path><description>Extract Method package deserializeValueIfNeeded(o Object, method Method) : Object extracted from private invokeRpc(method Method, args Object[]) : Object in class org.apache.flink.runtime.rpc.akka.AkkaInvocationHandler</description><code_before>@@ -47,6 +47,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.util.Objects;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
@@ -90,13 +91,16 @@ class AkkaInvocationHandler implements InvocationHandler, AkkaBasedEndpoint, Rpc
 	@Nullable
 	private final CompletableFuture&lt;Void&gt; terminationFuture;
 
 	AkkaInvocationHandler(
-			String address,
-			String hostname,
-			ActorRef rpcEndpoint,
-			Time timeout,
-			long maximumFramesize,
-			@Nullable CompletableFuture&lt;Void&gt; terminationFuture) {
 
 		this.address = Preconditions.checkNotNull(address);
 		this.hostname = Preconditions.checkNotNull(hostname);
@@ -105,6 +109,7 @@ class AkkaInvocationHandler implements InvocationHandler, AkkaBasedEndpoint, Rpc
 		this.timeout = Preconditions.checkNotNull(timeout);
 		this.maximumFramesize = maximumFramesize;
 		this.terminationFuture = terminationFuture;
 	}
 
 	@Override
@@ -208,20 +213,20 @@ private Object invokeRpc(Method method, Object[] args) throws Exception {
 
 			result = null;
 		} else {
 			// execute an asynchronous call
-			CompletableFuture&lt;?&gt; resultFuture = ask(rpcInvocation, futureTimeout);
-
-			CompletableFuture&lt;?&gt; completableFuture = resultFuture.thenApply((Object o) -&gt; {
-				if (o instanceof SerializedValue) {
-					try {
-						return  ((SerializedValue&lt;?&gt;) o).deserializeValue(getClass().getClassLoader());
-					} catch (IOException | ClassNotFoundException e) {
-						throw new CompletionException(
-							new RpcException("Could not deserialize the serialized payload of RPC method : "
-								+ methodName, e));
-					}
 				} else {
-					return o;
 				}
 			});
 
@@ -370,4 +375,35 @@ public String getHostname() {
 	public CompletableFuture&lt;Void&gt; getTerminationFuture() {
 		return terminationFuture;
 	}
 }
</code_before><code_after>@@ -47,6 +47,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
+import java.util.Arrays;
 import java.util.Objects;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
@@ -90,13 +91,16 @@ class AkkaInvocationHandler implements InvocationHandler, AkkaBasedEndpoint, Rpc
 	@Nullable
 	private final CompletableFuture&lt;Void&gt; terminationFuture;
 
+	private final boolean captureAskCallStack;
+
 	AkkaInvocationHandler(
+		String address,
+		String hostname,
+		ActorRef rpcEndpoint,
+		Time timeout,
+		long maximumFramesize,
+		@Nullable CompletableFuture&lt;Void&gt; terminationFuture,
+		boolean captureAskCallStack) {
 
 		this.address = Preconditions.checkNotNull(address);
 		this.hostname = Preconditions.checkNotNull(hostname);
@@ -105,6 +109,7 @@ class AkkaInvocationHandler implements InvocationHandler, AkkaBasedEndpoint, Rpc
 		this.timeout = Preconditions.checkNotNull(timeout);
 		this.maximumFramesize = maximumFramesize;
 		this.terminationFuture = terminationFuture;
+		this.captureAskCallStack = captureAskCallStack;
 	}
 
 	@Override
@@ -208,20 +213,20 @@ private Object invokeRpc(Method method, Object[] args) throws Exception {
 
 			result = null;
 		} else {
+			// Capture the call stack. It is significantly faster to do that via an exception than
+			// via Thread.getStackTrace(), because exceptions lazily initialize the stack trace, initially only
+			// capture a lightweight native pointer, and convert that into the stack trace lazily when needed.
+			final Throwable callStackCapture = captureAskCallStack ? new Throwable() : null;
+
 			// execute an asynchronous call
+			final CompletableFuture&lt;?&gt; resultFuture = ask(rpcInvocation, futureTimeout);
+
+			final CompletableFuture&lt;Object&gt; completableFuture = new CompletableFuture&lt;&gt;();
+			resultFuture.whenComplete((resultValue, failure) -&gt; {
+				if (failure != null) {
+					completableFuture.completeExceptionally(resolveTimeoutException(failure, callStackCapture, method));
 				} else {
+					completableFuture.complete(deserializeValueIfNeeded(resultValue, method));
 				}
 			});
 
@@ -370,4 +375,35 @@ public String getHostname() {
 	public CompletableFuture&lt;Void&gt; getTerminationFuture() {
 		return terminationFuture;
 	}
+
+	static Object deserializeValueIfNeeded(Object o, Method method) {
+		if (o instanceof SerializedValue) {
+			try {
+				return  ((SerializedValue&lt;?&gt;) o).deserializeValue(AkkaInvocationHandler.class.getClassLoader());
+			} catch (IOException | ClassNotFoundException e) {
+				throw new CompletionException(
+					new RpcException(
+						"Could not deserialize the serialized payload of RPC method : " + method.getName(), e));
+			}
+		} else {
+			return o;
+		}
+	}
+
+	static Throwable resolveTimeoutException(Throwable exception, @Nullable Throwable callStackCapture, Method method) {
+		if (!(exception instanceof akka.pattern.AskTimeoutException)) {
+			return exception;
+		}
+
+		final TimeoutException newException = new TimeoutException("Invocation of " + method + " timed out.");
+		newException.initCause(exception);
+
+		if (callStackCapture != null) {
+			// remove the stack frames coming from the proxy interface invocation
+			final StackTraceElement[] stackTrace = callStackCapture.getStackTrace();
+			newException.setStackTrace(Arrays.copyOfRange(stackTrace, 3, stackTrace.length));
+		}
+
+		return newException;
+	}
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>58465</refactoring_id><commit_sha>102fc92120bbc9d22a7aac53a99645270963a407</commit_sha><commit_link>https://github.com/apache/druid/commit/102fc92120bbc9d22a7aac53a99645270963a407</commit_link><file_path>server/src/main/java/io/druid/metadata/SQLMetadataConnector.java</file_path><description>Extract Method public retryWithHandle(callback HandleCallback&lt;T&gt;, myShouldRetry Predicate&lt;Throwable&gt;) : T extracted from public retryWithHandle(callback HandleCallback&lt;T&gt;) : T in class io.druid.metadata.SQLMetadataConnector</description><code_before>@@ -100,7 +100,10 @@ protected String getPayloadType()
 
   public abstract boolean tableExists(Handle handle, final String tableName);
 
-  public &lt;T&gt; T retryWithHandle(final HandleCallback&lt;T&gt; callback)
   {
     final Callable&lt;T&gt; call = new Callable&lt;T&gt;()
     {
@@ -112,13 +115,18 @@ public T call() throws Exception
     };
     final int maxTries = 10;
     try {
-      return RetryUtils.retry(call, shouldRetry, maxTries);
     }
     catch (Exception e) {
       throw Throwables.propagate(e);
     }
   }
 
   public &lt;T&gt; T retryTransaction(final TransactionCallback&lt;T&gt; callback)
   {
     final Callable&lt;T&gt; call = new Callable&lt;T&gt;()
@@ -399,21 +407,24 @@ public void createSegmentTable()
   }
 
   @Override
-  public void createRulesTable() {
     if (config.get().isCreateTables()) {
       createRulesTable(tablesConfigSupplier.get().getRulesTable());
     }
   }
 
   @Override
-  public void createConfigTable() {
     if (config.get().isCreateTables()) {
       createConfigTable(tablesConfigSupplier.get().getConfigTable());
     }
   }
 
   @Override
-  public void createTaskTables() {
     if (config.get().isCreateTables()) {
       final MetadataStorageTablesConfig tablesConfig = tablesConfigSupplier.get();
       final String entryType = tablesConfig.getTaskEntryType();
@@ -502,7 +513,8 @@ tableName, getSerialType(), getPayloadType()
     );
   }
   @Override
-  public void createAuditTable() {
     if (config.get().isCreateTables()) {
       createAuditTable(tablesConfigSupplier.get().getAuditTable());
     }
</code_before><code_after>@@ -100,7 +100,10 @@ protected String getPayloadType()
 
   public abstract boolean tableExists(Handle handle, final String tableName);
 
+  public &lt;T&gt; T retryWithHandle(
+      final HandleCallback&lt;T&gt; callback,
+      final Predicate&lt;Throwable&gt; myShouldRetry
+  )
   {
     final Callable&lt;T&gt; call = new Callable&lt;T&gt;()
     {
@@ -112,13 +115,18 @@ public T call() throws Exception
     };
     final int maxTries = 10;
     try {
+      return RetryUtils.retry(call, myShouldRetry, maxTries);
     }
     catch (Exception e) {
       throw Throwables.propagate(e);
     }
   }
 
+  public &lt;T&gt; T retryWithHandle(final HandleCallback&lt;T&gt; callback)
+  {
+    return retryWithHandle(callback, shouldRetry);
+  }
+
   public &lt;T&gt; T retryTransaction(final TransactionCallback&lt;T&gt; callback)
   {
     final Callable&lt;T&gt; call = new Callable&lt;T&gt;()
@@ -399,21 +407,24 @@ public void createSegmentTable()
   }
 
   @Override
+  public void createRulesTable()
+  {
     if (config.get().isCreateTables()) {
       createRulesTable(tablesConfigSupplier.get().getRulesTable());
     }
   }
 
   @Override
+  public void createConfigTable()
+  {
     if (config.get().isCreateTables()) {
       createConfigTable(tablesConfigSupplier.get().getConfigTable());
     }
   }
 
   @Override
+  public void createTaskTables()
+  {
     if (config.get().isCreateTables()) {
       final MetadataStorageTablesConfig tablesConfig = tablesConfigSupplier.get();
       final String entryType = tablesConfig.getTaskEntryType();
@@ -502,7 +513,8 @@ tableName, getSerialType(), getPayloadType()
     );
   }
   @Override
+  public void createAuditTable()
+  {
     if (config.get().isCreateTables()) {
       createAuditTable(tablesConfigSupplier.get().getAuditTable());
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>92395</refactoring_id><commit_sha>fb24dba67409078aeaae70cf6fdf075293e845a2</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/fb24dba67409078aeaae70cf6fdf075293e845a2</commit_link><file_path>core/src/main/java/ch/cyberduck/core/pool/SingleSessionPool.java</file_path><description>Extract Method public SingleSessionPool(connect ConnectionService, session Session&lt;?&gt;, cache PathCache, listener VaultLookupListener) extracted from public SingleSessionPool(connect ConnectionService, session Session&lt;?&gt;, cache PathCache, password PasswordCallback) in class ch.cyberduck.core.pool.SingleSessionPool</description><code_before>@@ -23,6 +23,7 @@
 import ch.cyberduck.core.exception.BackgroundException;
 import ch.cyberduck.core.features.Vault;
 import ch.cyberduck.core.threading.BackgroundActionState;
 import ch.cyberduck.core.vault.LoadingVaultLookupListener;
 import ch.cyberduck.core.vault.VaultLookupListener;
 
@@ -37,9 +38,15 @@ public class SingleSessionPool implements SessionPool, VaultLookupListener {
 
     public SingleSessionPool(final ConnectionService connect, final Session&lt;?&gt; session, final PathCache cache,
                              final PasswordCallback password) {
         this.connect = connect;
         this.session = session;
-        this.session.addListener(new LoadingVaultLookupListener(this, session, password));
         this.cache = cache;
     }
 
</code_before><code_after>@@ -23,6 +23,7 @@
 import ch.cyberduck.core.exception.BackgroundException;
 import ch.cyberduck.core.features.Vault;
 import ch.cyberduck.core.threading.BackgroundActionState;
+import ch.cyberduck.core.vault.DisabledVaultLookupListener;
 import ch.cyberduck.core.vault.LoadingVaultLookupListener;
 import ch.cyberduck.core.vault.VaultLookupListener;
 
@@ -37,9 +38,15 @@ public class SingleSessionPool implements SessionPool, VaultLookupListener {
 
     public SingleSessionPool(final ConnectionService connect, final Session&lt;?&gt; session, final PathCache cache,
                              final PasswordCallback password) {
+        this(connect, session, cache, new DisabledVaultLookupListener());
+        session.addListener(new LoadingVaultLookupListener(session, this, password));
+    }
+
+    public SingleSessionPool(final ConnectionService connect, final Session&lt;?&gt; session, final PathCache cache,
+                             final VaultLookupListener listener) {
         this.connect = connect;
         this.session = session;
+        this.session.addListener(listener);
         this.cache = cache;
     }
 
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>122648</refactoring_id><commit_sha>963588ce7a9b8f70ac4a1d5b867003926caab93e</commit_sha><commit_link>https://github.com/oracle/graal/commit/963588ce7a9b8f70ac4a1d5b867003926caab93e</commit_link><file_path>projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMTruffleObject.java</file_path><description>Extract Method public createPointer(ptr long) : LLVMTruffleObject extracted from public createNullPointer() : LLVMTruffleObject in class com.oracle.truffle.llvm.runtime.LLVMTruffleObject</description><code_before>@@ -65,7 +65,11 @@ private static LLVMSourceType overrideBaseType(LLVMTruffleObject obj, Type newTy
     }
 
     public static LLVMTruffleObject createNullPointer() {
-        return new LLVMTruffleObject(null, 0, null, null);
     }
 
     public LLVMTruffleObject(LLVMTruffleObject orig, Type type) {
</code_before><code_after>@@ -65,7 +65,11 @@ private static LLVMSourceType overrideBaseType(LLVMTruffleObject obj, Type newTy
     }
 
     public static LLVMTruffleObject createNullPointer() {
+        return createPointer(0L);
+    }
+
+    public static LLVMTruffleObject createPointer(long ptr) {
+        return new LLVMTruffleObject(null, ptr, null, null);
     }
 
     public LLVMTruffleObject(LLVMTruffleObject orig, Type type) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>12899</refactoring_id><commit_sha>93a45153694cde0d27a569c12ef21c9b367fc9e9</commit_sha><commit_link>https://github.com/apache/pinot/commit/93a45153694cde0d27a569c12ef21c9b367fc9e9</commit_link><file_path>pinot-tools/src/main/java/org/apache/pinot/tools/admin/command/QuickstartRunner.java</file_path><description>Extract Method public QuickstartRunner(tableRequests List&lt;QuickstartTableRequest&gt;, numServers int, numBrokers int, numControllers int, numMinions int, tempDir File, enableIsolation boolean) extracted from public QuickstartRunner(tableRequests List&lt;QuickstartTableRequest&gt;, numServers int, numBrokers int, numControllers int, tempDir File, enableIsolation boolean) in class org.apache.pinot.tools.admin.command.QuickstartRunner</description><code_before>@@ -60,6 +60,8 @@ public class QuickstartRunner {
   private static final int DEFAULT_SERVER_ADMIN_API_PORT = 7500;
   private static final int DEFAULT_BROKER_PORT = 8000;
   private static final int DEFAULT_CONTROLLER_PORT = 9000;
 
   private static final String DEFAULT_ZK_DIR = "PinotZkDir";
   private static final String DEFAULT_CONTROLLER_DIR = "PinotControllerDir";
@@ -70,6 +72,7 @@ public class QuickstartRunner {
   private final int _numServers;
   private final int _numBrokers;
   private final int _numControllers;
   private final File _tempDir;
   private final boolean _enableTenantIsolation;
 
@@ -81,10 +84,17 @@ public class QuickstartRunner {
   public QuickstartRunner(List&lt;QuickstartTableRequest&gt; tableRequests, int numServers, int numBrokers,
       int numControllers, File tempDir, boolean enableIsolation)
       throws Exception {
     _tableRequests = tableRequests;
     _numServers = numServers;
     _numBrokers = numBrokers;
     _numControllers = numControllers;
     _tempDir = tempDir;
     _enableTenantIsolation = enableIsolation;
     clean();
@@ -138,6 +148,16 @@ private void startServers()
     }
   }
 
   private void clean()
       throws Exception {
     FileUtils.cleanDirectory(_tempDir);
@@ -150,6 +170,7 @@ public void startAll()
     startControllers();
     startBrokers();
     startServers();
   }
 
   public void stop()
</code_before><code_after>@@ -60,6 +60,8 @@ public class QuickstartRunner {
   private static final int DEFAULT_SERVER_ADMIN_API_PORT = 7500;
   private static final int DEFAULT_BROKER_PORT = 8000;
   private static final int DEFAULT_CONTROLLER_PORT = 9000;
+  private static final int DEFAULT_MINION_PORT = 6000;
+
 
   private static final String DEFAULT_ZK_DIR = "PinotZkDir";
   private static final String DEFAULT_CONTROLLER_DIR = "PinotControllerDir";
@@ -70,6 +72,7 @@ public class QuickstartRunner {
   private final int _numServers;
   private final int _numBrokers;
   private final int _numControllers;
+  private final int _numMinions;
   private final File _tempDir;
   private final boolean _enableTenantIsolation;
 
@@ -81,10 +84,17 @@ public class QuickstartRunner {
   public QuickstartRunner(List&lt;QuickstartTableRequest&gt; tableRequests, int numServers, int numBrokers,
       int numControllers, File tempDir, boolean enableIsolation)
       throws Exception {
+    this(tableRequests, numServers, numBrokers, numControllers, 1, tempDir, enableIsolation);
+  }
+
+  public QuickstartRunner(List&lt;QuickstartTableRequest&gt; tableRequests, int numServers, int numBrokers,
+      int numControllers, int numMinions, File tempDir, boolean enableIsolation)
+      throws Exception {
     _tableRequests = tableRequests;
     _numServers = numServers;
     _numBrokers = numBrokers;
     _numControllers = numControllers;
+    _numMinions = numMinions;
     _tempDir = tempDir;
     _enableTenantIsolation = enableIsolation;
     clean();
@@ -138,6 +148,16 @@ private void startServers()
     }
   }
 
+  private void startMinions()
+      throws Exception {
+    for (int i = 0; i &lt; _numMinions; i++) {
+      StartMinionCommand minionStarter = new StartMinionCommand();
+      minionStarter.setMinionPort(DEFAULT_MINION_PORT + i)
+          .setZkAddress(ZK_ADDRESS).setClusterName(CLUSTER_NAME);
+      minionStarter.execute();
+    }
+  }
+
   private void clean()
       throws Exception {
     FileUtils.cleanDirectory(_tempDir);
@@ -150,6 +170,7 @@ public void startAll()
     startControllers();
     startBrokers();
     startServers();
+    startMinions();
   }
 
   public void stop()
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>27627</refactoring_id><commit_sha>8ddda5d0dc269131ef52cf59d2522401d5c0c49c</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/8ddda5d0dc269131ef52cf59d2522401d5c0c49c</commit_link><file_path>src/main/java/mekanism/common/tile/TileEntityElectricBlock.java</file_path><description>Extract Method public configure() : void extracted from public TileEntityElectricBlock(name String, maxEnergy double) in class mekanism.common.tile.TileEntityElectricBlock</description><code_before>@@ -62,13 +62,18 @@ public TileEntityElectricBlock(String name, double maxEnergy)
 		MAX_ELECTRICITY = maxEnergy;
 
 		if(MekanismUtils.useBuildCraft())
-		{
-			powerHandler = new PowerHandler(this, PowerHandler.Type.STORAGE);
-			powerHandler.configurePowerPerdition(0, 0);
-			powerHandler.configure(0, 0, 0, 0);
-		}
 	}
 
 	@Method(modid = "IC2API")
 	public void register()
 	{
@@ -98,7 +103,8 @@ public void deregister()
 	@Override
 	public void onUpdate()
 	{
-		reconfigure();
 	}
 
 	public EnumSet&lt;ForgeDirection&gt; getOutputtingSides()
@@ -156,7 +162,7 @@ public ArrayList getNetworkedData(ArrayList data)
 	public void onChunkUnload()
 	{
 		if(MekanismUtils.useIC2())
-		deregister();
 
 		super.onChunkUnload();
 	}
@@ -167,7 +173,7 @@ public void invalidate()
 		super.invalidate();
 
 		if(MekanismUtils.useIC2())
-		deregister();
 	}
 
 	@Override
@@ -176,7 +182,9 @@ public void readFromNBT(NBTTagCompound nbtTags)
 		super.readFromNBT(nbtTags);
 
 		electricityStored = nbtTags.getDouble("electricityStored");
-		reconfigure();
 	}
 
 	@Override
@@ -199,12 +207,10 @@ public PowerReceiver getPowerReceiver(ForgeDirection side)
 		return null;
 	}
 
 	protected void reconfigure()
 	{
-		if(MekanismUtils.useBuildCraft())
-		{
 			powerHandler.configure(1, (float)((getMaxEnergy()-getEnergy())*Mekanism.TO_BC), 0, (float)(getMaxEnergy()*Mekanism.TO_BC));
-		}
 	}
 
 	@Override
</code_before><code_after>@@ -62,13 +62,18 @@ public TileEntityElectricBlock(String name, double maxEnergy)
 		MAX_ELECTRICITY = maxEnergy;
 
 		if(MekanismUtils.useBuildCraft())
+			configure();
+	}
+
+	@Method(modid = "BuildCraftAPI|power")
+	public void configure()
+	{
+		powerHandler = new PowerHandler(this, PowerHandler.Type.STORAGE);
+		powerHandler.configurePowerPerdition(0, 0);
+		powerHandler.configure(0, 0, 0, 0);
 	}
 
+
 	@Method(modid = "IC2API")
 	public void register()
 	{
@@ -98,7 +103,8 @@ public void deregister()
 	@Override
 	public void onUpdate()
 	{
+		if(MekanismUtils.useBuildCraft())
+			reconfigure();
 	}
 
 	public EnumSet&lt;ForgeDirection&gt; getOutputtingSides()
@@ -156,7 +162,7 @@ public ArrayList getNetworkedData(ArrayList data)
 	public void onChunkUnload()
 	{
 		if(MekanismUtils.useIC2())
+			deregister();
 
 		super.onChunkUnload();
 	}
@@ -167,7 +173,7 @@ public void invalidate()
 		super.invalidate();
 
 		if(MekanismUtils.useIC2())
+			deregister();
 	}
 
 	@Override
@@ -176,7 +182,9 @@ public void readFromNBT(NBTTagCompound nbtTags)
 		super.readFromNBT(nbtTags);
 
 		electricityStored = nbtTags.getDouble("electricityStored");
+
+		if(MekanismUtils.useBuildCraft())
+			reconfigure();
 	}
 
 	@Override
@@ -199,12 +207,10 @@ public PowerReceiver getPowerReceiver(ForgeDirection side)
 		return null;
 	}
 
+	@Method(modid = "BuildCraftAPI|power")
 	protected void reconfigure()
 	{
 			powerHandler.configure(1, (float)((getMaxEnergy()-getEnergy())*Mekanism.TO_BC), 0, (float)(getMaxEnergy()*Mekanism.TO_BC));
 	}
 
 	@Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>73626</refactoring_id><commit_sha>2e2d28c2082d1812f2c7f3218fb7d823401f41d9</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/2e2d28c2082d1812f2c7f3218fb7d823401f41d9</commit_link><file_path>src/edu/stanford/nlp/ling/tokensregex/CoreMapExpressionExtractor.java</file_path><description>Extract Method private cleanupTags(cm CoreMap, cleaned Map&lt;Object,Boolean&gt;) : void extracted from private cleanupTags(objs Collection) : void in class edu.stanford.nlp.ling.tokensregex.CoreMapExpressionExtractor</description><code_before>@@ -41,7 +41,7 @@ public class CoreMapExpressionExtractor&lt;T extends MatchedExpression&gt; {
   private Logger logger = Logger.getLogger(CoreMapExpressionExtractor.class.getName());
   Env env;
   /* Keeps temporary tags created by extractor */
-  boolean keepTags = true;
   Class tokensAnnotationKey;
   Map&lt;Integer, Stage&lt;T&gt;&gt; stages;
 
@@ -331,25 +331,36 @@ public List&lt;CoreMap&gt; flatten(List&lt;CoreMap&gt; cms, Class key) {
     return res;
   }
 
-  private void cleanupTags(Collection objs) {
     for (Object obj:objs) {
-      if (obj instanceof CoreMap) {
-        cleanupTags((CoreMap) obj);
-      } else if (obj instanceof Collection) {
-        cleanupTags((Collection) obj);
       }
     }
   }
 
   private void cleanupTags(CoreMap cm) {
-    // TODO: Handle coremaps that are recursively linked
     cm.remove(Tags.TagsAnnotation.class);
     for (Class key:cm.keySet()) {
       Object obj = cm.get(key);
-      if (obj instanceof CoreMap) {
-        cleanupTags((CoreMap) obj);
-      } else if (obj instanceof Collection) {
-        cleanupTags((Collection) obj);
       }
     }
   }
</code_before><code_after>@@ -41,7 +41,7 @@ public class CoreMapExpressionExtractor&lt;T extends MatchedExpression&gt; {
   private Logger logger = Logger.getLogger(CoreMapExpressionExtractor.class.getName());
   Env env;
   /* Keeps temporary tags created by extractor */
+  boolean keepTags = false;
   Class tokensAnnotationKey;
   Map&lt;Integer, Stage&lt;T&gt;&gt; stages;
 
@@ -331,25 +331,36 @@ public List&lt;CoreMap&gt; flatten(List&lt;CoreMap&gt; cms, Class key) {
     return res;
   }
 
+  private void cleanupTags(Collection objs, Map&lt;Object, Boolean&gt; cleaned) {
     for (Object obj:objs) {
+      if (!cleaned.containsKey(obj)) {
+        cleaned.put(obj, false);
+        if (obj instanceof CoreMap) {
+          cleanupTags((CoreMap) obj, cleaned);
+        } else if (obj instanceof Collection) {
+          cleanupTags((Collection) obj, cleaned);
+        }
+        cleaned.put(obj, true);
       }
     }
   }
 
   private void cleanupTags(CoreMap cm) {
+    cleanupTags(cm, new IdentityHashMap&lt;Object, Boolean&gt;());
+  }
+
+  private void cleanupTags(CoreMap cm, Map&lt;Object, Boolean&gt; cleaned) {
     cm.remove(Tags.TagsAnnotation.class);
     for (Class key:cm.keySet()) {
       Object obj = cm.get(key);
+      if (!cleaned.containsKey(obj)) {
+        cleaned.put(obj, false);
+        if (obj instanceof CoreMap) {
+          cleanupTags((CoreMap) obj, cleaned);
+        } else if (obj instanceof Collection) {
+          cleanupTags((Collection) obj, cleaned);
+        }
+        cleaned.put(obj, true);
       }
     }
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>80519</refactoring_id><commit_sha>52e0761ee8e4f524ea211dda84b6da7d6f4e2ec9</commit_sha><commit_link>https://github.com/apache/logging-log4j2/commit/52e0761ee8e4f524ea211dda84b6da7d6f4e2ec9</commit_link><file_path>log4j-core/src/test/java/org/apache/logging/log4j/core/appender/SyslogAppenderTest.java</file_path><description>Extract Method protected newSyslogAppenderBuilder(protocol String, format String, newLine boolean, port int) : Builder extracted from protected newSyslogAppenderBuilder(protocol String, format String, newLine boolean) : Builder in class org.apache.logging.log4j.core.appender.SyslogAppenderTest</description><code_before>@@ -17,6 +17,7 @@
 package org.apache.logging.log4j.core.appender;
 
 import java.io.IOException;
 import java.net.SocketException;
 
 import org.apache.logging.log4j.core.appender.SyslogAppender.Builder;
@@ -47,6 +48,7 @@ public void teardown() {
         if (syslogServer != null) {
             syslogServer.shutdown();
         }
     }
 
     @Test
@@ -93,30 +95,46 @@ public void testUDPStructuredAppender() throws Exception {
     protected void initUDPTestEnvironment(final String messageFormat) throws SocketException {
         syslogServer = MockSyslogServerFactory.createUDPSyslogServer(1, PORTNUM);
         syslogServer.start();
-        initAppender("udp", messageFormat);
     }
 
     protected void initTCPTestEnvironment(final String messageFormat) throws IOException {
-        syslogServer = MockSyslogServerFactory.createTCPSyslogServer(1, PORTNUM);
         syslogServer.start();
-        initAppender("tcp", messageFormat);
     }
 
-    protected void initAppender(final String transportFormat, final String messageFormat) {
-        appender = createAppender(transportFormat, messageFormat);
         validate(appender);
         appender.start();
         initRootLogger(appender);
     }
 
-    protected SyslogAppender createAppender(final String protocol, final String format) {
-        return newSyslogAppenderBuilder(protocol, format, includeNewLine).build();
     }
 
     protected Builder newSyslogAppenderBuilder(final String protocol, final String format, final boolean newLine) {
         // @formatter:off
         return SyslogAppender.newSyslogAppenderBuilder()
-                .withPort(PORTNUM)
                 .withProtocol(EnglishEnums.valueOf(Protocol.class, protocol))
                 .withReconnectDelayMillis(-1)
                 .withName("TestApp")
</code_before><code_after>@@ -17,6 +17,7 @@
 package org.apache.logging.log4j.core.appender;
 
 import java.io.IOException;
+import java.net.BindException;
 import java.net.SocketException;
 
 import org.apache.logging.log4j.core.appender.SyslogAppender.Builder;
@@ -47,6 +48,7 @@ public void teardown() {
         if (syslogServer != null) {
             syslogServer.shutdown();
         }
+        syslogServer = null;
     }
 
     @Test
@@ -93,30 +95,46 @@ public void testUDPStructuredAppender() throws Exception {
     protected void initUDPTestEnvironment(final String messageFormat) throws SocketException {
         syslogServer = MockSyslogServerFactory.createUDPSyslogServer(1, PORTNUM);
         syslogServer.start();
+        initAppender("udp", messageFormat, PORTNUM);
     }
 
     protected void initTCPTestEnvironment(final String messageFormat) throws IOException {
+        int port = PORTNUM;
+        while (syslogServer == null) {
+            try {
+                syslogServer = MockSyslogServerFactory.createTCPSyslogServer(1, port);
+            } catch (BindException be) {
+                ++port;
+                if (port &gt; 65535) {
+                    throw be;
+                }
+            }
+        }
+
         syslogServer.start();
+        initAppender("tcp", messageFormat, port);
     }
 
+    protected void initAppender(final String transportFormat, final String messageFormat, int port) {
+        appender = createAppender(transportFormat, messageFormat, port);
         validate(appender);
         appender.start();
         initRootLogger(appender);
     }
 
+    protected SyslogAppender createAppender(final String protocol, final String format, int port) {
+        return newSyslogAppenderBuilder(protocol, format, includeNewLine, port).build();
     }
 
     protected Builder newSyslogAppenderBuilder(final String protocol, final String format, final boolean newLine) {
+        return newSyslogAppenderBuilder(protocol, format, newLine, PORTNUM);
+    }
+
+    protected Builder newSyslogAppenderBuilder(final String protocol, final String format, final boolean newLine,
+                                               int port) {
         // @formatter:off
         return SyslogAppender.newSyslogAppenderBuilder()
+                .withPort(port)
                 .withProtocol(EnglishEnums.valueOf(Protocol.class, protocol))
                 .withReconnectDelayMillis(-1)
                 .withName("TestApp")
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>92503</refactoring_id><commit_sha>bab5b5dd8fae927bde431ce91cdcfdb4596423b6</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/bab5b5dd8fae927bde431ce91cdcfdb4596423b6</commit_link><file_path>core/src/main/java/ch/cyberduck/core/LocaleFactory.java</file_path><description>Extract Method public set(l Locale) : void extracted from public get() : Locale in class ch.cyberduck.core.LocaleFactory</description><code_before>@@ -35,11 +35,15 @@ public LocaleFactory() {
      */
     public static synchronized Locale get() {
         if(null == locale) {
-            locale = new LocaleFactory().create();
         }
         return locale;
     }
 
     /**
      * @param key English variant
      * @return Localized from default table
</code_before><code_after>@@ -35,11 +35,15 @@ public LocaleFactory() {
      */
     public static synchronized Locale get() {
         if(null == locale) {
+            set(new LocaleFactory().create());
         }
         return locale;
     }
 
+    public static synchronized void set(Locale l) {
+        locale = l;
+    }
+
     /**
      * @param key English variant
      * @return Localized from default table
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>111925</refactoring_id><commit_sha>e502d2371ffea52ebfa6b8a1b9d2b4a23bc9bbaa</commit_sha><commit_link>https://github.com/apache/flink/commit/e502d2371ffea52ebfa6b8a1b9d2b4a23bc9bbaa</commit_link><file_path>flink-datastream/src/main/java/org/apache/flink/datastream/impl/operators/ProcessOperator.java</file_path><description>Extract Method protected getNonPartitionedContext() : NonPartitionedContext&lt;OUT&gt; extracted from public open() : void in class org.apache.flink.datastream.impl.operators.ProcessOperator</description><code_before>@@ -19,6 +19,7 @@
 package org.apache.flink.datastream.impl.operators;
 
 import org.apache.flink.api.common.TaskInfo;
 import org.apache.flink.datastream.api.context.ProcessingTimeManager;
 import org.apache.flink.datastream.api.function.OneInputStreamProcessFunction;
 import org.apache.flink.datastream.impl.common.OutputCollector;
@@ -43,7 +44,7 @@ public class ProcessOperator&lt;IN, OUT&gt;
 
     protected transient DefaultPartitionedContext partitionedContext;
 
-    protected transient DefaultNonPartitionedContext&lt;OUT&gt; nonPartitionedContext;
 
     protected transient TimestampCollector&lt;OUT&gt; outputCollector;
 
@@ -69,8 +70,8 @@ public void open() throws Exception {
         partitionedContext =
                 new DefaultPartitionedContext(
                         context, this::currentKey, this::setCurrentKey, getProcessingTimeManager());
-        nonPartitionedContext = new DefaultNonPartitionedContext&lt;&gt;(context);
         outputCollector = getOutputCollector();
     }
 
     @Override
@@ -95,4 +96,9 @@ protected Object currentKey() {
     protected ProcessingTimeManager getProcessingTimeManager() {
         return UnsupportedProcessingTimeManager.INSTANCE;
     }
 }
</code_before><code_after>@@ -19,6 +19,7 @@
 package org.apache.flink.datastream.impl.operators;
 
 import org.apache.flink.api.common.TaskInfo;
+import org.apache.flink.datastream.api.context.NonPartitionedContext;
 import org.apache.flink.datastream.api.context.ProcessingTimeManager;
 import org.apache.flink.datastream.api.function.OneInputStreamProcessFunction;
 import org.apache.flink.datastream.impl.common.OutputCollector;
@@ -43,7 +44,7 @@ public class ProcessOperator&lt;IN, OUT&gt;
 
     protected transient DefaultPartitionedContext partitionedContext;
 
+    protected transient NonPartitionedContext&lt;OUT&gt; nonPartitionedContext;
 
     protected transient TimestampCollector&lt;OUT&gt; outputCollector;
 
@@ -69,8 +70,8 @@ public void open() throws Exception {
         partitionedContext =
                 new DefaultPartitionedContext(
                         context, this::currentKey, this::setCurrentKey, getProcessingTimeManager());
         outputCollector = getOutputCollector();
+        nonPartitionedContext = getNonPartitionedContext();
     }
 
     @Override
@@ -95,4 +96,9 @@ protected Object currentKey() {
     protected ProcessingTimeManager getProcessingTimeManager() {
         return UnsupportedProcessingTimeManager.INSTANCE;
     }
+
+    protected NonPartitionedContext&lt;OUT&gt; getNonPartitionedContext() {
+        return new DefaultNonPartitionedContext&lt;&gt;(
+                context, partitionedContext, outputCollector, false, null);
+    }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>116776</refactoring_id><commit_sha>4bfd4b66bff0818d380c4ea673aade5129e1e532</commit_sha><commit_link>https://github.com/robolectric/robolectric/commit/4bfd4b66bff0818d380c4ea673aade5129e1e532</commit_link><file_path>shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java</file_path><description>Extract Method private convertWhenToScheduledTime(when long) : long extracted from package getLastScheduledTaskTime() : Duration in class org.robolectric.shadows.ShadowPausedMessageQueue</description><code_before>@@ -6,12 +6,10 @@
 import static android.os.Build.VERSION_CODES.KITKAT_WATCH;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
-import static org.robolectric.shadow.api.Shadow.directlyOn;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.os.Build;
 import android.os.Message;
 import android.os.MessageQueue;
 import android.os.MessageQueue.IdleHandler;
@@ -140,21 +138,30 @@ protected static boolean nativeIsPolling(long ptr) {
   /** Exposes the API23+_isIdle method to older platforms */
   @Implementation(minSdk = 23)
   public boolean isIdle() {
-    if (Build.VERSION.SDK_INT &gt;= M) {
-      return directlyOn(realQueue, MessageQueue.class).isIdle();
-    } else {
-      ReflectorMessageQueue internalQueue = reflector(ReflectorMessageQueue.class, realQueue);
-      // this is a copy of the implementation from P
-      synchronized (realQueue) {
-        final long now = SystemClock.uptimeMillis();
-        Message headMsg = internalQueue.getMessages();
-        if (headMsg == null) {
           return true;
-        }
-        long when = shadowOfMsg(headMsg).getWhen();
-        return now &lt; when;
       }
     }
   }
 
   Message getNext() {
@@ -214,23 +221,36 @@ private static int getInt(Object intOrLongObj) {
   }
 
   Duration getNextScheduledTaskTime() {
-    Message head = getMessages();
-    if (head == null) {
       return Duration.ZERO;
     }
-    return Duration.ofMillis(shadowOfMsg(head).getWhen());
   }
 
   Duration getLastScheduledTaskTime() {
     long when = 0;
     synchronized (realQueue) {
       Message next = getMessages();
       while (next != null) {
         when = shadowOfMsg(next).getWhen();
         next = shadowOfMsg(next).internalGetNext();
       }
     }
-    return Duration.ofMillis(when);
   }
 
   /**
</code_before><code_after>@@ -6,12 +6,10 @@
 import static android.os.Build.VERSION_CODES.KITKAT_WATCH;
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.os.Message;
 import android.os.MessageQueue;
 import android.os.MessageQueue.IdleHandler;
@@ -140,21 +138,30 @@ protected static boolean nativeIsPolling(long ptr) {
   /** Exposes the API23+_isIdle method to older platforms */
   @Implementation(minSdk = 23)
   public boolean isIdle() {
+    synchronized (realQueue) {
+      Message msg = peekNextExecutableMessage();
+      if (msg == null) {
           return true;
       }
+
+      long now = SystemClock.uptimeMillis();
+      long when = shadowOfMsg(msg).getWhen();
+      return now &lt; when;
+    }
+  }
+
+  Message peekNextExecutableMessage() {
+    ReflectorMessageQueue internalQueue = reflector(ReflectorMessageQueue.class, realQueue);
+    Message msg = internalQueue.getMessages();
+
+    if (msg != null &amp;&amp; shadowOfMsg(msg).getTarget() == null) {
+      // Stalled by a barrier.  Find the next asynchronous message in the queue.
+      do {
+        msg = shadowOfMsg(msg).internalGetNext();
+      } while (msg != null &amp;&amp; !msg.isAsynchronous());
     }
+
+    return msg;
   }
 
   Message getNext() {
@@ -214,23 +221,36 @@ private static int getInt(Object intOrLongObj) {
   }
 
   Duration getNextScheduledTaskTime() {
+    Message next = peekNextExecutableMessage();
+
+    if (next == null) {
       return Duration.ZERO;
     }
+    return Duration.ofMillis(convertWhenToScheduledTime(shadowOfMsg(next).getWhen()));
   }
 
   Duration getLastScheduledTaskTime() {
     long when = 0;
     synchronized (realQueue) {
       Message next = getMessages();
+      if (next == null) {
+        return Duration.ZERO;
+      }
       while (next != null) {
         when = shadowOfMsg(next).getWhen();
         next = shadowOfMsg(next).internalGetNext();
       }
     }
+    return Duration.ofMillis(convertWhenToScheduledTime(when));
+  }
+
+  private static long convertWhenToScheduledTime(long when) {
+    // in some situations, when can be 0 or less than uptimeMillis. Always floor it to at least
+    // convertWhenToUptime
+    if (when &lt; SystemClock.uptimeMillis()) {
+      when = SystemClock.uptimeMillis();
+    }
+    return when;
   }
 
   /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>62125</refactoring_id><commit_sha>1d82b675de58f50191ebf99f05bdcdf093c7d420</commit_sha><commit_link>https://github.com/apache/tomcat/commit/1d82b675de58f50191ebf99f05bdcdf093c7d420</commit_link><file_path>java/org/apache/catalina/websocket/WsInputStream.java</file_path><description>Extract Method private makePayloadDataAvailable() : void extracted from public read(b byte[], off int, len int) : int in class org.apache.catalina.websocket.WsInputStream</description><code_before>@@ -67,31 +67,8 @@ private void processFrame() throws IOException {
 
     @Override
     public int read() throws IOException {
-        if (error != null) {
-            throw new IOException(error);
-        }
-        while (remaining == 0 &amp;&amp; !getFrame().getFin()) {
-            // Need more data - process next frame
-            processFrame();
-            while (frame.isControl()) {
-                if (getFrame().getOpCode() == Constants.OPCODE_PING) {
-                    outbound.pong(frame.getPayLoad());
-                } else if (getFrame().getOpCode() == Constants.OPCODE_PONG) {
-                    // NO-OP. Swallow it.
-                } else if (getFrame().getOpCode() == Constants.OPCODE_CLOSE) {
-                    outbound.close(frame);
-                } else{
-                    throw new IOException(sm.getString("is.unknownOpCode",
-                            Byte.valueOf(getFrame().getOpCode())));
-                }
-                processFrame();
-            }
-            if (getFrame().getOpCode() != Constants.OPCODE_CONTINUATION) {
-                error = sm.getString("is.notContinutation",
-                        Byte.valueOf(getFrame().getOpCode()));
-                throw new IOException(error);
-            }
-        }
 
         if (remaining == 0) {
             return -1;
@@ -111,6 +88,35 @@ public int read() throws IOException {
 
     @Override
     public int read(byte b[], int off, int len) throws IOException {
         if (error != null) {
             throw new IOException(error);
         }
@@ -136,26 +142,5 @@ public int read(byte b[], int off, int len) throws IOException {
                 throw new IOException(error);
             }
         }
-
-        if (remaining == 0) {
-            return -1;
-        }
-
-        if (len &gt; remaining) {
-            len = (int) remaining;
-        }
-        int result = processor.read(b, off, len);
-        if(result == -1) {
-            return -1;
-        }
-
-        for (int i = off; i &lt; off + result; i++) {
-            b[i] = (byte) (b[i] ^
-                    frame.getMask()[(int) ((readThisFragment + i - off) % 4)]);
-        }
-        remaining -= result;
-        readThisFragment += result;
-        return result;
     }
-
 }
</code_before><code_after>@@ -67,31 +67,8 @@ private void processFrame() throws IOException {
 
     @Override
     public int read() throws IOException {
+
+        makePayloadDataAvailable();
 
         if (remaining == 0) {
             return -1;
@@ -111,6 +88,35 @@ public int read() throws IOException {
 
     @Override
     public int read(byte b[], int off, int len) throws IOException {
+
+        makePayloadDataAvailable();
+
+        if (remaining == 0) {
+            return -1;
+        }
+
+        if (len &gt; remaining) {
+            len = (int) remaining;
+        }
+        int result = processor.read(b, off, len);
+        if(result == -1) {
+            return -1;
+        }
+
+        for (int i = off; i &lt; off + result; i++) {
+            b[i] = (byte) (b[i] ^
+                    frame.getMask()[(int) ((readThisFragment + i - off) % 4)]);
+        }
+        remaining -= result;
+        readThisFragment += result;
+        return result;
+    }
+
+
+    /*
+     * Ensures that there is payload data ready to read.
+     */
+    private void makePayloadDataAvailable() throws IOException {
         if (error != null) {
             throw new IOException(error);
         }
@@ -136,26 +142,5 @@ public int read(byte b[], int off, int len) throws IOException {
                 throw new IOException(error);
             }
         }
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>34415</refactoring_id><commit_sha>cef4ec141e775bfc7441d4c0eebd014a89d534c5</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/cef4ec141e775bfc7441d4c0eebd014a89d534c5</commit_link><file_path>core/src/main/java/org/infinispan/persistence/PersistenceUtil.java</file_path><description>Extract Method private loadAndCheckExpiration(persistenceManager PersistenceManager, key Object, context InvocationContext, includeStores boolean) : MarshalledEntry&lt;K,V&gt; extracted from public loadAndCheckExpiration(persistenceManager PersistenceManager, key Object, context InvocationContext, timeService TimeService) : MarshalledEntry&lt;K,V&gt; in class org.infinispan.persistence.PersistenceUtil</description><code_before>@@ -131,75 +131,70 @@ public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndStoreInDataContainer(DataCon
 
    public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndStoreInDataContainer(DataContainer&lt;K, V&gt; dataContainer, int segment,
          final PersistenceManager persistenceManager, K key, final InvocationContext ctx, final TimeService timeService,
-                                                         final AtomicReference&lt;Boolean&gt; isLoaded) {
-      final ByRef&lt;Boolean&gt; expired = new ByRef&lt;&gt;(null);
-      DataContainer.ComputeAction&lt;K, V&gt; computeAction = (k, oldEntry, factory) -&gt; {
-         //under the lock, check if the entry exists in the DataContainer
-         if (oldEntry != null) {
-            if (isLoaded != null) {
-               isLoaded.set(null); //not loaded
-            }
-            if (oldEntry.canExpire() &amp;&amp; oldEntry.isExpired(timeService.wallClockTime())) {
-               expired.set(Boolean.TRUE);
-               return oldEntry;
-            }
-            return oldEntry; //no changes in container
-         }
-
-         // Load using key from command
-         MarshalledEntry&lt;K, V&gt; loaded = loadAndCheckExpiration(persistenceManager, key, ctx, timeService);
-         if (loaded == null) {
-            if (isLoaded != null) {
-               isLoaded.set(Boolean.FALSE); //not loaded
-            }
-            return null; //no changed in container
-         }
-
-         InternalCacheEntry&lt;K, V&gt; newEntry = convert(loaded, factory);
-
-         if (isLoaded != null) {
-            isLoaded.set(Boolean.TRUE); //loaded!
-         }
-         return newEntry;
-      };
-
-      InternalCacheEntry&lt;K,V&gt; entry;
-      if (segment != SEGMENT_NOT_PROVIDED &amp;&amp; dataContainer instanceof InternalDataContainer) {
-         entry = ((InternalDataContainer) dataContainer).compute(segment, key, computeAction);
-      } else {
-         entry = dataContainer.compute(key, computeAction);
-      }
-
-      if (expired.get() == Boolean.TRUE) {
-         return null;
-      } else {
-         return entry;
-      }
    }
 
    public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndComputeInDataContainer(DataContainer&lt;K, V&gt; dataContainer,
          int segment, final PersistenceManager persistenceManager, K key, final InvocationContext ctx,
          final TimeService timeService, DataContainer.ComputeAction&lt;K, V&gt; action) {
       final ByRef&lt;Boolean&gt; expired = new ByRef&lt;&gt;(null);
 
       DataContainer.ComputeAction&lt;K, V&gt; computeAction = (k, oldEntry, factory) -&gt; {
          //under the lock, check if the entry exists in the DataContainer
          if (oldEntry != null) {
             if (oldEntry.canExpire() &amp;&amp; oldEntry.isExpired(timeService.wallClockTime())) {
-               expired.set(Boolean.TRUE);
-               return oldEntry;
             }
-            return action.compute(k, oldEntry, factory);
-         }
 
-         // Load using key from command
-         MarshalledEntry&lt;K, V&gt; loaded = loadAndCheckExpiration(persistenceManager, key, ctx, timeService);
-         if (loaded == null) {
-            return action.compute(k, null, factory);
          }
 
-         InternalCacheEntry&lt;K, V&gt; newEntry = convert(loaded, factory);
-         return action.compute(k, newEntry, factory);
       };
       InternalCacheEntry&lt;K,V&gt; entry;
       if (segment != SEGMENT_NOT_PROVIDED &amp;&amp; dataContainer instanceof InternalDataContainer) {
@@ -216,7 +211,13 @@ public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndComputeInDataContainer(DataC
 
    public static &lt;K, V&gt; MarshalledEntry&lt;K, V&gt; loadAndCheckExpiration(PersistenceManager persistenceManager, Object key,
                                                         InvocationContext context, TimeService timeService) {
-      final MarshalledEntry&lt;K, V&gt; loaded = persistenceManager.loadFromAllStores(key, context.isOriginLocal());
       if (trace) {
          log.tracef("Loaded %s for key %s from persistence.", loaded, key);
       }
</code_before><code_after>@@ -131,75 +131,70 @@ public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndStoreInDataContainer(DataCon
 
    public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndStoreInDataContainer(DataContainer&lt;K, V&gt; dataContainer, int segment,
          final PersistenceManager persistenceManager, K key, final InvocationContext ctx, final TimeService timeService,
+         final AtomicReference&lt;Boolean&gt; isLoaded) {
+      return loadAndComputeInDataContainer(dataContainer, segment, persistenceManager, key, ctx, timeService, null, isLoaded);
    }
 
    public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndComputeInDataContainer(DataContainer&lt;K, V&gt; dataContainer,
          int segment, final PersistenceManager persistenceManager, K key, final InvocationContext ctx,
          final TimeService timeService, DataContainer.ComputeAction&lt;K, V&gt; action) {
+      return loadAndComputeInDataContainer(dataContainer, segment, persistenceManager, key, ctx, timeService, action, null);
+   }
+
+   private static &lt;K, V&gt; InternalCacheEntry&lt;K, V&gt; loadAndComputeInDataContainer(DataContainer&lt;K, V&gt; dataContainer,
+         int segment, final PersistenceManager persistenceManager, K key, final InvocationContext ctx,
+         final TimeService timeService, DataContainer.ComputeAction&lt;K, V&gt; action, final AtomicReference&lt;Boolean&gt; isLoaded) {
       final ByRef&lt;Boolean&gt; expired = new ByRef&lt;&gt;(null);
 
       DataContainer.ComputeAction&lt;K, V&gt; computeAction = (k, oldEntry, factory) -&gt; {
+         InternalCacheEntry&lt;K, V&gt; entryToUse;
          //under the lock, check if the entry exists in the DataContainer
          if (oldEntry != null) {
             if (oldEntry.canExpire() &amp;&amp; oldEntry.isExpired(timeService.wallClockTime())) {
+               // If it was expired we can check CacheLoaders - since they can have different
+               // metadata than a store
+               MarshalledEntry&lt;K, V&gt; loaded = loadAndCheckExpiration(persistenceManager, key, ctx, false);
+               if (loaded != null) {
+                  if (isLoaded != null) {
+                     isLoaded.set(Boolean.TRUE); //loaded!
+                  }
+                  entryToUse = convert(loaded, factory);
+
+               } else {
+                  if (isLoaded != null) {
+                     isLoaded.set(Boolean.FALSE); //not loaded
+                  }
+                  expired.set(Boolean.TRUE);
+                  // Return the original entry - so it doesn't remove expired entry early
+                  return oldEntry;
+               }
+            } else {
+               if (isLoaded != null) {
+                  isLoaded.set(null); //no attempt to load
+               }
+               entryToUse = oldEntry;
+            }
+         } else {
+            // There was no entry in memory so check all the stores to see if it is there
+            MarshalledEntry&lt;K, V&gt; loaded = loadAndCheckExpiration(persistenceManager, key, ctx, true);
+            if (loaded != null) {
+               if (isLoaded != null) {
+                  isLoaded.set(Boolean.TRUE); //loaded!
+               }
+               entryToUse = convert(loaded, factory);
+            } else {if (isLoaded != null) {
+               isLoaded.set(Boolean.FALSE); //not loaded
             }
 
+               entryToUse = null;
+            }
          }
 
+         if (action != null) {
+            return action.compute(k, entryToUse, factory);
+         } else {
+            return entryToUse;
+         }
       };
       InternalCacheEntry&lt;K,V&gt; entry;
       if (segment != SEGMENT_NOT_PROVIDED &amp;&amp; dataContainer instanceof InternalDataContainer) {
@@ -216,7 +211,13 @@ public static &lt;K, V&gt; InternalCacheEntry&lt;K,V&gt; loadAndComputeInDataContainer(DataC
 
    public static &lt;K, V&gt; MarshalledEntry&lt;K, V&gt; loadAndCheckExpiration(PersistenceManager persistenceManager, Object key,
                                                         InvocationContext context, TimeService timeService) {
+      return loadAndCheckExpiration(persistenceManager, key, context, true);
+   }
+
+   private static &lt;K, V&gt; MarshalledEntry&lt;K, V&gt; loadAndCheckExpiration(PersistenceManager persistenceManager, Object key,
+         InvocationContext context, boolean includeStores) {
+      final MarshalledEntry&lt;K, V&gt; loaded = persistenceManager.loadFromAllStores(key, context.isOriginLocal(),
+            includeStores);
       if (trace) {
          log.tracef("Loaded %s for key %s from persistence.", loaded, key);
       }
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>60684</refactoring_id><commit_sha>48269129fd3180e5861c3c53e391663a6a91f1f9</commit_sha><commit_link>https://github.com/groovy/groovy-core/commit/48269129fd3180e5861c3c53e391663a6a91f1f9</commit_link><file_path>src/main/groovy/lang/ExpandoMetaClass.java</file_path><description>Extract Method private ExpandoMetaClass(theClass Class, register boolean, allowChangesAfterInit boolean, add MetaMethod[]) extracted from public ExpandoMetaClass(theClass Class, add MetaMethod[]) in class groovy.lang.ExpandoMetaClass</description><code_before>@@ -29,7 +29,6 @@
 import org.codehaus.groovy.runtime.callsite.StaticMetaClassSite;
 import org.codehaus.groovy.runtime.metaclass.ClosureMetaMethod;
 import org.codehaus.groovy.runtime.metaclass.ClosureStaticMetaMethod;
-import org.codehaus.groovy.runtime.metaclass.MetaMethodIndex;
 import org.codehaus.groovy.runtime.metaclass.MixedInMetaClass;
 import org.codehaus.groovy.runtime.metaclass.MixinInstanceMetaMethod;
 import org.codehaus.groovy.runtime.metaclass.OwnedMetaClass;
@@ -269,12 +268,14 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
     // These two properties are used when no ExpandoMetaClassCreationHandle is present
 
     private MetaClass myMetaClass;
-    private boolean allowChangesAfterInit;
 
-    private boolean initialized;
     private boolean initCalled;
-    private boolean modified;
     public boolean inRegistry;
     private final Set&lt;MetaMethod&gt; inheritedMetaMethods = new HashSet&lt;MetaMethod&gt;();
     private final Map&lt;String, MetaProperty&gt; beanPropertyCache = new ConcurrentHashMap&lt;String, MetaProperty&gt;();
     private final Map&lt;String, MetaProperty&gt; staticBeanPropertyCache = new ConcurrentHashMap&lt;String, MetaProperty&gt;();
@@ -289,19 +290,24 @@ public Collection getExpandoSubclassMethods() {
     private ClosureStaticMetaMethod invokeStaticMethodMethod;
     private final Set&lt;MixinInMetaClass&gt; mixinClasses = new LinkedHashSet&lt;MixinInMetaClass&gt;();
 
     /**
      * Constructs a new ExpandoMetaClass instance for the given class
      *
      * @param theClass The class that the MetaClass applies to
      */
     public ExpandoMetaClass(Class theClass) {
-        super(GroovySystem.getMetaClassRegistry(), theClass);
-        this.myMetaClass = InvokerHelper.getMetaClass(getClass());
     }
 
-    public ExpandoMetaClass(Class theClass, MetaMethod[] add) {
-        super(GroovySystem.getMetaClassRegistry(), theClass, add);
-        this.myMetaClass = InvokerHelper.getMetaClass(getClass());
     }
 
     /**
@@ -312,27 +318,23 @@ public ExpandoMetaClass(Class theClass, MetaMethod[] add) {
      * @param register True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
      */
     public ExpandoMetaClass(Class theClass, boolean register) {
-        this(theClass);
-        this.inRegistry = register;
     }
 
-    public ExpandoMetaClass(Class theClass, boolean register, MetaMethod[] add) {
-        this(theClass, add);
-        this.inRegistry = register;
     }
 
     /**
      * Constructs a new ExpandoMetaClass instance for the given class optionally placing the MetaClass
      * in the MetaClassRegistry automatically
      *
-     * @param theClass              The class that the MetaClass applies to
-     * @param register              True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
      * @param allowChangesAfterInit Should the meta class be modifiable after initialization. Default is false.
      */
     public ExpandoMetaClass(Class theClass, boolean register, boolean allowChangesAfterInit) {
-        this(theClass);
-        this.inRegistry = register;
-        this.allowChangesAfterInit = allowChangesAfterInit;
     }
 
     public MetaMethod findMixinMethod(String methodName, Class[] arguments) {
@@ -390,7 +392,7 @@ protected void onGetPropertyFoundInHierarchy(MetaMethod method) {
         this.getPropertyMethod = method;
     }
 
-    public synchronized boolean isModified() {
         return this.modified;
     }
 
@@ -468,29 +470,24 @@ public synchronized void initialize() {
 
     /**
      * Checks if the meta class is initialized.
-     *
      * @see groovy.lang.MetaClassImpl#isInitialized()
      */
-    protected synchronized boolean isInitialized() {
         return this.initialized;
     }
 
-    protected synchronized void setInitialized(boolean b) {
         this.initialized = b;
     }
 
     private void addSuperMethodIfNotOverridden(final MetaMethod metaMethodFromSuper) {
         performOperationOnMetaClass(new Callable() {
             public void call() {
 
-                final MetaMethodIndex.Header header = metaMethodIndex.getHeader(theClass);
-                final MetaMethodIndex.Entry methods = metaMethodIndex.getOrPutMethods(metaMethodFromSuper.getName(), header);
-
                 MetaMethod existing = null;
                 try {
                     existing = pickMethod(metaMethodFromSuper.getName(), metaMethodFromSuper.getNativeParameterTypes());
-                }
-                catch (GroovyRuntimeException e) {
                     // ignore, this happens with overlapping method definitions
                 }
 
@@ -511,15 +508,13 @@ public void call() {
             private void addMethodWithKey(final MetaMethod metaMethodFromSuper) {
                 inheritedMetaMethods.add(metaMethodFromSuper);
                 if (metaMethodFromSuper instanceof ClosureMetaMethod) {
-                    ClosureMetaMethod closureMethod = (ClosureMetaMethod) metaMethodFromSuper;
-                    Closure cloned = (Closure) closureMethod.getClosure().clone();
                     String name = metaMethodFromSuper.getName();
                     final Class declaringClass = metaMethodFromSuper.getDeclaringClass().getTheClass();
                     ClosureMetaMethod localMethod = ClosureMetaMethod.copy(closureMethod);
                     addMetaMethod(localMethod);
 
                     MethodKey key = new DefaultCachedMethodKey(declaringClass, name, localMethod.getParameterTypes(), false);
-//                    cacheInstanceMethod(key, localMethod);
 
                     checkIfGroovyObjectMethod(localMethod);
                     expandoMethods.put(key, localMethod);
</code_before><code_after>@@ -29,7 +29,6 @@
 import org.codehaus.groovy.runtime.callsite.StaticMetaClassSite;
 import org.codehaus.groovy.runtime.metaclass.ClosureMetaMethod;
 import org.codehaus.groovy.runtime.metaclass.ClosureStaticMetaMethod;
 import org.codehaus.groovy.runtime.metaclass.MixedInMetaClass;
 import org.codehaus.groovy.runtime.metaclass.MixinInstanceMetaMethod;
 import org.codehaus.groovy.runtime.metaclass.OwnedMetaClass;
@@ -269,12 +268,14 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
     // These two properties are used when no ExpandoMetaClassCreationHandle is present
 
     private MetaClass myMetaClass;
+    private volatile boolean initialized;
+    private volatile boolean modified;
 
     private boolean initCalled;
+    
+    final private boolean allowChangesAfterInit;
     public boolean inRegistry;
+    
     private final Set&lt;MetaMethod&gt; inheritedMetaMethods = new HashSet&lt;MetaMethod&gt;();
     private final Map&lt;String, MetaProperty&gt; beanPropertyCache = new ConcurrentHashMap&lt;String, MetaProperty&gt;();
     private final Map&lt;String, MetaProperty&gt; staticBeanPropertyCache = new ConcurrentHashMap&lt;String, MetaProperty&gt;();
@@ -289,19 +290,24 @@ public Collection getExpandoSubclassMethods() {
     private ClosureStaticMetaMethod invokeStaticMethodMethod;
     private final Set&lt;MixinInMetaClass&gt; mixinClasses = new LinkedHashSet&lt;MixinInMetaClass&gt;();
 
+    private ExpandoMetaClass(Class theClass, boolean register, boolean allowChangesAfterInit, MetaMethod[] add) {
+        super(GroovySystem.getMetaClassRegistry(), theClass, add);
+        this.myMetaClass = InvokerHelper.getMetaClass(getClass());
+        this.inRegistry = register;
+        this.allowChangesAfterInit = allowChangesAfterInit;
+    }
+    
     /**
      * Constructs a new ExpandoMetaClass instance for the given class
      *
      * @param theClass The class that the MetaClass applies to
      */
     public ExpandoMetaClass(Class theClass) {
+        this(theClass,false,false,null);
     }
 
+    public ExpandoMetaClass(Class theClass, MetaMethod [] add) {
+        this(theClass,false,false,add);
     }
 
     /**
@@ -312,27 +318,23 @@ public ExpandoMetaClass(Class theClass, MetaMethod[] add) {
      * @param register True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
      */
     public ExpandoMetaClass(Class theClass, boolean register) {
+        this(theClass,register,false,null);
     }
 
+    public ExpandoMetaClass(Class theClass, boolean register, MetaMethod [] add) {
+        this(theClass, register, false, add);
     }
 
     /**
      * Constructs a new ExpandoMetaClass instance for the given class optionally placing the MetaClass
      * in the MetaClassRegistry automatically
      *
+     * @param theClass The class that the MetaClass applies to
+     * @param register True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
      * @param allowChangesAfterInit Should the meta class be modifiable after initialization. Default is false.
      */
     public ExpandoMetaClass(Class theClass, boolean register, boolean allowChangesAfterInit) {
+        this(theClass, register, allowChangesAfterInit, null);
     }
 
     public MetaMethod findMixinMethod(String methodName, Class[] arguments) {
@@ -390,7 +392,7 @@ protected void onGetPropertyFoundInHierarchy(MetaMethod method) {
         this.getPropertyMethod = method;
     }
 
+    public boolean isModified() {
         return this.modified;
     }
 
@@ -468,29 +470,24 @@ public synchronized void initialize() {
 
     /**
      * Checks if the meta class is initialized.
      * @see groovy.lang.MetaClassImpl#isInitialized()
      */
+    protected  boolean isInitialized() {
         return this.initialized;
     }
 
+    protected void setInitialized(boolean b) {
         this.initialized = b;
     }
 
     private void addSuperMethodIfNotOverridden(final MetaMethod metaMethodFromSuper) {
         performOperationOnMetaClass(new Callable() {
             public void call() {
 
                 MetaMethod existing = null;
                 try {
                     existing = pickMethod(metaMethodFromSuper.getName(), metaMethodFromSuper.getNativeParameterTypes());
+                } catch ( GroovyRuntimeException e) {
                     // ignore, this happens with overlapping method definitions
                 }
 
@@ -511,15 +508,13 @@ public void call() {
             private void addMethodWithKey(final MetaMethod metaMethodFromSuper) {
                 inheritedMetaMethods.add(metaMethodFromSuper);
                 if (metaMethodFromSuper instanceof ClosureMetaMethod) {
+                    ClosureMetaMethod closureMethod = (ClosureMetaMethod)metaMethodFromSuper;
                     String name = metaMethodFromSuper.getName();
                     final Class declaringClass = metaMethodFromSuper.getDeclaringClass().getTheClass();
                     ClosureMetaMethod localMethod = ClosureMetaMethod.copy(closureMethod);
                     addMetaMethod(localMethod);
 
                     MethodKey key = new DefaultCachedMethodKey(declaringClass, name, localMethod.getParameterTypes(), false);
 
                     checkIfGroovyObjectMethod(localMethod);
                     expandoMethods.put(key, localMethod);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>65049</refactoring_id><commit_sha>9a63ce7a57aaa2eb971bdbdaa44271e8e122e60a</commit_sha><commit_link>https://github.com/rstudio/rstudio/commit/9a63ce7a57aaa2eb971bdbdaa44271e8e122e60a</commit_link><file_path>src/gwt/src/com/google/gwt/user/client/ui/MenuBar.java</file_path><description>Extract Method private hideChildMenu(focus boolean) : void extracted from public selectItem(item MenuItem) : void in class com.google.gwt.user.client.ui.MenuBar</description><code_before>@@ -302,6 +302,7 @@ private int getClientRight() {
   private MenuPopup popup;
   private MenuItem selectedItem;
   private MenuBar shownChildMenu;
   private boolean vertical, autoOpen;
   private boolean focusOnHover = true;
 
@@ -513,6 +514,11 @@ public void clearItems() {
   public void closeAllChildren(boolean focus) {
     if (shownChildMenu != null) {
       // Hide any open submenus of this item
       shownChildMenu.onHide(focus);
       shownChildMenu = null;
       selectItem(null);
@@ -863,8 +869,7 @@ public void selectItem(MenuItem item) {
         if (shownChildMenu != null
             &amp;&amp; shownChildMenu == selectedItem.getSubMenu())
         {
-          shownChildMenu.onHide(false);
-          popup.hide();
           shownChildMenu = null;
         }
       }
@@ -1014,8 +1019,7 @@ public void execute() {
 
       // hide any open submenus of this item
       if (shownChildMenu != null) {
-        shownChildMenu.onHide(focus);
-        popup.hide();
         shownChildMenu = null;
         selectItem(null);
       }
@@ -1025,20 +1029,17 @@ public void execute() {
         openPopup(item);
       } else if (item.getSubMenu() != shownChildMenu) {
         // close the other submenu and open this one
-        shownChildMenu.onHide(focus);
-        popup.hide();
         openPopup(item);
       } else if (fireCommand &amp;&amp; !autoOpen) {
         // close this submenu
-        shownChildMenu.onHide(focus);
-        popup.hide();
         shownChildMenu = null;
         selectItem(item);
       }
     } else if (autoOpen &amp;&amp; shownChildMenu != null) {
       // close submenu
-      shownChildMenu.onHide(focus);
-      popup.hide();
       shownChildMenu = null;
     }
   }
@@ -1284,8 +1285,7 @@ private void moveToPrevItem() {
    */
   private void onHide(boolean focus) {
     if (shownChildMenu != null) {
-      shownChildMenu.onHide(focus);
-      popup.hide();
       if (focus) {
         focus();
       }
@@ -1301,6 +1301,8 @@ private void openPopup(final MenuItem item) {
     shownChildMenu = item.getSubMenu();
     shownChildMenu.selectItem(null);
     shownChildMenu.parentMenu = this;
 
     popup = new MenuPopup();
     popup.setWidget(shownChildMenu);
@@ -1444,4 +1446,19 @@ private void selectPrevItem() {
   private void setItemColSpan(UIObject item, int colspan) {
     item.getElement().setPropertyInt("colSpan", colspan);
   }
 }
</code_before><code_after>@@ -302,6 +302,7 @@ private int getClientRight() {
   private MenuPopup popup;
   private MenuItem selectedItem;
   private MenuBar shownChildMenu;
+  private MenuItem expandedMenuItem;
   private boolean vertical, autoOpen;
   private boolean focusOnHover = true;
 
@@ -513,6 +514,11 @@ public void clearItems() {
   public void closeAllChildren(boolean focus) {
     if (shownChildMenu != null) {
       // Hide any open submenus of this item
+      if (expandedMenuItem != null)
+      {
+        expandedMenuItem.setAriaExpanded(false);
+        expandedMenuItem = null;
+      }
       shownChildMenu.onHide(focus);
       shownChildMenu = null;
       selectItem(null);
@@ -863,8 +869,7 @@ public void selectItem(MenuItem item) {
         if (shownChildMenu != null
             &amp;&amp; shownChildMenu == selectedItem.getSubMenu())
         {
+          hideChildMenu(false);
           shownChildMenu = null;
         }
       }
@@ -1014,8 +1019,7 @@ public void execute() {
 
       // hide any open submenus of this item
       if (shownChildMenu != null) {
+        hideChildMenu(focus);
         shownChildMenu = null;
         selectItem(null);
       }
@@ -1025,20 +1029,17 @@ public void execute() {
         openPopup(item);
       } else if (item.getSubMenu() != shownChildMenu) {
         // close the other submenu and open this one
+        hideChildMenu(focus);
         openPopup(item);
       } else if (fireCommand &amp;&amp; !autoOpen) {
         // close this submenu
+        hideChildMenu(focus);
         shownChildMenu = null;
         selectItem(item);
       }
     } else if (autoOpen &amp;&amp; shownChildMenu != null) {
       // close submenu
+      hideChildMenu(focus);
       shownChildMenu = null;
     }
   }
@@ -1284,8 +1285,7 @@ private void moveToPrevItem() {
    */
   private void onHide(boolean focus) {
     if (shownChildMenu != null) {
+      hideChildMenu(focus);
       if (focus) {
         focus();
       }
@@ -1301,6 +1301,8 @@ private void openPopup(final MenuItem item) {
     shownChildMenu = item.getSubMenu();
     shownChildMenu.selectItem(null);
     shownChildMenu.parentMenu = this;
+    expandedMenuItem = item;
+    item.setAriaExpanded(true);
 
     popup = new MenuPopup();
     popup.setWidget(shownChildMenu);
@@ -1444,4 +1446,19 @@ private void selectPrevItem() {
   private void setItemColSpan(UIObject item, int colspan) {
     item.getElement().setPropertyInt("colSpan", colspan);
   }
+
+  /**
+   * Hide currently displayed child menu and mark the associate menu item as closed.
+   * @param focus
+   */
+  private void hideChildMenu(boolean focus)
+  {
+    if (expandedMenuItem != null)
+    {
+      expandedMenuItem.setAriaExpanded(false);
+      expandedMenuItem = null;
+    }
+    shownChildMenu.onHide(focus);
+    popup.hide();
+  }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>119126</refactoring_id><commit_sha>b88259ac67036252084860b678d7cecd99a05b59</commit_sha><commit_link>https://github.com/tronprotocol/java-tron/commit/b88259ac67036252084860b678d7cecd99a05b59</commit_link><file_path>src/main/java/org/tron/core/config/Configuration.java</file_path><description>Extract Method private resolveConfigFile(fileName String, confFile File) : void extracted from public getByPath(configurationPath String) : Config in class org.tron.core.config.Configuration</description><code_before>@@ -19,10 +19,15 @@
 package org.tron.core.config;
 
 import static org.apache.commons.lang3.StringUtils.isBlank;
 
 import com.typesafe.config.ConfigFactory;
 import java.io.File;
 import lombok.extern.slf4j.Slf4j;
 
 @Slf4j
 public class Configuration {
@@ -32,29 +37,36 @@ public class Configuration {
   /**
    * Get configuration by a given path.
    *
-   * @param configurationPath path to configuration file
    * @return loaded configuration
    */
-  public static com.typesafe.config.Config getByPath(final String configurationPath) {
-    if (isBlank(configurationPath)) {
-      throw new IllegalArgumentException("Configuration path is required!");
     }
 
-    File confFile = new File(configurationPath);
-    if (confFile.exists()) {
-      config = ConfigFactory.parseFile(new File(configurationPath));
     } else {
-      config = ConfigFactory.load(configurationPath);
     }
-    return config;
   }
 
-  public static com.typesafe.config.Config getByFile(final File confFile) {
-    if (!confFile.exists()) {
-      throw new IllegalArgumentException("Configuration path is required!");
     }
-    config = ConfigFactory.parseFile(confFile);
-    return config;
   }
 }
 
</code_before><code_after>@@ -19,10 +19,15 @@
 package org.tron.core.config;
 
 import static org.apache.commons.lang3.StringUtils.isBlank;
+import static org.apache.commons.lang3.StringUtils.isNoneBlank;
 
 import com.typesafe.config.ConfigFactory;
+
 import java.io.File;
+import java.io.FileNotFoundException;
+
 import lombok.extern.slf4j.Slf4j;
+import org.springframework.util.ResourceUtils;
 
 @Slf4j
 public class Configuration {
@@ -32,29 +37,36 @@ public class Configuration {
   /**
    * Get configuration by a given path.
    *
+   * @param confFileName path to configuration file
    * @return loaded configuration
    */
+  public static com.typesafe.config.Config getByFileName(final String shellConfFileName, final String confFileName) {
+    if (isNoneBlank(shellConfFileName)) {
+      File shellConfFile = new File(shellConfFileName);
+      resolveConfigFile(shellConfFileName, shellConfFile);
+      return config;
     }
 
+    if (isBlank(confFileName)) {
+      throw new IllegalArgumentException("Configuration path is required!");
     } else {
+      File confFile = new File(confFileName);
+      resolveConfigFile(confFileName, confFile);
+      return config;
     }
   }
 
+  private static void resolveConfigFile(String fileName, File confFile) {
+    if (confFile.exists()) {
+      config = ConfigFactory.parseFile(confFile);
+    } else {
+      try {
+        ResourceUtils.getFile("classpath:" + fileName);
+      } catch (FileNotFoundException e) {
+        throw new IllegalArgumentException("Configuration path is required! No Such file " + fileName);
+      }
+      config = ConfigFactory.load(fileName);
     }
   }
 }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>26734</refactoring_id><commit_sha>e0cb325a4e27eba9bcea7d0f7722161254f9f6e4</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/e0cb325a4e27eba9bcea7d0f7722161254f9f6e4</commit_link><file_path>src/datagen/additions/java/mekanism/additions/common/AdditionsDataGenerator.java</file_path><description>Extract Method private addProvider(gen DataGenerator, run boolean, factory DataProvider.Factory&lt;PROVIDER&gt;) : void extracted from public gatherData(event GatherDataEvent) : void in class mekanism.additions.common.AdditionsDataGenerator</description><code_before>@@ -1,15 +1,18 @@
 package mekanism.additions.common;
 
 import mekanism.additions.client.AdditionsBlockStateProvider;
 import mekanism.additions.client.AdditionsItemModelProvider;
 import mekanism.additions.client.AdditionsLangProvider;
 import mekanism.additions.client.AdditionsSoundProvider;
 import mekanism.additions.common.loot.AdditionsLootProvider;
 import mekanism.additions.common.recipe.AdditionsRecipeProvider;
-import mekanism.additions.common.world_modifier.AdditionsBiomeModifierProvider;
-import mekanism.additions.common.world_modifier.AdditionsStructureModifierProvider;
 import mekanism.common.MekanismDataGenerator;
 import net.minecraft.data.DataGenerator;
 import net.minecraftforge.common.data.ExistingFileHelper;
 import net.minecraftforge.data.event.GatherDataEvent;
 import net.minecraftforge.eventbus.api.SubscribeEvent;
@@ -27,19 +30,25 @@ public static void gatherData(GatherDataEvent event) {
         MekanismDataGenerator.bootstrapConfigs(MekanismAdditions.MODID);
         DataGenerator gen = event.getGenerator();
         ExistingFileHelper existingFileHelper = event.getExistingFileHelper();
         //Client side data generators
-        gen.addProvider(event.includeClient(), new AdditionsLangProvider(gen));
-        gen.addProvider(event.includeClient(), new AdditionsSoundProvider(gen, existingFileHelper));
         //Let the blockstate provider see models generated by the item model provider
-        AdditionsItemModelProvider itemModelProvider = new AdditionsItemModelProvider(gen, existingFileHelper);
         gen.addProvider(event.includeClient(), itemModelProvider);
-        gen.addProvider(event.includeClient(), new AdditionsBlockStateProvider(gen, itemModelProvider.existingFileHelper));
         //Server side data generators
-        gen.addProvider(event.includeServer(), new AdditionsTagProvider(gen, existingFileHelper));
-        gen.addProvider(event.includeServer(), new AdditionsLootProvider(gen));
-        gen.addProvider(event.includeServer(), new AdditionsBiomeModifierProvider(gen));
-        gen.addProvider(event.includeServer(), new AdditionsStructureModifierProvider(gen));
-        gen.addProvider(event.includeServer(), new AdditionsRecipeProvider(gen, existingFileHelper));
-        gen.addProvider(event.includeServer(), new AdditionsAdvancementProvider(gen, existingFileHelper));
     }
 }
\ No newline at end of file
</code_before><code_after>@@ -1,15 +1,18 @@
 package mekanism.additions.common;
 
+import java.util.concurrent.CompletableFuture;
 import mekanism.additions.client.AdditionsBlockStateProvider;
 import mekanism.additions.client.AdditionsItemModelProvider;
 import mekanism.additions.client.AdditionsLangProvider;
 import mekanism.additions.client.AdditionsSoundProvider;
+import mekanism.additions.client.AdditionsSpriteSourceProvider;
 import mekanism.additions.common.loot.AdditionsLootProvider;
 import mekanism.additions.common.recipe.AdditionsRecipeProvider;
+import mekanism.common.BasePackMetadataGenerator;
 import mekanism.common.MekanismDataGenerator;
+import net.minecraft.core.HolderLookup;
 import net.minecraft.data.DataGenerator;
+import net.minecraft.data.DataProvider;
 import net.minecraftforge.common.data.ExistingFileHelper;
 import net.minecraftforge.data.event.GatherDataEvent;
 import net.minecraftforge.eventbus.api.SubscribeEvent;
@@ -27,19 +30,25 @@ public static void gatherData(GatherDataEvent event) {
         MekanismDataGenerator.bootstrapConfigs(MekanismAdditions.MODID);
         DataGenerator gen = event.getGenerator();
         ExistingFileHelper existingFileHelper = event.getExistingFileHelper();
+        CompletableFuture&lt;HolderLookup.Provider&gt; lookupProvider = event.getLookupProvider();
+        addProvider(gen, true, output -&gt; new BasePackMetadataGenerator(output, AdditionsLang.PACK_DESCRIPTION));
         //Client side data generators
+        addProvider(gen, event.includeClient(), AdditionsLangProvider::new);
+        addProvider(gen, event.includeClient(), output -&gt; new AdditionsSoundProvider(output, existingFileHelper));
+        addProvider(gen, event.includeClient(), output -&gt; new AdditionsSpriteSourceProvider(output, existingFileHelper));
         //Let the blockstate provider see models generated by the item model provider
+        AdditionsItemModelProvider itemModelProvider = new AdditionsItemModelProvider(gen.getPackOutput(), existingFileHelper);
         gen.addProvider(event.includeClient(), itemModelProvider);
+        addProvider(gen, event.includeClient(), output -&gt; new AdditionsBlockStateProvider(output, itemModelProvider.existingFileHelper));
         //Server side data generators
+        addProvider(gen, event.includeServer(), output -&gt; new AdditionsTagProvider(output, lookupProvider, existingFileHelper));
+        addProvider(gen, event.includeServer(), AdditionsLootProvider::new);
+        addProvider(gen, event.includeServer(), output -&gt; new AdditionsDatapackRegistryProvider(output, lookupProvider));
+        addProvider(gen, event.includeServer(), output -&gt; new AdditionsRecipeProvider(output, existingFileHelper));
+        addProvider(gen, event.includeServer(), output -&gt; new AdditionsAdvancementProvider(output, existingFileHelper));
+    }
+
+    private static &lt;PROVIDER extends DataProvider&gt; void addProvider(DataGenerator gen, boolean run, DataProvider.Factory&lt;PROVIDER&gt; factory) {
+        gen.addProvider(run, factory);
     }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>11146</refactoring_id><commit_sha>9c5c8f4e609a22b49d19c0a659679fce036dfe2b</commit_sha><commit_link>https://github.com/nationalsecurityagency/ghidra/commit/9c5c8f4e609a22b49d19c0a659679fce036dfe2b</commit_link><file_path>Ghidra/Debug/Debugger/src/test/java/ghidra/app/plugin/core/debug/gui/AbstractGhidraHeadedDebuggerGUITest.java</file_path><description>Extract Method protected createProgram(lang Language) : void extracted from protected createProgram() : void in class ghidra.app.plugin.core.debug.gui.AbstractGhidraHeadedDebuggerGUITest</description><code_before>@@ -508,17 +508,23 @@ protected String getProgramName() {
 	}
 
 	protected void createProgramFromTrace(Trace trace) throws IOException {
-		program = new ProgramDB(getProgramName(), trace.getBaseLanguage(),
-			trace.getBaseCompilerSpec(), this);
 	}
 
 	protected void createProgramFromTrace() throws IOException {
 		createProgramFromTrace(tb.trace);
 	}
 
 	protected void createProgram() throws IOException {
-		Language lang = getToyBE64Language();
-		program = new ProgramDB(getProgramName(), lang, lang.getDefaultCompilerSpec(), this);
 	}
 
 	protected void createAndOpenProgramFromTrace() throws IOException {
</code_before><code_after>@@ -508,17 +508,23 @@ protected String getProgramName() {
 	}
 
 	protected void createProgramFromTrace(Trace trace) throws IOException {
+		createProgram(trace.getBaseLanguage(), trace.getBaseCompilerSpec());
 	}
 
 	protected void createProgramFromTrace() throws IOException {
 		createProgramFromTrace(tb.trace);
 	}
 
+	protected void createProgram(Language lang, CompilerSpec cSpec) throws IOException {
+		program = new ProgramDB(getProgramName(), lang, cSpec, this);
+	}
+
+	protected void createProgram(Language lang) throws IOException {
+		createProgram(lang, lang.getDefaultCompilerSpec());
+	}
+
 	protected void createProgram() throws IOException {
+		createProgram(getToyBE64Language());
 	}
 
 	protected void createAndOpenProgramFromTrace() throws IOException {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>79043</refactoring_id><commit_sha>16ecbff906b344ea397fea8c16fe06f7c249a9f9</commit_sha><commit_link>https://github.com/opentripplanner/opentripplanner/commit/16ecbff906b344ea397fea8c16fe06f7c249a9f9</commit_link><file_path>src/ext/java/org/opentripplanner/ext/fares/impl/GtfsFaresV2Service.java</file_path><description>Extract Method private filterByNetworkId(leg ScheduledTransitLeg, rule FareLegRule) : boolean extracted from private getLegProducts(leg ScheduledTransitLeg) : Stream&lt;FareProduct&gt; in class org.opentripplanner.ext.fares.impl.GtfsFaresV2Service</description><code_before>@@ -1,5 +1,7 @@
 package org.opentripplanner.ext.fares.impl;
 
 import java.util.Collection;
 import java.util.List;
 import java.util.Objects;
@@ -10,15 +12,20 @@
 import org.opentripplanner.model.FareProduct;
 import org.opentripplanner.model.plan.Itinerary;
 import org.opentripplanner.model.plan.ScheduledTransitLeg;
 
-public final class GtfsFaresV2Service {
 
   private final List&lt;FareLegRule&gt; legRules;
   private final Set&lt;String&gt; networksWithRules;
 
-  public GtfsFaresV2Service(List&lt;FareLegRule&gt; legRules) {
     this.legRules = legRules;
     this.networksWithRules = findNetworksWithRules(legRules);
   }
 
   public ProductResult getProducts(Itinerary itinerary) {
@@ -33,6 +40,13 @@ public ProductResult getProducts(Itinerary itinerary) {
     return new ProductResult(coveringItinerary);
   }
 
   private static Set&lt;String&gt; findNetworksWithRules(Collection&lt;FareLegRule&gt; legRules) {
     return legRules
       .stream()
@@ -46,18 +60,36 @@ private Stream&lt;FareProduct&gt; getLegProducts(ScheduledTransitLeg leg) {
       .stream()
       // make sure that you only get rules for the correct feed
       .filter(legRule -&gt; leg.getAgency().getId().getFeedId().equals(legRule.feedId()))
-      // get the fare products that match the network_id
-      // the the network id of the product is null it depends on the presence/absence of other rules
-      // with that network id
-      .filter(product -&gt;
-        (
-          Objects.isNull(product.networkId()) &amp;&amp;
-          !networksWithRules.contains(leg.getRoute().getNetworkId())
-        ) ||
-        Objects.equals(product.networkId(), leg.getRoute().getNetworkId())
-      )
       .map(FareLegRule::fareProduct);
   }
 }
 
 record ProductResult(List&lt;FareProduct&gt; productsCoveringItinerary) {}
</code_before><code_after>@@ -1,5 +1,7 @@
 package org.opentripplanner.ext.fares.impl;
 
+import com.google.common.collect.Multimap;
+import java.io.Serializable;
 import java.util.Collection;
 import java.util.List;
 import java.util.Objects;
@@ -10,15 +12,20 @@
 import org.opentripplanner.model.FareProduct;
 import org.opentripplanner.model.plan.Itinerary;
 import org.opentripplanner.model.plan.ScheduledTransitLeg;
+import org.opentripplanner.transit.model.framework.FeedScopedId;
 
+public final class GtfsFaresV2Service implements Serializable {
 
   private final List&lt;FareLegRule&gt; legRules;
+  private final Multimap&lt;FeedScopedId, String&gt; stopAreas;
   private final Set&lt;String&gt; networksWithRules;
+  private final Set&lt;String&gt; stopAreasWithRules;
 
+  public GtfsFaresV2Service(List&lt;FareLegRule&gt; legRules, Multimap&lt;FeedScopedId, String&gt; stopAreas) {
     this.legRules = legRules;
     this.networksWithRules = findNetworksWithRules(legRules);
+    this.stopAreasWithRules = findAreasWithRules(legRules);
+    this.stopAreas = stopAreas;
   }
 
   public ProductResult getProducts(Itinerary itinerary) {
@@ -33,6 +40,13 @@ public ProductResult getProducts(Itinerary itinerary) {
     return new ProductResult(coveringItinerary);
   }
 
+  private static Set&lt;String&gt; findAreasWithRules(List&lt;FareLegRule&gt; legRules) {
+    return legRules
+      .stream()
+      .flatMap(rule -&gt; Stream.of(rule.fromAreaId(), rule.toAreadId()).filter(Objects::nonNull))
+      .collect(Collectors.toSet());
+  }
+
   private static Set&lt;String&gt; findNetworksWithRules(Collection&lt;FareLegRule&gt; legRules) {
     return legRules
       .stream()
@@ -46,18 +60,36 @@ private Stream&lt;FareProduct&gt; getLegProducts(ScheduledTransitLeg leg) {
       .stream()
       // make sure that you only get rules for the correct feed
       .filter(legRule -&gt; leg.getAgency().getId().getFeedId().equals(legRule.feedId()))
+      .filter(rule -&gt; filterByNetworkId(leg, rule))
+      // apply only those rules which have the correct area ids
+      .filter(rule -&gt; filterByFromArea(leg, rule))
       .map(FareLegRule::fareProduct);
   }
+
+  private boolean filterByFromArea(ScheduledTransitLeg leg, FareLegRule rule) {
+    var fromStopAreas = stopAreas.get(leg.getFrom().stop.getId());
+    return (
+      (
+        Objects.isNull(rule.fromAreaId()) &amp;&amp;
+        fromStopAreas.stream().noneMatch(stopAreasWithRules::contains)
+      ) ||
+      (Objects.nonNull(rule.fromAreaId()) &amp;&amp; fromStopAreas.contains(rule.fromAreaId()))
+    );
+  }
+
+  /**
+   * Get the fare products that match the network_id. If the network id of the product is null it
+   * depends on the presence/absence of other rules with that network id.
+   */
+  private boolean filterByNetworkId(ScheduledTransitLeg leg, FareLegRule rule) {
+    return (
+      (
+        Objects.isNull(rule.networkId()) &amp;&amp;
+        !networksWithRules.contains(leg.getRoute().getNetworkId())
+      ) ||
+      Objects.equals(rule.networkId(), leg.getRoute().getNetworkId())
+    );
+  }
 }
 
 record ProductResult(List&lt;FareProduct&gt; productsCoveringItinerary) {}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>21719</refactoring_id><commit_sha>1d012ea64ea3815c96ce6301354f3efad6933f16</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/1d012ea64ea3815c96ce6301354f3efad6933f16</commit_link><file_path>enterprise/src/main/java/org/neo4j/kernel/DefaultExpander.java</file_path><description>Extract Method protected newExpander(types RelationshipType[], directions Map&lt;String,Direction&gt;) : RelationshipExpander extracted from public add(type RelationshipType, direction Direction) : DefaultExpander in class org.neo4j.kernel.DefaultExpander</description><code_before>@@ -18,12 +18,12 @@
 public class DefaultExpander implements RelationshipExpander
 {
     static RelationshipExpander ALL = new DefaultExpander(
-            new RelationshipType[0], new Direction[0] );
     
     private final RelationshipType[] types;
     private final Map&lt;String, Direction&gt; directions;
     
-    private DefaultExpander( RelationshipType[] types,
             Map&lt;String, Direction&gt; directions)
     {
         this.types = types;
@@ -35,20 +35,15 @@ public DefaultExpander()
         this.types = new RelationshipType[0];
         this.directions = new HashMap&lt;String, Direction&gt;();
     }
-
-    private DefaultExpander( RelationshipType[] types, Direction[] dirs )
     {
-        if ( types.length != dirs.length )
-        {
-            throw new IllegalArgumentException();
-        }
-        this.types = new RelationshipType[types.length];
-        this.directions = new HashMap&lt;String, Direction&gt;();
-        for ( int i = 0; i &lt; types.length; i++ )
-        {
-            this.types[i] = types[i];
-            this.directions.put( types[i].name(), dirs[i] );
-        }
     }
 
     /* (non-Javadoc)
@@ -76,6 +71,14 @@ public Iterable&lt;Relationship&gt; expand( final Node start,
             return start.getRelationships( type,
                     reversedDirection ? direction.reverse() : direction );
         }
         return new FilteringIterable&lt;Relationship&gt;(
                 start.getRelationships( types ) )
         {
@@ -143,6 +146,12 @@ public DefaultExpander add( RelationshipType type, Direction direction )
         Map&lt;String, Direction&gt; newDirections =
                 new HashMap&lt;String, Direction&gt;(directions);
         newDirections.put( type.name(), direction );
-        return new DefaultExpander(newTypes, newDirections);
     }
 }
</code_before><code_after>@@ -18,12 +18,12 @@
 public class DefaultExpander implements RelationshipExpander
 {
     static RelationshipExpander ALL = new DefaultExpander(
+            new RelationshipType[0], new HashMap&lt;String, Direction&gt;() );
     
     private final RelationshipType[] types;
     private final Map&lt;String, Direction&gt; directions;
     
+    protected DefaultExpander( RelationshipType[] types,
             Map&lt;String, Direction&gt; directions)
     {
         this.types = types;
@@ -35,20 +35,15 @@ public DefaultExpander()
         this.types = new RelationshipType[0];
         this.directions = new HashMap&lt;String, Direction&gt;();
     }
+    
+    protected RelationshipType[] getTypes()
     {
+        return this.types;
+    }
+    
+    protected Direction getDirection( RelationshipType type )
+    {
+        return this.directions.get( type );
     }
 
     /* (non-Javadoc)
@@ -76,6 +71,14 @@ public Iterable&lt;Relationship&gt; expand( final Node start,
             return start.getRelationships( type,
                     reversedDirection ? direction.reverse() : direction );
         }
+        return getRelationshipsForMultipleTypes( start, reversedDirection,
+                types, directions );
+    }
+    
+    protected Iterable&lt;Relationship&gt; getRelationshipsForMultipleTypes(
+            final Node start, final boolean reversedDirection,
+            RelationshipType[] types, final Map&lt;String, Direction&gt; directions )
+    {
         return new FilteringIterable&lt;Relationship&gt;(
                 start.getRelationships( types ) )
         {
@@ -143,6 +146,12 @@ public DefaultExpander add( RelationshipType type, Direction direction )
         Map&lt;String, Direction&gt; newDirections =
                 new HashMap&lt;String, Direction&gt;(directions);
         newDirections.put( type.name(), direction );
+        return (DefaultExpander) newExpander(newTypes, newDirections);
+    }
+    
+    protected RelationshipExpander newExpander( RelationshipType[] types,
+            Map&lt;String, Direction&gt; directions )
+    {
+        return new DefaultExpander( types, directions );
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>125687</refactoring_id><commit_sha>8d104f7fea392302532198d6b7362ad8075a5738</commit_sha><commit_link>https://github.com/i2p/i2p.i2p/commit/8d104f7fea392302532198d6b7362ad8075a5738</commit_link><file_path>apps/i2ptunnel/java/src/net/i2p/i2ptunnel/I2PTunnelHTTPClient.java</file_path><description>Extract Method private writeB32SaveForm(outs OutputStream, destination String, code int, targetRequest String) : void extracted from protected clientConnectionRun(s Socket) : void in class net.i2p.i2ptunnel.I2PTunnelHTTPClient</description><code_before>@@ -1163,7 +1163,7 @@ else if ("https".equals(protocol) ||
                             Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {
                         out.write(ERR_HELPER_DISABLED.getBytes("UTF-8"));
                     } else {
-                        LocalHTTPServer.serveLocalFile(out, method, internalPath, internalRawQuery, _proxyNonce);
                     }
                 } catch (IOException ioe) {
                     // ignore
@@ -1267,26 +1267,13 @@ else if ("https".equals(protocol) ||
                         if (code != LookupResult.RESULT_SUCCESS) {
                             if (_log.shouldWarn())
                                 _log.warn("Unable to resolve b33 " + destination + " error code " + code);
-                            // TODO new form to supply missing data
                             if (code != LookupResult.RESULT_FAILURE) {
-                                String header = getErrorPage("b32", ERR_DESTINATION_UNKNOWN);
-                                String msg;
-                                if (code == LookupResult.RESULT_SECRET_REQUIRED)
-                                    msg = "b32 address requires lookup password";
-                                else if (code == LookupResult.RESULT_KEY_REQUIRED)
-                                    msg = "b32 address requires encryption key";
-                                else if (code == LookupResult.RESULT_SECRET_AND_KEY_REQUIRED)
-                                    msg = "b32 address requires encryption key and lookup password";
-                                else if (code == LookupResult.RESULT_DECRYPTION_FAILURE)
-                                    msg = "b32 address decryption failure, check encryption key";
-                                else
-                                    msg = "lookup failure code " + code;
-                                try {
-                                    writeErrorMessage(header, msg, out, targetRequest, false, destination);
-                                } catch (IOException ioe) {}
                                 return;
 
                             }
                         }
                     }
                 } else {
@@ -1504,6 +1491,63 @@ private void writeHelperSaveForm(OutputStream outs, String destination, String a
         writeFooter(out);
     }
 
     /**
      *  Read the first line unbuffered.
      *  After that, switch to a BufferedReader, unless the method is "POST".
</code_before><code_after>@@ -1163,7 +1163,7 @@ else if ("https".equals(protocol) ||
                             Boolean.parseBoolean(getTunnel().getClientOptions().getProperty(PROP_DISABLE_HELPER))) {
                         out.write(ERR_HELPER_DISABLED.getBytes("UTF-8"));
                     } else {
+                        LocalHTTPServer.serveLocalFile(_context, sockMgr, out, method, internalPath, internalRawQuery, _proxyNonce);
                     }
                 } catch (IOException ioe) {
                     // ignore
@@ -1267,26 +1267,13 @@ else if ("https".equals(protocol) ||
                         if (code != LookupResult.RESULT_SUCCESS) {
                             if (_log.shouldWarn())
                                 _log.warn("Unable to resolve b33 " + destination + " error code " + code);
                             if (code != LookupResult.RESULT_FAILURE) {
+                                // form to supply missing data
+                                writeB32SaveForm(out, destination, code, targetRequest);
                                 return;
 
                             }
+                            // fall through to standard destination unreachable error page
                         }
                     }
                 } else {
@@ -1504,6 +1491,63 @@ private void writeHelperSaveForm(OutputStream outs, String destination, String a
         writeFooter(out);
     }
 
+    /** @since 0.9.43 */
+    private void writeB32SaveForm(OutputStream outs, String destination, int code,
+                                     String targetRequest) throws IOException {
+        if(outs == null)
+            return;
+        Writer out = new BufferedWriter(new OutputStreamWriter(outs, "UTF-8"));
+        String header = getErrorPage("b32", ERR_DESTINATION_UNKNOWN);
+        out.write(header);
+        out.write("&lt;table id=\"proxyNewHost\"&gt;\n&lt;tr&gt;&lt;td align=\"right\"&gt;" + _t("Host") +
+                "&lt;/td&gt;&lt;td&gt;" + destination + "&lt;/td&gt;&lt;/tr&gt;\n");
+        out.write("&lt;tr&gt;&lt;td align=\"right\"&gt;" + _t("Base 32") + "&lt;/td&gt;" +
+                  "&lt;td&gt;&lt;a href=\"http://" + destination + "/\"&gt;" + destination + "&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;");
+        out.write("\n&lt;/table&gt;\n" + "&lt;hr&gt;");
+        String msg;
+        if (code == LookupResult.RESULT_SECRET_REQUIRED)
+            msg = _t("b32 address requires lookup password");
+        else if (code == LookupResult.RESULT_KEY_REQUIRED)
+            msg = _t("b32 address requires encryption key");
+        else if (code == LookupResult.RESULT_SECRET_AND_KEY_REQUIRED)
+            msg = _t("b32 address requires encryption key and lookup password");
+        else if (code == LookupResult.RESULT_DECRYPTION_FAILURE)
+            msg = _t("b32 address decryption failure, check encryption key");
+        else
+            msg = "lookup failure code " + code;
+        out.write("&lt;p&gt;&lt;b&gt;" + msg + "&lt;/b&gt;&lt;/p&gt;");
+        out.write("&lt;form method=\"GET\" action=\"http://" + LOCAL_SERVER + "/b32\"&gt;\n" +
+                  "&lt;input type=\"hidden\" name=\"host\" value=\"" + destination + "\"&gt;\n" +
+                  "&lt;input type=\"hidden\" name=\"url\" value=\"" + targetRequest + "\"&gt;\n" +
+                  "&lt;input type=\"hidden\" name=\"code\" value=\"" + code + "\"&gt;\n" +
+                  "&lt;input type=\"hidden\" name=\"nonce\" value=\"" + _proxyNonce + "\"&gt;\n");
+
+        if (code == LookupResult.RESULT_KEY_REQUIRED || code == LookupResult.RESULT_SECRET_AND_KEY_REQUIRED) {
+            String label = _t("Generate");
+            out.write("&lt;h4&gt;" + _t("Encryption key") + "&lt;/h4&gt;\n&lt;p&gt;" +
+                      "&lt;p&gt;" + _t("You must either enter a PSK encryption key provided by the server operator, or generate a DH encryption key and send that to the server operator.") +
+                      ' ' + _t("Ask the server operator for help.") +
+                      "&lt;/p&gt;\n" +
+
+                      "&lt;input type=\"text\" size=\"55\" name=\"privkey\" value=\"\"&gt;&lt;/p&gt;\n" +
+                      "&lt;p&gt;" + _t("Generate new DH encryption key") +
+                      "&lt;button type=\"submit\" class=\"accept\" name=\"action\" value=\"newdh\"&gt;" + label + "&lt;/button&gt;\n");
+                      //"&lt;p&gt;" + _t("Generate new PSK encryption key") +
+                      //"&lt;button type=\"submit\" class=\"accept\" name=\"action\" value=\"newpsk\"&gt;" + label + "&lt;/button&gt;\n");
+        }
+        if (code == LookupResult.RESULT_SECRET_REQUIRED || code == LookupResult.RESULT_SECRET_AND_KEY_REQUIRED) {
+            out.write("&lt;h4&gt;" + _t("Lookup password") + "&lt;/h4&gt;\n&lt;p&gt;" +
+                      "&lt;input type=\"text\" size=\"55\" name=\"secret\" value=\"\"&gt;&lt;/p&gt;\n");
+        }
+
+        // FIXME wasn't escaped
+        String label = _t("Save &amp; continue").replace("&amp;", "&amp;amp;");
+        out.write("&lt;div class=\"formaction\"&gt;&lt;button type=\"submit\" class=\"accept\" name=\"action\" value=\"save\"&gt;" +
+                  label + "&lt;/button&gt;&lt;/div&gt;\n" +
+                  "&lt;/form&gt;\n&lt;/div&gt;\n");
+        writeFooter(out);
+    }
+
     /**
      *  Read the first line unbuffered.
      *  After that, switch to a BufferedReader, unless the method is "POST".
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>66201</refactoring_id><commit_sha>3efedef161038bff3e5d88f5ab36f3527f468b1f</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/3efedef161038bff3e5d88f5ab36f3527f468b1f</commit_link><file_path>spring-web/src/main/java/org/springframework/web/server/UnsupportedMediaTypeStatusException.java</file_path><description>Extract Method public getHeaders() : HttpHeaders extracted from public getResponseHeaders() : HttpHeaders in class org.springframework.web.server.UnsupportedMediaTypeStatusException</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2021 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -91,16 +91,17 @@ public UnsupportedMediaTypeStatusException(@Nullable MediaType contentType, List
 	public UnsupportedMediaTypeStatusException(@Nullable MediaType contentType, List&lt;MediaType&gt; supportedTypes,
 			@Nullable ResolvableType bodyType, @Nullable HttpMethod method) {
 
-		super(HttpStatus.UNSUPPORTED_MEDIA_TYPE, initReason(contentType, bodyType));
 		this.contentType = contentType;
 		this.supportedMediaTypes = Collections.unmodifiableList(supportedTypes);
 		this.bodyType = bodyType;
 		this.method = method;
-	}
 
-	private static String initReason(@Nullable MediaType contentType, @Nullable ResolvableType bodyType) {
-		return "Content type '" + (contentType != null ? contentType : "") + "' not supported" +
-				(bodyType != null ? " for bodyType=" + bodyType.toString() : "");
 	}
 
 
@@ -133,14 +134,31 @@ public ResolvableType getBodyType() {
 		return this.bodyType;
 	}
 
 	@Override
-	public HttpHeaders getResponseHeaders() {
-		if (HttpMethod.PATCH != this.method || CollectionUtils.isEmpty(this.supportedMediaTypes) ) {
 			return HttpHeaders.EMPTY;
 		}
 		HttpHeaders headers = new HttpHeaders();
-		headers.setAcceptPatch(this.supportedMediaTypes);
 		return headers;
 	}
 
 }
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright 2002-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -91,16 +91,17 @@ public UnsupportedMediaTypeStatusException(@Nullable MediaType contentType, List
 	public UnsupportedMediaTypeStatusException(@Nullable MediaType contentType, List&lt;MediaType&gt; supportedTypes,
 			@Nullable ResolvableType bodyType, @Nullable HttpMethod method) {
 
+		super(HttpStatus.UNSUPPORTED_MEDIA_TYPE,
+				"Content type '" + (contentType != null ? contentType : "") + "' not supported" +
+						(bodyType != null ? " for bodyType=" + bodyType : ""));
+
 		this.contentType = contentType;
 		this.supportedMediaTypes = Collections.unmodifiableList(supportedTypes);
 		this.bodyType = bodyType;
 		this.method = method;
 
+		// Set explicitly to avoid implementation details
+		setDetail(contentType != null ? "Content-Type '" + contentType + "' is not supported" : null);
 	}
 
 
@@ -133,14 +134,31 @@ public ResolvableType getBodyType() {
 		return this.bodyType;
 	}
 
+	/**
+	 * Return HttpHeaders with an "Accept" header that documents the supported
+	 * media types, if available, or an empty instance otherwise.
+	 */
 	@Override
+	public HttpHeaders getHeaders() {
+		if (CollectionUtils.isEmpty(this.supportedMediaTypes) ) {
 			return HttpHeaders.EMPTY;
 		}
 		HttpHeaders headers = new HttpHeaders();
+		headers.setAccept(this.supportedMediaTypes);
+		if (this.method == HttpMethod.PATCH) {
+			headers.setAcceptPatch(this.supportedMediaTypes);
+		}
 		return headers;
 	}
 
+	/**
+	 * Delegates to {@link #getHeaders()}.
+	 * @deprecated as of 6.0 in favor of {@link #getHeaders()}
+	 */
+	@Deprecated
+	@Override
+	public HttpHeaders getResponseHeaders() {
+		return getHeaders();
+	}
+
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>64544</refactoring_id><commit_sha>51923c4861c252cce7413be82e7dd0e5a048c03a</commit_sha><commit_link>https://github.com/rstudio/rstudio/commit/51923c4861c252cce7413be82e7dd0e5a048c03a</commit_link><file_path>src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/AceEditor.java</file_path><description>Extract Method public syncCompletionPrefs() : void extracted from private updateLanguage(suppressCompletion boolean) : void in class org.rstudio.studio.client.workbench.views.source.editors.text.AceEditor</description><code_before>@@ -454,9 +454,6 @@ private void updateLanguage(boolean suppressCompletion)
    {
       if (fileType_ == null)
          return;
-
-      // turn off any ace completion that's already installed
-      widget_.getEditor().setCompletionOptions(false, false, false);
       
       CompletionManager completionManager;
       if (!suppressCompletion)
@@ -485,16 +482,6 @@ private void updateLanguage(boolean suppressCompletion)
                                                      completionManager);
             }
          }
-         else if (fileType_.getEditorLanguage().useAceLanguageTools())
-         {
-            // no RStudio completion manager
-            completionManager = new NullCompletionManager();
-            
-            // enable ace native completion
-            boolean live = uiPrefs_.codeCompleteWeb().getValue().equals(
-                                          UIPrefsAccessor.COMPLETION_ALWAYS);
-            widget_.getEditor().setCompletionOptions(true, false, live);
-         }
          else
             completionManager = new NullCompletionManager();
       }
@@ -513,7 +500,9 @@ private void updateLanguage(CompletionManager completionManager)
       
       updateKeyboardHandlers();
       
-      syncUseWorker();
       
       getSession().setEditorMode(
             fileType_.getEditorLanguage().getParserName(),
@@ -523,7 +512,19 @@ private void updateLanguage(CompletionManager completionManager)
    } 
    
    @Override
-   public void syncUseWorker()
    {
       if (fileType_ == null)
          return;
</code_before><code_after>@@ -454,9 +454,6 @@ private void updateLanguage(boolean suppressCompletion)
    {
       if (fileType_ == null)
          return;
       
       CompletionManager completionManager;
       if (!suppressCompletion)
@@ -485,16 +482,6 @@ private void updateLanguage(boolean suppressCompletion)
                                                      completionManager);
             }
          }
          else
             completionManager = new NullCompletionManager();
       }
@@ -513,7 +500,9 @@ private void updateLanguage(CompletionManager completionManager)
       
       updateKeyboardHandlers();
       
+      syncCompletionPrefs();
+      
+      syncDiagnosticsPrefs();
       
       getSession().setEditorMode(
             fileType_.getEditorLanguage().getParserName(),
@@ -523,7 +512,19 @@ private void updateLanguage(CompletionManager completionManager)
    } 
    
    @Override
+   public void syncCompletionPrefs()
+   {
+      if (fileType_ == null)
+         return;
+      
+      boolean enabled = fileType_.getEditorLanguage().useAceLanguageTools();
+      boolean live = uiPrefs_.codeCompleteWeb().getValue().equals(
+                                       UIPrefsAccessor.COMPLETION_ALWAYS);
+      widget_.getEditor().setCompletionOptions(enabled, false, live);
+   }
+   
+   @Override
+   public void syncDiagnosticsPrefs()
    {
       if (fileType_ == null)
          return;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>64379</refactoring_id><commit_sha>52abc304a7b6895a6d867affd45c618fd45d5515</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/52abc304a7b6895a6d867affd45c618fd45d5515</commit_link><file_path>commons-server/src/test/java/com/navercorp/pinpoint/common/server/bo/serializer/stat/AgentStatHbaseOperationFactoryTest.java</file_path><description>Extract Method private assertPut(put Put, expectedBaseTimestamp long) : void extracted from public create_should_create_two_puts_if_dataPoints_span_over_a_timespan() : void in class com.navercorp.pinpoint.common.server.bo.serializer.stat.AgentStatHbaseOperationFactoryTest</description><code_before>@@ -36,7 +36,10 @@
 import java.util.TreeSet;
 
 import static com.navercorp.pinpoint.common.hbase.HbaseColumnFamily.AGENT_STAT_STATISTICS;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
 /**
  * @author HyunGil Jeong
@@ -84,11 +87,9 @@ public void create_should_create_one_put_if_there_is_only_one_dataPoint() {
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
-        assertEquals(1, puts.size());
         Put put = puts.get(0);
-        assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(put.getRow()));
-        assertEquals(TEST_AGENT_STAT_TYPE, this.agentStatHbaseOperationFactory.getAgentStatType(put.getRow()));
-        assertEquals(expectedBaseTimestamp, this.agentStatHbaseOperationFactory.getBaseTimestamp(put.getRow()));
     }
 
     @Test
@@ -101,11 +102,9 @@ public void create_should_create_one_put_if_dataPoints_fit_into_a_single_slot()
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
-        assertEquals(1, puts.size());
         Put put = puts.get(0);
-        assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(put.getRow()));
-        assertEquals(TEST_AGENT_STAT_TYPE, this.agentStatHbaseOperationFactory.getAgentStatType(put.getRow()));
-        assertEquals(expectedBaseTimestamp, this.agentStatHbaseOperationFactory.getBaseTimestamp(put.getRow()));
     }
 
     @Test
@@ -119,15 +118,17 @@ public void create_should_create_two_puts_if_dataPoints_span_over_a_timespan() {
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
-        assertEquals(2, puts.size());
         Put firstPut = puts.get(0);
-        assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(firstPut.getRow()));
-        assertEquals(TEST_AGENT_STAT_TYPE, this.agentStatHbaseOperationFactory.getAgentStatType(firstPut.getRow()));
-        assertEquals(expectedBaseTimestamp1, this.agentStatHbaseOperationFactory.getBaseTimestamp(firstPut.getRow()));
         Put secondPut = puts.get(1);
-        assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(secondPut.getRow()));
-        assertEquals(TEST_AGENT_STAT_TYPE, this.agentStatHbaseOperationFactory.getAgentStatType(secondPut.getRow()));
-        assertEquals(expectedBaseTimestamp2, this.agentStatHbaseOperationFactory.getBaseTimestamp(secondPut.getRow()));
     }
 
     @Test
@@ -140,7 +141,7 @@ public void create_should_create_the_same_number_of_puts_as_dataPoints_if_collec
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
-        assertEquals(numDataPoints, puts.size());
         for (int i = 0; i &lt; puts.size(); i++) {
             Put put = puts.get(i);
             assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(put.getRow()));
@@ -163,14 +164,12 @@ public void test_using_current_timestamp() {
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
-        assertEquals(uniqueTimeslots.size(), puts.size());
         int i = 0;
         for (Long timeslot : uniqueTimeslots) {
             long expectedBaseTimestamp = timeslot;
             Put put = puts.get(i++);
-            assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(put.getRow()));
-            assertEquals(TEST_AGENT_STAT_TYPE, this.agentStatHbaseOperationFactory.getAgentStatType(put.getRow()));
-            assertEquals(expectedBaseTimestamp, this.agentStatHbaseOperationFactory.getBaseTimestamp(put.getRow()));
         }
     }
 
@@ -188,45 +187,12 @@ private List&lt;AgentStatDataPoint&gt; createTestDataPoints(long initialTimestamp, lon
     private AgentStatDataPoint createTestDataPoint(final long testTimestamp) {
         final String testAgentId = "testAgentId";
         final long testStartTimestamp = 0L;
-        return new AgentStatDataPoint() {
-            private String agentId = testAgentId;
-            private long startTimestamp = testStartTimestamp;
-            private long timestamp = testTimestamp;
-
-            @Override
-            public String getAgentId() {
-                return this.agentId;
-            }
-
-            @Override
-            public void setAgentId(String agentId) {
-                this.agentId = agentId;
-            }
-
-            @Override
-            public long getStartTimestamp() {
-                return startTimestamp;
-            }
-
-            @Override
-            public void setStartTimestamp(long startTimestamp) {
-                this.startTimestamp = startTimestamp;
-            }
-
-            @Override
-            public long getTimestamp() {
-                return this.timestamp;
-            }
-
-            @Override
-            public void setTimestamp(long timestamp) {
-                this.timestamp = timestamp;
-            }
-
-            @Override
-            public AgentStatType getAgentStatType() {
-                return AgentStatType.UNKNOWN;
-            }
-        };
     }
 }
</code_before><code_after>@@ -36,7 +36,10 @@
 import java.util.TreeSet;
 
 import static com.navercorp.pinpoint.common.hbase.HbaseColumnFamily.AGENT_STAT_STATISTICS;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 /**
  * @author HyunGil Jeong
@@ -84,11 +87,9 @@ public void create_should_create_one_put_if_there_is_only_one_dataPoint() {
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
+        assertThat(puts).hasSize(1);
         Put put = puts.get(0);
+        assertPut(put, expectedBaseTimestamp);
     }
 
     @Test
@@ -101,11 +102,9 @@ public void create_should_create_one_put_if_dataPoints_fit_into_a_single_slot()
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
+        assertThat(puts).hasSize(1);
         Put put = puts.get(0);
+        assertPut(put, expectedBaseTimestamp);
     }
 
     @Test
@@ -119,15 +118,17 @@ public void create_should_create_two_puts_if_dataPoints_span_over_a_timespan() {
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
+        assertThat(puts).hasSize(2);
         Put firstPut = puts.get(0);
+        assertPut(firstPut, expectedBaseTimestamp1);
         Put secondPut = puts.get(1);
+        assertPut(secondPut, expectedBaseTimestamp2);
+    }
+
+    private void assertPut(Put put, long expectedBaseTimestamp) {
+        assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(put.getRow()));
+        assertEquals(TEST_AGENT_STAT_TYPE, this.agentStatHbaseOperationFactory.getAgentStatType(put.getRow()));
+        assertEquals(expectedBaseTimestamp, this.agentStatHbaseOperationFactory.getBaseTimestamp(put.getRow()));
     }
 
     @Test
@@ -140,7 +141,7 @@ public void create_should_create_the_same_number_of_puts_as_dataPoints_if_collec
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
+        assertThat(puts).hasSize(numDataPoints);
         for (int i = 0; i &lt; puts.size(); i++) {
             Put put = puts.get(i);
             assertEquals(TEST_AGENT_ID, this.agentStatHbaseOperationFactory.getAgentId(put.getRow()));
@@ -163,14 +164,12 @@ public void test_using_current_timestamp() {
         // When
         List&lt;Put&gt; puts = this.agentStatHbaseOperationFactory.createPuts(TEST_AGENT_ID, TEST_AGENT_STAT_TYPE, testDataPoints, this.mockSerializer);
         // Then
+        assertThat(puts).hasSameSizeAs(uniqueTimeslots);
         int i = 0;
         for (Long timeslot : uniqueTimeslots) {
             long expectedBaseTimestamp = timeslot;
             Put put = puts.get(i++);
+            assertPut(put, expectedBaseTimestamp);
         }
     }
 
@@ -188,45 +187,12 @@ private List&lt;AgentStatDataPoint&gt; createTestDataPoints(long initialTimestamp, lon
     private AgentStatDataPoint createTestDataPoint(final long testTimestamp) {
         final String testAgentId = "testAgentId";
         final long testStartTimestamp = 0L;
+
+        AgentStatDataPoint mock = mock(AgentStatDataPoint.class);
+        when(mock.getAgentId()).thenReturn(testAgentId);
+        when(mock.getStartTimestamp()).thenReturn(testStartTimestamp);
+        when(mock.getTimestamp()).thenReturn(testTimestamp);
+        when(mock.getAgentStatType()).thenReturn(AgentStatType.UNKNOWN);
+        return mock;
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>99773</refactoring_id><commit_sha>4836e525c851640e0da9d8d11321621a2c70e8f0</commit_sha><commit_link>https://github.com/AutoMQ/automq/commit/4836e525c851640e0da9d8d11321621a2c70e8f0</commit_link><file_path>streams/src/main/java/org/apache/kafka/streams/processor/TopologyBuilder.java</file_path><description>Extract Method public addSink(name String, topic String, keySerializer Serializer&lt;K&gt;, valSerializer Serializer&lt;V&gt;, partitioner StreamPartitioner&lt;K,V&gt;, parentNames String...) : TopologyBuilder extracted from public addSink(name String, topic String, keySerializer Serializer, valSerializer Serializer, parentNames String...) : TopologyBuilder in class org.apache.kafka.streams.processor.TopologyBuilder</description><code_before>@@ -132,19 +132,21 @@ private static class SinkNodeFactory extends NodeFactory {
         public final String topic;
         private Serializer keySerializer;
         private Serializer valSerializer;
 
-        private SinkNodeFactory(String name, String[] parents, String topic, Serializer keySerializer, Serializer valSerializer) {
             super(name);
             this.parents = parents.clone();
             this.topic = topic;
             this.keySerializer = keySerializer;
             this.valSerializer = valSerializer;
         }
 
         @SuppressWarnings("unchecked")
         @Override
         public ProcessorNode build() {
-            return new SinkNode(name, topic, keySerializer, valSerializer);
         }
     }
 
@@ -235,15 +237,53 @@ public final TopologyBuilder addSource(String name, Deserializer keyDeserializer
      *
      * @param name the unique name of the sink
      * @param topic the name of the Kafka topic to which this sink should write its messages
      * @return this builder instance so methods can be chained together; never null
      */
     public final TopologyBuilder addSink(String name, String topic, String... parentNames) {
         return addSink(name, topic, (Serializer) null, (Serializer) null, parentNames);
     }
 
     /**
      * Add a new sink that forwards messages from upstream parent processor and/or source nodes to the named Kafka topic.
      * The sink will use the specified key and value serializers.
      *
      * @param name the unique name of the sink
      * @param topic the name of the Kafka topic to which this sink should write its messages
@@ -256,8 +296,35 @@ public final TopologyBuilder addSink(String name, String topic, String... parent
      * @param parentNames the name of one or more source or processor nodes whose output message this sink should consume
      * and write to its topic
      * @return this builder instance so methods can be chained together; never null
      */
     public final TopologyBuilder addSink(String name, String topic, Serializer keySerializer, Serializer valSerializer, String... parentNames) {
         if (nodeFactories.containsKey(name))
             throw new TopologyException("Processor " + name + " is already added.");
 
@@ -272,7 +339,7 @@ public final TopologyBuilder addSink(String name, String topic, Serializer keySe
             }
         }
 
-        nodeFactories.put(name, new SinkNodeFactory(name, parentNames, topic, keySerializer, valSerializer));
         nodeGrouper.add(name);
         nodeGrouper.unite(name, parentNames);
         return this;
</code_before><code_after>@@ -132,19 +132,21 @@ private static class SinkNodeFactory extends NodeFactory {
         public final String topic;
         private Serializer keySerializer;
         private Serializer valSerializer;
+        private final StreamPartitioner partitioner;
 
+        private SinkNodeFactory(String name, String[] parents, String topic, Serializer keySerializer, Serializer valSerializer, StreamPartitioner partitioner) {
             super(name);
             this.parents = parents.clone();
             this.topic = topic;
             this.keySerializer = keySerializer;
             this.valSerializer = valSerializer;
+            this.partitioner = partitioner;
         }
 
         @SuppressWarnings("unchecked")
         @Override
         public ProcessorNode build() {
+            return new SinkNode(name, topic, keySerializer, valSerializer, partitioner);
         }
     }
 
@@ -235,15 +237,53 @@ public final TopologyBuilder addSource(String name, Deserializer keyDeserializer
      *
      * @param name the unique name of the sink
      * @param topic the name of the Kafka topic to which this sink should write its messages
+     * @param parentNames the name of one or more source or processor nodes whose output message this sink should consume
+     * and write to its topic
      * @return this builder instance so methods can be chained together; never null
+     * @see #addSink(String, String, StreamPartitioner, String...)
+     * @see #addSink(String, String, Serializer, Serializer, String...)
+     * @see #addSink(String, String, Serializer, Serializer, StreamPartitioner, String...)
      */
     public final TopologyBuilder addSink(String name, String topic, String... parentNames) {
         return addSink(name, topic, (Serializer) null, (Serializer) null, parentNames);
     }
 
+    /**
+     * Add a new sink that forwards messages from upstream parent processor and/or source nodes to the named Kafka topic, using
+     * the supplied partitioner.
+     * The sink will use the {@link StreamingConfig#KEY_SERIALIZER_CLASS_CONFIG default key serializer} and
+     * {@link StreamingConfig#VALUE_SERIALIZER_CLASS_CONFIG default value serializer} specified in the
+     * {@link StreamingConfig streaming configuration}.
+     * &lt;p&gt;
+     * The sink will also use the specified {@link StreamPartitioner} to determine how messages are distributed among
+     * the named Kafka topic's partitions. Such control is often useful with topologies that use
+     * {@link #addStateStore(StateStoreSupplier, String...) state stores}
+     * in its processors. In most other cases, however, a partitioner need not be specified and Kafka will automatically distribute
+     * messages among partitions using Kafka's default partitioning logic.
+     *
+     * @param name the unique name of the sink
+     * @param topic the name of the Kafka topic to which this sink should write its messages
+     * @param partitioner the function that should be used to determine the partition for each message processed by the sink
+     * @param parentNames the name of one or more source or processor nodes whose output message this sink should consume
+     * and write to its topic
+     * @return this builder instance so methods can be chained together; never null
+     * @see #addSink(String, String, String...)
+     * @see #addSink(String, String, Serializer, Serializer, String...)
+     * @see #addSink(String, String, Serializer, Serializer, StreamPartitioner, String...)
+     */
+    public final TopologyBuilder addSink(String name, String topic, StreamPartitioner partitioner, String... parentNames) {
+        return addSink(name, topic, (Serializer) null, (Serializer) null, partitioner, parentNames);
+    }
+
     /**
      * Add a new sink that forwards messages from upstream parent processor and/or source nodes to the named Kafka topic.
      * The sink will use the specified key and value serializers.
+     * &lt;p&gt;
+     * The sink will also use the specified {@link StreamPartitioner} to determine how messages are distributed among
+     * the named Kafka topic's partitions. Such control is often useful with topologies that use
+     * {@link #addStateStore(StateStoreSupplier, String...) state stores}
+     * in its processors. In most other cases, however, a partitioner need not be specified and Kafka will automatically distribute
+     * messages among partitions using Kafka's default partitioning logic.
      *
      * @param name the unique name of the sink
      * @param topic the name of the Kafka topic to which this sink should write its messages
@@ -256,8 +296,35 @@ public final TopologyBuilder addSink(String name, String topic, String... parent
      * @param parentNames the name of one or more source or processor nodes whose output message this sink should consume
      * and write to its topic
      * @return this builder instance so methods can be chained together; never null
+     * @see #addSink(String, String, String...)
+     * @see #addSink(String, String, StreamPartitioner, String...)
+     * @see #addSink(String, String, Serializer, Serializer, StreamPartitioner, String...)
      */
     public final TopologyBuilder addSink(String name, String topic, Serializer keySerializer, Serializer valSerializer, String... parentNames) {
+        return addSink(name, topic, keySerializer, valSerializer, (StreamPartitioner) null, parentNames);
+    }
+
+    /**
+     * Add a new sink that forwards messages from upstream parent processor and/or source nodes to the named Kafka topic.
+     * The sink will use the specified key and value serializers, and the supplied partitioner.
+     *
+     * @param name the unique name of the sink
+     * @param topic the name of the Kafka topic to which this sink should write its messages
+     * @param keySerializer the {@link Serializer key serializer} used when consuming messages; may be null if the sink
+     * should use the {@link StreamingConfig#KEY_SERIALIZER_CLASS_CONFIG default key serializer} specified in the
+     * {@link StreamingConfig streaming configuration}
+     * @param valSerializer the {@link Serializer value serializer} used when consuming messages; may be null if the sink
+     * should use the {@link StreamingConfig#VALUE_SERIALIZER_CLASS_CONFIG default value serializer} specified in the
+     * {@link StreamingConfig streaming configuration}
+     * @param partitioner the function that should be used to determine the partition for each message processed by the sink
+     * @param parentNames the name of one or more source or processor nodes whose output message this sink should consume
+     * and write to its topic
+     * @return this builder instance so methods can be chained together; never null
+     * @see #addSink(String, String, String...)
+     * @see #addSink(String, String, StreamPartitioner, String...)
+     * @see #addSink(String, String, Serializer, Serializer, String...)
+     */
+    public final &lt;K, V&gt; TopologyBuilder addSink(String name, String topic, Serializer&lt;K&gt; keySerializer, Serializer&lt;V&gt; valSerializer, StreamPartitioner&lt;K, V&gt; partitioner, String... parentNames) {
         if (nodeFactories.containsKey(name))
             throw new TopologyException("Processor " + name + " is already added.");
 
@@ -272,7 +339,7 @@ public final TopologyBuilder addSink(String name, String topic, Serializer keySe
             }
         }
 
+        nodeFactories.put(name, new SinkNodeFactory(name, parentNames, topic, keySerializer, valSerializer, partitioner));
         nodeGrouper.add(name);
         nodeGrouper.unite(name, parentNames);
         return this;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>113493</refactoring_id><commit_sha>fe5df06c727138ef02359aa3b23ef0e4b80a57df</commit_sha><commit_link>https://github.com/apache/flink/commit/fe5df06c727138ef02359aa3b23ef0e4b80a57df</commit_link><file_path>flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/ChangelogStateBackend.java</file_path><description>Extract Method private restore(env Environment, operatorIdentifier String, keyGroupRange KeyGroupRange, ttlTimeProvider TtlTimeProvider, stateHandles Collection&lt;KeyedStateHandle&gt;, baseBackendBuilder BaseBackendBuilder&lt;K&gt;) : ChangelogKeyedStateBackend&lt;K&gt; extracted from public createKeyedStateBackend(env Environment, jobID JobID, operatorIdentifier String, keySerializer TypeSerializer&lt;K&gt;, numberOfKeyGroups int, keyGroupRange KeyGroupRange, kvStateRegistry TaskKvStateRegistry, ttlTimeProvider TtlTimeProvider, metricGroup MetricGroup, stateHandles Collection&lt;KeyedStateHandle&gt;, cancelStreamRegistry CloseableRegistry, managedMemoryFraction double) : CheckpointableKeyedStateBackend&lt;K&gt; in class org.apache.flink.state.changelog.ChangelogStateBackend</description><code_before>@@ -39,6 +39,8 @@
 import org.apache.flink.runtime.state.changelog.inmemory.InMemoryStateChangelogStorage;
 import org.apache.flink.runtime.state.delegate.DelegatingStateBackend;
 import org.apache.flink.runtime.state.ttl.TtlTimeProvider;
 import org.apache.flink.util.Preconditions;
 
 import org.slf4j.Logger;
@@ -47,7 +49,6 @@
 import javax.annotation.Nonnull;
 
 import java.util.Collection;
-import java.util.Objects;
 import java.util.stream.Collectors;
 
 /**
@@ -96,28 +97,26 @@ public &lt;K&gt; ChangelogKeyedStateBackend&lt;K&gt; createKeyedStateBackend(
             @Nonnull Collection&lt;KeyedStateHandle&gt; stateHandles,
             CloseableRegistry cancelStreamRegistry)
             throws Exception {
-        AbstractKeyedStateBackend&lt;K&gt; keyedStateBackend =
-                (AbstractKeyedStateBackend&lt;K&gt;)
-                        delegatedStateBackend.createKeyedStateBackend(
-                                env,
-                                jobID,
-                                operatorIdentifier,
-                                keySerializer,
-                                numberOfKeyGroups,
-                                keyGroupRange,
-                                kvStateRegistry,
-                                ttlTimeProvider,
-                                metricGroup,
-                                extractMaterializedState(stateHandles),
-                                cancelStreamRegistry);
-        // todo: FLINK-21804 get from Environment.getTaskStateManager
-        InMemoryStateChangelogStorage changelogWriterFactory = new InMemoryStateChangelogStorage();
-        // todo: apply state changes from non-materialized part of stateHandles
-        return new ChangelogKeyedStateBackend&lt;&gt;(
-                keyedStateBackend,
-                env.getExecutionConfig(),
                 ttlTimeProvider,
-                changelogWriterFactory.createWriter(operatorIdentifier, keyGroupRange));
     }
 
     @Override
@@ -135,31 +134,27 @@ public &lt;K&gt; CheckpointableKeyedStateBackend&lt;K&gt; createKeyedStateBackend(
             CloseableRegistry cancelStreamRegistry,
             double managedMemoryFraction)
             throws Exception {
-
-        AbstractKeyedStateBackend&lt;K&gt; keyedStateBackend =
-                (AbstractKeyedStateBackend&lt;K&gt;)
-                        delegatedStateBackend.createKeyedStateBackend(
-                                env,
-                                jobID,
-                                operatorIdentifier,
-                                keySerializer,
-                                numberOfKeyGroups,
-                                keyGroupRange,
-                                kvStateRegistry,
-                                ttlTimeProvider,
-                                metricGroup,
-                                extractMaterializedState(stateHandles),
-                                cancelStreamRegistry,
-                                managedMemoryFraction);
-
-        // todo: FLINK-21804 get from Environment.getTaskStateManager
-        InMemoryStateChangelogStorage changelogWriterFactory = new InMemoryStateChangelogStorage();
-        // todo: apply state changes from non-materialized part of stateHandles
-        return new ChangelogKeyedStateBackend&lt;&gt;(
-                keyedStateBackend,
-                env.getExecutionConfig(),
                 ttlTimeProvider,
-                changelogWriterFactory.createWriter(operatorIdentifier, keyGroupRange));
     }
 
     @Override
@@ -196,15 +191,35 @@ public StateBackend configure(ReadableConfig config, ClassLoader classLoader)
         return this;
     }
 
-    private static Collection&lt;KeyedStateHandle&gt; extractMaterializedState(
             Collection&lt;KeyedStateHandle&gt; stateHandles) {
         return stateHandles.stream()
-                .flatMap(
-                        keyedStateHandle -&gt;
-                                ((ChangelogStateBackendHandle.ChangelogStateBackendHandleImpl)
-                                                keyedStateHandle)
-                                        .getMaterializedStateHandles().stream())
-                .filter(Objects::nonNull)
                 .collect(Collectors.toList());
     }
 }
</code_before><code_after>@@ -39,6 +39,8 @@
 import org.apache.flink.runtime.state.changelog.inmemory.InMemoryStateChangelogStorage;
 import org.apache.flink.runtime.state.delegate.DelegatingStateBackend;
 import org.apache.flink.runtime.state.ttl.TtlTimeProvider;
+import org.apache.flink.state.changelog.restore.ChangelogBackendRestoreOperation;
+import org.apache.flink.state.changelog.restore.ChangelogBackendRestoreOperation.BaseBackendBuilder;
 import org.apache.flink.util.Preconditions;
 
 import org.slf4j.Logger;
@@ -47,7 +49,6 @@
 import javax.annotation.Nonnull;
 
 import java.util.Collection;
 import java.util.stream.Collectors;
 
 /**
@@ -96,28 +97,26 @@ public &lt;K&gt; ChangelogKeyedStateBackend&lt;K&gt; createKeyedStateBackend(
             @Nonnull Collection&lt;KeyedStateHandle&gt; stateHandles,
             CloseableRegistry cancelStreamRegistry)
             throws Exception {
+        return restore(
+                env,
+                operatorIdentifier,
+                keyGroupRange,
                 ttlTimeProvider,
+                stateHandles,
+                baseHandles -&gt;
+                        (AbstractKeyedStateBackend&lt;K&gt;)
+                                delegatedStateBackend.createKeyedStateBackend(
+                                        env,
+                                        jobID,
+                                        operatorIdentifier,
+                                        keySerializer,
+                                        numberOfKeyGroups,
+                                        keyGroupRange,
+                                        kvStateRegistry,
+                                        ttlTimeProvider,
+                                        metricGroup,
+                                        baseHandles,
+                                        cancelStreamRegistry));
     }
 
     @Override
@@ -135,31 +134,27 @@ public &lt;K&gt; CheckpointableKeyedStateBackend&lt;K&gt; createKeyedStateBackend(
             CloseableRegistry cancelStreamRegistry,
             double managedMemoryFraction)
             throws Exception {
+        return restore(
+                env,
+                operatorIdentifier,
+                keyGroupRange,
                 ttlTimeProvider,
+                stateHandles,
+                baseHandles -&gt;
+                        (AbstractKeyedStateBackend&lt;K&gt;)
+                                delegatedStateBackend.createKeyedStateBackend(
+                                        env,
+                                        jobID,
+                                        operatorIdentifier,
+                                        keySerializer,
+                                        numberOfKeyGroups,
+                                        keyGroupRange,
+                                        kvStateRegistry,
+                                        ttlTimeProvider,
+                                        metricGroup,
+                                        baseHandles,
+                                        cancelStreamRegistry,
+                                        managedMemoryFraction));
     }
 
     @Override
@@ -196,15 +191,35 @@ public StateBackend configure(ReadableConfig config, ClassLoader classLoader)
         return this;
     }
 
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    private &lt;K&gt; ChangelogKeyedStateBackend&lt;K&gt; restore(
+            Environment env,
+            String operatorIdentifier,
+            KeyGroupRange keyGroupRange,
+            TtlTimeProvider ttlTimeProvider,
+            Collection&lt;KeyedStateHandle&gt; stateHandles,
+            BaseBackendBuilder&lt;K&gt; baseBackendBuilder)
+            throws Exception {
+        // todo: FLINK-21804 get from Environment.getTaskStateManager
+        InMemoryStateChangelogStorage changelogStorage = new InMemoryStateChangelogStorage();
+        return ChangelogBackendRestoreOperation.restore(
+                changelogStorage.createReader(),
+                env.getUserCodeClassLoader().asClassLoader(),
+                castHandles(stateHandles),
+                baseBackendBuilder,
+                (baseBackend, baseState) -&gt;
+                        new ChangelogKeyedStateBackend(
+                                baseBackend,
+                                env.getExecutionConfig(),
+                                ttlTimeProvider,
+                                changelogStorage.createWriter(operatorIdentifier, keyGroupRange),
+                                baseState));
+    }
+
+    private Collection&lt;ChangelogStateBackendHandle&gt; castHandles(
             Collection&lt;KeyedStateHandle&gt; stateHandles) {
         return stateHandles.stream()
+                .map(keyedStateHandle -&gt; (ChangelogStateBackendHandle) keyedStateHandle)
                 .collect(Collectors.toList());
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>90703</refactoring_id><commit_sha>55edfe55f78a702d34c12b2258e2850f7ec8bc4d</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/55edfe55f78a702d34c12b2258e2850f7ec8bc4d</commit_link><file_path>src/com/android/launcher3/PagedView.java</file_path><description>Extract Method public getVisiblePageIndices() : IntSet extracted from public forEachVisiblePage(callback Consumer&lt;View&gt;) : void in class com.android.launcher3.PagedView</description><code_before>@@ -16,6 +16,7 @@
 
 package com.android.launcher3;
 
 import static com.android.launcher3.anim.Interpolators.SCROLL;
 import static com.android.launcher3.compat.AccessibilityManagerCompat.isAccessibilityEnabled;
 import static com.android.launcher3.compat.AccessibilityManagerCompat.isObservedEventType;
@@ -48,13 +49,15 @@
 import android.widget.ScrollView;
 
 import androidx.annotation.Nullable;
 
 import com.android.launcher3.compat.AccessibilityManagerCompat;
 import com.android.launcher3.config.FeatureFlags;
 import com.android.launcher3.pageindicators.PageIndicator;
 import com.android.launcher3.touch.PagedOrientationHandler;
 import com.android.launcher3.touch.PagedOrientationHandler.ChildBounds;
 import com.android.launcher3.util.EdgeEffectCompat;
 import com.android.launcher3.util.Thunk;
 import com.android.launcher3.views.ActivityContext;
 
@@ -282,9 +285,15 @@ private int validateNewPage(int newPage) {
         return newPage;
     }
 
-    private int getLeftmostVisiblePageForIndex(int pageIndex) {
         int panelCount = getPanelCount();
-        return (pageIndex / panelCount) * panelCount;
     }
 
     /**
@@ -294,17 +303,35 @@ protected int getPanelCount() {
         return 1;
     }
 
     /**
      * Executes the callback against each visible page
      */
     public void forEachVisiblePage(Consumer&lt;View&gt; callback) {
-        int panelCount = getPanelCount();
-        for (int i = mCurrentPage; i &lt; mCurrentPage + panelCount; i++) {
-            View page = getPageAt(i);
             if (page != null) {
                 callback.accept(page);
             }
-        }
     }
 
     /**
</code_before><code_after>@@ -16,6 +16,7 @@
 
 package com.android.launcher3;
 
+import static androidx.annotation.VisibleForTesting.PACKAGE_PRIVATE;
 import static com.android.launcher3.anim.Interpolators.SCROLL;
 import static com.android.launcher3.compat.AccessibilityManagerCompat.isAccessibilityEnabled;
 import static com.android.launcher3.compat.AccessibilityManagerCompat.isObservedEventType;
@@ -48,13 +49,15 @@
 import android.widget.ScrollView;
 
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 
 import com.android.launcher3.compat.AccessibilityManagerCompat;
 import com.android.launcher3.config.FeatureFlags;
 import com.android.launcher3.pageindicators.PageIndicator;
 import com.android.launcher3.touch.PagedOrientationHandler;
 import com.android.launcher3.touch.PagedOrientationHandler.ChildBounds;
 import com.android.launcher3.util.EdgeEffectCompat;
+import com.android.launcher3.util.IntSet;
 import com.android.launcher3.util.Thunk;
 import com.android.launcher3.views.ActivityContext;
 
@@ -282,9 +285,15 @@ private int validateNewPage(int newPage) {
         return newPage;
     }
 
+    /**
+     * In most cases where panelCount is 1, this method will just return the page index that was
+     * passed in.
+     * But for example when two panel home is enabled we might need the leftmost visible page index
+     * because that page is the current page.
+     */
+    public int getLeftmostVisiblePageForIndex(int pageIndex) {
         int panelCount = getPanelCount();
+        return pageIndex - pageIndex % panelCount;
     }
 
     /**
@@ -294,17 +303,35 @@ protected int getPanelCount() {
         return 1;
     }
 
+    /**
+     * Returns an IntSet with the indices of the currently visible pages
+     */
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    public IntSet getVisiblePageIndices() {
+        IntSet visiblePageIndices = new IntSet();
+        int panelCount = getPanelCount();
+        int pageCount = getPageCount();
+
+        // If a device goes from one panel to two panel (i.e. unfolding a foldable device) while
+        // an odd indexed page is the current page, then the new leftmost visible page will be
+        // different from the old mCurrentPage.
+        int currentPage = getLeftmostVisiblePageForIndex(mCurrentPage);
+        for (int page = currentPage; page &lt; currentPage + panelCount &amp;&amp; page &lt; pageCount; page++) {
+            visiblePageIndices.add(page);
+        }
+        return visiblePageIndices;
+    }
+
     /**
      * Executes the callback against each visible page
      */
     public void forEachVisiblePage(Consumer&lt;View&gt; callback) {
+        getVisiblePageIndices().forEach(pageIndex -&gt; {
+            View page = getPageAt(pageIndex);
             if (page != null) {
                 callback.accept(page);
             }
+        });
     }
 
     /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>93328</refactoring_id><commit_sha>cfaf9f8a4013757266d1693c11a8e54e8228defc</commit_sha><commit_link>https://github.com/broadleafcommerce/broadleafcommerce/commit/cfaf9f8a4013757266d1693c11a8e54e8228defc</commit_link><file_path>BroadleafCommerce/src-framework/org/broadleafcommerce/payment/service/CompositePaymentServiceImpl.java</file_path><description>Extract Method public executePayment(order Order, payments Map&lt;PaymentInfo,Referenced&gt;, response PaymentResponse) : CompositePaymentResponse extracted from public executePayment(order Order, payments Map&lt;PaymentInfo,Referenced&gt;) : void in class org.broadleafcommerce.payment.service.CompositePaymentServiceImpl</description><code_before>@@ -8,6 +8,9 @@
 import org.broadleafcommerce.order.domain.PaymentInfo;
 import org.broadleafcommerce.payment.domain.Referenced;
 import org.broadleafcommerce.payment.service.exception.PaymentException;
 import org.broadleafcommerce.payment.service.workflow.PaymentSeed;
 import org.broadleafcommerce.workflow.SequenceProcessor;
 import org.broadleafcommerce.workflow.WorkflowException;
@@ -26,21 +29,35 @@ public class CompositePaymentServiceImpl implements CompositePaymentService {
     SequenceProcessor paymentWorkflow;
 
     @Override
-    public void executePayment(Order order, Map&lt;PaymentInfo, Referenced&gt; payments) throws PaymentException {
         /*
          * TODO add validation that checks the order and payment information for validity.
          */
         try {
-            PaymentSeed seed = new PaymentSeed(order, payments);
             paymentWorkflow.doActivities(seed);
         } catch (WorkflowException e) {
             throw new PaymentException("Unable to execute payment for order -- id: " + order.getId(), e);
         }
     }
 
     @Override
-    public void executePayment(Order order) throws PaymentException {
-        executePayment(order, null);
     }
 
 }
</code_before><code_after>@@ -8,6 +8,9 @@
 import org.broadleafcommerce.order.domain.PaymentInfo;
 import org.broadleafcommerce.payment.domain.Referenced;
 import org.broadleafcommerce.payment.service.exception.PaymentException;
+import org.broadleafcommerce.payment.service.module.PaymentResponse;
+import org.broadleafcommerce.payment.service.module.PaymentResponseImpl;
+import org.broadleafcommerce.payment.service.workflow.CompositePaymentResponse;
 import org.broadleafcommerce.payment.service.workflow.PaymentSeed;
 import org.broadleafcommerce.workflow.SequenceProcessor;
 import org.broadleafcommerce.workflow.WorkflowException;
@@ -26,21 +29,35 @@ public class CompositePaymentServiceImpl implements CompositePaymentService {
     SequenceProcessor paymentWorkflow;
 
     @Override
+    public CompositePaymentResponse executePayment(Order order, Map&lt;PaymentInfo, Referenced&gt; payments, PaymentResponse response) throws PaymentException {
         /*
          * TODO add validation that checks the order and payment information for validity.
          */
         try {
+            PaymentSeed seed = new PaymentSeed(order, payments, response);
             paymentWorkflow.doActivities(seed);
+
+            return seed;
         } catch (WorkflowException e) {
+            Throwable cause = null;
+            while(e.getCause() != null) {
+                cause = e.getCause();
+            }
+            if (cause != null &amp;&amp; PaymentException.class.isAssignableFrom(cause.getClass())) {
+                throw (PaymentException) cause;
+            }
             throw new PaymentException("Unable to execute payment for order -- id: " + order.getId(), e);
         }
     }
 
     @Override
+    public CompositePaymentResponse executePayment(Order order, Map&lt;PaymentInfo, Referenced&gt; payments) throws PaymentException {
+        return executePayment(order, payments, new PaymentResponseImpl());
+    }
+
+    @Override
+    public CompositePaymentResponse executePayment(Order order) throws PaymentException {
+        return executePayment(order, null);
     }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>93859</refactoring_id><commit_sha>b7f4a1521bb68baa0d347ba05d0da73dba1e5f07</commit_sha><commit_link>https://github.com/yacy/yacy_search_server/commit/b7f4a1521bb68baa0d347ba05d0da73dba1e5f07</commit_link><file_path>source/de/anomic/kelondro/kelondroFlexWidthArray.java</file_path><description>Extract Method public open(path File, tablename String, rowdef kelondroRow) : kelondroFlexWidthArray extracted from public main(args String[]) : void in class de.anomic.kelondro.kelondroFlexWidthArray</description><code_before>@@ -104,8 +104,41 @@ public kelondroFlexWidthArray(File path, String tablename, kelondroRow rowdef) t
         }
     }
     
     public void close() throws IOException {
-        for (int i = 0; i &lt; col.length; i++) if (col[i] != null) col[i].close();
     }
     
     protected static final String colfilename(int start, int end) {
@@ -222,9 +255,8 @@ public static void main(String[] args) {
         String testname = "flextest";
         try {
             System.out.println("erster Test");
-            new File(f, testname).delete();
-            
-            kelondroFlexWidthArray k = new kelondroFlexWidthArray(f, "flextest", rowdef);
             k.add(k.row().newEntry(new byte[][]{"a".getBytes(), "xxxx".getBytes()}));
             k.add(k.row().newEntry(new byte[][]{"b".getBytes(), "xxxx".getBytes()}));
             k.remove(0);
@@ -243,16 +275,22 @@ public static void main(String[] args) {
             
             
             System.out.println("zweiter Test");
-            new File(f, testname).delete();
-            k = new kelondroFlexWidthArray(f, "flextest", rowdef);
             for (int i = 1; i &lt;= 20; i = i * 2) {
                 for (int j = 0; j &lt; i*2; j++) {
                     k.add(k.row().newEntry(new byte[][]{(Integer.toString(i) + "-" + Integer.toString(j)).getBytes(), "xxxx".getBytes()}));
                 }
                 for (int j = 0; j &lt; i; j++) {
-                    k.remove(j);
                 }
             }
             k.print();
             k.col[0].print(true);
             k.close();
</code_before><code_after>@@ -104,8 +104,41 @@ public kelondroFlexWidthArray(File path, String tablename, kelondroRow rowdef) t
         }
     }
     
+    public static void delete(File path, String tablename) {
+        File tabledir = new File(path, tablename);
+        if ((tabledir.exists()) &amp;&amp; (!(tabledir.isDirectory()))) {
+            tabledir.delete();
+            return;
+        }
+
+        String[] files = tabledir.list();
+        for (int i = 0; i &lt; files.length; i++) {
+            new File(tabledir, files[i]).delete();
+        }
+        
+        tabledir.delete();
+    }
+    
+    public static kelondroFlexWidthArray open(File path, String tablename, kelondroRow rowdef) {
+        try {
+            return new kelondroFlexWidthArray(path, tablename, rowdef);
+        } catch (IOException e) {
+            kelondroFlexWidthArray.delete(path, tablename);
+            try {
+                return new kelondroFlexWidthArray(path, tablename, rowdef);
+            } catch (IOException ee) {
+                e.printStackTrace();
+                ee.printStackTrace();
+                System.exit(-1);
+                return null;
+            }
+        }
+    }
+    
     public void close() throws IOException {
+        synchronized (col) {
+            for (int i = 0; i &lt; col.length; i++) if (col[i] != null) col[i].close();
+        }
     }
     
     protected static final String colfilename(int start, int end) {
@@ -222,9 +255,8 @@ public static void main(String[] args) {
         String testname = "flextest";
         try {
             System.out.println("erster Test");
+            kelondroFlexWidthArray.delete(f, testname);
+            kelondroFlexWidthArray k = kelondroFlexWidthArray.open(f, "flextest", rowdef);
             k.add(k.row().newEntry(new byte[][]{"a".getBytes(), "xxxx".getBytes()}));
             k.add(k.row().newEntry(new byte[][]{"b".getBytes(), "xxxx".getBytes()}));
             k.remove(0);
@@ -243,16 +275,22 @@ public static void main(String[] args) {
             
             
             System.out.println("zweiter Test");
+            kelondroFlexWidthArray.delete(f, testname);
+            //k = kelondroFlexWidthArray.open(f, "flextest", rowdef);
             for (int i = 1; i &lt;= 20; i = i * 2) {
+                System.out.println("LOOP: " + i);
+                k = kelondroFlexWidthArray.open(f, "flextest", rowdef);
                 for (int j = 0; j &lt; i*2; j++) {
                     k.add(k.row().newEntry(new byte[][]{(Integer.toString(i) + "-" + Integer.toString(j)).getBytes(), "xxxx".getBytes()}));
                 }
+                k.close();
+                k = kelondroFlexWidthArray.open(f, "flextest", rowdef);
                 for (int j = 0; j &lt; i; j++) {
+                    k.remove(i*2 - j - 1);
                 }
+                k.close();
             }
+            k = kelondroFlexWidthArray.open(f, "flextest", rowdef);
             k.print();
             k.col[0].print(true);
             k.close();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>49508</refactoring_id><commit_sha>40c68d2964fe59743e8ab4ac54fc75a1810d2531</commit_sha><commit_link>https://github.com/opensolon/solon/commit/40c68d2964fe59743e8ab4ac54fc75a1810d2531</commit_link><file_path>_extend/solon.serialization.jackson/src/main/java/org/noear/solon/serialization/jackson/JacksonRender.java</file_path><description>Extract Method protected output(ctx Context, obj Object, txt String) : void extracted from public render(obj Object, ctx Context) : void in class org.noear.solon.serialization.StringSerializerRender</description><code_before>@@ -1,68 +0,0 @@
-package org.noear.solon.serialization.jackson;
-
-import com.fasterxml.jackson.annotation.JsonAutoDetect;
-import com.fasterxml.jackson.annotation.PropertyAccessor;
-import com.fasterxml.jackson.databind.DeserializationFeature;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.SerializationFeature;
-import org.noear.solon.core.handle.Context;
-import org.noear.solon.core.handle.Render;
-
-public class JacksonRender implements Render {
-    ObjectMapper mapper = new ObjectMapper();
-    ObjectMapper mapper_type = new ObjectMapper();
-
-    private boolean _typedJson;
-
-    public JacksonRender(boolean typedJson) {
-        _typedJson = typedJson;
-
-        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
-
-        mapper_type.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
-        mapper_type.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
-        mapper_type.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
-        mapper_type.activateDefaultTypingAsProperty(
-                mapper_type.getPolymorphicTypeValidator(),
-                ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, "@type");
-    }
-
-    @Override
-    public void render(Object obj, Context ctx) throws Throwable {
-        String txt = null;
-
-        if (_typedJson) {
-            //&#x5E8F;&#x5217;&#x5316;&#x5904;&#x7406;
-            //
-            txt = mapper_type.writeValueAsString(obj);
-        } else {
-            //&#x975E;&#x5E8F;&#x5217;&#x5316;&#x5904;&#x7406;
-            //
-            if (obj == null) {
-                return;
-            }
-
-            if (obj instanceof Throwable) {
-                throw (Throwable) obj;
-            }
-
-            if (obj instanceof String) {
-                txt = (String) obj;
-            }else {
-                txt = mapper.writeValueAsString(obj);
-            }
-        }
-
-        if (XPluginImp.output_meta) {
-            ctx.headerSet("solon.serialization", "JacksonRender");
-        }
-
-        ctx.attrSet("output", txt);
-
-        if (obj instanceof String &amp;&amp; ctx.accept().contains("/json") == false) {
-            ctx.output(txt);
-        } else {
-            ctx.outputAsJson(txt);
-        }
-    }
-}
</code_before><code_after>@@ -1,68 +0,0 @@
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>93099</refactoring_id><commit_sha>4d72f640e53ffe99c82f79ba8fac2b126c84553d</commit_sha><commit_link>https://github.com/broadleafcommerce/broadleafcommerce/commit/4d72f640e53ffe99c82f79ba8fac2b126c84553d</commit_link><file_path>integration/src/test/java/org/broadleafcommerce/core/offer/service/CreateOfferUtility.java</file_path><description>Extract Method public createOffer(offerName String, offerType OfferType, discountType OfferDiscountType, value double, orderRule String, stackable boolean, combinable boolean, priority int, qualifierRule String, adjustmentType OfferAdjustmentType) : Offer extracted from public createOffer(offerName String, offerType OfferType, discountType OfferDiscountType, value double, orderRule String, stackable boolean, combinable boolean, priority int, qualifierRule String) : Offer in class org.broadleafcommerce.core.offer.service.CreateOfferUtility</description><code_before>@@ -28,6 +28,7 @@
 import org.broadleafcommerce.core.offer.domain.OfferQualifyingCriteriaXrefImpl;
 import org.broadleafcommerce.core.offer.domain.OfferTargetCriteriaXref;
 import org.broadleafcommerce.core.offer.domain.OfferTargetCriteriaXrefImpl;
 import org.broadleafcommerce.core.offer.service.type.OfferDiscountType;
 import org.broadleafcommerce.core.offer.service.type.OfferItemRestrictionRuleType;
 import org.broadleafcommerce.core.offer.service.type.OfferType;
@@ -63,11 +64,31 @@ public OfferCode createOfferCode(String offerCodeName, String offerName, OfferTy
         return offerCode;
     }
 
     public Offer createOffer(String offerName, OfferType offerType, OfferDiscountType discountType, double value,
             String orderRule, boolean stackable, boolean combinable, int priority, String qualifierRule) {
         Offer offer = offerDao.create();
         offer.setName(offerName);
         offer.setStartDate(SystemTime.asDate());
         Calendar calendar = Calendar.getInstance();
         calendar.add(Calendar.DATE, -1);
         offer.setStartDate(calendar.getTime());
</code_before><code_after>@@ -28,6 +28,7 @@
 import org.broadleafcommerce.core.offer.domain.OfferQualifyingCriteriaXrefImpl;
 import org.broadleafcommerce.core.offer.domain.OfferTargetCriteriaXref;
 import org.broadleafcommerce.core.offer.domain.OfferTargetCriteriaXrefImpl;
+import org.broadleafcommerce.core.offer.service.type.OfferAdjustmentType;
 import org.broadleafcommerce.core.offer.service.type.OfferDiscountType;
 import org.broadleafcommerce.core.offer.service.type.OfferItemRestrictionRuleType;
 import org.broadleafcommerce.core.offer.service.type.OfferType;
@@ -63,11 +64,31 @@ public OfferCode createOfferCode(String offerCodeName, String offerName, OfferTy
         return offerCode;
     }
 
+    public OfferCode createOfferCode(String offerCodeName, String offerName, OfferType offerType, 
+                                     OfferDiscountType discountType, double value, String orderRule, boolean stackable, 
+                                     boolean combinable, int priority, String qualifierRule, OfferAdjustmentType adjustmentType) {
+        OfferCode offerCode = offerCodeDao.create();
+        Offer offer = createOffer(offerName, offerType, discountType, value, orderRule, stackable, combinable, priority, 
+                qualifierRule, adjustmentType);
+        offerCode.setOffer(offer);
+        offerCode.setOfferCode(offerCodeName);
+        offerCode = offerService.saveOfferCode(offerCode);
+        return offerCode;
+    }
+
     public Offer createOffer(String offerName, OfferType offerType, OfferDiscountType discountType, double value,
             String orderRule, boolean stackable, boolean combinable, int priority, String qualifierRule) {
+        return createOffer(offerName, offerType, discountType, value, orderRule, stackable, combinable, priority, 
+                qualifierRule, OfferAdjustmentType.ORDER_DISCOUNT);
+    }
+
+    public Offer createOffer(String offerName, OfferType offerType, OfferDiscountType discountType, double value,
+                             String orderRule, boolean stackable, boolean combinable, int priority, String qualifierRule,
+                             OfferAdjustmentType adjustmentType) {
         Offer offer = offerDao.create();
         offer.setName(offerName);
         offer.setStartDate(SystemTime.asDate());
+        offer.setAdjustmentType(adjustmentType);
         Calendar calendar = Calendar.getInstance();
         calendar.add(Calendar.DATE, -1);
         offer.setStartDate(calendar.getTime());
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>4185</refactoring_id><commit_sha>dacbe22d53326cd4729d485e8cbb054923f944ed</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/dacbe22d53326cd4729d485e8cbb054923f944ed</commit_link><file_path>server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java</file_path><description>Extract Method public toModel(scope ScopeRepresentation, resourceServer ResourceServer, authorization AuthorizationProvider, updateIfExists boolean) : Scope extracted from public toModel(scope ScopeRepresentation, resourceServer ResourceServer, authorization AuthorizationProvider) : Scope in class org.keycloak.models.utils.RepresentationToModel</description><code_before>@@ -2567,7 +2567,7 @@ public static Resource toModel(ResourceRepresentation resource, ResourceServer r
             existing.setIconUri(resource.getIconUri());
             existing.setOwnerManagedAccess(Boolean.TRUE.equals(resource.getOwnerManagedAccess()));
             existing.updateScopes(resource.getScopes().stream()
-                    .map((ScopeRepresentation scope) -&gt; toModel(scope, resourceServer, authorization))
                     .collect(Collectors.toSet()));
             Map&lt;String, List&lt;String&gt;&gt; attributes = resource.getAttributes();
 
@@ -2602,7 +2602,7 @@ public static Resource toModel(ResourceRepresentation resource, ResourceServer r
         Set&lt;ScopeRepresentation&gt; scopes = resource.getScopes();
 
         if (scopes != null) {
-            model.updateScopes(scopes.stream().map((Function&lt;ScopeRepresentation, Scope&gt;) scope -&gt; toModel(scope, resourceServer, authorization)).collect(Collectors.toSet()));
         }
 
         Map&lt;String, List&lt;String&gt;&gt; attributes = resource.getAttributes();
@@ -2619,6 +2619,10 @@ public static Resource toModel(ResourceRepresentation resource, ResourceServer r
     }
 
     public static Scope toModel(ScopeRepresentation scope, ResourceServer resourceServer, AuthorizationProvider authorization) {
         StoreFactory storeFactory = authorization.getStoreFactory();
         ScopeStore scopeStore = storeFactory.getScopeStore();
         Scope existing;
@@ -2630,9 +2634,11 @@ public static Scope toModel(ScopeRepresentation scope, ResourceServer resourceSe
         }
 
         if (existing != null) {
-            existing.setName(scope.getName());
-            existing.setDisplayName(scope.getDisplayName());
-            existing.setIconUri(scope.getIconUri());
             return existing;
         }
 
</code_before><code_after>@@ -2567,7 +2567,7 @@ public static Resource toModel(ResourceRepresentation resource, ResourceServer r
             existing.setIconUri(resource.getIconUri());
             existing.setOwnerManagedAccess(Boolean.TRUE.equals(resource.getOwnerManagedAccess()));
             existing.updateScopes(resource.getScopes().stream()
+                    .map((ScopeRepresentation scope) -&gt; toModel(scope, resourceServer, authorization, false))
                     .collect(Collectors.toSet()));
             Map&lt;String, List&lt;String&gt;&gt; attributes = resource.getAttributes();
 
@@ -2602,7 +2602,7 @@ public static Resource toModel(ResourceRepresentation resource, ResourceServer r
         Set&lt;ScopeRepresentation&gt; scopes = resource.getScopes();
 
         if (scopes != null) {
+            model.updateScopes(scopes.stream().map(scope -&gt; toModel(scope, resourceServer, authorization, false)).collect(Collectors.toSet()));
         }
 
         Map&lt;String, List&lt;String&gt;&gt; attributes = resource.getAttributes();
@@ -2619,6 +2619,10 @@ public static Resource toModel(ResourceRepresentation resource, ResourceServer r
     }
 
     public static Scope toModel(ScopeRepresentation scope, ResourceServer resourceServer, AuthorizationProvider authorization) {
+        return toModel(scope, resourceServer, authorization, true);
+    }
+    
+    public static Scope toModel(ScopeRepresentation scope, ResourceServer resourceServer, AuthorizationProvider authorization, boolean updateIfExists) {
         StoreFactory storeFactory = authorization.getStoreFactory();
         ScopeStore scopeStore = storeFactory.getScopeStore();
         Scope existing;
@@ -2630,9 +2634,11 @@ public static Scope toModel(ScopeRepresentation scope, ResourceServer resourceSe
         }
 
         if (existing != null) {
+            if (updateIfExists) {
+                existing.setName(scope.getName());
+                existing.setDisplayName(scope.getDisplayName());
+                existing.setIconUri(scope.getIconUri());
+            }
             return existing;
         }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>115838</refactoring_id><commit_sha>20f2634ba8688a9e55f71f7de9fd443599647166</commit_sha><commit_link>https://github.com/bcgit/bc-java/commit/20f2634ba8688a9e55f71f7de9fd443599647166</commit_link><file_path>pg/src/main/java/org/bouncycastle/openpgp/operator/bc/BcPublicKeyDataDecryptorFactory.java</file_path><description>Extract Method private assertOutOfRange(pLen int, enc byte[]) : void extracted from public recoverSessionData(keyAlgorithm int, secKeyData byte[][]) : byte[] in class org.bouncycastle.openpgp.operator.bc.BcPublicKeyDataDecryptorFactory</description><code_before>@@ -64,35 +64,27 @@ public byte[] recoverSessionData(int keyAlgorithm, byte[][] secKeyData)
 
             if (keyAlgorithm == PublicKeyAlgorithmTags.X25519)
             {
-                return getSessionData(secKeyData, privKey, X25519PublicBCPGKey.LENGTH, HashAlgorithmTags.SHA256,
-                    SymmetricKeyAlgorithmTags.AES_128, new X25519Agreement(),
-                    X25519PublicKeyParameters::new);
             }
             else if (keyAlgorithm == PublicKeyAlgorithmTags.X448)
             {
-                return getSessionData(secKeyData, privKey, X448PublicBCPGKey.LENGTH, HashAlgorithmTags.SHA512,
-                    SymmetricKeyAlgorithmTags.AES_256, new X448Agreement(),
-                    X448PublicKeyParameters::new);
             }
             else if (keyAlgorithm == PublicKeyAlgorithmTags.ECDH)
             {
                 byte[] enc = secKeyData[0];
                 byte[] pEnc;
                 byte[] keyEnc;
                 int pLen = ((((enc[0] &amp; 0xff) &lt;&lt; 8) + (enc[1] &amp; 0xff)) + 7) / 8;
-                if ((2 + pLen + 1) &gt; enc.length)
-                {
-                    throw new PGPException("encoded length out of range");
-                }
 
                 pEnc = new byte[pLen];
                 System.arraycopy(enc, 2, pEnc, 0, pLen);
 
                 int keyLen = enc[pLen + 2] &amp; 0xff;
-                if ((2 + pLen + 1 + keyLen) &gt; enc.length)
-                {
-                    throw new PGPException("encoded length out of range");
-                }
 
                 keyEnc = new byte[keyLen];
                 System.arraycopy(enc, 2 + pLen + 1, keyEnc, 0, keyLen);
@@ -131,7 +123,7 @@ else if (keyAlgorithm == PublicKeyAlgorithmTags.ECDH)
                 rfc6637KDFCalculator = new RFC6637KDFCalculator(new BcPGPDigestCalculatorProvider().get(hashAlgorithm), symmetricKeyAlgorithm);
                 KeyParameter key = new KeyParameter(rfc6637KDFCalculator.createKey(secret, userKeyingMaterial));
 
-                return PGPPad.unpadSessionData(getUnwrap(keyEnc, symmetricKeyAlgorithm, key));
             }
             else
             {
@@ -224,20 +216,15 @@ private interface PublicKeyParametersOperation
         AsymmetricKeyParameter getPublicKeyParameters(byte[] pEnc, int pEncOff);
     }
 
-    private byte[] getSessionData(byte[][] secKeyData, AsymmetricKeyParameter privKey, int pLen, int hashAlgorithm,
-                                  int symmetricKeyAlgorithm, RawAgreement agreement, PublicKeyParametersOperation pkp
-    )
         throws PGPException, InvalidCipherTextException
     {
-        byte[] enc = secKeyData[0];
         byte[] pEnc = new byte[pLen];
         byte[] keyEnc;
         System.arraycopy(enc, 0, pEnc, 0, pLen);
         int keyLen = enc[pLen] &amp; 0xff;
-        if ((pLen + 1 + keyLen) &gt; enc.length)
-        {
-            throw new PGPException("encoded length out of range");
-        }
         keyEnc = new byte[keyLen - 1];
         System.arraycopy(enc, pLen + 2, keyEnc, 0, keyEnc.length);
         byte[] secret = getSecret(agreement, privKey, pkp.getPublicKeyParameters(pEnc, 0));
@@ -246,7 +233,7 @@ private byte[] getSessionData(byte[][] secKeyData, AsymmetricKeyParameter privKe
 
         KeyParameter key = new KeyParameter(rfc6637KDFCalculator.createKey(Arrays.concatenate(pgpPrivKey.getPublicKeyPacket().getKey().getEncoded(), pEnc, secret)));
 
-        return Arrays.concatenate(new byte[]{enc[pLen + 1]}, getUnwrap(keyEnc, symmetricKeyAlgorithm, key));
     }
 
     private static byte[] getSecret(RawAgreement agreement, AsymmetricKeyParameter privKey, AsymmetricKeyParameter ephPub)
@@ -257,11 +244,20 @@ private static byte[] getSecret(RawAgreement agreement, AsymmetricKeyParameter p
         return secret;
     }
 
-    private static byte[] getUnwrap(byte[] keyEnc, int symmetricKeyAlgorithm, KeyParameter key)
         throws PGPException, InvalidCipherTextException
     {
         Wrapper c = BcImplProvider.createWrapper(symmetricKeyAlgorithm);
         c.init(false, key);
         return c.unwrap(keyEnc, 0, keyEnc.length);
     }
-}
\ No newline at end of file
</code_before><code_after>@@ -64,35 +64,27 @@ public byte[] recoverSessionData(int keyAlgorithm, byte[][] secKeyData)
 
             if (keyAlgorithm == PublicKeyAlgorithmTags.X25519)
             {
+                return getSessionData(secKeyData[0], privKey, X25519PublicBCPGKey.LENGTH, HashAlgorithmTags.SHA256,
+                    SymmetricKeyAlgorithmTags.AES_128, new X25519Agreement(), X25519PublicKeyParameters::new);
             }
             else if (keyAlgorithm == PublicKeyAlgorithmTags.X448)
             {
+                return getSessionData(secKeyData[0], privKey, X448PublicBCPGKey.LENGTH, HashAlgorithmTags.SHA512,
+                    SymmetricKeyAlgorithmTags.AES_256, new X448Agreement(), X448PublicKeyParameters::new);
             }
             else if (keyAlgorithm == PublicKeyAlgorithmTags.ECDH)
             {
                 byte[] enc = secKeyData[0];
                 byte[] pEnc;
                 byte[] keyEnc;
                 int pLen = ((((enc[0] &amp; 0xff) &lt;&lt; 8) + (enc[1] &amp; 0xff)) + 7) / 8;
+                assertOutOfRange(2 + pLen + 1, enc);
 
                 pEnc = new byte[pLen];
                 System.arraycopy(enc, 2, pEnc, 0, pLen);
 
                 int keyLen = enc[pLen + 2] &amp; 0xff;
+                assertOutOfRange(2 + pLen + 1 + keyLen, enc);
 
                 keyEnc = new byte[keyLen];
                 System.arraycopy(enc, 2 + pLen + 1, keyEnc, 0, keyLen);
@@ -131,7 +123,7 @@ else if (keyAlgorithm == PublicKeyAlgorithmTags.ECDH)
                 rfc6637KDFCalculator = new RFC6637KDFCalculator(new BcPGPDigestCalculatorProvider().get(hashAlgorithm), symmetricKeyAlgorithm);
                 KeyParameter key = new KeyParameter(rfc6637KDFCalculator.createKey(secret, userKeyingMaterial));
 
+                return PGPPad.unpadSessionData(unwrapSessionData(keyEnc, symmetricKeyAlgorithm, key));
             }
             else
             {
@@ -224,20 +216,15 @@ private interface PublicKeyParametersOperation
         AsymmetricKeyParameter getPublicKeyParameters(byte[] pEnc, int pEncOff);
     }
 
+    private byte[] getSessionData(byte[] enc, AsymmetricKeyParameter privKey, int pLen, int hashAlgorithm,
+                                  int symmetricKeyAlgorithm, RawAgreement agreement, PublicKeyParametersOperation pkp)
         throws PGPException, InvalidCipherTextException
     {
         byte[] pEnc = new byte[pLen];
         byte[] keyEnc;
         System.arraycopy(enc, 0, pEnc, 0, pLen);
         int keyLen = enc[pLen] &amp; 0xff;
+        assertOutOfRange(pLen + 1 + keyLen, enc);
         keyEnc = new byte[keyLen - 1];
         System.arraycopy(enc, pLen + 2, keyEnc, 0, keyEnc.length);
         byte[] secret = getSecret(agreement, privKey, pkp.getPublicKeyParameters(pEnc, 0));
@@ -246,7 +233,7 @@ private byte[] getSessionData(byte[][] secKeyData, AsymmetricKeyParameter privKe
 
         KeyParameter key = new KeyParameter(rfc6637KDFCalculator.createKey(Arrays.concatenate(pgpPrivKey.getPublicKeyPacket().getKey().getEncoded(), pEnc, secret)));
 
+        return Arrays.concatenate(new byte[]{enc[pLen + 1]}, unwrapSessionData(keyEnc, symmetricKeyAlgorithm, key));
     }
 
     private static byte[] getSecret(RawAgreement agreement, AsymmetricKeyParameter privKey, AsymmetricKeyParameter ephPub)
@@ -257,11 +244,20 @@ private static byte[] getSecret(RawAgreement agreement, AsymmetricKeyParameter p
         return secret;
     }
 
+    private static byte[] unwrapSessionData(byte[] keyEnc, int symmetricKeyAlgorithm, KeyParameter key)
         throws PGPException, InvalidCipherTextException
     {
         Wrapper c = BcImplProvider.createWrapper(symmetricKeyAlgorithm);
         c.init(false, key);
         return c.unwrap(keyEnc, 0, keyEnc.length);
     }
+
+    private static void assertOutOfRange(int pLen, byte[] enc)
+        throws PGPException
+    {
+        if (pLen &gt; enc.length)
+        {
+            throw new PGPException("encoded length out of range");
+        }
+    }
+}
\ No newline at end of file
</code_after><evaluations><evaluation><vote>1</vote></evaluation></evaluations></refactoring></Extract_Method><Rename_Method><refactoring><refactoring_id>125768</refactoring_id><commit_sha>7f34698eefa7a48fdce2aab1079f64e57e029f9f</commit_sha><commit_link>https://github.com/apache/doris/commit/7f34698eefa7a48fdce2aab1079f64e57e029f9f</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/nereids/stats/JoinEstimation.java</file_path><description>Rename Method public estimate2(leftStats StatsDeriveResult, rightStats StatsDeriveResult, join Join) : StatsDeriveResult renamed to public estimateV2(leftStats StatsDeriveResult, rightStats StatsDeriveResult, join Join) : StatsDeriveResult in class org.apache.doris.nereids.stats.JoinEstimation</description><code_before>@@ -150,7 +150,7 @@ private static JoinEstimationResult estimateInnerJoin(PhysicalHashJoin join, Equ
     /**
      * estimate join
      */
-    public static StatsDeriveResult estimate(StatsDeriveResult leftStats, StatsDeriveResult rightStats, Join join) {
         JoinType joinType = join.getJoinType();
         double rowCount = Double.MAX_VALUE;
         if (joinType == JoinType.LEFT_SEMI_JOIN || joinType == JoinType.LEFT_ANTI_JOIN) {
@@ -196,7 +196,10 @@ public static StatsDeriveResult estimate(StatsDeriveResult leftStats, StatsDeriv
      * Do estimate.
      * // TODO: since we have no column stats here. just use a fix ratio to compute the row count.
      */
-    public static StatsDeriveResult estimate2(StatsDeriveResult leftStats, StatsDeriveResult rightStats, Join join) {
         JoinType joinType = join.getJoinType();
         // TODO: normalize join hashConjuncts.
         // List&lt;Expression&gt; hashJoinConjuncts = join.getHashJoinConjuncts();
</code_before><code_after>@@ -150,7 +150,7 @@ private static JoinEstimationResult estimateInnerJoin(PhysicalHashJoin join, Equ
     /**
      * estimate join
      */
+    public static StatsDeriveResult estimateV2(StatsDeriveResult leftStats, StatsDeriveResult rightStats, Join join) {
         JoinType joinType = join.getJoinType();
         double rowCount = Double.MAX_VALUE;
         if (joinType == JoinType.LEFT_SEMI_JOIN || joinType == JoinType.LEFT_ANTI_JOIN) {
@@ -196,7 +196,10 @@ public static StatsDeriveResult estimate(StatsDeriveResult leftStats, StatsDeriv
      * Do estimate.
      * // TODO: since we have no column stats here. just use a fix ratio to compute the row count.
      */
+    public static StatsDeriveResult estimate(StatsDeriveResult leftStats, StatsDeriveResult rightStats, Join join) {
+        if (ConnectContext.get() != null &amp;&amp; ConnectContext.get().getSessionVariable().enableNereidsStatsDeriveV2) {
+            return estimateV2(leftStats, rightStats, join);
+        }
         JoinType joinType = join.getJoinType();
         // TODO: normalize join hashConjuncts.
         // List&lt;Expression&gt; hashJoinConjuncts = join.getHashJoinConjuncts();
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>197054</refactoring_id><commit_sha>d579526645cb13bf9a595ea451553ad685b89d15</commit_sha><commit_link>https://github.com/camunda/camunda/commit/d579526645cb13bf9a595ea451553ad685b89d15</commit_link><file_path>backend/src/main/java/org/camunda/optimize/service/es/writer/EventProcessPublishStateWriter.java</file_path><description>Rename Method public deleteAllEventProcessPublishStatesForEventProcessMappingId(eventProcessMappingId String) : boolean renamed to public markAsDeletedAllEventProcessPublishStatesForEventProcessMappingId(eventProcessMappingId String) : boolean in class org.camunda.optimize.service.es.writer.EventProcessPublishStateWriter</description><code_before>@@ -123,7 +123,7 @@ public void updateEventProcessPublishState(final EventProcessPublishStateDto eve
     }
   }
 
-  public boolean deleteAllEventProcessPublishStatesForEventProcessMappingId(final String eventProcessMappingId) {
     final String updateItem = String.format(
       "event process publish state with %s [%s]",
       EventProcessPublishStateIndex.PROCESS_MAPPING_ID,
@@ -149,7 +149,7 @@ public boolean deleteAllEventProcessPublishStatesForEventProcessMappingId(final
     );
   }
 
-  public boolean deleteAllEventProcessPublishStatesForEventProcessMappingIdExceptOne(
     final String eventProcessMappingId,
     final String publishStateIdToExclude) {
     final String updateItem = String.format(
@@ -173,8 +173,7 @@ public boolean deleteAllEventProcessPublishStatesForEventProcessMappingIdExceptO
       .must(termQuery(EventProcessPublishStateIndex.PROCESS_MAPPING_ID, eventProcessMappingId))
       .mustNot(termQuery(EventProcessPublishStateIndex.ID, publishStateIdToExclude));
 
-
-    return ElasticsearchWriterUtil.tryUpdateByQueryRequest(
       esClient,
       updateItem,
       updateScript,
</code_before><code_after>@@ -123,7 +123,7 @@ public void updateEventProcessPublishState(final EventProcessPublishStateDto eve
     }
   }
 
+  public boolean markAsDeletedAllEventProcessPublishStatesForEventProcessMappingId(final String eventProcessMappingId) {
     final String updateItem = String.format(
       "event process publish state with %s [%s]",
       EventProcessPublishStateIndex.PROCESS_MAPPING_ID,
@@ -149,7 +149,7 @@ public boolean deleteAllEventProcessPublishStatesForEventProcessMappingId(final
     );
   }
 
+  public void markAsDeletedPublishStatesForEventProcessMappingIdExcludingPublishStateId(
     final String eventProcessMappingId,
     final String publishStateIdToExclude) {
     final String updateItem = String.format(
@@ -173,8 +173,7 @@ public boolean deleteAllEventProcessPublishStatesForEventProcessMappingIdExceptO
       .must(termQuery(EventProcessPublishStateIndex.PROCESS_MAPPING_ID, eventProcessMappingId))
       .mustNot(termQuery(EventProcessPublishStateIndex.ID, publishStateIdToExclude));
 
+    ElasticsearchWriterUtil.tryUpdateByQueryRequest(
       esClient,
       updateItem,
       updateScript,
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>285872</refactoring_id><commit_sha>f2393f1d206a88d092a2637511216edb5dad4da4</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/f2393f1d206a88d092a2637511216edb5dad4da4</commit_link><file_path>quickstep/recents_ui_overrides/src/com/android/launcher3/uioverrides/states/OverviewPeekState.java</file_path><description>Rename Method public getOverviewScaleAndTranslation(launcher Launcher) : ScaleAndTranslation renamed to public getOverviewScaleAndOffset(launcher Launcher) : float[] in class com.android.launcher3.uioverrides.states.OverviewPeekState</description><code_before>@@ -24,24 +24,18 @@
 
 import com.android.launcher3.Launcher;
 import com.android.launcher3.LauncherState;
-import com.android.launcher3.R;
-import com.android.launcher3.Utilities;
 import com.android.launcher3.states.StateAnimationConfig;
 
 public class OverviewPeekState extends OverviewState {
     public OverviewPeekState(int id) {
         super(id);
     }
 
     @Override
-    public ScaleAndTranslation getOverviewScaleAndTranslation(Launcher launcher) {
-        ScaleAndTranslation result = super.getOverviewScaleAndTranslation(launcher);
-        result.translationX = NORMAL.getOverviewScaleAndTranslation(launcher).translationX
-                - launcher.getResources().getDimension(R.dimen.overview_peek_distance);
-        if (Utilities.isRtl(launcher.getResources())) {
-            result.translationX = -result.translationX;
-        }
-        return result;
     }
 
     @Override
</code_before><code_after>@@ -24,24 +24,18 @@
 
 import com.android.launcher3.Launcher;
 import com.android.launcher3.LauncherState;
 import com.android.launcher3.states.StateAnimationConfig;
 
 public class OverviewPeekState extends OverviewState {
+    private static final float OVERVIEW_OFFSET = 0.7f;
+
     public OverviewPeekState(int id) {
         super(id);
     }
 
     @Override
+    public float[] getOverviewScaleAndOffset(Launcher launcher) {
+        return new float[] {NO_SCALE, OVERVIEW_OFFSET};
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>190220</refactoring_id><commit_sha>76a163fa8f49ce3eb5716461cdc2235a1089e41f</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/76a163fa8f49ce3eb5716461cdc2235a1089e41f</commit_link><file_path>OsmAnd/src/net/osmand/plus/notifications/OsMoNotification.java</file_path><description>Rename Method public getUniqueId() : int renamed to public getOsmandNotificationId() : int in class net.osmand.plus.notifications.OsMoNotification</description><code_before>@@ -22,9 +22,10 @@ public class OsMoNotification extends OsmandNotification {
 	public final static String OSMAND_STOP_OSMO_SERVICE_ACTION = "OSMAND_STOP_OSMO_SERVICE_ACTION";
 	public final static String OSMAND_START_SHARE_LOCATION_ACTION = "OSMAND_START_SHARE_LOCATION_ACTION";
 	public final static String OSMAND_STOP_SHARE_LOCATION_ACTION = "OSMAND_STOP_SHARE_LOCATION_ACTION";
 
 	public OsMoNotification(OsmandApplication app) {
-		super(app);
 	}
 
 	@Override
@@ -115,7 +116,7 @@ public boolean isEnabled() {
 	}
 
 	@Override
-	public Builder buildNotification() {
 		OsMoPlugin osMoPlugin = OsmandPlugin.getEnabledPlugin(OsMoPlugin.class);
 		if (osMoPlugin == null) {
 			return null;
@@ -130,7 +131,7 @@ public Builder buildNotification() {
 		notificationTitle = app.getString(R.string.osmo_service_running);
 		notificationText = app.getString(R.string.osmo_share_my_location) + ": " + (shareLocation ? app.getString(R.string.shared_string_yes) : app.getString(R.string.shared_string_no)).toLowerCase();
 
-		final Builder notificationBuilder = createBuilder()
 				.setContentTitle(notificationTitle)
 				.setContentText(notificationText);
 
@@ -169,7 +170,12 @@ public Builder buildNotification() {
 
 
 	@Override
-	public int getUniqueId() {
 		return OSMO_NOTIFICATION_SERVICE_ID;
 	}
 }
</code_before><code_after>@@ -22,9 +22,10 @@ public class OsMoNotification extends OsmandNotification {
 	public final static String OSMAND_STOP_OSMO_SERVICE_ACTION = "OSMAND_STOP_OSMO_SERVICE_ACTION";
 	public final static String OSMAND_START_SHARE_LOCATION_ACTION = "OSMAND_START_SHARE_LOCATION_ACTION";
 	public final static String OSMAND_STOP_SHARE_LOCATION_ACTION = "OSMAND_STOP_SHARE_LOCATION_ACTION";
+	public final static String GROUP_NAME = "OSMO";
 
 	public OsMoNotification(OsmandApplication app) {
+		super(app, GROUP_NAME);
 	}
 
 	@Override
@@ -115,7 +116,7 @@ public boolean isEnabled() {
 	}
 
 	@Override
+	public Builder buildNotification(boolean wearable) {
 		OsMoPlugin osMoPlugin = OsmandPlugin.getEnabledPlugin(OsMoPlugin.class);
 		if (osMoPlugin == null) {
 			return null;
@@ -130,7 +131,7 @@ public Builder buildNotification() {
 		notificationTitle = app.getString(R.string.osmo_service_running);
 		notificationText = app.getString(R.string.osmo_share_my_location) + ": " + (shareLocation ? app.getString(R.string.shared_string_yes) : app.getString(R.string.shared_string_no)).toLowerCase();
 
+		final Builder notificationBuilder = createBuilder(wearable)
 				.setContentTitle(notificationTitle)
 				.setContentText(notificationText);
 
@@ -169,7 +170,12 @@ public Builder buildNotification() {
 
 
 	@Override
+	public int getOsmandNotificationId() {
 		return OSMO_NOTIFICATION_SERVICE_ID;
 	}
+
+	@Override
+	public int getOsmandWearableNotificationId() {
+		return WEAR_OSMO_NOTIFICATION_SERVICE_ID;
+	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>260677</refactoring_id><commit_sha>2fbbcc4bd006dff49bc97b948ae264e0a7978d86</commit_sha><commit_link>https://github.com/spring-projects/spring-security/commit/2fbbcc4bd006dff49bc97b948ae264e0a7978d86</commit_link><file_path>config/src/main/java/org/springframework/security/config/annotation/method/configuration/DeferringObservationReactiveAuthorizationManager.java</file_path><description>Rename Method public postProcessResult(methodInvocationResult MethodInvocationResult, authorizationResult AuthorizationResult) : Object renamed to public handleDeniedInvocationResult(methodInvocationResult MethodInvocationResult, authorizationResult AuthorizationResult) : Object in class org.springframework.security.config.annotation.method.configuration.DeferringObservationReactiveAuthorizationManager</description><code_before>@@ -28,22 +28,18 @@
 import org.springframework.security.authorization.ObservationReactiveAuthorizationManager;
 import org.springframework.security.authorization.ReactiveAuthorizationManager;
 import org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler;
-import org.springframework.security.authorization.method.MethodAuthorizationDeniedPostProcessor;
 import org.springframework.security.authorization.method.MethodInvocationResult;
 import org.springframework.security.authorization.method.ThrowingMethodAuthorizationDeniedHandler;
-import org.springframework.security.authorization.method.ThrowingMethodAuthorizationDeniedPostProcessor;
 import org.springframework.security.core.Authentication;
 import org.springframework.util.function.SingletonSupplier;
 
-final class DeferringObservationReactiveAuthorizationManager&lt;T&gt; implements ReactiveAuthorizationManager&lt;T&gt;,
-		MethodAuthorizationDeniedHandler, MethodAuthorizationDeniedPostProcessor {
 
 	private final Supplier&lt;ReactiveAuthorizationManager&lt;T&gt;&gt; delegate;
 
 	private MethodAuthorizationDeniedHandler handler = new ThrowingMethodAuthorizationDeniedHandler();
 
-	private MethodAuthorizationDeniedPostProcessor postProcessor = new ThrowingMethodAuthorizationDeniedPostProcessor();
-
 	DeferringObservationReactiveAuthorizationManager(ObjectProvider&lt;ObservationRegistry&gt; provider,
 			ReactiveAuthorizationManager&lt;T&gt; delegate) {
 		this.delegate = SingletonSupplier.of(() -&gt; {
@@ -56,9 +52,6 @@ final class DeferringObservationReactiveAuthorizationManager&lt;T&gt; implements React
 		if (delegate instanceof MethodAuthorizationDeniedHandler h) {
 			this.handler = h;
 		}
-		if (delegate instanceof MethodAuthorizationDeniedPostProcessor p) {
-			this.postProcessor = p;
-		}
 	}
 
 	@Override
@@ -67,14 +60,14 @@ public Mono&lt;AuthorizationDecision&gt; check(Mono&lt;Authentication&gt; authentication, T
 	}
 
 	@Override
-	public Object handle(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {
-		return this.handler.handle(methodInvocation, authorizationResult);
 	}
 
 	@Override
-	public Object postProcessResult(MethodInvocationResult methodInvocationResult,
 			AuthorizationResult authorizationResult) {
-		return this.postProcessor.postProcessResult(methodInvocationResult, authorizationResult);
 	}
 
 }
</code_before><code_after>@@ -28,22 +28,18 @@
 import org.springframework.security.authorization.ObservationReactiveAuthorizationManager;
 import org.springframework.security.authorization.ReactiveAuthorizationManager;
 import org.springframework.security.authorization.method.MethodAuthorizationDeniedHandler;
 import org.springframework.security.authorization.method.MethodInvocationResult;
 import org.springframework.security.authorization.method.ThrowingMethodAuthorizationDeniedHandler;
 import org.springframework.security.core.Authentication;
 import org.springframework.util.function.SingletonSupplier;
 
+final class DeferringObservationReactiveAuthorizationManager&lt;T&gt;
+		implements ReactiveAuthorizationManager&lt;T&gt;, MethodAuthorizationDeniedHandler {
 
 	private final Supplier&lt;ReactiveAuthorizationManager&lt;T&gt;&gt; delegate;
 
 	private MethodAuthorizationDeniedHandler handler = new ThrowingMethodAuthorizationDeniedHandler();
 
 	DeferringObservationReactiveAuthorizationManager(ObjectProvider&lt;ObservationRegistry&gt; provider,
 			ReactiveAuthorizationManager&lt;T&gt; delegate) {
 		this.delegate = SingletonSupplier.of(() -&gt; {
@@ -56,9 +52,6 @@ final class DeferringObservationReactiveAuthorizationManager&lt;T&gt; implements React
 		if (delegate instanceof MethodAuthorizationDeniedHandler h) {
 			this.handler = h;
 		}
 	}
 
 	@Override
@@ -67,14 +60,14 @@ public Mono&lt;AuthorizationDecision&gt; check(Mono&lt;Authentication&gt; authentication, T
 	}
 
 	@Override
+	public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {
+		return this.handler.handleDeniedInvocation(methodInvocation, authorizationResult);
 	}
 
 	@Override
+	public Object handleDeniedInvocationResult(MethodInvocationResult methodInvocationResult,
 			AuthorizationResult authorizationResult) {
+		return this.handler.handleDeniedInvocationResult(methodInvocationResult, authorizationResult);
 	}
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>210095</refactoring_id><commit_sha>2e3fa4cdd4f2daa13f06cf2573fdfb815086961f</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/2e3fa4cdd4f2daa13f06cf2573fdfb815086961f</commit_link><file_path>common/src/test/java/tachyon/conf/TachyonConfTest.java</file_path><description>Rename Method public testUserDefault() : void renamed to public userDefaultTest() : void in class tachyon.conf.TachyonConfTest</description><code_before>@@ -62,7 +62,7 @@ public void beforeTests() {
   // test default properties
 
   @Test
-  public void testCommonDefault() {
     String tachyonHome = sDefaultTachyonConf.get(Constants.TACHYON_HOME);
     Assert.assertNotNull(tachyonHome);
     Assert.assertEquals("/mnt/tachyon_default_home", tachyonHome);
@@ -107,7 +107,7 @@ public void testCommonDefault() {
   }
 
   @Test
-  public void testMasterDefault() {
     String tachyonHome = sDefaultTachyonConf.get(Constants.TACHYON_HOME);
     Assert.assertNotNull(tachyonHome);
     Assert.assertEquals("/mnt/tachyon_default_home", tachyonHome);
@@ -155,7 +155,7 @@ public void testMasterDefault() {
   }
 
   @Test
-  public void testWorkerDefault() {
     String value = sDefaultTachyonConf.get(Constants.WORKER_DATA_FOLDER);
     Assert.assertNotNull(value);
     Assert.assertEquals("/tachyonworker/", value);
@@ -204,7 +204,7 @@ public void testWorkerDefault() {
   }
 
   @Test
-  public void testUserDefault() {
     int intValue = sDefaultTachyonConf.getInt(Constants.USER_FAILED_SPACE_REQUEST_LIMITS);
     Assert.assertEquals(3, intValue);
 
@@ -222,7 +222,7 @@ public void testUserDefault() {
   }
 
   @Test
-  public void testVariableSubstitutionSimple() {
     String home = mCustomPropsTachyonConf.get("home");
     Assert.assertEquals("hometest", home);
 
@@ -248,14 +248,14 @@ public void testVariableSubstitutionSimple() {
   }
 
   @Test
-  public void testVariableSubstitutionRecursive() {
     String multiplesubs = mCustomPropsTachyonConf.get("multiplesubs");
     String recursive = mCustomPropsTachyonConf.get("recursive");
     Assert.assertEquals(multiplesubs, recursive);
   }
 
   @Test
-  public void testSystemVariableSubstitutionSample() {
     String masterAddress = mSystemPropsTachyonConf.get(Constants.MASTER_ADDRESS);
     Assert.assertNotNull(masterAddress);
     Assert.assertEquals("tachyon-ft://master:20001", masterAddress);
</code_before><code_after>@@ -62,7 +62,7 @@ public void beforeTests() {
   // test default properties
 
   @Test
+  public void commonDefaultTest() {
     String tachyonHome = sDefaultTachyonConf.get(Constants.TACHYON_HOME);
     Assert.assertNotNull(tachyonHome);
     Assert.assertEquals("/mnt/tachyon_default_home", tachyonHome);
@@ -107,7 +107,7 @@ public void testCommonDefault() {
   }
 
   @Test
+  public void masterDefaultTest() {
     String tachyonHome = sDefaultTachyonConf.get(Constants.TACHYON_HOME);
     Assert.assertNotNull(tachyonHome);
     Assert.assertEquals("/mnt/tachyon_default_home", tachyonHome);
@@ -155,7 +155,7 @@ public void testMasterDefault() {
   }
 
   @Test
+  public void workerDefaultTest() {
     String value = sDefaultTachyonConf.get(Constants.WORKER_DATA_FOLDER);
     Assert.assertNotNull(value);
     Assert.assertEquals("/tachyonworker/", value);
@@ -204,7 +204,7 @@ public void testWorkerDefault() {
   }
 
   @Test
+  public void userDefaultTest() {
     int intValue = sDefaultTachyonConf.getInt(Constants.USER_FAILED_SPACE_REQUEST_LIMITS);
     Assert.assertEquals(3, intValue);
 
@@ -222,7 +222,7 @@ public void testUserDefault() {
   }
 
   @Test
+  public void variableSubstitutionSimpleTest() {
     String home = mCustomPropsTachyonConf.get("home");
     Assert.assertEquals("hometest", home);
 
@@ -248,14 +248,14 @@ public void testVariableSubstitutionSimple() {
   }
 
   @Test
+  public void variableSubstitutionRecursiveTest() {
     String multiplesubs = mCustomPropsTachyonConf.get("multiplesubs");
     String recursive = mCustomPropsTachyonConf.get("recursive");
     Assert.assertEquals(multiplesubs, recursive);
   }
 
   @Test
+  public void systemVariableSubstitutionSampleTest() {
     String masterAddress = mSystemPropsTachyonConf.get(Constants.MASTER_ADDRESS);
     Assert.assertNotNull(masterAddress);
     Assert.assertEquals("tachyon-ft://master:20001", masterAddress);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>309741</refactoring_id><commit_sha>6b81dbcc3306054af0dfa510dcb9b5e99aa0cd54</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/6b81dbcc3306054af0dfa510dcb9b5e99aa0cd54</commit_link><file_path>engine/src/main/java/org/terasology/rendering/nui/widgets/browser/ui/style/ParagraphRenderStyle.java</file_path><description>Rename Method public getParagraphBackgroundIndentTop() : Integer renamed to public getParagraphPaddingTop() : ContainerInteger in class org.terasology.rendering.nui.widgets.browser.ui.style.ParagraphRenderStyle</description><code_before>@@ -19,45 +19,63 @@
 import org.terasology.rendering.nui.HorizontalAlign;
 
 public interface ParagraphRenderStyle extends TextRenderStyle {
-    default Integer getParagraphIndentTop(boolean firstParagraph) {
         return null;
     }
 
-    default Integer getParagraphIndentBottom(boolean lastParagraph) {
         return null;
     }
 
-    default Integer getParagraphIndentLeft() {
         return null;
     }
 
-    default Integer getParagraphIndentRight() {
         return null;
     }
 
-    default Integer getParagraphBackgroundIndentTop() {
         return null;
     }
 
-    default Integer getParagraphBackgroundIndentBottom() {
         return null;
     }
 
-    default Integer getParagraphBackgroundIndentLeft() {
         return null;
     }
 
-    default Integer getParagraphBackgroundIndentRight() {
         return null;
     }
 
     default Color getParagraphBackground() {
         return null;
     }
 
-    default Integer getParagraphMinimumWidth() {
         return null;
     }
 
-    default HorizontalAlign getHorizontalAlignment() { return null; }
 }
</code_before><code_after>@@ -19,45 +19,63 @@
 import org.terasology.rendering.nui.HorizontalAlign;
 
 public interface ParagraphRenderStyle extends TextRenderStyle {
+    public enum FloatStyle {
+        LEFT, RIGHT, NONE
+    }
+
+    public enum ClearStyle {
+        LEFT, RIGHT, BOTH, NONE
+    }
+
+    default ContainerInteger getParagraphMarginTop() {
         return null;
     }
 
+    default ContainerInteger getParagraphMarginBottom() {
         return null;
     }
 
+    default ContainerInteger getParagraphMarginLeft() {
         return null;
     }
 
+    default ContainerInteger getParagraphMarginRight() {
         return null;
     }
 
+    default ContainerInteger getParagraphPaddingTop() {
         return null;
     }
 
+    default ContainerInteger getParagraphPaddingBottom() {
         return null;
     }
 
+    default ContainerInteger getParagraphPaddingLeft() {
         return null;
     }
 
+    default ContainerInteger getParagraphPaddingRight() {
         return null;
     }
 
     default Color getParagraphBackground() {
         return null;
     }
 
+    default ContainerInteger getParagraphMinimumWidth() {
+        return null;
+    }
+
+    default HorizontalAlign getHorizontalAlignment() {
+        return null;
+    }
+
+    default FloatStyle getFloatStyle() {
         return null;
     }
 
+    default ClearStyle getClearStyle() {
+        return null;
+    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>286950</refactoring_id><commit_sha>538fc563c492abceff74376b0d26872ec3100117</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/538fc563c492abceff74376b0d26872ec3100117</commit_link><file_path>source/ch/cyberduck/core/Session.java</file_path><description>Rename Method public getPublicAcl(readable boolean, writable boolean) : Acl renamed to public getPrivateAcl(container String) : Acl in class ch.cyberduck.core.Session</description><code_before>@@ -626,13 +626,17 @@ public List&lt;Acl.User&gt; getAvailableAclUsers() {
         return Collections.emptyList();
     }
 
     /**
      *
-     * @param readable
-     * @param writable
-     * @return
      */
-    public Acl getPublicAcl(boolean readable, boolean writable) {
         return Acl.EMPTY;
     };
 
</code_before><code_after>@@ -626,13 +626,17 @@ public List&lt;Acl.User&gt; getAvailableAclUsers() {
         return Collections.emptyList();
     }
 
+    public Acl getPrivateAcl(String container) {
+        return Acl.EMPTY;
+    }
+
     /**
      *
+     * @param container
+     *@param readable
+     * @param writable   @return
      */
+    public Acl getPublicAcl(String container, boolean readable, boolean writable) {
         return Acl.EMPTY;
     };
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>208085</refactoring_id><commit_sha>80b0942ae07eca57d32b7e53bceefa5dfb52ca86</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/80b0942ae07eca57d32b7e53bceefa5dfb52ca86</commit_link><file_path>integration/tools/validation/src/main/java/alluxio/cli/hdfs/HdfsVersionValidationTask.java</file_path><description>Rename Method public validate(optionMap Map&lt;String,String&gt;) : ValidationTaskResult renamed to public validateImpl(optionMap Map&lt;String,String&gt;) : ValidationTaskResult in class alluxio.cli.hdfs.HdfsVersionValidationTask</description><code_before>@@ -78,7 +78,7 @@ protected String parseVersion(String output) {
   }
 
   @Override
-  public ValidationTaskResult validate(Map&lt;String, String&gt; optionMap)
           throws InterruptedException {
     String hadoopVersion;
     try {
</code_before><code_after>@@ -78,7 +78,7 @@ protected String parseVersion(String output) {
   }
 
   @Override
+  public ValidationTaskResult validateImpl(Map&lt;String, String&gt; optionMap)
           throws InterruptedException {
     String hadoopVersion;
     try {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>247573</refactoring_id><commit_sha>d5ee787e1e6653257720afe31ee3f8819cd4605c</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/d5ee787e1e6653257720afe31ee3f8819cd4605c</commit_link><file_path>spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ControllerClassNameHandlerMappingTests.java</file_path><description>Rename Method public testWithFullBasePackage() : void renamed to public withFullBasePackage() : void in class org.springframework.web.servlet.mvc.annotation.ControllerClassNameHandlerMappingTests</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,45 +16,48 @@
 
 package org.springframework.web.servlet.mvc.annotation;
 
-import junit.framework.TestCase;
 
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockServletContext;
 import org.springframework.web.context.support.XmlWebApplicationContext;
 import org.springframework.web.servlet.HandlerExecutionChain;
 import org.springframework.web.servlet.HandlerMapping;
 
 /**
  * @author Juergen Hoeller
  */
-public class ControllerClassNameHandlerMappingTests extends TestCase {
-
-	public static final String LOCATION = "/org/springframework/web/servlet/mvc/annotation/class-mapping.xml";
-
-	private XmlWebApplicationContext wac;
 
-	private HandlerMapping hm;
 
-	private HandlerMapping hm2;
 
-	private HandlerMapping hm3;
 
-	private HandlerMapping hm4;
 
-	@Override
 	public void setUp() throws Exception {
-		MockServletContext sc = new MockServletContext("");
-		this.wac = new XmlWebApplicationContext();
-		this.wac.setServletContext(sc);
-		this.wac.setConfigLocations(new String[] {LOCATION});
 		this.wac.refresh();
 		this.hm = (HandlerMapping) this.wac.getBean("mapping");
 		this.hm2 = (HandlerMapping) this.wac.getBean("mapping2");
 		this.hm3 = (HandlerMapping) this.wac.getBean("mapping3");
 		this.hm4 = (HandlerMapping) this.wac.getBean("mapping4");
 	}
 
-	public void testIndexUri() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/index");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("index"), chain.getHandler());
@@ -64,7 +67,8 @@ public void testIndexUri() throws Exception {
 		assertEquals(this.wac.getBean("index"), chain.getHandler());
 	}
 
-	public void testMapSimpleUri() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/welcome");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
@@ -74,15 +78,17 @@ public void testMapSimpleUri() throws Exception {
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
-	public void testWithContextPath() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/welcome");
 		request.setContextPath("/myapp");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
-	public void testWithoutControllerSuffix() throws Exception {
-	  MockHttpServletRequest request = new MockHttpServletRequest("GET", "/buyform");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("buy"), chain.getHandler());
 
@@ -91,28 +97,32 @@ public void testWithoutControllerSuffix() throws Exception {
 		assertEquals(this.wac.getBean("buy"), chain.getHandler());
 	}
 
-	public void testWithBasePackage() throws Exception {
-	  MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/mvc/annotation/welcome");
 		HandlerExecutionChain chain = this.hm2.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
-	public void testWithBasePackageAndCaseSensitive() throws Exception {
-	  MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/mvc/annotation/buyForm");
 		HandlerExecutionChain chain = this.hm2.getHandler(request);
 		assertEquals(this.wac.getBean("buy"), chain.getHandler());
 	}
 
-	public void testWithFullBasePackage() throws Exception {
-	  MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/welcome");
 		HandlerExecutionChain chain = this.hm3.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
-	public void testWithRootAsBasePackage() throws Exception {
-	  MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/org/springframework/web/servlet/mvc/annotation/welcome");
 		HandlerExecutionChain chain = this.hm4.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
-}
\ No newline at end of file
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright 2002-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,45 +16,48 @@
 
 package org.springframework.web.servlet.mvc.annotation;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockServletContext;
 import org.springframework.web.context.support.XmlWebApplicationContext;
 import org.springframework.web.servlet.HandlerExecutionChain;
 import org.springframework.web.servlet.HandlerMapping;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Juergen Hoeller
  */
+public class ControllerClassNameHandlerMappingTests {
 
+	private static final String LOCATION = "/org/springframework/web/servlet/mvc/annotation/class-mapping.xml";
 
+	private final XmlWebApplicationContext wac = new XmlWebApplicationContext();
 
+	private HandlerMapping hm, hm2, hm3, hm4;
 
 
+	@Before
 	public void setUp() throws Exception {
+		this.wac.setServletContext(new MockServletContext(""));
+		this.wac.setConfigLocations(LOCATION);
 		this.wac.refresh();
 		this.hm = (HandlerMapping) this.wac.getBean("mapping");
 		this.hm2 = (HandlerMapping) this.wac.getBean("mapping2");
 		this.hm3 = (HandlerMapping) this.wac.getBean("mapping3");
 		this.hm4 = (HandlerMapping) this.wac.getBean("mapping4");
 	}
 
+	@After
+	public void closeWac() {
+		this.wac.close();
+	}
+
+	@Test
+	public void indexUri() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/index");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("index"), chain.getHandler());
@@ -64,7 +67,8 @@ public void testIndexUri() throws Exception {
 		assertEquals(this.wac.getBean("index"), chain.getHandler());
 	}
 
+	@Test
+	public void mapSimpleUri() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/welcome");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
@@ -74,15 +78,17 @@ public void testMapSimpleUri() throws Exception {
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
+	@Test
+	public void withContextPath() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/welcome");
 		request.setContextPath("/myapp");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
+	@Test
+	public void withoutControllerSuffix() throws Exception {
+		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/buyform");
 		HandlerExecutionChain chain = this.hm.getHandler(request);
 		assertEquals(this.wac.getBean("buy"), chain.getHandler());
 
@@ -91,28 +97,32 @@ public void testWithoutControllerSuffix() throws Exception {
 		assertEquals(this.wac.getBean("buy"), chain.getHandler());
 	}
 
+	@Test
+	public void withBasePackage() throws Exception {
+		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/mvc/annotation/welcome");
 		HandlerExecutionChain chain = this.hm2.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
+	@Test
+	public void withBasePackageAndCaseSensitive() throws Exception {
+		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/mvc/annotation/buyForm");
 		HandlerExecutionChain chain = this.hm2.getHandler(request);
 		assertEquals(this.wac.getBean("buy"), chain.getHandler());
 	}
 
+	@Test
+	public void withFullBasePackage() throws Exception {
+		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/welcome");
 		HandlerExecutionChain chain = this.hm3.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
+	@Test
+	public void withRootAsBasePackage() throws Exception {
+		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/myapp/org/springframework/web/servlet/mvc/annotation/welcome");
 		HandlerExecutionChain chain = this.hm4.getHandler(request);
 		assertEquals(this.wac.getBean("welcome"), chain.getHandler());
 	}
 
\ No newline at end of file
+}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>167305</refactoring_id><commit_sha>e2fed8bc7d15092deb701cba5f0b158d250c2485</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/e2fed8bc7d15092deb701cba5f0b158d250c2485</commit_link><file_path>clients/java/src/test/java/io/zeebe/client/job/CompleteJobTest.java</file_path><description>Rename Method public shouldCompleteWithJsonMapPayload() : void renamed to public shouldCompleteWithJsonMapVariables() : void in class io.zeebe.client.job.CompleteJobTest</description><code_before>@@ -39,77 +39,77 @@ public void shouldCompleteJob() {
     // then
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
-    assertThat(request.getPayload()).isEmpty();
   }
 
   @Test
-  public void shouldCompleteWithJsonStringPayload() {
     // given
     final long jobKey = 12;
     final String json = JsonUtil.toJson(Collections.singletonMap("key", "val"));
 
     // when
-    client.newCompleteCommand(jobKey).payload(json).send().join();
 
     // then
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
-    JsonUtil.assertEquality(request.getPayload(), json);
   }
 
   @Test
-  public void shouldCompleteWithJsonStreamPayload() {
     // given
     final long jobKey = 12;
     final String json = JsonUtil.toJson(Collections.singletonMap("key", "val"));
 
     // when
     client
         .newCompleteCommand(jobKey)
-        .payload(new ByteArrayInputStream(StringUtil.getBytes(json)))
         .send()
         .join();
 
     // then
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
-    JsonUtil.assertEquality(request.getPayload(), json);
   }
 
   @Test
-  public void shouldCompleteWithJsonMapPayload() {
     // given
     final long jobKey = 12;
     final Map&lt;String, Object&gt; map = Collections.singletonMap("key", "val");
 
     // when
-    client.newCompleteCommand(jobKey).payload(map).send().join();
 
     // then
     final String expectedJson = JsonUtil.toJson(map);
 
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
-    JsonUtil.assertEquality(request.getPayload(), expectedJson);
   }
 
   @Test
-  public void shouldCompleteWithJsonPOJOPayload() {
 
     // given
     final long jobKey = 12;
     final POJO pojo = new POJO();
     pojo.setKey("val");
 
     // when
-    client.newCompleteCommand(jobKey).payload(pojo).send().join();
 
     // then
     final String expectedJson = JsonUtil.toJson(pojo);
 
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
-    JsonUtil.assertEquality(request.getPayload(), expectedJson);
   }
 
   public static class POJO {
</code_before><code_after>@@ -39,77 +39,77 @@ public void shouldCompleteJob() {
     // then
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
+    assertThat(request.getVariables()).isEmpty();
   }
 
   @Test
+  public void shouldCompleteWithJsonStringVariables() {
     // given
     final long jobKey = 12;
     final String json = JsonUtil.toJson(Collections.singletonMap("key", "val"));
 
     // when
+    client.newCompleteCommand(jobKey).variables(json).send().join();
 
     // then
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
+    JsonUtil.assertEquality(request.getVariables(), json);
   }
 
   @Test
+  public void shouldCompleteWithJsonStreamVariables() {
     // given
     final long jobKey = 12;
     final String json = JsonUtil.toJson(Collections.singletonMap("key", "val"));
 
     // when
     client
         .newCompleteCommand(jobKey)
+        .variables(new ByteArrayInputStream(StringUtil.getBytes(json)))
         .send()
         .join();
 
     // then
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
+    JsonUtil.assertEquality(request.getVariables(), json);
   }
 
   @Test
+  public void shouldCompleteWithJsonMapVariables() {
     // given
     final long jobKey = 12;
     final Map&lt;String, Object&gt; map = Collections.singletonMap("key", "val");
 
     // when
+    client.newCompleteCommand(jobKey).variables(map).send().join();
 
     // then
     final String expectedJson = JsonUtil.toJson(map);
 
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
+    JsonUtil.assertEquality(request.getVariables(), expectedJson);
   }
 
   @Test
+  public void shouldCompleteWithJsonPOJOVariables() {
 
     // given
     final long jobKey = 12;
     final POJO pojo = new POJO();
     pojo.setKey("val");
 
     // when
+    client.newCompleteCommand(jobKey).variables(pojo).send().join();
 
     // then
     final String expectedJson = JsonUtil.toJson(pojo);
 
     final CompleteJobRequest request = gatewayService.getLastRequest();
     assertThat(request.getJobKey()).isEqualTo(jobKey);
+    JsonUtil.assertEquality(request.getVariables(), expectedJson);
   }
 
   public static class POJO {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>160077</refactoring_id><commit_sha>8eacf87b40fac798c3f8f94ae3bff16f41c54acc</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/8eacf87b40fac798c3f8f94ae3bff16f41c54acc</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/api/KernelTransactionImplementation.java</file_path><description>Rename Method public markForTerminate() : void renamed to public markForTermination() : void in class org.neo4j.kernel.impl.api.KernelTransactionImplementation</description><code_before>@@ -85,7 +85,7 @@ public class KernelTransactionImplementation implements KernelTransaction, TxSta
     private TransactionHooks.TransactionHooksState hooksState;
     private final TransactionRecordState recordState;
     private boolean failure, success;
-    private volatile boolean terminateed;
 
     // For committing
     private final TransactionHeaderInformation headerInformation;
@@ -146,16 +146,16 @@ public void failure()
     }
 
     @Override
-    public boolean shouldBeTerminateed()
     {
-        return terminateed;
     }
 
     @Override
-    public void markForTerminate()
     {
         failure = true;
-        terminateed = true;
     }
 
     private void release()
</code_before><code_after>@@ -85,7 +85,7 @@ public class KernelTransactionImplementation implements KernelTransaction, TxSta
     private TransactionHooks.TransactionHooksState hooksState;
     private final TransactionRecordState recordState;
     private boolean failure, success;
+    private volatile boolean terminated;
 
     // For committing
     private final TransactionHeaderInformation headerInformation;
@@ -146,16 +146,16 @@ public void failure()
     }
 
     @Override
+    public boolean shouldBeTerminated()
     {
+        return terminated;
     }
 
     @Override
+    public void markForTermination()
     {
         failure = true;
+        terminated = true;
     }
 
     private void release()
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>125885</refactoring_id><commit_sha>a041f8eabeb3a5e07fbc13ed23bf9e044281f4a8</commit_sha><commit_link>https://github.com/apache/doris/commit/a041f8eabeb3a5e07fbc13ed23bf9e044281f4a8</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/common/util/DynamicPartitionUtil.java</file_path><description>Rename Method private getSimpleDateFormat(timeUnit String) : SimpleDateFormat renamed to private getDateTimeFormatter(timeUnit String) : DateTimeFormatter in class org.apache.doris.common.util.DynamicPartitionUtil</description><code_before>@@ -49,13 +49,14 @@
 import org.apache.logging.log4j.Logger;
 
 import java.sql.Timestamp;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
 import java.time.DayOfWeek;
 import java.time.Month;
 import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Comparator;
@@ -320,7 +321,7 @@ private static void checkReservedHistoryPeriodValidate(String reservedHistoryPer
 
         List&lt;Range&gt; reservedHistoryPeriodsToRangeList = convertStringToPeriodsList(reservedHistoryPeriods, timeUnit);
         Integer sizeOfPeriods = reservedHistoryPeriods.split("],\\[").length;
-        SimpleDateFormat sdf = getSimpleDateFormat(timeUnit);
 
         if (reservedHistoryPeriodsToRangeList.size() != sizeOfPeriods) {
             ErrorReport.reportDdlException(ErrorCode.ERROR_DYNAMIC_PARTITION_RESERVED_HISTORY_PERIODS_INVALID,
@@ -338,7 +339,7 @@ private static void checkReservedHistoryPeriodValidate(String reservedHistoryPer
                                 + " \"[yyyy-MM-dd HH:mm:ss,yyyy-MM-dd HH:mm:ss],[...,...]\" while time_unit is HOUR.");
                     }
                 }
-            } catch (ParseException e) {
                 throw new DdlException("Invalid " + DynamicPartitionProperty.RESERVED_HISTORY_PERIODS
                         + " value. It must be like \"[yyyy-MM-dd,yyyy-MM-dd],[...,...]\""
                         + " while time_unit is DAY/WEEK/MONTH "
@@ -377,11 +378,11 @@ private static void checkStorageMedium(String storageMedium) throws DdlException
         }
     }
 
-    private static SimpleDateFormat getSimpleDateFormat(String timeUnit) {
         if (timeUnit.equalsIgnoreCase(TimeUnit.HOUR.toString())) {
-            return new SimpleDateFormat(DATETIME_FORMAT);
         } else {
-            return new SimpleDateFormat(DATE_FORMAT);
         }
     }
 
@@ -721,8 +722,10 @@ public static String getFormattedPartitionName(TimeZone tz, String formattedDate
             formattedDateStr = formattedDateStr.substring(0, 8);
             Calendar calendar = Calendar.getInstance(tz);
             try {
-                calendar.setTime(new SimpleDateFormat("yyyyMMdd").parse(formattedDateStr));
-            } catch (ParseException e) {
                 LOG.warn("Format dynamic partition name error. Error={}", e.getMessage());
                 return formattedDateStr;
             }
@@ -756,22 +759,29 @@ public static String getPartitionRangeString(DynamicPartitionProperty property,
     public static String getHistoryPartitionRangeString(DynamicPartitionProperty dynamicPartitionProperty,
             String time, String format) throws AnalysisException {
         ZoneId zoneId = dynamicPartitionProperty.getTimeZone().toZoneId();
-        Date date = null;
         Timestamp timestamp = null;
         String timeUnit = dynamicPartitionProperty.getTimeUnit();
         DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.s").withZone(zoneId);
-        SimpleDateFormat simpleDateFormat = getSimpleDateFormat(timeUnit);
         try {
-            date = simpleDateFormat.parse(time);
-        } catch (ParseException e) {
             LOG.warn("Parse dynamic partition periods error. Error={}", e.getMessage());
             throw new AnalysisException("Parse dynamic partition periods error. Error=" + e.getMessage());
         }
-        timestamp = new Timestamp(date.getTime());
         return getFormattedTimeWithoutMinuteSecond(
                 ZonedDateTime.parse(timestamp.toString(), dateTimeFormatter), format);
     }
 
     /**
      * return formatted string of partition range in HOUR granularity.
      * offset: The offset from the current hour. 0 means current hour, 1 means next hour, -1 last hour.
</code_before><code_after>@@ -49,13 +49,14 @@
 import org.apache.logging.log4j.Logger;
 
 import java.sql.Timestamp;
 import java.time.DayOfWeek;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
 import java.time.Month;
 import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
+import java.time.format.DateTimeParseException;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Comparator;
@@ -320,7 +321,7 @@ private static void checkReservedHistoryPeriodValidate(String reservedHistoryPer
 
         List&lt;Range&gt; reservedHistoryPeriodsToRangeList = convertStringToPeriodsList(reservedHistoryPeriods, timeUnit);
         Integer sizeOfPeriods = reservedHistoryPeriods.split("],\\[").length;
+        DateTimeFormatter sdf = getDateTimeFormatter(timeUnit);
 
         if (reservedHistoryPeriodsToRangeList.size() != sizeOfPeriods) {
             ErrorReport.reportDdlException(ErrorCode.ERROR_DYNAMIC_PARTITION_RESERVED_HISTORY_PERIODS_INVALID,
@@ -338,7 +339,7 @@ private static void checkReservedHistoryPeriodValidate(String reservedHistoryPer
                                 + " \"[yyyy-MM-dd HH:mm:ss,yyyy-MM-dd HH:mm:ss],[...,...]\" while time_unit is HOUR.");
                     }
                 }
+            } catch (DateTimeParseException e) {
                 throw new DdlException("Invalid " + DynamicPartitionProperty.RESERVED_HISTORY_PERIODS
                         + " value. It must be like \"[yyyy-MM-dd,yyyy-MM-dd],[...,...]\""
                         + " while time_unit is DAY/WEEK/MONTH "
@@ -377,11 +378,11 @@ private static void checkStorageMedium(String storageMedium) throws DdlException
         }
     }
 
+    private static DateTimeFormatter getDateTimeFormatter(String timeUnit) {
         if (timeUnit.equalsIgnoreCase(TimeUnit.HOUR.toString())) {
+            return TimeUtils.DATETIME_FORMAT;
         } else {
+            return TimeUtils.DATE_FORMAT;
         }
     }
 
@@ -721,8 +722,10 @@ public static String getFormattedPartitionName(TimeZone tz, String formattedDate
             formattedDateStr = formattedDateStr.substring(0, 8);
             Calendar calendar = Calendar.getInstance(tz);
             try {
+                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
+                calendar.setTime(Date.from(
+                        LocalDate.parse(formattedDateStr, formatter).atStartOfDay().atZone(tz.toZoneId()).toInstant()));
+            } catch (DateTimeParseException e) {
                 LOG.warn("Format dynamic partition name error. Error={}", e.getMessage());
                 return formattedDateStr;
             }
@@ -756,22 +759,29 @@ public static String getPartitionRangeString(DynamicPartitionProperty property,
     public static String getHistoryPartitionRangeString(DynamicPartitionProperty dynamicPartitionProperty,
             String time, String format) throws AnalysisException {
         ZoneId zoneId = dynamicPartitionProperty.getTimeZone().toZoneId();
+        LocalDateTime dateTime = null;
         Timestamp timestamp = null;
         String timeUnit = dynamicPartitionProperty.getTimeUnit();
         DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.s").withZone(zoneId);
         try {
+            dateTime = getDateTimeByTimeUnit(time, timeUnit);
+        } catch (DateTimeParseException e) {
             LOG.warn("Parse dynamic partition periods error. Error={}", e.getMessage());
             throw new AnalysisException("Parse dynamic partition periods error. Error=" + e.getMessage());
         }
+        timestamp = Timestamp.valueOf(dateTime);
         return getFormattedTimeWithoutMinuteSecond(
                 ZonedDateTime.parse(timestamp.toString(), dateTimeFormatter), format);
     }
 
+    private static LocalDateTime getDateTimeByTimeUnit(String time, String timeUnit) {
+        if (timeUnit.equalsIgnoreCase(TimeUnit.HOUR.toString())) {
+            return LocalDateTime.parse(time, TimeUtils.DATETIME_FORMAT);
+        } else {
+            return LocalDate.from(TimeUtils.DATE_FORMAT.parse(time)).atStartOfDay();
+        }
+    }
+
     /**
      * return formatted string of partition range in HOUR granularity.
      * offset: The offset from the current hour. 0 means current hour, 1 means next hour, -1 last hour.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>191407</refactoring_id><commit_sha>cdad7eb033d687b7a0bd4a91c3b685ca61a3a24a</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/cdad7eb033d687b7a0bd4a91c3b685ca61a3a24a</commit_link><file_path>OsmAnd/src/net/osmand/plus/voice/TTSCommandPlayerImpl.java</file_path><description>Rename Method public getTtsVoiceName() : String renamed to public getTtsVoiceUsed() : String in class net.osmand.plus.voice.TTSCommandPlayerImpl</description><code_before>@@ -65,7 +65,8 @@ public void onClick(DialogInterface dialog, int which) {
 	// TODO: We could actually remove v102 support, I am done updating all existing 35 TTS voices to v103. Hardy, July 2016
 	private static final Log log = PlatformUtil.getLog(TTSCommandPlayerImpl.class);
 	private static TextToSpeech mTts;
-	private static String ttsVoiceName = "";
 	private Context mTtsContext;
 	private HashMap&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
 	private VoiceRouter vrt;
@@ -164,7 +165,8 @@ private void initializeEngine(final Context ctx, final Activity act) {
 		}
 		if (mTts == null) {
 			mTtsContext = ctx;
-			ttsVoiceName = "";
 			ttsRequests = 0;
 			final float speechRate = cSpeechRate;
 
@@ -185,7 +187,7 @@ private void initializeEngine(final Context ctx, final Activity act) {
 				@Override
 				public void onInit(int status) {
 					if (status != TextToSpeech.SUCCESS) {
-						ttsVoiceName = "NO INIT SUCCESS";
 						internalClear();
 					} else if (mTts != null) {
 						speechAllowed = true;
@@ -201,13 +203,13 @@ public void onInit(int status) {
 										act);
 									builder.show();
 								}
-								ttsVoiceName = newLocale.getDisplayName() + ": LANG_MISSING_DATA";
-								ttsVoiceName = ttsVoiceName + "\n\n" + getVoiceUsed();
 								break;
 							case TextToSpeech.LANG_AVAILABLE:
-								ttsVoiceName = newLocale.getDisplayName() + ": LANG_AVAILABLE";
 							case TextToSpeech.LANG_COUNTRY_AVAILABLE:
-								ttsVoiceName = "".equals(ttsVoiceName) ? newLocale.getDisplayName() + ": LANG_COUNTRY_AVAILABLE" : ttsVoiceName;
 							case TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE:
 								try {
 									mTts.setLanguage(newLocale);
@@ -218,8 +220,8 @@ public void onInit(int status) {
 								if(speechRate != 1) {
 									mTts.setSpeechRate(speechRate);
 								}
-								ttsVoiceName = "".equals(ttsVoiceName) ? newLocale.getDisplayName() + ": LANG_COUNTRY_VAR_AVAILABLE" : ttsVoiceName;
-								ttsVoiceName = ttsVoiceName + "\n\n" + getVoiceUsed();
 								break;
 							case TextToSpeech.LANG_NOT_SUPPORTED:
 								//maybe weird, but I didn't want to introduce parameter in around 5 methods just to do this if condition
@@ -234,8 +236,8 @@ public void onInit(int status) {
 											act);
 									builder.show();
 								}
-								ttsVoiceName = newLocale.getDisplayName() + ": LANG_NOT_SUPPORTED";
-								ttsVoiceName = ttsVoiceName + "\n\n" + getVoiceUsed();
 								break;
 						}
 					}
@@ -275,8 +277,12 @@ public synchronized void onUtteranceCompleted(String utteranceId) {
 		}
 	}
 
-	public static String getTtsVoiceName() {
-		return ttsVoiceName;
 	}
 
 	private AlertDialog.Builder createAlertDialog(int titleResID, int messageResID,
@@ -299,7 +305,8 @@ private void internalClear() {
 		}
 		abandonAudioFocus();
 		mTtsContext = null;
-		ttsVoiceName = "";
 	}
 	
 	@Override
</code_before><code_after>@@ -65,7 +65,8 @@ public void onClick(DialogInterface dialog, int which) {
 	// TODO: We could actually remove v102 support, I am done updating all existing 35 TTS voices to v103. Hardy, July 2016
 	private static final Log log = PlatformUtil.getLog(TTSCommandPlayerImpl.class);
 	private static TextToSpeech mTts;
+	private static String ttsVoiceStatus = "";
+	private static String ttsVoiceUsed = "";
 	private Context mTtsContext;
 	private HashMap&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
 	private VoiceRouter vrt;
@@ -164,7 +165,8 @@ private void initializeEngine(final Context ctx, final Activity act) {
 		}
 		if (mTts == null) {
 			mTtsContext = ctx;
+			ttsVoiceStatus = "";
+			ttsVoiceUsed = "";
 			ttsRequests = 0;
 			final float speechRate = cSpeechRate;
 
@@ -185,7 +187,7 @@ private void initializeEngine(final Context ctx, final Activity act) {
 				@Override
 				public void onInit(int status) {
 					if (status != TextToSpeech.SUCCESS) {
+						ttsVoiceStatus = "NO INIT SUCCESS";
 						internalClear();
 					} else if (mTts != null) {
 						speechAllowed = true;
@@ -201,13 +203,13 @@ public void onInit(int status) {
 										act);
 									builder.show();
 								}
+								ttsVoiceStatus = newLocale.getDisplayName() + ": LANG_MISSING_DATA";
+								ttsVoiceUsed = getTtsVoiceUsed();
 								break;
 							case TextToSpeech.LANG_AVAILABLE:
+								ttsVoiceStatus = newLocale.getDisplayName() + ": LANG_AVAILABLE";
 							case TextToSpeech.LANG_COUNTRY_AVAILABLE:
+								ttsVoiceStatus = "".equals(ttsVoiceStatus) ? newLocale.getDisplayName() + ": LANG_COUNTRY_AVAILABLE" : ttsVoiceStatus;
 							case TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE:
 								try {
 									mTts.setLanguage(newLocale);
@@ -218,8 +220,8 @@ public void onInit(int status) {
 								if(speechRate != 1) {
 									mTts.setSpeechRate(speechRate);
 								}
+								ttsVoiceStatus = "".equals(ttsVoiceStatus) ? newLocale.getDisplayName() + ": LANG_COUNTRY_VAR_AVAILABLE" : ttsVoiceStatus;
+								ttsVoiceUsed = getTtsVoiceUsed();
 								break;
 							case TextToSpeech.LANG_NOT_SUPPORTED:
 								//maybe weird, but I didn't want to introduce parameter in around 5 methods just to do this if condition
@@ -234,8 +236,8 @@ public void onInit(int status) {
 											act);
 									builder.show();
 								}
+								ttsVoiceStatus = newLocale.getDisplayName() + ": LANG_NOT_SUPPORTED";
+								ttsVoiceUsed = getTtsVoiceUsed();
 								break;
 						}
 					}
@@ -275,8 +277,12 @@ public synchronized void onUtteranceCompleted(String utteranceId) {
 		}
 	}
 
+	public static String getTtsVoiceStatus() {
+		return ttsVoiceStatus;
+	}
+
+	public static String getTtsVoiceUsed() {
+		return ttsVoiceUsed;
 	}
 
 	private AlertDialog.Builder createAlertDialog(int titleResID, int messageResID,
@@ -299,7 +305,8 @@ private void internalClear() {
 		}
 		abandonAudioFocus();
 		mTtsContext = null;
+		ttsVoiceStatus = "";
+		ttsVoiceUsed = "";
 	}
 	
 	@Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>213960</refactoring_id><commit_sha>4d607b5a594bbf2be76626200d989a9e65ba3da9</commit_sha><commit_link>https://github.com/apache/beam/commit/4d607b5a594bbf2be76626200d989a9e65ba3da9</commit_link><file_path>examples/java8/src/main/java/org/apache/beam/examples/complete/game/LeaderBoard.java</file_path><description>Rename Method public apply(infos PCollection&lt;GameActionInfo&gt;) : PCollection&lt;KV&lt;String,Integer&gt;&gt; renamed to public expand(infos PCollection&lt;GameActionInfo&gt;) : PCollection&lt;KV&lt;String,Integer&gt;&gt; in class org.apache.beam.examples.complete.game.LeaderBoard.CalculateTeamScores</description><code_before>@@ -234,7 +234,7 @@ static class CalculateTeamScores
     }
 
     @Override
-    public PCollection&lt;KV&lt;String, Integer&gt;&gt; apply(PCollection&lt;GameActionInfo&gt; infos) {
       return infos.apply("LeaderboardTeamFixedWindows",
           Window.&lt;GameActionInfo&gt;into(FixedWindows.of(teamWindowDuration))
               // We will get early (speculative) results as well as cumulative
@@ -267,7 +267,7 @@ static class CalculateUserScores
     }
 
     @Override
-    public PCollection&lt;KV&lt;String, Integer&gt;&gt; apply(PCollection&lt;GameActionInfo&gt; input) {
       return input.apply("LeaderboardUserGlobalWindow",
           Window.&lt;GameActionInfo&gt;into(new GlobalWindows())
               // Get periodic results every ten minutes.
</code_before><code_after>@@ -234,7 +234,7 @@ static class CalculateTeamScores
     }
 
     @Override
+    public PCollection&lt;KV&lt;String, Integer&gt;&gt; expand(PCollection&lt;GameActionInfo&gt; infos) {
       return infos.apply("LeaderboardTeamFixedWindows",
           Window.&lt;GameActionInfo&gt;into(FixedWindows.of(teamWindowDuration))
               // We will get early (speculative) results as well as cumulative
@@ -267,7 +267,7 @@ static class CalculateUserScores
     }
 
     @Override
+    public PCollection&lt;KV&lt;String, Integer&gt;&gt; expand(PCollection&lt;GameActionInfo&gt; input) {
       return input.apply("LeaderboardUserGlobalWindow",
           Window.&lt;GameActionInfo&gt;into(new GlobalWindows())
               // Get periodic results every ten minutes.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>207774</refactoring_id><commit_sha>f6735f8cc98ce6d44d635ca3adf6cc66444b2ccf</commit_sha><commit_link>https://github.com/netty/netty/commit/f6735f8cc98ce6d44d635ca3adf6cc66444b2ccf</commit_link><file_path>transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java</file_path><description>Rename Method package active(channel AsynchronousServerSocketChannel) : void renamed to package assign(channel AsynchronousServerSocketChannel) : void in class io.netty.channel.socket.aio.AioServerSocketChannelConfig</description><code_before>@@ -45,9 +45,18 @@ final class AioServerSocketChannelConfig extends DefaultChannelConfig
     private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;
     private static final boolean DEFAULT_SO_REUSEADDR = false;
 
     AioServerSocketChannelConfig() {
     }
 
     AioServerSocketChannelConfig(AsynchronousServerSocketChannel channel) {
         this.channel.set(channel);
     }
@@ -131,6 +140,7 @@ public ServerSocketChannelConfig setBacklog(int backlog) {
         return this;
     }
 
     private Object getOption(SocketOption option, Object defaultValue) {
         if (channel.get() == null) {
             Object value = options.get(option);
@@ -148,6 +158,7 @@ private Object getOption(SocketOption option, Object defaultValue) {
         }
     }
 
     private void setOption(SocketOption option, Object defaultValue) {
         if (channel.get() == null) {
             options.put(option, defaultValue);
@@ -160,7 +171,10 @@ private void setOption(SocketOption option, Object defaultValue) {
         }
     }
 
-    void active(AsynchronousServerSocketChannel channel) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }
@@ -169,6 +183,7 @@ void active(AsynchronousServerSocketChannel channel) {
         }
     }
 
     private void propagateOptions() {
         for (SocketOption option: options.keySet()) {
             Object value = options.remove(option);
</code_before><code_after>@@ -45,9 +45,18 @@ final class AioServerSocketChannelConfig extends DefaultChannelConfig
     private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;
     private static final boolean DEFAULT_SO_REUSEADDR = false;
 
+    /**
+     * Creates a new instance with no {@link AsynchronousServerSocketChannel} assigned to it.
+     *
+     * You should call {@link #assign(AsynchronousServerSocketChannel)} to assign a
+     * {@link AsynchronousServerSocketChannel} to it and have the configuration set on it.
+     */
     AioServerSocketChannelConfig() {
     }
 
+    /**
+     * Creates a new instance with the given {@link AsynchronousServerSocketChannel} assigned to it.
+     */
     AioServerSocketChannelConfig(AsynchronousServerSocketChannel channel) {
         this.channel.set(channel);
     }
@@ -131,6 +140,7 @@ public ServerSocketChannelConfig setBacklog(int backlog) {
         return this;
     }
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     private Object getOption(SocketOption option, Object defaultValue) {
         if (channel.get() == null) {
             Object value = options.get(option);
@@ -148,6 +158,7 @@ private Object getOption(SocketOption option, Object defaultValue) {
         }
     }
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     private void setOption(SocketOption option, Object defaultValue) {
         if (channel.get() == null) {
             options.put(option, defaultValue);
@@ -160,7 +171,10 @@ private void setOption(SocketOption option, Object defaultValue) {
         }
     }
 
+    /**
+     * Assing the given {@link AsynchronousServerSocketChannel} to this instance
+     */
+    void assign(AsynchronousServerSocketChannel channel) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }
@@ -169,6 +183,7 @@ void active(AsynchronousServerSocketChannel channel) {
         }
     }
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     private void propagateOptions() {
         for (SocketOption option: options.keySet()) {
             Object value = options.remove(option);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>209057</refactoring_id><commit_sha>4793291123abc0c7f9929814dd26e6c292d286c7</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/4793291123abc0c7f9929814dd26e6c292d286c7</commit_link><file_path>tests/src/test/java/alluxio/worker/block/BlockWorkerClientRestApiTest.java</file_path><description>Rename Method public unlockBlockTest() : void renamed to public unlockBlock() : void in class alluxio.worker.block.BlockWorkerClientRestApiTest</description><code_before>@@ -56,19 +56,19 @@ public void before() throws Exception {
   }
 
   @Test
-  public void serviceNameTest() throws Exception {
     new TestCase(mHostname, mPort, getEndpoint(BlockWorkerClientRestServiceHandler.SERVICE_NAME),
         NO_PARAMS, HttpMethod.GET, Constants.BLOCK_WORKER_CLIENT_SERVICE_NAME).run();
   }
 
   @Test
-  public void serviceVersionTest() throws Exception {
     new TestCase(mHostname, mPort, getEndpoint(BlockWorkerClientRestServiceHandler.SERVICE_VERSION),
         NO_PARAMS, HttpMethod.GET, Constants.BLOCK_WORKER_CLIENT_SERVICE_VERSION).run();
   }
 
   @Test
-  public void accessBlockTest() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -80,7 +80,7 @@ public void accessBlockTest() throws Exception {
   }
 
   @Test
-  public void asyncCheckpointTest() throws Exception {
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
     params.put("fileId", "1");
 
@@ -90,7 +90,7 @@ public void asyncCheckpointTest() throws Exception {
   }
 
   @Test
-  public void cacheBlockTest() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -103,7 +103,7 @@ public void cacheBlockTest() throws Exception {
   }
 
   @Test
-  public void cancelBlockTest() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
 
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
@@ -114,7 +114,7 @@ public void cancelBlockTest() throws Exception {
   }
 
   @Test
-  public void lockBlockTest() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -130,7 +130,7 @@ public void lockBlockTest() throws Exception {
   }
 
   @Test
-  public void promoteBlockTest() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -141,7 +141,7 @@ public void promoteBlockTest() throws Exception {
   }
 
   @Test
-  public void readBlockTest() throws Exception {
     // Write a block and acquire a lock for it.
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     BlockWriter writer = mBlockWorker.getTempBlockWriterRemote(SESSION_ID, BLOCK_ID);
@@ -170,7 +170,7 @@ public void readBlockTest() throws Exception {
   }
 
   @Test
-  public void requestBlockLocationTest() throws Exception {
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
     params.put("blockId", "1");
     params.put("sessionId", "1");
@@ -182,7 +182,7 @@ public void requestBlockLocationTest() throws Exception {
   }
 
   @Test
-  public void requestSpaceTest() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
 
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
@@ -194,7 +194,7 @@ public void requestSpaceTest() throws Exception {
   }
 
   @Test
-  public void unlockBlockTest() throws Exception {
     // Write a block and acquire a lock for it.
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     BlockWriter writer = mBlockWorker.getTempBlockWriterRemote(SESSION_ID, BLOCK_ID);
@@ -213,7 +213,7 @@ public void unlockBlockTest() throws Exception {
   }
 
   @Test
-  public void writeBlockTest() throws Exception {
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
     params.put("blockId", Long.toString(BLOCK_ID));
     params.put("sessionId", Long.toString(SESSION_ID));
</code_before><code_after>@@ -56,19 +56,19 @@ public void before() throws Exception {
   }
 
   @Test
+  public void serviceName() throws Exception {
     new TestCase(mHostname, mPort, getEndpoint(BlockWorkerClientRestServiceHandler.SERVICE_NAME),
         NO_PARAMS, HttpMethod.GET, Constants.BLOCK_WORKER_CLIENT_SERVICE_NAME).run();
   }
 
   @Test
+  public void serviceVersion() throws Exception {
     new TestCase(mHostname, mPort, getEndpoint(BlockWorkerClientRestServiceHandler.SERVICE_VERSION),
         NO_PARAMS, HttpMethod.GET, Constants.BLOCK_WORKER_CLIENT_SERVICE_VERSION).run();
   }
 
   @Test
+  public void accessBlock() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -80,7 +80,7 @@ public void accessBlockTest() throws Exception {
   }
 
   @Test
+  public void asyncCheckpoint() throws Exception {
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
     params.put("fileId", "1");
 
@@ -90,7 +90,7 @@ public void asyncCheckpointTest() throws Exception {
   }
 
   @Test
+  public void cacheBlock() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -103,7 +103,7 @@ public void cacheBlockTest() throws Exception {
   }
 
   @Test
+  public void cancelBlock() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
 
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
@@ -114,7 +114,7 @@ public void cancelBlockTest() throws Exception {
   }
 
   @Test
+  public void lockBlock() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -130,7 +130,7 @@ public void lockBlockTest() throws Exception {
   }
 
   @Test
+  public void promoteBlock() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     mBlockWorker.commitBlock(SESSION_ID, BLOCK_ID);
 
@@ -141,7 +141,7 @@ public void promoteBlockTest() throws Exception {
   }
 
   @Test
+  public void readBlock() throws Exception {
     // Write a block and acquire a lock for it.
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     BlockWriter writer = mBlockWorker.getTempBlockWriterRemote(SESSION_ID, BLOCK_ID);
@@ -170,7 +170,7 @@ public void readBlockTest() throws Exception {
   }
 
   @Test
+  public void requestBlockLocation() throws Exception {
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
     params.put("blockId", "1");
     params.put("sessionId", "1");
@@ -182,7 +182,7 @@ public void requestBlockLocationTest() throws Exception {
   }
 
   @Test
+  public void requestSpace() throws Exception {
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
 
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
@@ -194,7 +194,7 @@ public void requestSpaceTest() throws Exception {
   }
 
   @Test
+  public void unlockBlock() throws Exception {
     // Write a block and acquire a lock for it.
     mBlockWorker.createBlock(SESSION_ID, BLOCK_ID, TIER_ALIAS, INITIAL_BYTES);
     BlockWriter writer = mBlockWorker.getTempBlockWriterRemote(SESSION_ID, BLOCK_ID);
@@ -213,7 +213,7 @@ public void unlockBlockTest() throws Exception {
   }
 
   @Test
+  public void writeBlock() throws Exception {
     Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
     params.put("blockId", Long.toString(BLOCK_ID));
     params.put("sessionId", Long.toString(SESSION_ID));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>185049</refactoring_id><commit_sha>61ec8d1bec3c8281a12e17c4498816d945c72058</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/61ec8d1bec3c8281a12e17c4498816d945c72058</commit_link><file_path>src/main/java/com/google/devtools/build/lib/analysis/configuredtargets/FileConfiguredTarget.java</file_path><description>Rename Method protected rawGetSkylarkProvider(providerKey String) : Object renamed to protected rawGetStarlarkProvider(providerKey String) : Object in class com.google.devtools.build.lib.analysis.configuredtargets.FileConfiguredTarget</description><code_before>@@ -113,12 +113,12 @@ public &lt;P extends TransitiveInfoProvider&gt; P getProvider(Class&lt;P&gt; provider) {
   }
 
   @Override
-  protected Info rawGetSkylarkProvider(Provider.Key providerKey) {
     return providers.get(providerKey);
   }
 
   @Override
-  protected Object rawGetSkylarkProvider(String providerKey) {
     return providers.get(providerKey);
   }
 }
</code_before><code_after>@@ -113,12 +113,12 @@ public &lt;P extends TransitiveInfoProvider&gt; P getProvider(Class&lt;P&gt; provider) {
   }
 
   @Override
+  protected Info rawGetStarlarkProvider(Provider.Key providerKey) {
     return providers.get(providerKey);
   }
 
   @Override
+  protected Object rawGetStarlarkProvider(String providerKey) {
     return providers.get(providerKey);
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>221512</refactoring_id><commit_sha>887fcb7ecf203286e1f666f317e30c11c08b9d33</commit_sha><commit_link>https://github.com/liquibase/liquibase/commit/887fcb7ecf203286e1f666f317e30c11c08b9d33</commit_link><file_path>src/java/liquibase/migrator/change/ModifyColumnChange.java</file_path><description>Rename Method public generateStatement(database AbstractDatabase) : String renamed to public generateStatements(database MSSQLDatabase) : String[] in class liquibase.migrator.change.ModifyColumnChange</description><code_before>@@ -1,13 +1,11 @@
 package liquibase.migrator.change;
 
-import liquibase.database.AbstractDatabase;
-import liquibase.database.struture.Column;
-import liquibase.database.struture.DatabaseStructure;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
-import java.util.Set;
-
 public class ModifyColumnChange extends AbstractChange {
 
     private String tableName;
@@ -33,23 +31,28 @@ public void setColumn(ColumnConfig column) {
         this.column = column;
     }
 
-    public String generateStatement(AbstractDatabase database) {
-        StringBuffer buffer = new StringBuffer();
-        buffer.append("alter table ").append(getTableName());
-        buffer.append(" modify (");
-        //buffer.append(" (");
-        buffer.append(getColumn().getName()).append(" ");
-        buffer.append(getColumn().getType());
-        buffer.append(")");
-        return buffer.toString();
     }
 
-    public String getConfirmationMessage() {
-        return "Column with the name " + column.getName() + " has been modified.";
     }
 
-    public boolean isApplicableTo(Set&lt;DatabaseStructure&gt; selectedDatabaseStructures) {
-        return selectedDatabaseStructures.size() == 1 &amp;&amp; (selectedDatabaseStructures.iterator().next() instanceof Column);
     }
 
     public Element createNode(Document currentMigrationFileDOM) {
</code_before><code_after>@@ -1,13 +1,11 @@
 package liquibase.migrator.change;
 
+import liquibase.database.*;
+import liquibase.migrator.UnsupportedChangeException;
+import liquibase.migrator.RollbackImpossibleException;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 public class ModifyColumnChange extends AbstractChange {
 
     private String tableName;
@@ -33,23 +31,28 @@ public void setColumn(ColumnConfig column) {
         this.column = column;
     }
 
+    private String[] generateStatements() {
+        return new String[] { "ALTER TABLE " + getTableName() + " MODIFY (" + getColumn().getName() + " " + getColumn().getType() + ")" };
     }
 
+    public String[] generateStatements(MSSQLDatabase database) {
+        return generateStatements();
     }
 
+    public String[] generateStatements(OracleDatabase database) {
+        return generateStatements();
+    }
+
+    public String[] generateStatements(MySQLDatabase database) {
+        return generateStatements();
+    }
+
+    public String[] generateStatements(PostgresDatabase database) {
+        return generateStatements();
+    }
+
+    public String getConfirmationMessage() {
+        return "Column with the name " + column.getName() + " has been modified.";
     }
 
     public Element createNode(Document currentMigrationFileDOM) {
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>218574</refactoring_id><commit_sha>febd5a8a13b30ee7b69b539c188ef064603ea46f</commit_sha><commit_link>https://github.com/teammates/teammates/commit/febd5a8a13b30ee7b69b539c188ef064603ea46f</commit_link><file_path>src/main/java/teammates/common/util/Config.java</file_path><description>Rename Method private getStudentBannerUrl() : String renamed to private getStudentMotdUrl() : String in class teammates.common.util.Config</description><code_before>@@ -37,8 +37,8 @@ public class Config {
     /** The value of the "app.crashreport.email" in build.properties file */
     public static String SUPPORT_EMAIL;
     
-    /** The value of the "app.crashreport.email" in build.properties file */
-    public static String STUDENT_BANNER_URL;
 
     public static Config inst() {
         if (instance == null) {
@@ -79,7 +79,7 @@ private static void initProperties(){
         ENCRYPTION_KEY = instance.getEncyptionKey();
         PERSISTENCE_CHECK_DURATION = instance.getPersistenceCheckduration();
         SUPPORT_EMAIL = instance.getSupportEmail();
-        STUDENT_BANNER_URL = instance.getStudentBannerUrl();
     }
 
     private String getGcsBucketname() {
@@ -106,8 +106,8 @@ private String getSupportEmail() {
         return props.getProperty("app.crashreport.email");
     }
 
-    private String getStudentBannerUrl() {
-        return props.getProperty("app.student.bannerurl");
     }
 
 }
\ No newline at end of file
</code_before><code_after>@@ -37,8 +37,8 @@ public class Config {
     /** The value of the "app.crashreport.email" in build.properties file */
     public static String SUPPORT_EMAIL;
     
+    /** The value of the "app.student.motd.url" in build.properties file */
+    public static String STUDENT_MOTD_URL;
 
     public static Config inst() {
         if (instance == null) {
@@ -79,7 +79,7 @@ private static void initProperties(){
         ENCRYPTION_KEY = instance.getEncyptionKey();
         PERSISTENCE_CHECK_DURATION = instance.getPersistenceCheckduration();
         SUPPORT_EMAIL = instance.getSupportEmail();
+        STUDENT_MOTD_URL = instance.getStudentMotdUrl();
     }
 
     private String getGcsBucketname() {
@@ -106,8 +106,8 @@ private String getSupportEmail() {
         return props.getProperty("app.crashreport.email");
     }
 
+    private String getStudentMotdUrl() {
+        return props.getProperty("app.student.motd.url");
     }
 
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>133992</refactoring_id><commit_sha>8c5818a46e55e941fc4927b6fbaf71528ea5e5dc</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/8c5818a46e55e941fc4927b6fbaf71528ea5e5dc</commit_link><file_path>quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/integration/web/QuarkusRequestFilter.java</file_path><description>Rename Method private createBlockingHandler(context RoutingContext) : Runnable renamed to private runBlockingCode(context RoutingContext) : void in class org.keycloak.quarkus.runtime.integration.web.QuarkusRequestFilter</description><code_before>@@ -17,7 +17,6 @@
 
 package org.keycloak.quarkus.runtime.integration.web;
 
-import java.util.concurrent.ExecutorService;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Predicate;
@@ -53,17 +52,14 @@ public class QuarkusRequestFilter implements Handler&lt;RoutingContext&gt;, Transactio
 
     private final Logger logger = Logger.getLogger(QuarkusRequestFilter.class);
 
-    private final ExecutorService executor;
-
-    private Predicate&lt;RoutingContext&gt; contextFilter;
 
     public QuarkusRequestFilter() {
-        this(null, null);
     }
 
-    public QuarkusRequestFilter(Predicate&lt;RoutingContext&gt; contextFilter, ExecutorService executor) {
         this.contextFilter = contextFilter;
-        this.executor = executor;
     }
 
     private final LongAdder rejectedRequests = new LongAdder();
@@ -78,7 +74,18 @@ public void handle(RoutingContext context) {
         // our code should always be run as blocking until we don't provide a better support for running non-blocking code
         // in the event loop
         try {
-            executor.execute(createBlockingHandler(context));
             if (loadSheddingActive) {
                 synchronized (rejectedRequests) {
                     if (loadSheddingActive) {
@@ -107,22 +114,20 @@ private boolean ignoreContext(RoutingContext context) {
         return contextFilter != null &amp;&amp; contextFilter.test(context);
     }
 
-    private Runnable createBlockingHandler(RoutingContext context) {
-        return () -&gt; {
-            KeycloakSession session = configureContextualData(context);
-
-            try {
-                context.next();
-            } catch (Throwable cause) {
-                // re-throw so that the any exception is handled from parent
-                throw new RuntimeException(cause);
-            } finally {
-                // force closing the session if not already closed
-                // under some circumstances resteasy might not be invoked like when no route is found for a particular path
-                // in this case context is set with status code 404, and we need to close the session
-                close(session);
-            }
-        };
     }
 
     private KeycloakSession configureContextualData(RoutingContext context) {
</code_before><code_after>@@ -17,7 +17,6 @@
 
 package org.keycloak.quarkus.runtime.integration.web;
 
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Predicate;
@@ -53,17 +52,14 @@ public class QuarkusRequestFilter implements Handler&lt;RoutingContext&gt;, Transactio
 
     private final Logger logger = Logger.getLogger(QuarkusRequestFilter.class);
 
+    private final Predicate&lt;RoutingContext&gt; contextFilter;
 
     public QuarkusRequestFilter() {
+        this(null);
     }
 
+    public QuarkusRequestFilter(Predicate&lt;RoutingContext&gt; contextFilter) {
         this.contextFilter = contextFilter;
     }
 
     private final LongAdder rejectedRequests = new LongAdder();
@@ -78,7 +74,18 @@ public void handle(RoutingContext context) {
         // our code should always be run as blocking until we don't provide a better support for running non-blocking code
         // in the event loop
         try {
+            // When running in Quarkus dev mode, this will run on Vert.x default worker pool.
+            // When running in Quarkus production mode, this will run on the Quarkus executor pool.
+            // It should not call the Quarkus executor directly, as this prevents metrics for `worker_pool_*` to be collected.
+            // See https://github.com/quarkusio/quarkus/issues/34998 for a discussion.
+            context.vertx().executeBlocking(ctx -&gt; {
+                try {
+                    runBlockingCode(context);
+                    ctx.complete();
+                } catch (Throwable ex) {
+                    ctx.fail(ex);
+                }
+            }, false, null);
             if (loadSheddingActive) {
                 synchronized (rejectedRequests) {
                     if (loadSheddingActive) {
@@ -107,22 +114,20 @@ private boolean ignoreContext(RoutingContext context) {
         return contextFilter != null &amp;&amp; contextFilter.test(context);
     }
 
+    private void runBlockingCode(RoutingContext context) {
+        KeycloakSession session = configureContextualData(context);
+
+        try {
+            context.next();
+        } catch (Throwable cause) {
+            // re-throw so that the any exception is handled from parent
+            throw new RuntimeException(cause);
+        } finally {
+            // force closing the session if not already closed
+            // under some circumstances resteasy might not be invoked like when no route is found for a particular path
+            // in this case context is set with status code 404, and we need to close the session
+            close(session);
+        }
     }
 
     private KeycloakSession configureContextualData(RoutingContext context) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>305543</refactoring_id><commit_sha>4d8dc8bf3e75bcfef51c1bd104bed855e57b53bb</commit_sha><commit_link>https://github.com/flowable/flowable-engine/commit/4d8dc8bf3e75bcfef51c1bd104bed855e57b53bb</commit_link><file_path>modules/activiti-engine/src/test/java/org/activiti/engine/test/bpmn/async/AsyncTaskTest.java</file_path><description>Rename Method public testBasicAsycCallActivity() : void renamed to public testBasicAsyncCallActivity() : void in class org.activiti.engine.test.bpmn.async.AsyncTaskTest</description><code_before>@@ -31,7 +31,7 @@ public class AsyncTaskTest extends PluggableActivitiTestCase {
   public static boolean INVOCATION;
   
   @Deployment
-  public void testAsycServiceNoListeners() {  
     INVOCATION = false;
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
@@ -49,7 +49,7 @@ public void testAsycServiceNoListeners() {
   }
   
   @Deployment
-  public void testAsycServiceListeners() {  
     String pid = runtimeService.startProcessInstanceByKey("asyncService").getProcessInstanceId();
     assertEquals(1, managementService.createJobQuery().count());
     // the listener was not yet invoked:
@@ -61,7 +61,7 @@ public void testAsycServiceListeners() {
   }
   
   @Deployment
-  public void testAsycServiceConcurrent() {  
     INVOCATION = false;
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
@@ -98,17 +98,22 @@ public void testAsyncServiceMultiInstance() {
   
 
   @Deployment
-  public void testFailingAsycServiceTimer() { 
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
     // now there should be one job in the database, and it is a message
     assertEquals(1, managementService.createJobQuery().count());
     Job job = managementService.createJobQuery().singleResult();
-    if(!(job instanceof MessageEntity)) {
       fail("the job must be a message");
     }      
     
-    waitForJobExecutorToProcessAllJobs(10000L, 100L);
     
     // the service failed: the execution is still sitting in the service task:
     Execution execution = runtimeService.createExecutionQuery().singleResult();
@@ -153,7 +158,7 @@ public void FAILING_testFailingAsycServiceTimer() {
   }
   
   @Deployment
-  public void testAsycServiceSubProcessTimer() { 
     INVOCATION = false;
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
@@ -172,7 +177,7 @@ public void testAsycServiceSubProcessTimer() {
   }
   
   @Deployment
-  public void testAsycServiceSubProcess() {    
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
 
@@ -186,7 +191,7 @@ public void testAsycServiceSubProcess() {
   }
 
   @Deployment
-  public void testAsycTask() {  
     // start process 
     runtimeService.startProcessInstanceByKey("asyncTask");
     // now there should be one job in the database:
@@ -199,7 +204,7 @@ public void testAsycTask() {
   }
 
   @Deployment
-  public void testAsycScript() {  
     // start process 
     runtimeService.startProcessInstanceByKey("asyncScript").getProcessInstanceId();
     // now there should be one job in the database:
@@ -219,8 +224,8 @@ public void testAsycScript() {
     runtimeService.signal(eid);        
   }
   
-  @Deployment(resources={"org/activiti/engine/test/bpmn/async/AsyncTaskTest.testAsycCallActivity.bpmn20.xml", 
-          "org/activiti/engine/test/bpmn/async/AsyncTaskTest.testAsycServiceNoListeners.bpmn20.xml"})
   public void testAsyncCallActivity() throws Exception {  
     // start process 
     runtimeService.startProcessInstanceByKey("asyncCallactivity");
@@ -233,12 +238,12 @@ public void testAsyncCallActivity() throws Exception {
     assertEquals(0, runtimeService.createProcessInstanceQuery().count());
   }
 
-  @Deployment(resources = {"org/activiti/engine/test/bpmn/async/AsyncTaskTest.testBasicAsycCallActivity.bpmn20.xml",
             "org/activiti/engine/test/bpmn/StartToEndTest.testStartToEnd.bpmn20.xml"})
-  public void testBasicAsycCallActivity() {
     runtimeService.startProcessInstanceByKey("myProcess");
     Assert.assertEquals("There should be one job available.", 1, managementService.createJobQuery().count());
-    waitForJobExecutorToProcessAllJobs(10000L, 100L);
     assertEquals(0, managementService.createJobQuery().count());
   }
   
@@ -255,7 +260,7 @@ public void testAsyncUserTask() {
     // there is no usertask
     assertNull(taskService.createTaskQuery().singleResult());
         
-    waitForJobExecutorToProcessAllJobs(10000L, 100L);
     // the listener was now invoked:
     assertNotNull(runtimeService.getVariable(pid, "listener"));
     // the task listener was now invoked:
</code_before><code_after>@@ -31,7 +31,7 @@ public class AsyncTaskTest extends PluggableActivitiTestCase {
   public static boolean INVOCATION;
   
   @Deployment
+  public void testAsyncServiceNoListeners() {  
     INVOCATION = false;
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
@@ -49,7 +49,7 @@ public void testAsycServiceNoListeners() {
   }
   
   @Deployment
+  public void testAsyncServiceListeners() {  
     String pid = runtimeService.startProcessInstanceByKey("asyncService").getProcessInstanceId();
     assertEquals(1, managementService.createJobQuery().count());
     // the listener was not yet invoked:
@@ -61,7 +61,7 @@ public void testAsycServiceListeners() {
   }
   
   @Deployment
+  public void testAsyncServiceConcurrent() {  
     INVOCATION = false;
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
@@ -98,17 +98,22 @@ public void testAsyncServiceMultiInstance() {
   
 
   @Deployment
+  public void testFailingAsyncServiceTimer() { 
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
     // now there should be one job in the database, and it is a message
     assertEquals(1, managementService.createJobQuery().count());
     Job job = managementService.createJobQuery().singleResult();
+    if (!(job instanceof MessageEntity)) {
       fail("the job must be a message");
     }      
     
+    try {
+      managementService.executeJob(job.getId());
+      fail();
+    } catch (Exception e) {
+      // exception expected
+    }
     
     // the service failed: the execution is still sitting in the service task:
     Execution execution = runtimeService.createExecutionQuery().singleResult();
@@ -153,7 +158,7 @@ public void FAILING_testFailingAsycServiceTimer() {
   }
   
   @Deployment
+  public void testAsyncServiceSubProcessTimer() { 
     INVOCATION = false;
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
@@ -172,7 +177,7 @@ public void testAsycServiceSubProcessTimer() {
   }
   
   @Deployment
+  public void testAsyncServiceSubProcess() {    
     // start process 
     runtimeService.startProcessInstanceByKey("asyncService");
 
@@ -186,7 +191,7 @@ public void testAsycServiceSubProcess() {
   }
 
   @Deployment
+  public void testAsyncTask() {  
     // start process 
     runtimeService.startProcessInstanceByKey("asyncTask");
     // now there should be one job in the database:
@@ -199,7 +204,7 @@ public void testAsycTask() {
   }
 
   @Deployment
+  public void testAsyncScript() {  
     // start process 
     runtimeService.startProcessInstanceByKey("asyncScript").getProcessInstanceId();
     // now there should be one job in the database:
@@ -219,8 +224,8 @@ public void testAsycScript() {
     runtimeService.signal(eid);        
   }
   
+  @Deployment(resources={"org/activiti/engine/test/bpmn/async/AsyncTaskTest.testAsyncCallActivity.bpmn20.xml", 
+          "org/activiti/engine/test/bpmn/async/AsyncTaskTest.testAsyncServiceNoListeners.bpmn20.xml"})
   public void testAsyncCallActivity() throws Exception {  
     // start process 
     runtimeService.startProcessInstanceByKey("asyncCallactivity");
@@ -233,12 +238,12 @@ public void testAsyncCallActivity() throws Exception {
     assertEquals(0, runtimeService.createProcessInstanceQuery().count());
   }
 
+  @Deployment(resources = {"org/activiti/engine/test/bpmn/async/AsyncTaskTest.testBasicAsyncCallActivity.bpmn20.xml",
             "org/activiti/engine/test/bpmn/StartToEndTest.testStartToEnd.bpmn20.xml"})
+  public void testBasicAsyncCallActivity() {
     runtimeService.startProcessInstanceByKey("myProcess");
     Assert.assertEquals("There should be one job available.", 1, managementService.createJobQuery().count());
+    waitForJobExecutorToProcessAllJobs(10000L, 500L);
     assertEquals(0, managementService.createJobQuery().count());
   }
   
@@ -255,7 +260,7 @@ public void testAsyncUserTask() {
     // there is no usertask
     assertNull(taskService.createTaskQuery().singleResult());
         
+    waitForJobExecutorToProcessAllJobs(10000L, 500L);
     // the listener was now invoked:
     assertNotNull(runtimeService.getVariable(pid, "listener"));
     // the task listener was now invoked:
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>207882</refactoring_id><commit_sha>f619504fa0d9d9fcffe6ee9410e85ddb6ef86779</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/f619504fa0d9d9fcffe6ee9410e85ddb6ef86779</commit_link><file_path>servers/src/main/java/tachyon/master/file/FileSystemMasterClientServiceHandler.java</file_path><description>Rename Method public setOwner(path String, user String, recursive boolean) : boolean renamed to public setAcl(path String, options SetAclTOptions) : boolean in class tachyon.master.file.FileSystemMasterClientServiceHandler</description><code_before>@@ -22,6 +22,7 @@
 
 import tachyon.Constants;
 import tachyon.TachyonURI;
 import tachyon.client.file.options.SetStateOptions;
 import tachyon.exception.TachyonException;
 import tachyon.master.file.options.CompleteFileOptions;
@@ -33,6 +34,7 @@
 import tachyon.thrift.FileInfo;
 import tachyon.thrift.FileSystemMasterClientService;
 import tachyon.thrift.MkdirTOptions;
 import tachyon.thrift.SetStateTOptions;
 import tachyon.thrift.TachyonTException;
 import tachyon.thrift.ThriftIOException;
@@ -204,50 +206,31 @@ public boolean rename(long fileId, String dstPath)
   }
 
   @Override
-  public void setState(long fileId, SetStateTOptions options) throws TachyonTException {
-    try {
-      mFileSystemMaster.setState(fileId, new SetStateOptions(options));
-    } catch (TachyonException e) {
-      throw e.toTachyonTException();
-    }
-  }
-
-  @Override
-  public boolean unmount(String tachyonPath) throws TachyonTException, ThriftIOException {
-    try {
-      return mFileSystemMaster.unmount(new TachyonURI(tachyonPath));
-    } catch (TachyonException e) {
-      throw e.toTachyonTException();
-    } catch (IOException e) {
-      throw new ThriftIOException(e.getMessage());
-    }
-  }
-
-  @Override
-  public boolean setOwner(String path, String user, boolean recursive) throws TachyonTException {
     try {
-      return mFileSystemMaster.setOwner(new TachyonURI(path), user, recursive);
     } catch (TachyonException e) {
       throw e.toTachyonTException();
     }
   }
 
   @Override
-  public boolean setGroup(String path, String group, boolean recursive) throws TachyonTException {
     try {
-      return mFileSystemMaster.setGroup(new TachyonURI(path), group, recursive);
     } catch (TachyonException e) {
       throw e.toTachyonTException();
     }
   }
 
   @Override
-  public boolean setPermission(String path, int permission, boolean recursive) throws
-      TachyonTException {
     try {
-      return mFileSystemMaster.setPermission(new TachyonURI(path), (short) permission, recursive);
     } catch (TachyonException e) {
       throw e.toTachyonTException();
     }
   }
 }
</code_before><code_after>@@ -22,6 +22,7 @@
 
 import tachyon.Constants;
 import tachyon.TachyonURI;
+import tachyon.client.file.options.SetAclOptions;
 import tachyon.client.file.options.SetStateOptions;
 import tachyon.exception.TachyonException;
 import tachyon.master.file.options.CompleteFileOptions;
@@ -33,6 +34,7 @@
 import tachyon.thrift.FileInfo;
 import tachyon.thrift.FileSystemMasterClientService;
 import tachyon.thrift.MkdirTOptions;
+import tachyon.thrift.SetAclTOptions;
 import tachyon.thrift.SetStateTOptions;
 import tachyon.thrift.TachyonTException;
 import tachyon.thrift.ThriftIOException;
@@ -204,50 +206,31 @@ public boolean rename(long fileId, String dstPath)
   }
 
   @Override
+  public boolean setAcl(String path, SetAclTOptions options) throws TachyonTException {
     try {
+      return mFileSystemMaster.setAcl(new TachyonURI(path), new SetAclOptions(options));
     } catch (TachyonException e) {
       throw e.toTachyonTException();
     }
   }
 
   @Override
+  public void setState(long fileId, SetStateTOptions options) throws TachyonTException {
     try {
+      mFileSystemMaster.setState(fileId, new SetStateOptions(options));
     } catch (TachyonException e) {
       throw e.toTachyonTException();
     }
   }
 
   @Override
+  public boolean unmount(String tachyonPath) throws TachyonTException, ThriftIOException {
     try {
+      return mFileSystemMaster.unmount(new TachyonURI(tachyonPath));
     } catch (TachyonException e) {
       throw e.toTachyonTException();
+    } catch (IOException e) {
+      throw new ThriftIOException(e.getMessage());
     }
   }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>173336</refactoring_id><commit_sha>dd3da9ca5095006bdb8bb7ca1a1d4b74ff49d3e9</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/dd3da9ca5095006bdb8bb7ca1a1d4b74ff49d3e9</commit_link><file_path>src/main/java/mekanism/common/tile/transmitter/mechanical_pipe/TileEntityMechanicalPipe.java</file_path><description>Rename Method public update() : void renamed to public tick() : void in class mekanism.common.tile.transmitter.mechanical_pipe.TileEntityMechanicalPipe</description><code_before>@@ -57,7 +57,7 @@ public void setBaseTier(BaseTier baseTier) {
     }
 
     @Override
-    public void update() {
         if (!getWorld().isRemote) {
             updateShare();
             IFluidHandler[] connectedAcceptors = PipeUtils.getConnectedAcceptors(getPos(), getWorld());
@@ -71,7 +71,7 @@ public void update() {
                 }
             }
         }
-        super.update();
     }
 
     @Override
</code_before><code_after>@@ -57,7 +57,7 @@ public void setBaseTier(BaseTier baseTier) {
     }
 
     @Override
+    public void tick() {
         if (!getWorld().isRemote) {
             updateShare();
             IFluidHandler[] connectedAcceptors = PipeUtils.getConnectedAcceptors(getPos(), getWorld());
@@ -71,7 +71,7 @@ public void update() {
                 }
             }
         }
+        super.tick();
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>225293</refactoring_id><commit_sha>04aebce3ef7bc731988a015dfbe0bb2fff52f75f</commit_sha><commit_link>https://github.com/apache/iotdb/commit/04aebce3ef7bc731988a015dfbe0bb2fff52f75f</commit_link><file_path>node-commons/src/main/java/org/apache/iotdb/commons/conf/CommonConfig.java</file_path><description>Rename Method public isRpcThriftCompressionEnabled() : boolean renamed to public isCnRpcThriftCompressionEnabled() : boolean in class org.apache.iotdb.commons.conf.CommonConfig</description><code_before>@@ -90,7 +90,7 @@ public class CommonConfig {
    * &lt;p&gt;Notice: if this property is changed, previous created storage group which are not set TTL
    * will also be affected. Unit: millisecond
    */
-  private long defaultTTL = Long.MAX_VALUE;
 
   /** Thrift socket and connection timeout between data node and config node. */
   private int connectionTimeoutInMS = (int) TimeUnit.SECONDS.toMillis(20);
@@ -105,7 +105,7 @@ public class CommonConfig {
           : 1;
 
   /** whether to use thrift compression. */
-  private boolean isRpcThriftCompressionEnabled = false;
 
   /** What will the system do when unrecoverable error occurs. */
   private HandleSystemErrorStrategy handleSystemErrorStrategy =
@@ -238,36 +238,36 @@ public void setSystemFileStorageFs(FSType systemFileStorageFs) {
     this.systemFileStorageFs = systemFileStorageFs;
   }
 
-  public long getDefaultTTL() {
-    return defaultTTL;
   }
 
-  public void setDefaultTTL(long defaultTTL) {
-    this.defaultTTL = defaultTTL;
   }
 
-  public int getConnectionTimeoutInMS() {
     return connectionTimeoutInMS;
   }
 
-  public void setConnectionTimeoutInMS(int connectionTimeoutInMS) {
     this.connectionTimeoutInMS = connectionTimeoutInMS;
   }
 
-  public int getSelectorNumOfClientManager() {
     return selectorNumOfClientManager;
   }
 
-  public void setSelectorNumOfClientManager(int selectorNumOfClientManager) {
     this.selectorNumOfClientManager = selectorNumOfClientManager;
   }
 
-  public boolean isRpcThriftCompressionEnabled() {
-    return isRpcThriftCompressionEnabled;
   }
 
-  public void setRpcThriftCompressionEnabled(boolean rpcThriftCompressionEnabled) {
-    isRpcThriftCompressionEnabled = rpcThriftCompressionEnabled;
   }
 
   HandleSystemErrorStrategy getHandleSystemErrorStrategy() {
</code_before><code_after>@@ -90,7 +90,7 @@ public class CommonConfig {
    * &lt;p&gt;Notice: if this property is changed, previous created storage group which are not set TTL
    * will also be affected. Unit: millisecond
    */
+  private long defaultTTLInMs = Long.MAX_VALUE;
 
   /** Thrift socket and connection timeout between data node and config node. */
   private int connectionTimeoutInMS = (int) TimeUnit.SECONDS.toMillis(20);
@@ -105,7 +105,7 @@ public class CommonConfig {
           : 1;
 
   /** whether to use thrift compression. */
+  private boolean isCnRpcThriftCompressionEnabled = false;
 
   /** What will the system do when unrecoverable error occurs. */
   private HandleSystemErrorStrategy handleSystemErrorStrategy =
@@ -238,36 +238,36 @@ public void setSystemFileStorageFs(FSType systemFileStorageFs) {
     this.systemFileStorageFs = systemFileStorageFs;
   }
 
+  public long getDefaultTTLInMs() {
+    return defaultTTLInMs;
   }
 
+  public void setDefaultTTLInMs(long defaultTTLInMs) {
+    this.defaultTTLInMs = defaultTTLInMs;
   }
 
+  public int getCnConnectionTimeoutInMS() {
     return connectionTimeoutInMS;
   }
 
+  public void setCnConnectionTimeoutInMS(int connectionTimeoutInMS) {
     this.connectionTimeoutInMS = connectionTimeoutInMS;
   }
 
+  public int getCnSelectorNumOfClientManager() {
     return selectorNumOfClientManager;
   }
 
+  public void setCnSelectorNumOfClientManager(int selectorNumOfClientManager) {
     this.selectorNumOfClientManager = selectorNumOfClientManager;
   }
 
+  public boolean isCnRpcThriftCompressionEnabled() {
+    return isCnRpcThriftCompressionEnabled;
   }
 
+  public void setCnRpcThriftCompressionEnabled(boolean cnRpcThriftCompressionEnabled) {
+    isCnRpcThriftCompressionEnabled = cnRpcThriftCompressionEnabled;
   }
 
   HandleSystemErrorStrategy getHandleSystemErrorStrategy() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>223679</refactoring_id><commit_sha>1079e2e0d6923a4abe495018fd5f64737d80c19e</commit_sha><commit_link>https://github.com/apache/iotdb/commit/1079e2e0d6923a4abe495018fd5f64737d80c19e</commit_link><file_path>server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertTabletPlan.java</file_path><description>Rename Method public serializeTo(buffer ByteBuffer) : void renamed to public serialize(buffer ByteBuffer) : void in class org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan</description><code_before>@@ -127,7 +127,7 @@ public List&lt;Path&gt; getPaths() {
   }
 
   @Override
-  public void serializeTo(DataOutputStream stream) throws IOException {
     int type = PhysicalPlanType.BATCHINSERT.ordinal();
     stream.writeByte((byte) type);
 
@@ -215,7 +215,7 @@ private void serializeColumn(TSDataType dataType, Object column, DataOutputStrea
   }
 
   @Override
-  public void serializeTo(ByteBuffer buffer) {
     int type = PhysicalPlanType.BATCHINSERT.ordinal();
     buffer.put((byte) type);
 
@@ -312,7 +312,7 @@ public void setValueBuffer(ByteBuffer valueBuffer) {
   }
 
   @Override
-  public void deserializeFrom(ByteBuffer buffer) {
     this.deviceId = readString(buffer);
 
     int measurementSize = buffer.getInt();
</code_before><code_after>@@ -127,7 +127,7 @@ public List&lt;Path&gt; getPaths() {
   }
 
   @Override
+  public void serialize(DataOutputStream stream) throws IOException {
     int type = PhysicalPlanType.BATCHINSERT.ordinal();
     stream.writeByte((byte) type);
 
@@ -215,7 +215,7 @@ private void serializeColumn(TSDataType dataType, Object column, DataOutputStrea
   }
 
   @Override
+  public void serialize(ByteBuffer buffer) {
     int type = PhysicalPlanType.BATCHINSERT.ordinal();
     buffer.put((byte) type);
 
@@ -312,7 +312,7 @@ public void setValueBuffer(ByteBuffer valueBuffer) {
   }
 
   @Override
+  public void deserialize(ByteBuffer buffer) {
     this.deviceId = readString(buffer);
 
     int measurementSize = buffer.getInt();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>291122</refactoring_id><commit_sha>5420b7a2296d230e7fd5bc2f41fc6472a9c8b55e</commit_sha><commit_link>https://github.com/apache/cassandra/commit/5420b7a2296d230e7fd5bc2f41fc6472a9c8b55e</commit_link><file_path>src/java/org/apache/cassandra/concurrent/StageManager.java</file_path><description>Rename Method private multiThreadedConfigurableStage(stage Stage, numThreads int) : JMXConfigurableThreadPoolExecutor renamed to private multiThreadedLowSignalStage(stage Stage, numThreads int) : TracingAwareExecutorService in class org.apache.cassandra.concurrent.StageManager</description><code_before>@@ -45,10 +45,10 @@ public class StageManager
 
     static
     {
-        stages.put(Stage.MUTATION, multiThreadedConfigurableStage(Stage.MUTATION, getConcurrentWriters()));
-        stages.put(Stage.COUNTER_MUTATION, multiThreadedConfigurableStage(Stage.COUNTER_MUTATION, getConcurrentCounterWriters()));
-        stages.put(Stage.READ, multiThreadedConfigurableStage(Stage.READ, getConcurrentReaders()));
-        stages.put(Stage.REQUEST_RESPONSE, multiThreadedStage(Stage.REQUEST_RESPONSE, FBUtilities.getAvailableProcessors()));
         stages.put(Stage.INTERNAL_RESPONSE, multiThreadedStage(Stage.INTERNAL_RESPONSE, FBUtilities.getAvailableProcessors()));
         // the rest are all single-threaded
         stages.put(Stage.GOSSIP, new JMXEnabledThreadPoolExecutor(Stage.GOSSIP));
@@ -87,14 +87,9 @@ private static JMXEnabledThreadPoolExecutor multiThreadedStage(Stage stage, int
                                                 stage.getJmxType());
     }
 
-    private static JMXConfigurableThreadPoolExecutor multiThreadedConfigurableStage(Stage stage, int numThreads)
     {
-        return new JMXConfigurableThreadPoolExecutor(numThreads,
-                                                     KEEPALIVE,
-                                                     TimeUnit.SECONDS,
-                                                     new LinkedBlockingQueue&lt;Runnable&gt;(),
-                                                     new NamedThreadFactory(stage.getJmxName()),
-                                                     stage.getJmxType());
     }
 
     /**
@@ -134,6 +129,11 @@ public void execute(Runnable command, TraceState state)
             super.execute(command);
         }
 
         @Override
         public Future&lt;?&gt; submit(Runnable task)
         {
</code_before><code_after>@@ -45,10 +45,10 @@ public class StageManager
 
     static
     {
+        stages.put(Stage.MUTATION, multiThreadedLowSignalStage(Stage.MUTATION, getConcurrentWriters()));
+        stages.put(Stage.COUNTER_MUTATION, multiThreadedLowSignalStage(Stage.COUNTER_MUTATION, getConcurrentCounterWriters()));
+        stages.put(Stage.READ, multiThreadedLowSignalStage(Stage.READ, getConcurrentReaders()));
+        stages.put(Stage.REQUEST_RESPONSE, multiThreadedLowSignalStage(Stage.REQUEST_RESPONSE, FBUtilities.getAvailableProcessors()));
         stages.put(Stage.INTERNAL_RESPONSE, multiThreadedStage(Stage.INTERNAL_RESPONSE, FBUtilities.getAvailableProcessors()));
         // the rest are all single-threaded
         stages.put(Stage.GOSSIP, new JMXEnabledThreadPoolExecutor(Stage.GOSSIP));
@@ -87,14 +87,9 @@ private static JMXEnabledThreadPoolExecutor multiThreadedStage(Stage stage, int
                                                 stage.getJmxType());
     }
 
+    private static TracingAwareExecutorService multiThreadedLowSignalStage(Stage stage, int numThreads)
     {
+        return JMXEnabledSharedExecutorPool.SHARED.newExecutor(numThreads, Integer.MAX_VALUE, stage.getJmxName(), stage.getJmxType());
     }
 
     /**
@@ -134,6 +129,11 @@ public void execute(Runnable command, TraceState state)
             super.execute(command);
         }
 
+        public void maybeExecuteImmediately(Runnable command)
+        {
+            execute(command);
+        }
+
         @Override
         public Future&lt;?&gt; submit(Runnable task)
         {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>268395</refactoring_id><commit_sha>c0ef5f6de496b3ad2b990bf1a0b37557e17d8e28</commit_sha><commit_link>https://github.com/androidx/media/commit/c0ef5f6de496b3ad2b990bf1a0b37557e17d8e28</commit_link><file_path>libraries/extractor/src/test/java/androidx/media3/extractor/text/CueSerializationTest.java</file_path><description>Rename Method public serializingBitmapCueAndCueWithAndroidSpans() : void renamed to public serializingCueWithAndroidAndCustomSpans() : void in class androidx.media3.extractor.text.CueSerializationTest</description><code_before>@@ -19,16 +19,15 @@
 
 import android.graphics.Bitmap;
 import android.graphics.Color;
-import android.graphics.Typeface;
 import android.text.Layout;
 import android.text.Spannable;
 import android.text.SpannableString;
 import android.text.Spanned;
 import android.text.SpannedString;
 import android.text.style.StrikethroughSpan;
-import android.text.style.StyleSpan;
-import android.text.style.UnderlineSpan;
 import androidx.media3.common.text.Cue;
 import androidx.media3.test.utils.truth.SpannedSubject;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
@@ -87,48 +86,52 @@ public void serializingCueWithoutSpans() {
   }
 
   @Test
-  public void serializingBitmapCueAndCueWithAndroidSpans() {
     CueEncoder encoder = new CueEncoder();
     CueDecoder decoder = new CueDecoder();
-    Spannable spannable = SpannableString.valueOf("text text");
-    spannable.setSpan(
-        new StrikethroughSpan(), 0, "text".length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-    spannable.setSpan(
-        new StyleSpan(Typeface.BOLD), 0, "text text".length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-    spannable.setSpan(
-        new StyleSpan(Typeface.ITALIC), 0, "text text".length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-    spannable.setSpan(
-        new UnderlineSpan(),
-        "text ".length(),
-        "text text".length(),
-        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-    Cue textCue = new Cue.Builder().setText(spannable).build();
     Bitmap bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
     Cue bitmapCue = new Cue.Builder().setBitmap(bitmap).build();
 
     // encoding and decoding
-    byte[] encodedCues =
-        encoder.encode(ImmutableList.of(textCue, bitmapCue), /* durationUs= */ 2000);
     CuesWithTiming cuesAfterDecoding = decoder.decode(/* startTimeUs= */ 1000, encodedCues);
 
     assertThat(cuesAfterDecoding.startTimeUs).isEqualTo(1000);
     assertThat(cuesAfterDecoding.durationUs).isEqualTo(2000);
     assertThat(cuesAfterDecoding.endTimeUs).isEqualTo(3000);
 
-    assertThat(cuesAfterDecoding.cues).hasSize(2);
-    Cue textCueAfterDecoding = cuesAfterDecoding.cues.get(0);
-    Cue bitmapCueAfterDecoding = cuesAfterDecoding.cues.get(1);
 
-    assertThat(textCueAfterDecoding.text.toString()).isEqualTo(textCue.text.toString());
-    SpannedSubject.assertThat((Spanned) textCueAfterDecoding.text)
-        .hasStrikethroughSpanBetween(0, "text".length());
-    SpannedSubject.assertThat((Spanned) textCueAfterDecoding.text)
-        .hasBoldSpanBetween(0, "text text".length());
-    SpannedSubject.assertThat((Spanned) textCueAfterDecoding.text)
-        .hasItalicSpanBetween(0, "text text".length());
-    SpannedSubject.assertThat((Spanned) textCueAfterDecoding.text)
-        .hasUnderlineSpanBetween("text ".length(), "text text".length());
 
-    assertThat(bitmapCueAfterDecoding.bitmap.sameAs(bitmap)).isTrue();
   }
 }
</code_before><code_after>@@ -19,16 +19,15 @@
 
 import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.text.Layout;
 import android.text.Spannable;
 import android.text.SpannableString;
 import android.text.Spanned;
 import android.text.SpannedString;
 import android.text.style.StrikethroughSpan;
 import androidx.media3.common.text.Cue;
+import androidx.media3.common.text.RubySpan;
+import androidx.media3.common.text.TextAnnotation;
 import androidx.media3.test.utils.truth.SpannedSubject;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
@@ -87,48 +86,52 @@ public void serializingCueWithoutSpans() {
   }
 
   @Test
+  public void serializingBitmapCue() {
     CueEncoder encoder = new CueEncoder();
     CueDecoder decoder = new CueDecoder();
     Bitmap bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
     Cue bitmapCue = new Cue.Builder().setBitmap(bitmap).build();
 
     // encoding and decoding
+    byte[] encodedCues = encoder.encode(ImmutableList.of(bitmapCue), /* durationUs= */ 2000);
     CuesWithTiming cuesAfterDecoding = decoder.decode(/* startTimeUs= */ 1000, encodedCues);
 
     assertThat(cuesAfterDecoding.startTimeUs).isEqualTo(1000);
     assertThat(cuesAfterDecoding.durationUs).isEqualTo(2000);
     assertThat(cuesAfterDecoding.endTimeUs).isEqualTo(3000);
 
+    Cue bitmapCueAfterDecoding = cuesAfterDecoding.cues.get(0);
+    assertThat(bitmapCueAfterDecoding.bitmap.sameAs(bitmap)).isTrue();
+  }
 
+  @Test
+  public void serializingCueWithAndroidAndCustomSpans() {
+    CueEncoder encoder = new CueEncoder();
+    CueDecoder decoder = new CueDecoder();
+    Spannable spannable = SpannableString.valueOf("The Player");
+    spannable.setSpan(new StrikethroughSpan(), 0, "The".length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+    spannable.setSpan(
+        new RubySpan("small ruby", TextAnnotation.POSITION_AFTER),
+        "The ".length(),
+        "The Player".length(),
+        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+    Cue mixedSpansCue = new Cue.Builder().setText(spannable).build();
 
+    // encoding and decoding
+    byte[] encodedCues = encoder.encode(ImmutableList.of(mixedSpansCue), /* durationUs= */ 2000);
+    CuesWithTiming cuesAfterDecoding = decoder.decode(/* startTimeUs= */ 1000, encodedCues);
+
+    assertThat(cuesAfterDecoding.startTimeUs).isEqualTo(1000);
+    assertThat(cuesAfterDecoding.durationUs).isEqualTo(2000);
+    assertThat(cuesAfterDecoding.endTimeUs).isEqualTo(3000);
+
+    Cue mixedSpansCueAfterDecoding = cuesAfterDecoding.cues.get(0);
+
+    assertThat(mixedSpansCueAfterDecoding.text.toString()).isEqualTo(mixedSpansCue.text.toString());
+    Spanned mixedSpans = (Spanned) mixedSpansCueAfterDecoding.text;
+    SpannedSubject.assertThat(mixedSpans).hasStrikethroughSpanBetween(0, "The".length());
+    SpannedSubject.assertThat(mixedSpans)
+        .hasRubySpanBetween("The ".length(), "The Player".length())
+        .withTextAndPosition("small ruby", TextAnnotation.POSITION_AFTER);
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>183334</refactoring_id><commit_sha>bfbd95f3a5a8f928fd477c3d875ac62ec3d40dcc</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/bfbd95f3a5a8f928fd477c3d875ac62ec3d40dcc</commit_link><file_path>src/test/java/com/google/devtools/build/lib/analysis/platform/PlatformUtilsTest.java</file_path><description>Rename Method public testParsePlatformSortsProperties_ExecProperties() : void renamed to public testParsePlatformSortsProperties_execProperties() : void in class com.google.devtools.build.lib.analysis.platform.PlatformUtilsTest</description><code_before>@@ -80,7 +80,7 @@ public void testParsePlatformHandlesNull() throws Exception {
   }
 
   @Test
-  public void testParsePlatformSortsProperties_ExecProperties() throws Exception {
     // execProperties are chosen even if there are remoteOptions
     ImmutableMap&lt;String, String&gt; map = ImmutableMap.of("aa", "99", "zz", "66", "dd", "11");
     Spawn s = new SpawnBuilder("dummy").withExecProperties(map).build();
</code_before><code_after>@@ -80,7 +80,7 @@ public void testParsePlatformHandlesNull() throws Exception {
   }
 
   @Test
+  public void testParsePlatformSortsProperties_execProperties() throws Exception {
     // execProperties are chosen even if there are remoteOptions
     ImmutableMap&lt;String, String&gt; map = ImmutableMap.of("aa", "99", "zz", "66", "dd", "11");
     Spawn s = new SpawnBuilder("dummy").withExecProperties(map).build();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>252894</refactoring_id><commit_sha>cdb71eda1c8026dd671091c3202b46c0f83c30b2</commit_sha><commit_link>https://github.com/real-logic/aeron/commit/cdb71eda1c8026dd671091c3202b46c0f83c30b2</commit_link><file_path>aeron-cluster/src/test/java/io/aeron/cluster/StartClusterFromTruncatedRecordingLogTest.java</file_path><description>Rename Method private awaitsSnapshotCounter(index int, value long) : void renamed to private awaitSnapshotCounter(index int, value long) : void in class io.aeron.cluster.StartClusterFromTruncatedRecordingLogTest</description><code_before>@@ -168,18 +168,18 @@ private void stopAndStartClusterWithTruncationOfRecordingLog() throws Interrupte
         final int followerMemberIdB = (followerMemberIdA + 1) &gt;= MEMBER_COUNT ? 0 : (followerMemberIdA + 1);
 
         takeSnapshot(leaderMemberId);
-        awaitsSnapshotCounter(leaderMemberId, 1);
-        awaitsSnapshotCounter(followerMemberIdA, 1);
-        awaitsSnapshotCounter(followerMemberIdB, 1);
 
         awaitNeutralCounter(leaderMemberId);
         awaitNeutralCounter(followerMemberIdA);
         awaitNeutralCounter(followerMemberIdB);
 
         shutdown(leaderMemberId);
-        awaitsSnapshotCounter(leaderMemberId, 2);
-        awaitsSnapshotCounter(followerMemberIdA, 2);
-        awaitsSnapshotCounter(followerMemberIdB, 2);
 
         stopNode(leaderMemberId);
         stopNode(followerMemberIdA);
@@ -474,11 +474,6 @@ static class EchoService extends StubClusteredService
             this.latchTwo = latchTwo;
         }
 
-        int index()
-        {
-            return index;
-        }
-
         int messageCount()
         {
             return messageCount;
@@ -539,15 +534,16 @@ private int findLeaderId(final int skipMemberId)
     private Cluster.Role roleOf(final int index)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
         return Cluster.Role.get((int)driver.consensusModule().context().clusterNodeCounter().get());
     }
 
     private void takeSnapshot(final int index)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
-
         final CountersReader countersReader = driver.consensusModule().context().aeron().countersReader();
         final AtomicCounter controlToggle = ClusterControl.findControlToggle(countersReader);
         assertNotNull(controlToggle);
         assertTrue(ClusterControl.ToggleState.SNAPSHOT.toggle(controlToggle));
     }
@@ -564,8 +560,8 @@ private void shutdown(final int index)
     private AtomicCounter getControlToggle(final int index)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
-
         final CountersReader countersReader = driver.consensusModule().context().aeron().countersReader();
         return ClusterControl.findControlToggle(countersReader);
     }
 
@@ -579,12 +575,12 @@ private void awaitNeutralCounter(final int index)
         }
     }
 
-    private void awaitsSnapshotCounter(final int index, final long value)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
         final Counter snapshotCounter = driver.consensusModule().context().snapshotCounter();
 
-        while (snapshotCounter.getWeak() != value)
         {
             TestUtil.checkInterruptedStatus();
             Thread.yield();
</code_before><code_after>@@ -168,18 +168,18 @@ private void stopAndStartClusterWithTruncationOfRecordingLog() throws Interrupte
         final int followerMemberIdB = (followerMemberIdA + 1) &gt;= MEMBER_COUNT ? 0 : (followerMemberIdA + 1);
 
         takeSnapshot(leaderMemberId);
+        awaitSnapshotCounter(leaderMemberId, 1);
+        awaitSnapshotCounter(followerMemberIdA, 1);
+        awaitSnapshotCounter(followerMemberIdB, 1);
 
         awaitNeutralCounter(leaderMemberId);
         awaitNeutralCounter(followerMemberIdA);
         awaitNeutralCounter(followerMemberIdB);
 
         shutdown(leaderMemberId);
+        awaitSnapshotCounter(leaderMemberId, 2);
+        awaitSnapshotCounter(followerMemberIdA, 2);
+        awaitSnapshotCounter(followerMemberIdB, 2);
 
         stopNode(leaderMemberId);
         stopNode(followerMemberIdA);
@@ -474,11 +474,6 @@ static class EchoService extends StubClusteredService
             this.latchTwo = latchTwo;
         }
 
         int messageCount()
         {
             return messageCount;
@@ -539,15 +534,16 @@ private int findLeaderId(final int skipMemberId)
     private Cluster.Role roleOf(final int index)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
+
         return Cluster.Role.get((int)driver.consensusModule().context().clusterNodeCounter().get());
     }
 
     private void takeSnapshot(final int index)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
         final CountersReader countersReader = driver.consensusModule().context().aeron().countersReader();
         final AtomicCounter controlToggle = ClusterControl.findControlToggle(countersReader);
+
         assertNotNull(controlToggle);
         assertTrue(ClusterControl.ToggleState.SNAPSHOT.toggle(controlToggle));
     }
@@ -564,8 +560,8 @@ private void shutdown(final int index)
     private AtomicCounter getControlToggle(final int index)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
         final CountersReader countersReader = driver.consensusModule().context().aeron().countersReader();
+
         return ClusterControl.findControlToggle(countersReader);
     }
 
@@ -579,12 +575,12 @@ private void awaitNeutralCounter(final int index)
         }
     }
 
+    private void awaitSnapshotCounter(final int index, final long value)
     {
         final ClusteredMediaDriver driver = clusteredMediaDrivers[index];
         final Counter snapshotCounter = driver.consensusModule().context().snapshotCounter();
 
+        while (snapshotCounter.get() != value)
         {
             TestUtil.checkInterruptedStatus();
             Thread.yield();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>270207</refactoring_id><commit_sha>95ba4f85b076d63ff6676256fe73b84fdad05c59</commit_sha><commit_link>https://github.com/androidx/media/commit/95ba4f85b076d63ff6676256fe73b84fdad05c59</commit_link><file_path>library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java</file_path><description>Rename Method public testResolveStyleNoStyleAtAll() : void renamed to public resolveStyleNoStyleAtAll() : void in class com.google.android.exoplayer2.text.ttml.TtmlRenderUtilTest</description><code_before>@@ -35,12 +35,12 @@
 public final class TtmlRenderUtilTest {
 
   @Test
-  public void testResolveStyleNoStyleAtAll() {
     assertThat(resolveStyle(null, null, null)).isNull();
   }
 
   @Test
-  public void testResolveStyleSingleReferentialStyle() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0"};
 
@@ -49,7 +49,7 @@ public void testResolveStyleSingleReferentialStyle() {
   }
 
   @Test
-  public void testResolveStyleMultipleReferentialStyles() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0", "s1"};
 
@@ -67,7 +67,7 @@ public void testResolveStyleMultipleReferentialStyles() {
   }
 
   @Test
-  public void testResolveMergeSingleReferentialStyleIntoInlineStyle() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0"};
     TtmlStyle style = new TtmlStyle();
@@ -83,7 +83,7 @@ public void testResolveMergeSingleReferentialStyleIntoInlineStyle() {
   }
 
   @Test
-  public void testResolveMergeMultipleReferentialStylesIntoInlineStyle() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0", "s1"};
     TtmlStyle style = new TtmlStyle();
@@ -99,7 +99,7 @@ public void testResolveMergeMultipleReferentialStylesIntoInlineStyle() {
   }
 
   @Test
-  public void testResolveStyleOnlyInlineStyle() {
     TtmlStyle inlineStyle = new TtmlStyle();
     assertThat(TtmlRenderUtil.resolveStyle(inlineStyle, null, null)).isSameInstanceAs(inlineStyle);
   }
</code_before><code_after>@@ -35,12 +35,12 @@
 public final class TtmlRenderUtilTest {
 
   @Test
+  public void resolveStyleNoStyleAtAll() {
     assertThat(resolveStyle(null, null, null)).isNull();
   }
 
   @Test
+  public void resolveStyleSingleReferentialStyle() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0"};
 
@@ -49,7 +49,7 @@ public void testResolveStyleSingleReferentialStyle() {
   }
 
   @Test
+  public void resolveStyleMultipleReferentialStyles() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0", "s1"};
 
@@ -67,7 +67,7 @@ public void testResolveStyleMultipleReferentialStyles() {
   }
 
   @Test
+  public void resolveMergeSingleReferentialStyleIntoInlineStyle() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0"};
     TtmlStyle style = new TtmlStyle();
@@ -83,7 +83,7 @@ public void testResolveMergeSingleReferentialStyleIntoInlineStyle() {
   }
 
   @Test
+  public void resolveMergeMultipleReferentialStylesIntoInlineStyle() {
     Map&lt;String, TtmlStyle&gt; globalStyles = getGlobalStyles();
     String[] styleIds = {"s0", "s1"};
     TtmlStyle style = new TtmlStyle();
@@ -99,7 +99,7 @@ public void testResolveMergeMultipleReferentialStylesIntoInlineStyle() {
   }
 
   @Test
+  public void resolveStyleOnlyInlineStyle() {
     TtmlStyle inlineStyle = new TtmlStyle();
     assertThat(TtmlRenderUtil.resolveStyle(inlineStyle, null, null)).isSameInstanceAs(inlineStyle);
   }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>301775</refactoring_id><commit_sha>c492e4ef1fa7888cf1a5f69249c0fd87b2dcc4ed</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/c492e4ef1fa7888cf1a5f69249c0fd87b2dcc4ed</commit_link><file_path>jdk/test/java/time/tck/java/time/TCKYear.java</file_path><description>Rename Method public test_periodUntil_TemporalUnit_nullEnd() : void renamed to public test_until_TemporalUnit_nullEnd() : void in class tck.java.time.TCKYear</description><code_before>@@ -65,10 +65,8 @@
 import static java.time.temporal.ChronoUnit.CENTURIES;
 import static java.time.temporal.ChronoUnit.DAYS;
 import static java.time.temporal.ChronoUnit.DECADES;
-import static java.time.temporal.ChronoUnit.HOURS;
 import static java.time.temporal.ChronoUnit.MILLENNIA;
 import static java.time.temporal.ChronoUnit.MONTHS;
-import static java.time.temporal.ChronoUnit.WEEKS;
 import static java.time.temporal.ChronoUnit.YEARS;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertTrue;
@@ -90,8 +88,8 @@
 import java.time.YearMonth;
 import java.time.ZoneId;
 import java.time.ZoneOffset;
-import java.time.chrono.IsoEra;
 import java.time.chrono.IsoChronology;
 import java.time.format.DateTimeFormatter;
 import java.time.format.DateTimeParseException;
 import java.time.temporal.ChronoField;
@@ -229,17 +227,17 @@ public void test_factory_int_tooHigh() {
 
     //-----------------------------------------------------------------------
     @Test
-    public void test_factory_CalendricalObject() {
         assertEquals(Year.from(LocalDate.of(2007, 7, 15)), Year.of(2007));
     }
 
     @Test(expectedExceptions=DateTimeException.class)
-    public void test_factory_CalendricalObject_invalid_noDerive() {
         Year.from(LocalTime.of(12, 30));
     }
 
     @Test(expectedExceptions=NullPointerException.class)
-    public void test_factory_CalendricalObject_null() {
         Year.from((TemporalAccessor) null);
     }
 
@@ -597,13 +595,13 @@ Object[][] data_plus_long_TemporalUnit() {
         };
     }
 
-    @Test(groups={"tck"}, dataProvider="plus_long_TemporalUnit")
     public void test_plus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class expectedEx) {
         if (expectedEx == null) {
             assertEquals(base.plus(amount, unit), expectedYear);
         } else {
             try {
-                Year result = base.plus(amount, unit);
                 fail();
             } catch (Exception ex) {
                 assertTrue(expectedEx.isInstance(ex));
@@ -729,7 +727,7 @@ Object[][] data_minus_long_TemporalUnit() {
         };
     }
 
-    @Test(groups={"tck"}, dataProvider="minus_long_TemporalUnit")
     public void test_minus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class expectedEx) {
         if (expectedEx == null) {
             assertEquals(base.minus(amount, unit), expectedYear);
@@ -788,7 +786,7 @@ public void test_with_BadTemporalAdjuster() {
     //-----------------------------------------------------------------------
     // with(TemporalField, long)
     //-----------------------------------------------------------------------
-    @Test(groups={"tck"})
     public void test_with() {
         Year base = Year.of(5);
         Year result = base.with(ChronoField.ERA, 0);
@@ -923,29 +921,48 @@ Object[][] data_periodUntilUnit() {
     }
 
     @Test(dataProvider="periodUntilUnit")
-    public void test_periodUntil_TemporalUnit(Year year1, Year year2, TemporalUnit unit, long expected) {
         long amount = year1.until(year2, unit);
         assertEquals(amount, expected);
     }
 
     @Test(dataProvider="periodUntilUnit")
-    public void test_periodUntil_TemporalUnit_negated(Year year1, Year year2, TemporalUnit unit, long expected) {
         long amount = year2.until(year1, unit);
         assertEquals(amount, -expected);
     }
 
     @Test(expectedExceptions = UnsupportedTemporalTypeException.class)
-    public void test_periodUntil_TemporalUnit_unsupportedUnit() {
         TEST_2008.until(TEST_2008, MONTHS);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
-    public void test_periodUntil_TemporalUnit_nullEnd() {
         TEST_2008.until(null, DAYS);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
-    public void test_periodUntil_TemporalUnit_nullUnit() {
         TEST_2008.until(TEST_2008, null);
     }
 
</code_before><code_after>@@ -65,10 +65,8 @@
 import static java.time.temporal.ChronoUnit.CENTURIES;
 import static java.time.temporal.ChronoUnit.DAYS;
 import static java.time.temporal.ChronoUnit.DECADES;
 import static java.time.temporal.ChronoUnit.MILLENNIA;
 import static java.time.temporal.ChronoUnit.MONTHS;
 import static java.time.temporal.ChronoUnit.YEARS;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertTrue;
@@ -90,8 +88,8 @@
 import java.time.YearMonth;
 import java.time.ZoneId;
 import java.time.ZoneOffset;
 import java.time.chrono.IsoChronology;
+import java.time.chrono.IsoEra;
 import java.time.format.DateTimeFormatter;
 import java.time.format.DateTimeParseException;
 import java.time.temporal.ChronoField;
@@ -229,17 +227,17 @@ public void test_factory_int_tooHigh() {
 
     //-----------------------------------------------------------------------
     @Test
+    public void test_from_TemporalAccessor() {
         assertEquals(Year.from(LocalDate.of(2007, 7, 15)), Year.of(2007));
     }
 
     @Test(expectedExceptions=DateTimeException.class)
+    public void test_from_TemporalAccessor_invalid_noDerive() {
         Year.from(LocalTime.of(12, 30));
     }
 
     @Test(expectedExceptions=NullPointerException.class)
+    public void test_from_TemporalAccessor_null() {
         Year.from((TemporalAccessor) null);
     }
 
@@ -597,13 +595,13 @@ Object[][] data_plus_long_TemporalUnit() {
         };
     }
 
+    @Test(dataProvider="plus_long_TemporalUnit")
     public void test_plus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class expectedEx) {
         if (expectedEx == null) {
             assertEquals(base.plus(amount, unit), expectedYear);
         } else {
             try {
+                base.plus(amount, unit);
                 fail();
             } catch (Exception ex) {
                 assertTrue(expectedEx.isInstance(ex));
@@ -729,7 +727,7 @@ Object[][] data_minus_long_TemporalUnit() {
         };
     }
 
+    @Test(dataProvider="minus_long_TemporalUnit")
     public void test_minus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class expectedEx) {
         if (expectedEx == null) {
             assertEquals(base.minus(amount, unit), expectedYear);
@@ -788,7 +786,7 @@ public void test_with_BadTemporalAdjuster() {
     //-----------------------------------------------------------------------
     // with(TemporalField, long)
     //-----------------------------------------------------------------------
+    @Test
     public void test_with() {
         Year base = Year.of(5);
         Year result = base.with(ChronoField.ERA, 0);
@@ -923,29 +921,48 @@ Object[][] data_periodUntilUnit() {
     }
 
     @Test(dataProvider="periodUntilUnit")
+    public void test_until_TemporalUnit(Year year1, Year year2, TemporalUnit unit, long expected) {
         long amount = year1.until(year2, unit);
         assertEquals(amount, expected);
     }
 
     @Test(dataProvider="periodUntilUnit")
+    public void test_until_TemporalUnit_negated(Year year1, Year year2, TemporalUnit unit, long expected) {
         long amount = year2.until(year1, unit);
         assertEquals(amount, -expected);
     }
 
+    @Test(dataProvider="periodUntilUnit")
+    public void test_until_TemporalUnit_between(Year year1, Year year2, TemporalUnit unit, long expected) {
+        long amount = unit.between(year1, year2);
+        assertEquals(amount, expected);
+    }
+
+    @Test
+    public void test_until_convertedType() {
+        Year start = Year.of(2010);
+        YearMonth end = start.plusYears(2).atMonth(Month.APRIL);
+        assertEquals(start.until(end, YEARS), 2);
+    }
+
+    @Test(expectedExceptions=DateTimeException.class)
+    public void test_until_invalidType() {
+        Year start = Year.of(2010);
+        start.until(LocalTime.of(11, 30), YEARS);
+    }
+
     @Test(expectedExceptions = UnsupportedTemporalTypeException.class)
+    public void test_until_TemporalUnit_unsupportedUnit() {
         TEST_2008.until(TEST_2008, MONTHS);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
+    public void test_until_TemporalUnit_nullEnd() {
         TEST_2008.until(null, DAYS);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
+    public void test_until_TemporalUnit_nullUnit() {
         TEST_2008.until(TEST_2008, null);
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>197414</refactoring_id><commit_sha>b42e17c7b3211c087131951bb9d1e17587b12811</commit_sha><commit_link>https://github.com/camunda/camunda/commit/b42e17c7b3211c087131951bb9d1e17587b12811</commit_link><file_path>search/search-domain/src/main/java/io/camunda/search/filter/IncidentFilter.java</file_path><description>Rename Method public bpmnProcessIds(value String, values String...) : Builder renamed to public processDefinitionIds(value String, values String...) : Builder in class io.camunda.search.filter.IncidentFilter.Builder</description><code_before>@@ -18,9 +18,9 @@
 import java.util.Objects;
 
 public record IncidentFilter(
-    List&lt;Long&gt; keys,
     List&lt;Long&gt; processDefinitionKeys,
-    List&lt;String&gt; bpmnProcessIds,
     List&lt;Long&gt; processInstanceKeys,
     List&lt;ErrorType&gt; errorTypes,
     List&lt;String&gt; errorMessages,
@@ -35,9 +35,9 @@ public record IncidentFilter(
 
   public static final class Builder implements ObjectBuilder&lt;IncidentFilter&gt; {
 
-    private List&lt;Long&gt; keys;
     private List&lt;Long&gt; processDefinitionKeys;
-    private List&lt;String&gt; bpmnProcessIds;
     private List&lt;Long&gt; processInstanceKeys;
     private List&lt;ErrorType&gt; errorTypes;
     private List&lt;String&gt; errorMessages;
@@ -49,12 +49,12 @@ public static final class Builder implements ObjectBuilder&lt;IncidentFilter&gt; {
     private List&lt;String&gt; treePaths;
     private List&lt;String&gt; tenantIds;
 
-    public Builder keys(final Long value, final Long... values) {
-      return keys(collectValues(value, values));
     }
 
-    public Builder keys(final List&lt;Long&gt; values) {
-      keys = addValuesToList(keys, values);
       return this;
     }
 
@@ -67,12 +67,12 @@ public Builder processDefinitionKeys(final List&lt;Long&gt; values) {
       return this;
     }
 
-    public Builder bpmnProcessIds(final String value, final String... values) {
-      return bpmnProcessIds(collectValues(value, values));
     }
 
-    public Builder bpmnProcessIds(final List&lt;String&gt; values) {
-      bpmnProcessIds = addValuesToList(bpmnProcessIds, values);
       return this;
     }
 
@@ -165,9 +165,9 @@ public Builder tenantIds(final List&lt;String&gt; values) {
     @Override
     public IncidentFilter build() {
       return new IncidentFilter(
-          Objects.requireNonNullElse(keys, Collections.emptyList()),
           Objects.requireNonNullElse(processDefinitionKeys, Collections.emptyList()),
-          Objects.requireNonNullElse(bpmnProcessIds, Collections.emptyList()),
           Objects.requireNonNullElse(processInstanceKeys, Collections.emptyList()),
           Objects.requireNonNullElse(errorTypes, Collections.emptyList()),
           Objects.requireNonNullElse(errorMessages, Collections.emptyList()),
</code_before><code_after>@@ -18,9 +18,9 @@
 import java.util.Objects;
 
 public record IncidentFilter(
+    List&lt;Long&gt; incidentKeys,
     List&lt;Long&gt; processDefinitionKeys,
+    List&lt;String&gt; processDefinitionIds,
     List&lt;Long&gt; processInstanceKeys,
     List&lt;ErrorType&gt; errorTypes,
     List&lt;String&gt; errorMessages,
@@ -35,9 +35,9 @@ public record IncidentFilter(
 
   public static final class Builder implements ObjectBuilder&lt;IncidentFilter&gt; {
 
+    private List&lt;Long&gt; incidentKeys;
     private List&lt;Long&gt; processDefinitionKeys;
+    private List&lt;String&gt; processDefinitionIds;
     private List&lt;Long&gt; processInstanceKeys;
     private List&lt;ErrorType&gt; errorTypes;
     private List&lt;String&gt; errorMessages;
@@ -49,12 +49,12 @@ public static final class Builder implements ObjectBuilder&lt;IncidentFilter&gt; {
     private List&lt;String&gt; treePaths;
     private List&lt;String&gt; tenantIds;
 
+    public Builder incidentKeys(final Long value, final Long... values) {
+      return incidentKeys(collectValues(value, values));
     }
 
+    public Builder incidentKeys(final List&lt;Long&gt; values) {
+      incidentKeys = addValuesToList(incidentKeys, values);
       return this;
     }
 
@@ -67,12 +67,12 @@ public Builder processDefinitionKeys(final List&lt;Long&gt; values) {
       return this;
     }
 
+    public Builder processDefinitionIds(final String value, final String... values) {
+      return processDefinitionIds(collectValues(value, values));
     }
 
+    public Builder processDefinitionIds(final List&lt;String&gt; values) {
+      processDefinitionIds = addValuesToList(processDefinitionIds, values);
       return this;
     }
 
@@ -165,9 +165,9 @@ public Builder tenantIds(final List&lt;String&gt; values) {
     @Override
     public IncidentFilter build() {
       return new IncidentFilter(
+          Objects.requireNonNullElse(incidentKeys, Collections.emptyList()),
           Objects.requireNonNullElse(processDefinitionKeys, Collections.emptyList()),
+          Objects.requireNonNullElse(processDefinitionIds, Collections.emptyList()),
           Objects.requireNonNullElse(processInstanceKeys, Collections.emptyList()),
           Objects.requireNonNullElse(errorTypes, Collections.emptyList()),
           Objects.requireNonNullElse(errorMessages, Collections.emptyList()),
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>178214</refactoring_id><commit_sha>8c65309963a286a700698ccfd05426f6cfe2767f</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/8c65309963a286a700698ccfd05426f6cfe2767f</commit_link><file_path>jetty-websocket/websocket-common/src/test/java/org/eclipse/jetty/websocket/common/events/JettyAnnotatedScannerTest.java</file_path><description>Rename Method public testAnnotatedBadSignature_NonVoidReturn() : void renamed to public testAnnotatedBadSignatureNonVoidReturn() : void in class org.eclipse.jetty.websocket.common.events.JettyAnnotatedScannerTest</description><code_before>@@ -95,7 +95,7 @@ public void testAnnotatedBadDuplicateFrameSocket()
      * Test Case for bad declaration a method with a non-void return type
      */
     @Test
-    public void testAnnotatedBadSignature_NonVoidReturn()
     {
         JettyAnnotatedScanner impl = new JettyAnnotatedScanner();
         InvalidWebSocketException e = assertThrows(InvalidWebSocketException.class, () -&gt;
@@ -111,7 +111,7 @@ public void testAnnotatedBadSignature_NonVoidReturn()
      * Test Case for bad declaration a method with a public static method
      */
     @Test
-    public void testAnnotatedBadSignature_Static()
     {
         JettyAnnotatedScanner impl = new JettyAnnotatedScanner();
         InvalidWebSocketException e = assertThrows(InvalidWebSocketException.class, () -&gt;
</code_before><code_after>@@ -95,7 +95,7 @@ public void testAnnotatedBadDuplicateFrameSocket()
      * Test Case for bad declaration a method with a non-void return type
      */
     @Test
+    public void testAnnotatedBadSignatureNonVoidReturn()
     {
         JettyAnnotatedScanner impl = new JettyAnnotatedScanner();
         InvalidWebSocketException e = assertThrows(InvalidWebSocketException.class, () -&gt;
@@ -111,7 +111,7 @@ public void testAnnotatedBadSignature_NonVoidReturn()
      * Test Case for bad declaration a method with a public static method
      */
     @Test
+    public void testAnnotatedBadSignatureStatic()
     {
         JettyAnnotatedScanner impl = new JettyAnnotatedScanner();
         InvalidWebSocketException e = assertThrows(InvalidWebSocketException.class, () -&gt;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>202579</refactoring_id><commit_sha>969f7148bf4af675b93329360c08c8370e6da41d</commit_sha><commit_link>https://github.com/pmd/pmd/commit/969f7148bf4af675b93329360c08c8370e6da41d</commit_link><file_path>pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/TreeIndex.java</file_path><description>Rename Method package prepare() : void renamed to package reset() : void in class net.sourceforge.pmd.lang.rule.internal.TreeIndex</description><code_before>@@ -45,12 +45,7 @@ void indexNode(Node n) {
         byClass.put(n.getClass(), n);
     }
 
-    void complete() {
-        byClass.makeReadable();
-    }
-
-    void prepare() {
-        byClass.makeWritable();
         byClass.clearValues();
         byName.clear();
     }
</code_before><code_after>@@ -45,12 +45,7 @@ void indexNode(Node n) {
         byClass.put(n.getClass(), n);
     }
 
+    void reset() {
         byClass.clearValues();
         byName.clear();
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>330064</refactoring_id><commit_sha>51bbe7ecdb920c422a852a6179893dbe750d2e64</commit_sha><commit_link>https://github.com/oracle/graal/commit/51bbe7ecdb920c422a852a6179893dbe750d2e64</commit_link><file_path>regex/src/com.oracle.truffle.regex/src/com/oracle/truffle/regex/tregex/parser/ast/CharacterClass.java</file_path><description>Rename Method public setMatcherBuilder(matcherBuilder CharSet) : void renamed to public setCharSet(charSet CharSet) : void in class com.oracle.truffle.regex.tregex.parser.ast.CharacterClass</description><code_before>@@ -54,24 +54,24 @@
  */
 public class CharacterClass extends Term {
 
-    private CharSet matcherBuilder;
     // look-behind groups which might match the same character as this CharacterClass node
     private ASTNodeSet&lt;Group&gt; lookBehindEntries;
 
     /**
      * Creates a new {@link CharacterClass} node which matches the set of characters specified by
      * the {@code matcherBuilder}.
      */
-    CharacterClass(CharSet matcherBuilder) {
-        this.matcherBuilder = matcherBuilder;
-        if (matcherBuilder.matchesNothing()) {
             markAsDead();
         }
     }
 
     private CharacterClass(CharacterClass copy) {
         super(copy);
-        matcherBuilder = copy.matcherBuilder;
     }
 
     @Override
@@ -88,12 +88,12 @@ public Sequence getParent() {
      * Returns the {@link CharSet} representing the set of characters that can be matched by this
      * {@link CharacterClass}.
      */
-    public CharSet getMatcherBuilder() {
-        return matcherBuilder;
     }
 
-    public void setMatcherBuilder(CharSet matcherBuilder) {
-        this.matcherBuilder = matcherBuilder;
     }
 
     public void addLookBehindEntry(RegexAST ast, Group lookBehindEntry) {
@@ -120,7 +120,7 @@ public Set&lt;Group&gt; getLookBehindEntries() {
     }
 
     public void extractSingleChar(CharArrayBuffer literal, CharArrayBuffer mask) {
-        CharSet c = matcherBuilder;
         char c1 = (char) c.getLo(0);
         if (c.matches2CharsWith1BitDifference()) {
             int c2 = c.size() == 1 ? c.getHi(0) : c.getLo(1);
@@ -134,7 +134,7 @@ public void extractSingleChar(CharArrayBuffer literal, CharArrayBuffer mask) {
     }
 
     public void extractSingleChar(char[] literal, char[] mask, int i) {
-        CharSet c = matcherBuilder;
         char c1 = (char) c.getLo(0);
         if (c.matches2CharsWith1BitDifference()) {
             int c2 = c.size() == 1 ? c.getHi(0) : c.getLo(1);
@@ -149,13 +149,13 @@ public void extractSingleChar(char[] literal, char[] mask, int i) {
 
     @Override
     public String toString() {
-        return matcherBuilder.toString();
     }
 
     @TruffleBoundary
     @Override
     public JsonValue toJson() {
-        final JsonObject json = toJson("CharacterClass").append(Json.prop("matcherBuilder", matcherBuilder));
         if (lookBehindEntries != null) {
             json.append(Json.prop("lookBehindEntries", lookBehindEntries.stream().map(RegexASTNode::astNodeId).collect(Collectors.toList())));
         }
</code_before><code_after>@@ -54,24 +54,24 @@
  */
 public class CharacterClass extends Term {
 
+    private CharSet charSet;
     // look-behind groups which might match the same character as this CharacterClass node
     private ASTNodeSet&lt;Group&gt; lookBehindEntries;
 
     /**
      * Creates a new {@link CharacterClass} node which matches the set of characters specified by
      * the {@code matcherBuilder}.
      */
+    CharacterClass(CharSet charSet) {
+        this.charSet = charSet;
+        if (charSet.matchesNothing()) {
             markAsDead();
         }
     }
 
     private CharacterClass(CharacterClass copy) {
         super(copy);
+        charSet = copy.charSet;
     }
 
     @Override
@@ -88,12 +88,12 @@ public Sequence getParent() {
      * Returns the {@link CharSet} representing the set of characters that can be matched by this
      * {@link CharacterClass}.
      */
+    public CharSet getCharSet() {
+        return charSet;
     }
 
+    public void setCharSet(CharSet charSet) {
+        this.charSet = charSet;
     }
 
     public void addLookBehindEntry(RegexAST ast, Group lookBehindEntry) {
@@ -120,7 +120,7 @@ public Set&lt;Group&gt; getLookBehindEntries() {
     }
 
     public void extractSingleChar(CharArrayBuffer literal, CharArrayBuffer mask) {
+        CharSet c = charSet;
         char c1 = (char) c.getLo(0);
         if (c.matches2CharsWith1BitDifference()) {
             int c2 = c.size() == 1 ? c.getHi(0) : c.getLo(1);
@@ -134,7 +134,7 @@ public void extractSingleChar(CharArrayBuffer literal, CharArrayBuffer mask) {
     }
 
     public void extractSingleChar(char[] literal, char[] mask, int i) {
+        CharSet c = charSet;
         char c1 = (char) c.getLo(0);
         if (c.matches2CharsWith1BitDifference()) {
             int c2 = c.size() == 1 ? c.getHi(0) : c.getLo(1);
@@ -149,13 +149,13 @@ public void extractSingleChar(char[] literal, char[] mask, int i) {
 
     @Override
     public String toString() {
+        return charSet.toString();
     }
 
     @TruffleBoundary
     @Override
     public JsonValue toJson() {
+        final JsonObject json = toJson("CharacterClass").append(Json.prop("charSet", charSet));
         if (lookBehindEntries != null) {
             json.append(Json.prop("lookBehindEntries", lookBehindEntries.stream().map(RegexASTNode::astNodeId).collect(Collectors.toList())));
         }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>189767</refactoring_id><commit_sha>8f6f447926d12a4607d38a864bf4c271e9e6ecf9</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/8f6f447926d12a4607d38a864bf4c271e9e6ecf9</commit_link><file_path>OsmAnd/src/net/osmand/plus/mapcontextmenu/MenuController.java</file_path><description>Rename Method public fabVisible() : boolean renamed to public bottomButtonsVisible() : boolean in class net.osmand.plus.mapcontextmenu.MenuController</description><code_before>@@ -350,7 +350,7 @@ public boolean supportZoomIn() {
 		return true;
 	}
 
-	public boolean fabVisible() {
 		return true;
 	}
 
</code_before><code_after>@@ -350,7 +350,7 @@ public boolean supportZoomIn() {
 		return true;
 	}
 
+	public boolean bottomButtonsVisible() {
 		return true;
 	}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>224790</refactoring_id><commit_sha>5cb15970ef7421a5cd319d6920bd1cb0d8f1ba3a</commit_sha><commit_link>https://github.com/apache/iotdb/commit/5cb15970ef7421a5cd319d6920bd1cb0d8f1ba3a</commit_link><file_path>iotdb-core/datanode/src/main/java/org/apache/iotdb/db/queryengine/execution/operator/OperatorContext.java</file_path><description>Rename Method public getInputRows() : long renamed to public getOutputRows() : long in class org.apache.iotdb.db.queryengine.execution.operator.OperatorContext</description><code_before>@@ -58,7 +58,7 @@ public class OperatorContext {
   // SpecifiedInfo is used to record some custom information for the operator,
   // which will be shown in the result of EXPLAIN ANALYZE to analyze the query.
   private Map&lt;String, String&gt; specifiedInfo = null;
-  private long inputRows = 0;
   private long estimatedMemorySize;
 
   public OperatorContext(
@@ -149,12 +149,12 @@ public long getEstimatedMemorySize() {
     return estimatedMemorySize;
   }
 
-  public void addInputRows(long inputRows) {
-    this.inputRows += inputRows;
   }
 
-  public long getInputRows() {
-    return inputRows;
   }
 
   public void recordSpecifiedInfo(String key, String value) {
</code_before><code_after>@@ -58,7 +58,7 @@ public class OperatorContext {
   // SpecifiedInfo is used to record some custom information for the operator,
   // which will be shown in the result of EXPLAIN ANALYZE to analyze the query.
   private Map&lt;String, String&gt; specifiedInfo = null;
+  private long output = 0;
   private long estimatedMemorySize;
 
   public OperatorContext(
@@ -149,12 +149,12 @@ public long getEstimatedMemorySize() {
     return estimatedMemorySize;
   }
 
+  public void addOutputRows(long outputRows) {
+    this.output += outputRows;
   }
 
+  public long getOutputRows() {
+    return output;
   }
 
   public void recordSpecifiedInfo(String key, String value) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>144910</refactoring_id><commit_sha>a11f47a7ef9106a05dd3cc88a73970c8853fdbfd</commit_sha><commit_link>https://github.com/nationalsecurityagency/ghidra/commit/a11f47a7ef9106a05dd3cc88a73970c8853fdbfd</commit_link><file_path>Ghidra/Framework/Docking/src/main/java/docking/widgets/tree/GTree.java</file_path><description>Rename Method package restoreNonFilteredRootNode() : void renamed to package swingRestoreNonFilteredRootNode() : void in class docking.widgets.tree.GTree</description><code_before>@@ -26,7 +26,6 @@
 import java.util.*;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.BooleanSupplier;
 
 import javax.swing.*;
@@ -94,7 +93,6 @@ public class GTree extends JPanel implements BusyListener {
 	private GTreeDragNDropHandler dragNDropHandler;
 	private boolean isFilteringEnabled = true;
 
-	private AtomicLong modificationID = new AtomicLong();
 	private ThreadLocal&lt;TaskMonitor&gt; threadLocalMonitor = new ThreadLocal&lt;&gt;();
 	private PriorityWorker worker;
 	private Timer showTimer;
@@ -208,28 +206,6 @@ public GTreeDragNDropHandler getDragNDropHandler() {
 	}
 
 	private void init() {
-		model.addTreeModelListener(new TreeModelListener() {
-			@Override
-			public void treeStructureChanged(TreeModelEvent e) {
-				modificationID.incrementAndGet();
-			}
-
-			@Override
-			public void treeNodesRemoved(TreeModelEvent e) {
-				modificationID.incrementAndGet();
-			}
-
-			@Override
-			public void treeNodesInserted(TreeModelEvent e) {
-				modificationID.incrementAndGet();
-			}
-
-			@Override
-			public void treeNodesChanged(TreeModelEvent e) {
-				// don't care
-			}
-		});
-
 		tree = new AutoScrollTree(model);
 
 		setLayout(new BorderLayout());
@@ -295,7 +271,6 @@ public void filterChanged() {
 
 	protected void updateModelFilter() {
 		filter = filterProvider.getFilter();
-		modificationID.incrementAndGet();
 
 		if (lastFilterTask != null) {
 			// it is safe to repeatedly call cancel
@@ -744,33 +719,30 @@ public boolean isMyJTree(JTree jTree) {
 
 	/**
 	 * Sets the root node for the GTree.
-	 * &lt;p&gt;
-	 * Note: If this call is made from the Swing thread, then it will install a temporary
-	 * "In Progress" node and then return immediately.  However, when called from any other thread,
-	 * this method will block while any pending work is cancelled.  In this scenario, when this
-	 * method returns, the given root node will be the actual root node.
-	 *
-	 * @param rootNode The node to set.
 	 */
 	public void setRootNode(GTreeNode rootNode) {
-		worker.clearAllJobs();
-		rootNode.setParent(rootParent);
-		realModelRootNode = rootNode;
-		realViewRootNode = rootNode;
-		GTreeNode oldRoot;
-		try {
-			oldRoot = doSetModelRootNode(rootNode);
-			oldRoot.dispose();
-			if (filter != null) {
-				filterUpdateManager.update();
 			}
-		}
-		catch (CancelledException e) {
-			throw new AssertException("Setting the root node should never be cancelled");
-		}
 	}
 
-	void setFilteredRootNode(GTreeNode filteredRootNode) {
 		filteredRootNode.setParent(rootParent);
 		realViewRootNode = filteredRootNode;
 		try {
@@ -784,7 +756,7 @@ void setFilteredRootNode(GTreeNode filteredRootNode) {
 		}
 	}
 
-	void restoreNonFilteredRootNode() {
 		realViewRootNode = realModelRootNode;
 		try {
 			GTreeNode currentRoot = doSetModelRootNode(realModelRootNode);
@@ -1063,10 +1035,6 @@ public void setRootNodeAllowedToCollapse(boolean allowed) {
 		tree.setRootNodeAllowedToCollapse(allowed);
 	}
 
-	public long getModificationID() {
-		return modificationID.get();
-	}
-
 	private void showProgressPanel(boolean show) {
 		if (show) {
 			progressPanel = monitor;
</code_before><code_after>@@ -26,7 +26,6 @@
 import java.util.*;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BooleanSupplier;
 
 import javax.swing.*;
@@ -94,7 +93,6 @@ public class GTree extends JPanel implements BusyListener {
 	private GTreeDragNDropHandler dragNDropHandler;
 	private boolean isFilteringEnabled = true;
 
 	private ThreadLocal&lt;TaskMonitor&gt; threadLocalMonitor = new ThreadLocal&lt;&gt;();
 	private PriorityWorker worker;
 	private Timer showTimer;
@@ -208,28 +206,6 @@ public GTreeDragNDropHandler getDragNDropHandler() {
 	}
 
 	private void init() {
 		tree = new AutoScrollTree(model);
 
 		setLayout(new BorderLayout());
@@ -295,7 +271,6 @@ public void filterChanged() {
 
 	protected void updateModelFilter() {
 		filter = filterProvider.getFilter();
 
 		if (lastFilterTask != null) {
 			// it is safe to repeatedly call cancel
@@ -744,33 +719,30 @@ public boolean isMyJTree(JTree jTree) {
 
 	/**
 	 * Sets the root node for the GTree.
+	 * 
+	 * @param rootNode The node to set as the root.
 	 */
 	public void setRootNode(GTreeNode rootNode) {
+		Swing.runIfSwingOrRunLater(() -&gt; {
+			worker.clearAllJobs();
+			rootNode.setParent(rootParent);
+			realModelRootNode = rootNode;
+			realViewRootNode = rootNode;
+			GTreeNode oldRoot;
+			try {
+				oldRoot = doSetModelRootNode(rootNode);
+				oldRoot.dispose();
+				if (filter != null) {
+					filterUpdateManager.update();
+				}
 			}
+			catch (CancelledException e) {
+				throw new AssertException("Setting the root node should never be cancelled");
+			}
+		});
 	}
 
+	void swingSetFilteredRootNode(GTreeNode filteredRootNode) {
 		filteredRootNode.setParent(rootParent);
 		realViewRootNode = filteredRootNode;
 		try {
@@ -784,7 +756,7 @@ void setFilteredRootNode(GTreeNode filteredRootNode) {
 		}
 	}
 
+	void swingRestoreNonFilteredRootNode() {
 		realViewRootNode = realModelRootNode;
 		try {
 			GTreeNode currentRoot = doSetModelRootNode(realModelRootNode);
@@ -1063,10 +1035,6 @@ public void setRootNodeAllowedToCollapse(boolean allowed) {
 		tree.setRootNodeAllowedToCollapse(allowed);
 	}
 
 	private void showProgressPanel(boolean show) {
 		if (show) {
 			progressPanel = monitor;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>240916</refactoring_id><commit_sha>8e3ad78a6e7def6ed87d937f3542374c531b37ce</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/8e3ad78a6e7def6ed87d937f3542374c531b37ce</commit_link><file_path>realtime/realtime-common/src/main/java/com/navercorp/pinpoint/realtime/dto/mapper/ATDSupplyMapper.java</file_path><description>Rename Method public fromThrift(s TBase&lt;?,?&gt;) : ATDSupply renamed to package from(s GeneratedMessageV3) : ATDSupply in class com.navercorp.pinpoint.realtime.dto.mapper.grpc.ATDSupplyMapper</description><code_before>@@ -1,81 +0,0 @@
-/*
- * Copyright 2023 NAVER Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.navercorp.pinpoint.realtime.dto.mapper;
-
-import com.navercorp.pinpoint.realtime.dto.ATDSupply;
-import com.navercorp.pinpoint.thrift.dto.command.TCmdActiveThreadDumpRes;
-import com.navercorp.pinpoint.thrift.dto.command.TCmdActiveThreadLightDumpRes;
-import org.apache.thrift.TBase;
-
-/**
- * @author youngjin.kim2
- */
-@SuppressWarnings("ALL")
-public class ATDSupplyMapper {
-
-    public static ATDSupply fromThrift(TBase&lt;?, ?&gt; s) {
-        if (s instanceof TCmdActiveThreadDumpRes) {
-            return fromThrift((TCmdActiveThreadDumpRes) s);
-        }
-        if (s instanceof TCmdActiveThreadLightDumpRes) {
-            return fromThrift((TCmdActiveThreadLightDumpRes) s);
-        }
-        return null;
-    }
-
-    public static ATDSupply fromThrift(TCmdActiveThreadDumpRes s) {
-        final ATDSupply t = new ATDSupply();
-        t.setType(s.getType());
-        t.setSubType(s.getSubType());
-        t.setVersion(s.getVersion());
-        t.setThreadDumps(MapperUtils.mapList(s.getThreadDumps(), ActiveThreadDumpMapper::fromThrift));
-        return t;
-    }
-
-    public static ATDSupply fromThrift(TCmdActiveThreadLightDumpRes s) {
-        final ATDSupply t = new ATDSupply();
-        t.setType(s.getType());
-        t.setSubType(s.getSubType());
-        t.setVersion(s.getVersion());
-        t.setThreadDumps(MapperUtils.mapList(s.getThreadDumps(), ActiveThreadDumpMapper::fromThrift));
-        return t;
-    }
-
-    public static TCmdActiveThreadDumpRes toThriftDetailed(ATDSupply s) {
-        if (s == null) {
-            return null;
-        }
-        final TCmdActiveThreadDumpRes t = new TCmdActiveThreadDumpRes();
-        t.setType(s.getType());
-        t.setSubType(s.getSubType());
-        t.setVersion(s.getVersion());
-        t.setThreadDumps(MapperUtils.mapList(s.getThreadDumps(), ActiveThreadDumpMapper::toThriftDetailed));
-        return t;
-    }
-
-    public static TCmdActiveThreadLightDumpRes toThriftLight(ATDSupply s) {
-        if (s == null) {
-            return null;
-        }
-        final TCmdActiveThreadLightDumpRes t = new TCmdActiveThreadLightDumpRes();
-        t.setType(s.getType());
-        t.setSubType(s.getSubType());
-        t.setVersion(s.getVersion());
-        t.setThreadDumps(MapperUtils.mapList(s.getThreadDumps(), ActiveThreadDumpMapper::toThriftLight));
-        return t;
-    }
-
-}
</code_before><code_after>@@ -1,81 +0,0 @@
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>238866</refactoring_id><commit_sha>8b4c8fef14cb8da2b3c15e1d611995d74d08104f</commit_sha><commit_link>https://github.com/apache/tomcat/commit/8b4c8fef14cb8da2b3c15e1d611995d74d08104f</commit_link><file_path>java/org/apache/catalina/storeconfig/StandardServiceSF.java</file_path><description>Rename Method public storeChilds(aWriter PrintWriter, indent int, aService Object, parentDesc StoreDescription) : void renamed to public storeChildren(aWriter PrintWriter, indent int, aService Object, parentDesc StoreDescription) : void in class org.apache.catalina.storeconfig.StandardServiceSF</description><code_before>@@ -27,20 +27,20 @@
 import org.apache.catalina.core.StandardService;
 
 /**
- * Store server.xml Element Service and all childs
  */
 public class StandardServiceSF extends StoreFactoryBase {
 
     /**
-     * Store Childs from this StandardService description
      *
      * @param aWriter
      * @param indent
      * @param aService
      * @throws Exception
      */
     @Override
-    public void storeChilds(PrintWriter aWriter, int indent, Object aService,
             StoreDescription parentDesc) throws Exception {
         if (aService instanceof StandardService) {
             StandardService service = (StandardService) aService;
</code_before><code_after>@@ -27,20 +27,20 @@
 import org.apache.catalina.core.StandardService;
 
 /**
+ * Store server.xml Element Service and all children
  */
 public class StandardServiceSF extends StoreFactoryBase {
 
     /**
+     * Store Children from this StandardService description
      *
      * @param aWriter
      * @param indent
      * @param aService
      * @throws Exception
      */
     @Override
+    public void storeChildren(PrintWriter aWriter, int indent, Object aService,
             StoreDescription parentDesc) throws Exception {
         if (aService instanceof StandardService) {
             StandardService service = (StandardService) aService;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>282951</refactoring_id><commit_sha>d723c54e8f7fde69fc6ff70a9dcc4c47517db983</commit_sha><commit_link>https://github.com/gocd/gocd/commit/d723c54e8f7fde69fc6ff70a9dcc4c47517db983</commit_link><file_path>server/src/test-fast/java/com/thoughtworks/go/server/domain/user/FiltersTest.java</file_path><description>Rename Method private whitelist(pipelines String...) : DashboardFilter renamed to private includes(pipelines String...) : DashboardFilter in class com.thoughtworks.go.server.domain.user.FiltersTest</description><code_before>@@ -33,22 +33,22 @@ class FiltersTest {
 
     @Test
     void validatesNameFormatOnConstruction() {
-        DashboardFilter a = namedWhitelist("&#xAF;\\_(&#x30C4;)_/&#xAF;");
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(a)));
         assertEquals(MSG_NAME_FORMAT, e.getMessage());
 
-        DashboardFilter b = namedWhitelist(" filter");
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(b)));
         assertEquals(MSG_NO_LEADING_TRAILING_SPACES, e.getMessage());
 
-        DashboardFilter c = namedWhitelist("filter ");
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(c)));
         assertEquals(MSG_NO_LEADING_TRAILING_SPACES, e.getMessage());
 
-        DashboardFilter d = namedWhitelist(NAME_TOO_LONG);
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(d)));
         assertEquals(MSG_MAX_LENGTH, e.getMessage());
     }
@@ -82,17 +82,17 @@ void validatesNameFormatOnDeserialize() {
 
     @Test
     void validatesNamePresenceOnConstruction() {
-        DashboardFilter a = namedWhitelist("");
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(a)));
         assertEquals(MSG_MISSING_NAME, e.getMessage());
 
-        DashboardFilter b = namedWhitelist(" ");
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(b)));
         assertEquals(MSG_MISSING_NAME, e.getMessage());
 
-        DashboardFilter c = namedWhitelist(null);
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(c)));
         assertEquals(MSG_MISSING_NAME, e.getMessage());
@@ -121,8 +121,8 @@ void validatesNamePresenceOnDeserialize() {
 
     @Test
     void validatesDuplicateNamesOnConstruction() {
-        DashboardFilter a = namedWhitelist("one");
-        DashboardFilter b = namedBlacklist("one");
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Arrays.asList(a, b)));
         assertEquals("Duplicate filter name: one", e.getMessage());
@@ -150,7 +150,7 @@ void validatesStateOnDeserialize() {
 
     @Test
     void validatesPresenceOfAtLeastOneFilterOnConstruction() {
-        assertDoesNotThrow(() -&gt; new Filters(Collections.singletonList(namedWhitelist("foo", "p1"))));
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.emptyList()));
         assertEquals(MSG_NO_DEFAULT_FILTER, e.getMessage());
@@ -171,16 +171,16 @@ void fromJson() {
         assertEquals(1, filters.filters().size());
         final DashboardFilter first = filters.filters().get(0);
         assertEquals(first.name(), DEFAULT_NAME);
-        assertTrue(first instanceof WhitelistFilter);
-        assertEquals(1, ((WhitelistFilter) first).pipelines().size());
-        assertTrue(((WhitelistFilter) first).pipelines().contains(new CaseInsensitiveString("p1")));
     }
 
     @Test
     void toJson() {
         List&lt;DashboardFilter&gt; views = new ArrayList&lt;&gt;();
         views.add(WILDCARD_FILTER);
-        views.add(namedBlacklist("Cool Pipelines", "Pipely McPipe"));
         final Filters filters = new Filters(views);
 
         assertEquals("{\"filters\":[" +
@@ -191,39 +191,39 @@ void toJson() {
 
     @Test
     void equalsIsStructuralEquality() {
-        final Filters a = Filters.single(blacklist("p1", "p2"));
-        final Filters b = Filters.single(blacklist("p1", "p2"));
-        final Filters c = Filters.single(blacklist("p1", "p3"));
 
         assertEquals(a, b);
         assertNotEquals(a, c);
 
-        final Filters d = Filters.single(whitelist("p1", "p2"));
-        final Filters e = Filters.single(whitelist("p1", "p2"));
-        final Filters f = Filters.single(whitelist("p1", "p3"));
 
         assertEquals(d, e);
         assertNotEquals(d, f);
 
         assertNotEquals(a, d);
 
-        assertEquals(Filters.defaults(), Filters.single(blacklist()));
     }
 
 
-    private DashboardFilter namedWhitelist(String name, String... pipelines) {
-        return new WhitelistFilter(name, CaseInsensitiveString.list(pipelines), new HashSet&lt;&gt;());
     }
 
-    private DashboardFilter whitelist(String... pipelines) {
-        return namedWhitelist(DEFAULT_NAME, pipelines);
     }
 
-    private DashboardFilter namedBlacklist(String name, String... pipelines) {
-        return new BlacklistFilter(name, CaseInsensitiveString.list(pipelines), new HashSet&lt;&gt;());
     }
 
-    private DashboardFilter blacklist(String... pipelines) {
-        return namedBlacklist(DEFAULT_NAME, pipelines);
     }
 }
\ No newline at end of file
</code_before><code_after>@@ -33,22 +33,22 @@ class FiltersTest {
 
     @Test
     void validatesNameFormatOnConstruction() {
+        DashboardFilter a = namedIncludes("&#xAF;\\_(&#x30C4;)_/&#xAF;");
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(a)));
         assertEquals(MSG_NAME_FORMAT, e.getMessage());
 
+        DashboardFilter b = namedIncludes(" filter");
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(b)));
         assertEquals(MSG_NO_LEADING_TRAILING_SPACES, e.getMessage());
 
+        DashboardFilter c = namedIncludes("filter ");
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(c)));
         assertEquals(MSG_NO_LEADING_TRAILING_SPACES, e.getMessage());
 
+        DashboardFilter d = namedIncludes(NAME_TOO_LONG);
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(d)));
         assertEquals(MSG_MAX_LENGTH, e.getMessage());
     }
@@ -82,17 +82,17 @@ void validatesNameFormatOnDeserialize() {
 
     @Test
     void validatesNamePresenceOnConstruction() {
+        DashboardFilter a = namedIncludes("");
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(a)));
         assertEquals(MSG_MISSING_NAME, e.getMessage());
 
+        DashboardFilter b = namedIncludes(" ");
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(b)));
         assertEquals(MSG_MISSING_NAME, e.getMessage());
 
+        DashboardFilter c = namedIncludes(null);
 
         e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.singletonList(c)));
         assertEquals(MSG_MISSING_NAME, e.getMessage());
@@ -121,8 +121,8 @@ void validatesNamePresenceOnDeserialize() {
 
     @Test
     void validatesDuplicateNamesOnConstruction() {
+        DashboardFilter a = namedIncludes("one");
+        DashboardFilter b = namedExcludes("one");
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Arrays.asList(a, b)));
         assertEquals("Duplicate filter name: one", e.getMessage());
@@ -150,7 +150,7 @@ void validatesStateOnDeserialize() {
 
     @Test
     void validatesPresenceOfAtLeastOneFilterOnConstruction() {
+        assertDoesNotThrow(() -&gt; new Filters(Collections.singletonList(namedIncludes("foo", "p1"))));
 
         Throwable e = assertThrows(FilterValidationException.class, () -&gt; new Filters(Collections.emptyList()));
         assertEquals(MSG_NO_DEFAULT_FILTER, e.getMessage());
@@ -171,16 +171,16 @@ void fromJson() {
         assertEquals(1, filters.filters().size());
         final DashboardFilter first = filters.filters().get(0);
         assertEquals(first.name(), DEFAULT_NAME);
+        assertTrue(first instanceof IncludesFilter);
+        assertEquals(1, ((IncludesFilter) first).pipelines().size());
+        assertTrue(((IncludesFilter) first).pipelines().contains(new CaseInsensitiveString("p1")));
     }
 
     @Test
     void toJson() {
         List&lt;DashboardFilter&gt; views = new ArrayList&lt;&gt;();
         views.add(WILDCARD_FILTER);
+        views.add(namedExcludes("Cool Pipelines", "Pipely McPipe"));
         final Filters filters = new Filters(views);
 
         assertEquals("{\"filters\":[" +
@@ -191,39 +191,39 @@ void toJson() {
 
     @Test
     void equalsIsStructuralEquality() {
+        final Filters a = Filters.single(excludes("p1", "p2"));
+        final Filters b = Filters.single(excludes("p1", "p2"));
+        final Filters c = Filters.single(excludes("p1", "p3"));
 
         assertEquals(a, b);
         assertNotEquals(a, c);
 
+        final Filters d = Filters.single(includes("p1", "p2"));
+        final Filters e = Filters.single(includes("p1", "p2"));
+        final Filters f = Filters.single(includes("p1", "p3"));
 
         assertEquals(d, e);
         assertNotEquals(d, f);
 
         assertNotEquals(a, d);
 
+        assertEquals(Filters.defaults(), Filters.single(excludes()));
     }
 
 
+    private DashboardFilter namedIncludes(String name, String... pipelines) {
+        return new IncludesFilter(name, CaseInsensitiveString.list(pipelines), new HashSet&lt;&gt;());
     }
 
+    private DashboardFilter includes(String... pipelines) {
+        return namedIncludes(DEFAULT_NAME, pipelines);
     }
 
+    private DashboardFilter namedExcludes(String name, String... pipelines) {
+        return new ExcludesFilter(name, CaseInsensitiveString.list(pipelines), new HashSet&lt;&gt;());
     }
 
+    private DashboardFilter excludes(String... pipelines) {
+        return namedExcludes(DEFAULT_NAME, pipelines);
     }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>143592</refactoring_id><commit_sha>f498d393b0b2250664353c2dc3bdba69fe372f14</commit_sha><commit_link>https://github.com/bisq-network/bisq/commit/f498d393b0b2250664353c2dc3bdba69fe372f14</commit_link><file_path>core/src/main/java/io/bitsquare/trade/protocol/availability/CheckOfferAvailabilityProtocol.java</file_path><description>Rename Method private handleReportOfferAvailabilityMessage(message ReportOfferAvailabilityMessage) : void renamed to private handle(message ReportOfferAvailabilityMessage) : void in class io.bitsquare.trade.protocol.availability.CheckOfferAvailabilityProtocol</description><code_before>@@ -29,16 +29,24 @@
 import io.bitsquare.trade.protocol.availability.tasks.ProcessReportOfferAvailabilityMessage;
 import io.bitsquare.trade.protocol.availability.tasks.RequestIsOfferAvailable;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class CheckOfferAvailabilityProtocol {
     private static final Logger log = LoggerFactory.getLogger(CheckOfferAvailabilityProtocol.class);
 
     private final CheckOfferAvailabilityModel model;
     private final ResultHandler resultHandler;
     private final ErrorMessageHandler errorMessageHandler;
     private final MessageHandler messageHandler;
 
     private boolean isCanceled;
     private TaskRunner&lt;CheckOfferAvailabilityModel&gt; taskRunner;
@@ -56,6 +64,7 @@ public CheckOfferAvailabilityProtocol(CheckOfferAvailabilityModel model, ResultH
     }
 
     private void cleanup() {
         model.messageService.removeMessageHandler(messageHandler);
     }
 
@@ -78,6 +87,7 @@ public void checkOfferAvailability() {
                 GetPeerAddress.class,
                 RequestIsOfferAvailable.class
         );
         taskRunner.run();
     }
 
@@ -95,11 +105,12 @@ public void cancel() {
     private void handleMessage(Message message, @SuppressWarnings("UnusedParameters") Peer sender) {
         if (!isCanceled) {
             if (message instanceof ReportOfferAvailabilityMessage &amp;&amp; model.offer.getId().equals(((ReportOfferAvailabilityMessage) message).offerId))
-                handleReportOfferAvailabilityMessage((ReportOfferAvailabilityMessage) message);
         }
     }
 
-    private void handleReportOfferAvailabilityMessage(ReportOfferAvailabilityMessage message) {
         model.setMessage(message);
 
         taskRunner = new TaskRunner&lt;&gt;(model,
@@ -115,4 +126,30 @@ private void handleReportOfferAvailabilityMessage(ReportOfferAvailabilityMessage
         taskRunner.addTasks(ProcessReportOfferAvailabilityMessage.class);
         taskRunner.run();
     }
 }
</code_before><code_after>@@ -29,16 +29,24 @@
 import io.bitsquare.trade.protocol.availability.tasks.ProcessReportOfferAvailabilityMessage;
 import io.bitsquare.trade.protocol.availability.tasks.RequestIsOfferAvailable;
 
+import java.util.Timer;
+import java.util.TimerTask;
+
+import javafx.application.Platform;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class CheckOfferAvailabilityProtocol {
     private static final Logger log = LoggerFactory.getLogger(CheckOfferAvailabilityProtocol.class);
 
+    private static final long TIMEOUT = 10000;
+
     private final CheckOfferAvailabilityModel model;
     private final ResultHandler resultHandler;
     private final ErrorMessageHandler errorMessageHandler;
     private final MessageHandler messageHandler;
+    private Timer timeoutTimer;
 
     private boolean isCanceled;
     private TaskRunner&lt;CheckOfferAvailabilityModel&gt; taskRunner;
@@ -56,6 +64,7 @@ public CheckOfferAvailabilityProtocol(CheckOfferAvailabilityModel model, ResultH
     }
 
     private void cleanup() {
+        stopTimeout();
         model.messageService.removeMessageHandler(messageHandler);
     }
 
@@ -78,6 +87,7 @@ public void checkOfferAvailability() {
                 GetPeerAddress.class,
                 RequestIsOfferAvailable.class
         );
+        startTimeout();
         taskRunner.run();
     }
 
@@ -95,11 +105,12 @@ public void cancel() {
     private void handleMessage(Message message, @SuppressWarnings("UnusedParameters") Peer sender) {
         if (!isCanceled) {
             if (message instanceof ReportOfferAvailabilityMessage &amp;&amp; model.offer.getId().equals(((ReportOfferAvailabilityMessage) message).offerId))
+                handle((ReportOfferAvailabilityMessage) message);
         }
     }
 
+    private void handle(ReportOfferAvailabilityMessage message) {
+        stopTimeout();
         model.setMessage(message);
 
         taskRunner = new TaskRunner&lt;&gt;(model,
@@ -115,4 +126,30 @@ private void handleReportOfferAvailabilityMessage(ReportOfferAvailabilityMessage
         taskRunner.addTasks(ProcessReportOfferAvailabilityMessage.class);
         taskRunner.run();
     }
+
+    protected void startTimeout() {
+        log.debug("startTimeout");
+        stopTimeout();
+
+        timeoutTimer = new Timer();
+        TimerTask task = new TimerTask() {
+            @Override
+            public void run() {
+                Platform.runLater(() -&gt; {
+                    log.debug("Timeout reached");
+                    errorMessageHandler.handleErrorMessage("Timeout reached: Peer has not responded.");
+                });
+            }
+        };
+
+        timeoutTimer.schedule(task, TIMEOUT);
+    }
+
+    protected void stopTimeout() {
+        log.debug("stopTimeout");
+        if (timeoutTimer != null) {
+            timeoutTimer.cancel();
+            timeoutTimer = null;
+        }
+    }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>329512</refactoring_id><commit_sha>af31d3dd6243c1690792a2593bb844552af5a669</commit_sha><commit_link>https://github.com/oracle/graal/commit/af31d3dd6243c1690792a2593bb844552af5a669</commit_link><file_path>projects/com.oracle.truffle.llvm.nodes/src/com/oracle/truffle/llvm/nodes/cast/LLVMTo80BitFloatingNode.java</file_path><description>Rename Method public executeLLVM80BitFloatNode(from float) : LLVM80BitFloat renamed to protected doLLVM80BitFloatNode(from float) : LLVM80BitFloat in class com.oracle.truffle.llvm.nodes.cast.LLVMTo80BitFloatingNode.LLVMUnsignedToLLVM80BitFloatNode</description><code_before>@@ -45,42 +45,42 @@ public abstract class LLVMTo80BitFloatingNode extends LLVMExpressionNode {
     public abstract static class LLVMSignedToLLVM80BitFloatNode extends LLVMTo80BitFloatingNode {
 
         @Specialization
-        public LLVM80BitFloat execute80BitFloat(byte from) {
             return LLVM80BitFloat.fromByte(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(short from) {
             return LLVM80BitFloat.fromShort(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(int from) {
             return LLVM80BitFloat.fromInt(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(long from) {
             return LLVM80BitFloat.fromLong(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(float from) {
             return LLVM80BitFloat.fromFloat(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(double from) {
             return LLVM80BitFloat.fromDouble(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(LLVM80BitFloat from) {
             return from;
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(LLVMIVarBit from) {
             return LLVM80BitFloat.fromBytesBigEndian(from.getBytes());
         }
     }
@@ -89,37 +89,37 @@ public LLVM80BitFloat executeLLVM80BitFloatNode(LLVMIVarBit from) {
     public abstract static class LLVMUnsignedToLLVM80BitFloatNode extends LLVMTo80BitFloatingNode {
 
         @Specialization
-        public LLVM80BitFloat execute80BitFloat(byte from) {
             return LLVM80BitFloat.fromUnsignedByte(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(int from) {
             return LLVM80BitFloat.fromUnsignedInt(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(long from) {
             return LLVM80BitFloat.fromUnsignedLong(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(float from) {
             return LLVM80BitFloat.fromFloat(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(double from) {
             return LLVM80BitFloat.fromDouble(from);
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(LLVM80BitFloat from) {
             return from;
         }
 
         @Specialization
-        public LLVM80BitFloat executeLLVM80BitFloatNode(LLVMIVarBit from) {
             return LLVM80BitFloat.fromBytesBigEndian(from.getBytes());
         }
     }
@@ -128,7 +128,7 @@ public LLVM80BitFloat executeLLVM80BitFloatNode(LLVMIVarBit from) {
     public abstract static class LLVMToLLVM80BitFloatBitNode extends LLVMTo80BitFloatingNode {
 
         @Specialization
-        public LLVM80BitFloat executeI1Vector(LLVMI1Vector from) {
             if (from.getLength() != LLVM80BitFloat.BIT_WIDTH) {
                 CompilerDirectives.transferToInterpreter();
                 throw new AssertionError("invalid vector size!");
@@ -144,7 +144,7 @@ public LLVM80BitFloat executeI1Vector(LLVMI1Vector from) {
         }
 
         @Specialization
-        public LLVM80BitFloat executeI8Vector(LLVMI8Vector from) {
             if (from.getLength() != LLVM80BitFloat.BIT_WIDTH / Byte.SIZE) {
                 CompilerDirectives.transferToInterpreter();
                 throw new AssertionError("invalid vector size!");
@@ -157,7 +157,7 @@ public LLVM80BitFloat executeI8Vector(LLVMI8Vector from) {
         }
 
         @Specialization
-        public LLVM80BitFloat executeI16Vector(LLVMI16Vector from) {
             if (from.getLength() != LLVM80BitFloat.BIT_WIDTH / Short.SIZE) {
                 CompilerDirectives.transferToInterpreter();
                 throw new AssertionError("invalid vector size!");
@@ -170,5 +170,4 @@ public LLVM80BitFloat executeI16Vector(LLVMI16Vector from) {
             return LLVM80BitFloat.fromBytes(values);
         }
     }
-
 }
</code_before><code_after>@@ -45,42 +45,42 @@ public abstract class LLVMTo80BitFloatingNode extends LLVMExpressionNode {
     public abstract static class LLVMSignedToLLVM80BitFloatNode extends LLVMTo80BitFloatingNode {
 
         @Specialization
+        protected LLVM80BitFloat do80BitFloat(byte from) {
             return LLVM80BitFloat.fromByte(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(short from) {
             return LLVM80BitFloat.fromShort(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(int from) {
             return LLVM80BitFloat.fromInt(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(long from) {
             return LLVM80BitFloat.fromLong(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(float from) {
             return LLVM80BitFloat.fromFloat(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(double from) {
             return LLVM80BitFloat.fromDouble(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(LLVM80BitFloat from) {
             return from;
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(LLVMIVarBit from) {
             return LLVM80BitFloat.fromBytesBigEndian(from.getBytes());
         }
     }
@@ -89,37 +89,37 @@ public LLVM80BitFloat executeLLVM80BitFloatNode(LLVMIVarBit from) {
     public abstract static class LLVMUnsignedToLLVM80BitFloatNode extends LLVMTo80BitFloatingNode {
 
         @Specialization
+        protected LLVM80BitFloat do80BitFloat(byte from) {
             return LLVM80BitFloat.fromUnsignedByte(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(int from) {
             return LLVM80BitFloat.fromUnsignedInt(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(long from) {
             return LLVM80BitFloat.fromUnsignedLong(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(float from) {
             return LLVM80BitFloat.fromFloat(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(double from) {
             return LLVM80BitFloat.fromDouble(from);
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(LLVM80BitFloat from) {
             return from;
         }
 
         @Specialization
+        protected LLVM80BitFloat doLLVM80BitFloatNode(LLVMIVarBit from) {
             return LLVM80BitFloat.fromBytesBigEndian(from.getBytes());
         }
     }
@@ -128,7 +128,7 @@ public LLVM80BitFloat executeLLVM80BitFloatNode(LLVMIVarBit from) {
     public abstract static class LLVMToLLVM80BitFloatBitNode extends LLVMTo80BitFloatingNode {
 
         @Specialization
+        protected LLVM80BitFloat doI1Vector(LLVMI1Vector from) {
             if (from.getLength() != LLVM80BitFloat.BIT_WIDTH) {
                 CompilerDirectives.transferToInterpreter();
                 throw new AssertionError("invalid vector size!");
@@ -144,7 +144,7 @@ public LLVM80BitFloat executeI1Vector(LLVMI1Vector from) {
         }
 
         @Specialization
+        protected LLVM80BitFloat doI8Vector(LLVMI8Vector from) {
             if (from.getLength() != LLVM80BitFloat.BIT_WIDTH / Byte.SIZE) {
                 CompilerDirectives.transferToInterpreter();
                 throw new AssertionError("invalid vector size!");
@@ -157,7 +157,7 @@ public LLVM80BitFloat executeI8Vector(LLVMI8Vector from) {
         }
 
         @Specialization
+        protected LLVM80BitFloat doI16Vector(LLVMI16Vector from) {
             if (from.getLength() != LLVM80BitFloat.BIT_WIDTH / Short.SIZE) {
                 CompilerDirectives.transferToInterpreter();
                 throw new AssertionError("invalid vector size!");
@@ -170,5 +170,4 @@ public LLVM80BitFloat executeI16Vector(LLVMI16Vector from) {
             return LLVM80BitFloat.fromBytes(values);
         }
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>252840</refactoring_id><commit_sha>411348ea663a14c6f9d07ffdc9a8332ac105142b</commit_sha><commit_link>https://github.com/real-logic/aeron/commit/411348ea663a14c6f9d07ffdc9a8332ac105142b</commit_link><file_path>aeron-driver/src/main/java/io/aeron/driver/SubscriptionLink.java</file_path><description>Rename Method public removeImage(image PublicationImage) : void renamed to public removeSource(source Object) : void in class io.aeron.driver.NetworkSubscriptionLink</description><code_before>@@ -83,21 +83,9 @@ public boolean matches(final ReceiveChannelEndpoint channelEndpoint, final int s
         return false;
     }
 
-    public void addSpiedPublication(final NetworkPublication publication, final ReadablePosition position)
-    {
-    }
 
-    public void removeSpiedPublication()
-    {
-    }
-
-    public void addImage(final PublicationImage image, final ReadablePosition position)
-    {
-    }
-
-    public void removeImage(final PublicationImage image)
-    {
-    }
 
     public abstract void close();
 
@@ -167,14 +155,15 @@ public boolean matches(final ReceiveChannelEndpoint channelEndpoint, final int s
         return channelEndpoint == this.channelEndpoint &amp;&amp; streamId == this.streamId;
     }
 
-    public void addImage(final PublicationImage image, final ReadablePosition position)
     {
-        positionByImageMap.put(image, position);
     }
 
-    public void removeImage(final PublicationImage image)
     {
-        positionByImageMap.remove(image);
     }
 
     public void close()
@@ -185,38 +174,48 @@ public void close()
 
 class IpcSubscriptionLink extends SubscriptionLink
 {
-    private final IpcPublication ipcPublication;
-    private final ReadablePosition ipcPublicationSubscriberPosition;
 
     IpcSubscriptionLink(
         final long registrationId,
         final int streamId,
         final String channelUri,
-        final IpcPublication ipcPublication,
-        final ReadablePosition subscriberPosition,
         final AeronClient aeronClient,
         final long clientLivenessTimeoutNs)
     {
         super(registrationId, streamId, channelUri, aeronClient, clientLivenessTimeoutNs);
 
-        this.ipcPublication = ipcPublication;
-        this.ipcPublicationSubscriberPosition = subscriberPosition;
 
-        ipcPublication.incRef();
     }
 
     public void close()
     {
-        ipcPublication.removeSubscription(ipcPublicationSubscriberPosition);
-        ipcPublication.decRef();
     }
 }
 
 class SpySubscriptionLink extends SubscriptionLink
 {
-    private final UdpChannel spiedChannel;
-    private NetworkPublication spiedPublication = null;
-    private ReadablePosition spiedPosition = null;
 
     SpySubscriptionLink(
         final long registrationId,
@@ -226,32 +225,32 @@ class SpySubscriptionLink extends SubscriptionLink
         final long clientLivenessTimeoutNs)
     {
         super(registrationId, streamId, spiedChannel.originalUriString(), aeronClient, clientLivenessTimeoutNs);
-        this.spiedChannel = spiedChannel;
     }
 
-    public void addSpiedPublication(final NetworkPublication publication, final ReadablePosition position)
     {
-        spiedPublication = publication;
-        spiedPosition = position;
     }
 
-    public void removeSpiedPublication()
     {
-        spiedPublication = null;
-        spiedPosition = null;
     }
 
     public boolean matches(final NetworkPublication publication)
     {
         return streamId == publication.streamId() &amp;&amp;
-            publication.sendChannelEndpoint().udpChannel().canonicalForm().equals(spiedChannel.canonicalForm());
     }
 
     public void close()
     {
-        if (null != spiedPublication)
         {
-            spiedPublication.removeSpyPosition(spiedPosition);
         }
     }
 }
\ No newline at end of file
</code_before><code_after>@@ -83,21 +83,9 @@ public boolean matches(final ReceiveChannelEndpoint channelEndpoint, final int s
         return false;
     }
 
+    public abstract void addSource(Object source, ReadablePosition position);
 
+    public abstract void removeSource(Object source);
 
     public abstract void close();
 
@@ -167,14 +155,15 @@ public boolean matches(final ReceiveChannelEndpoint channelEndpoint, final int s
         return channelEndpoint == this.channelEndpoint &amp;&amp; streamId == this.streamId;
     }
 
+    public void addSource(final Object source, final ReadablePosition position)
     {
+        positionByImageMap.put((PublicationImage)source, position);
     }
 
+    @SuppressWarnings("SuspiciousMethodCalls")
+    public void removeSource(final Object source)
     {
+        positionByImageMap.remove(source);
     }
 
     public void close()
@@ -185,38 +174,48 @@ public void close()
 
 class IpcSubscriptionLink extends SubscriptionLink
 {
+    private IpcPublication publication;
+    private ReadablePosition position;
 
     IpcSubscriptionLink(
         final long registrationId,
         final int streamId,
         final String channelUri,
         final AeronClient aeronClient,
         final long clientLivenessTimeoutNs)
     {
         super(registrationId, streamId, channelUri, aeronClient, clientLivenessTimeoutNs);
+    }
+
+    public void addSource(final Object source, final ReadablePosition position)
+    {
+        this.publication = (IpcPublication)source;
+        this.position = position;
 
+        publication.incRef();
+    }
 
+    public void removeSource(final Object source)
+    {
+        publication = null;
+        position = null;
     }
 
     public void close()
     {
+        if (null != publication)
+        {
+            publication.removeSubscription(position);
+            publication.decRef();
+        }
     }
 }
 
 class SpySubscriptionLink extends SubscriptionLink
 {
+    private final UdpChannel udpChannel;
+    private NetworkPublication publication = null;
+    private ReadablePosition position = null;
 
     SpySubscriptionLink(
         final long registrationId,
@@ -226,32 +225,32 @@ class SpySubscriptionLink extends SubscriptionLink
         final long clientLivenessTimeoutNs)
     {
         super(registrationId, streamId, spiedChannel.originalUriString(), aeronClient, clientLivenessTimeoutNs);
+        this.udpChannel = spiedChannel;
     }
 
+    public void addSource(final Object source, final ReadablePosition position)
     {
+        this.publication = (NetworkPublication)source;
+        this.position = position;
     }
 
+    public void removeSource(final Object source)
     {
+        publication = null;
+        position = null;
     }
 
     public boolean matches(final NetworkPublication publication)
     {
         return streamId == publication.streamId() &amp;&amp;
+            publication.sendChannelEndpoint().udpChannel().canonicalForm().equals(udpChannel.canonicalForm());
     }
 
     public void close()
     {
+        if (null != publication)
         {
+            publication.removeSpyPosition(position);
         }
     }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>254739</refactoring_id><commit_sha>6e7cd88b487189d8fa11ccb84e60382e4bd5d980</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/6e7cd88b487189d8fa11ccb84e60382e4bd5d980</commit_link><file_path>src/edu/stanford/nlp/io/IOUtils.java</file_path><description>Rename Method public readerFromString(textFileOrUrl String) : BufferedReader renamed to public readReaderFromString(textFileOrUrl String) : BufferedReader in class edu.stanford.nlp.io.IOUtils</description><code_before>@@ -422,30 +422,17 @@ public static InputStream getInputStreamFromURLOrClasspathOrFileSystem(String te
     return in;
   }
 
-  /**
-   * Open a BufferedReader to a file or URL specified by a String name. If the
-   * String starts with https?://, then it is first tried as a URL, otherwise it
-   * is next tried as a resource on the CLASSPATH, and then finally it is tried
-   * as a local file or other network-available file . If the String ends in .gz, it
-   * is interpreted as a gzipped file (and uncompressed). The file is then
-   * interpreted as a utf-8 text file.
-   *
-   * @param textFileOrUrl What to read from
-   * @return The BufferedReader
-   * @throws IOException If there is an I/O problem
-   */
-  public static BufferedReader readerFromString(String textFileOrUrl)
           throws IOException {
     return new BufferedReader(new InputStreamReader(
-            getInputStreamFromURLOrClasspathOrFileSystem(textFileOrUrl), "UTF-8"));
   }
 
   /**
    * Open a BufferedReader to a file or URL specified by a String name. If the
-   * String starts with https?://, then it is first tried as a URL, otherwise it
-   * is next tried as a resource on the CLASSPATH, and then finally it is tried
-   * as a local file or other network-available file . If the String ends in .gz, it
-   * is interpreted as a gzipped file (and uncompressed), else it is interpreted as
    * a regular text file in the given encoding.
    *
    * @param textFileOrUrl What to read from
</code_before><code_after>@@ -422,30 +422,17 @@ public static InputStream getInputStreamFromURLOrClasspathOrFileSystem(String te
     return in;
   }
 
+  public static BufferedReader readReaderFromString(String textFileOrUrl)
           throws IOException {
     return new BufferedReader(new InputStreamReader(
+            getInputStreamFromURLOrClasspathOrFileSystem(textFileOrUrl)));
   }
 
   /**
    * Open a BufferedReader to a file or URL specified by a String name. If the
+   * String starts with https?://, then it is interpreted as a URL, otherwise it
+   * is interpreted as a local file. If the String ends in .gz, it is
+   * interpreted as a gzipped file (and uncompressed), else it is interpreted as
    * a regular text file in the given encoding.
    *
    * @param textFileOrUrl What to read from
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>306073</refactoring_id><commit_sha>cc09c3a504e94270f1c2c000526556ac9059b412</commit_sha><commit_link>https://github.com/flowable/flowable-engine/commit/cc09c3a504e94270f1c2c000526556ac9059b412</commit_link><file_path>modules/activiti-engine/src/test/java/org/activiti/examples/bpmn/servicetask/ExpressionServiceTaskTest.java</file_path><description>Rename Method public testSetServiceResultToProcessVariables() : void renamed to public testBackwardsCompatibleExpression() : void in class org.activiti.examples.bpmn.servicetask.ExpressionServiceTaskTest</description><code_before>@@ -12,14 +12,19 @@
  */
 public class ExpressionServiceTaskTest extends PluggableActivitiTestCase {
 
   @Deployment
-  public void testSetServiceResultToProcessVariables() {
     Map&lt;String,Object&gt; variables = new HashMap&lt;String, Object&gt;();
-    variables.put("bean", new ValueBean("ok"));
-
-    ProcessInstance pi = runtimeService.startProcessInstanceByKey("setServiceResultToProcessVariables", variables);
-
-    assertEquals("ok", runtimeService.getVariable(pi.getId(), "result"));
   }
-
 }
</code_before><code_after>@@ -12,14 +12,19 @@
  */
 public class ExpressionServiceTaskTest extends PluggableActivitiTestCase {
 
+//  @Deployment
+//  public void testSetServiceResultToProcessVariables() {
+//    Map&lt;String,Object&gt; variables = new HashMap&lt;String, Object&gt;();
+//    variables.put("bean", new ValueBean("ok"));
+//    ProcessInstance pi = runtimeService.startProcessInstanceByKey("setServiceResultToProcessVariables", variables);
+//    assertEquals("ok", runtimeService.getVariable(pi.getId(), "result"));
+//  }
+
   @Deployment
+  public void testBackwardsCompatibleExpression() {
     Map&lt;String,Object&gt; variables = new HashMap&lt;String, Object&gt;();
+    variables.put("var", "---");
+    ProcessInstance pi = runtimeService.startProcessInstanceByKey("BackwardsCompatibleExpressionProcess", variables);
+    assertEquals("...---...", runtimeService.getVariable(pi.getId(), "result"));
   }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>229871</refactoring_id><commit_sha>3b720c3995decf59fef67d21936d0a7e7a246a02</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/3b720c3995decf59fef67d21936d0a7e7a246a02</commit_link><file_path>js-karma/src/com/intellij/javascript/karma/execution/KarmaRunSettings.java</file_path><description>Rename Method public getKarmaPackageDir() : String renamed to public getKarmaPackage() : NodePackage in class com.intellij.javascript.karma.execution.KarmaRunSettings</description><code_before>@@ -2,24 +2,23 @@
 
 import com.intellij.execution.configuration.EnvironmentVariablesData;
 import com.intellij.javascript.nodejs.interpreter.NodeJsInterpreterRef;
 import com.intellij.openapi.util.io.FileUtil;
-import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.util.containers.ComparatorUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 public class KarmaRunSettings {
 
   private final String myConfigPath;
-  private final String myKarmaPackageDir;
   private final String myBrowsers;
   private final NodeJsInterpreterRef myInterpreterRef;
   private final EnvironmentVariablesData myEnvData;
 
   public KarmaRunSettings(@NotNull Builder builder) {
     myConfigPath = FileUtil.toSystemDependentName(builder.myConfigPath);
-    myKarmaPackageDir = builder.myKarmaPackageDir != null ? FileUtil.toSystemDependentName(builder.myKarmaPackageDir)
-                                                          : null;
     myBrowsers = builder.myBrowsers;
     myInterpreterRef = builder.myInterpreterRef;
     myEnvData = builder.myEnvData;
@@ -36,13 +35,8 @@ public String getConfigSystemIndependentPath() {
   }
 
   @Nullable
-  public String getKarmaPackageDir() {
-    return myKarmaPackageDir;
-  }
-
-  @Nullable
-  public String getKarmaPackageDirSystemIndependentPath() {
-    return myKarmaPackageDir == null ? null : FileUtil.toSystemIndependentName(myKarmaPackageDir);
   }
 
   @NotNull
@@ -68,7 +62,7 @@ public boolean equals(Object o) {
     KarmaRunSettings that = (KarmaRunSettings)o;
 
     return myConfigPath.equals(that.myConfigPath) &amp;&amp;
-          ComparatorUtil.equalsNullable(myKarmaPackageDir, that.myKarmaPackageDir) &amp;&amp;
           myBrowsers.equals(that.myBrowsers) &amp;&amp;
           myInterpreterRef.getReferenceName().equals(that.myInterpreterRef.getReferenceName()) &amp;&amp;
           myEnvData.equals(that.myEnvData);
@@ -77,7 +71,7 @@ public boolean equals(Object o) {
   @Override
   public int hashCode() {
     int result = myConfigPath.hashCode();
-    result = 31 * result + StringUtil.notNullize(myKarmaPackageDir).hashCode();
     result = 31 * result + myBrowsers.hashCode();
     result = 31 * result + myInterpreterRef.getReferenceName().hashCode();
     result = 31 * result + myEnvData.hashCode();
@@ -92,7 +86,7 @@ public Builder builder() {
   public static class Builder {
 
     private String myConfigPath = "";
-    private String myKarmaPackageDir = null;
     private String myBrowsers = "";
     private NodeJsInterpreterRef myInterpreterRef = NodeJsInterpreterRef.createProjectRef();
     private EnvironmentVariablesData myEnvData = EnvironmentVariablesData.DEFAULT;
@@ -101,7 +95,7 @@ public Builder() {}
 
     public Builder(@NotNull KarmaRunSettings settings) {
       myConfigPath = settings.getConfigPath();
-      myKarmaPackageDir = settings.getKarmaPackageDir();
       myBrowsers = settings.getBrowsers();
       myInterpreterRef = settings.getInterpreterRef();
       myEnvData = settings.myEnvData;
@@ -114,8 +108,8 @@ public Builder setConfigPath(@NotNull String configPath) {
     }
 
     @NotNull
-    public Builder setKarmaPackageDir(@Nullable String karmaPackageDir) {
-      myKarmaPackageDir = karmaPackageDir;
       return this;
     }
 
</code_before><code_after>@@ -2,24 +2,23 @@
 
 import com.intellij.execution.configuration.EnvironmentVariablesData;
 import com.intellij.javascript.nodejs.interpreter.NodeJsInterpreterRef;
+import com.intellij.javascript.nodejs.util.NodePackage;
 import com.intellij.openapi.util.io.FileUtil;
 import com.intellij.util.containers.ComparatorUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 public class KarmaRunSettings {
 
   private final String myConfigPath;
+  private final NodePackage myKarmaPackage;
   private final String myBrowsers;
   private final NodeJsInterpreterRef myInterpreterRef;
   private final EnvironmentVariablesData myEnvData;
 
   public KarmaRunSettings(@NotNull Builder builder) {
     myConfigPath = FileUtil.toSystemDependentName(builder.myConfigPath);
+    myKarmaPackage = builder.myKarmaPackage;
     myBrowsers = builder.myBrowsers;
     myInterpreterRef = builder.myInterpreterRef;
     myEnvData = builder.myEnvData;
@@ -36,13 +35,8 @@ public String getConfigSystemIndependentPath() {
   }
 
   @Nullable
+  public NodePackage getKarmaPackage() {
+    return myKarmaPackage;
   }
 
   @NotNull
@@ -68,7 +62,7 @@ public boolean equals(Object o) {
     KarmaRunSettings that = (KarmaRunSettings)o;
 
     return myConfigPath.equals(that.myConfigPath) &amp;&amp;
+          ComparatorUtil.equalsNullable(myKarmaPackage, that.myKarmaPackage) &amp;&amp;
           myBrowsers.equals(that.myBrowsers) &amp;&amp;
           myInterpreterRef.getReferenceName().equals(that.myInterpreterRef.getReferenceName()) &amp;&amp;
           myEnvData.equals(that.myEnvData);
@@ -77,7 +71,7 @@ public boolean equals(Object o) {
   @Override
   public int hashCode() {
     int result = myConfigPath.hashCode();
+    result = 31 * result + (myKarmaPackage != null ? myKarmaPackage.hashCode() : 0);
     result = 31 * result + myBrowsers.hashCode();
     result = 31 * result + myInterpreterRef.getReferenceName().hashCode();
     result = 31 * result + myEnvData.hashCode();
@@ -92,7 +86,7 @@ public Builder builder() {
   public static class Builder {
 
     private String myConfigPath = "";
+    private NodePackage myKarmaPackage = null;
     private String myBrowsers = "";
     private NodeJsInterpreterRef myInterpreterRef = NodeJsInterpreterRef.createProjectRef();
     private EnvironmentVariablesData myEnvData = EnvironmentVariablesData.DEFAULT;
@@ -101,7 +95,7 @@ public Builder() {}
 
     public Builder(@NotNull KarmaRunSettings settings) {
       myConfigPath = settings.getConfigPath();
+      myKarmaPackage = settings.getKarmaPackage();
       myBrowsers = settings.getBrowsers();
       myInterpreterRef = settings.getInterpreterRef();
       myEnvData = settings.myEnvData;
@@ -114,8 +108,8 @@ public Builder setConfigPath(@NotNull String configPath) {
     }
 
     @NotNull
+    public Builder setKarmaPackage(@Nullable NodePackage karmaPackage) {
+      myKarmaPackage = karmaPackage;
       return this;
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>128232</refactoring_id><commit_sha>27472621c726ef6f6933d8f43b65c0e2b3c1468c</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/27472621c726ef6f6933d8f43b65c0e2b3c1468c</commit_link><file_path>backend/de.metas.serviceprovider/src/main/java/de/metas/serviceprovider/issue/IssueRepository.java</file_path><description>Rename Method private buildIssueEntity(record I_S_Issue) : IssueEntity renamed to public ofRecord(record I_S_Issue) : IssueEntity in class de.metas.serviceprovider.issue.IssueRepository</description><code_before>@@ -102,7 +102,7 @@ public IssueEntity getById(@NonNull final IssueId issueId)
 					.setParameter("S_Issue_Id", issueId);
 		}
 
-		return buildIssueEntity(record);
 	}
 
 	@NonNull
@@ -111,7 +111,7 @@ public Optional&lt;IssueEntity&gt; getByIdOptional(@NonNull final IssueId issueId)
 		final I_S_Issue record = getRecordOrNull(issueId);
 
 		return record != null
-				? Optional.of(buildIssueEntity(record))
 				: Optional.empty();
 	}
 
@@ -123,7 +123,7 @@ public Optional&lt;IssueEntity&gt; getByExternalURLOptional(@NonNull final String exte
 				.addEqualsFilter(I_S_Issue.COLUMNNAME_IssueURL, externalURL)
 				.create()
 				.firstOnlyOptional(I_S_Issue.class)
-				.map(IssueRepository::buildIssueEntity);
 	}
 
 	@NonNull
@@ -135,7 +135,7 @@ public ImmutableList&lt;IssueEntity&gt; getDirectlyLinkedSubIssues(@NonNull final Issu
 				.create()
 				.list()
 				.stream()
-				.map(IssueRepository::buildIssueEntity)
 				.collect(ImmutableList.toImmutableList());
 	}
 
@@ -217,7 +217,7 @@ public Stream&lt;IssueEntity&gt; streamIssuesWithOpenEffort()
 				.addNotInSubQueryFilter(I_S_Issue.COLUMNNAME_EffortAggregationKey, I_S_EffortControl.COLUMNNAME_EffortAggregationKey, effortControlQuery)
 				.create()
 				.iterateAndStream()
-				.map(IssueRepository::buildIssueEntity);
 	}
 
 	public void setAggregationKeyIfMissing()
@@ -248,23 +248,12 @@ public List&lt;IssueEntity&gt; geyByQuery(@NonNull final IssueQuery query)
 				.addEqualsFilter(I_S_Issue.COLUMNNAME_C_Project_ID, query.getProjectId())
 				.create()
 				.iterateAndStream()
-				.map(IssueRepository::buildIssueEntity)
 				.collect(ImmutableList.toImmutableList());
 	}
 
-	@Nullable
-	private I_S_Issue getRecordOrNull(@NonNull final IssueId issueId)
-	{
-		return queryBL
-				.createQueryBuilder(I_S_Issue.class)
-				.addOnlyActiveRecordsFilter()
-				.addEqualsFilter(I_S_Issue.COLUMNNAME_S_Issue_ID, issueId.getRepoId())
-				.create()
-				.firstOnly(I_S_Issue.class);
-	}
-
 	@NonNull
-	private static IssueEntity buildIssueEntity(@NonNull final I_S_Issue record)
 	{
 		final IssueType issueType = IssueType
 				.getTypeByValue(record.getIssueType())
@@ -312,6 +301,17 @@ private static IssueEntity buildIssueEntity(@NonNull final I_S_Issue record)
 				.build();
 	}
 
 	@NonNull
 	private static I_S_Issue buildRecord(@NonNull final IssueEntity issueEntity)
 	{
</code_before><code_after>@@ -102,7 +102,7 @@ public IssueEntity getById(@NonNull final IssueId issueId)
 					.setParameter("S_Issue_Id", issueId);
 		}
 
+		return ofRecord(record);
 	}
 
 	@NonNull
@@ -111,7 +111,7 @@ public Optional&lt;IssueEntity&gt; getByIdOptional(@NonNull final IssueId issueId)
 		final I_S_Issue record = getRecordOrNull(issueId);
 
 		return record != null
+				? Optional.of(ofRecord(record))
 				: Optional.empty();
 	}
 
@@ -123,7 +123,7 @@ public Optional&lt;IssueEntity&gt; getByExternalURLOptional(@NonNull final String exte
 				.addEqualsFilter(I_S_Issue.COLUMNNAME_IssueURL, externalURL)
 				.create()
 				.firstOnlyOptional(I_S_Issue.class)
+				.map(IssueRepository::ofRecord);
 	}
 
 	@NonNull
@@ -135,7 +135,7 @@ public ImmutableList&lt;IssueEntity&gt; getDirectlyLinkedSubIssues(@NonNull final Issu
 				.create()
 				.list()
 				.stream()
+				.map(IssueRepository::ofRecord)
 				.collect(ImmutableList.toImmutableList());
 	}
 
@@ -217,7 +217,7 @@ public Stream&lt;IssueEntity&gt; streamIssuesWithOpenEffort()
 				.addNotInSubQueryFilter(I_S_Issue.COLUMNNAME_EffortAggregationKey, I_S_EffortControl.COLUMNNAME_EffortAggregationKey, effortControlQuery)
 				.create()
 				.iterateAndStream()
+				.map(IssueRepository::ofRecord);
 	}
 
 	public void setAggregationKeyIfMissing()
@@ -248,23 +248,12 @@ public List&lt;IssueEntity&gt; geyByQuery(@NonNull final IssueQuery query)
 				.addEqualsFilter(I_S_Issue.COLUMNNAME_C_Project_ID, query.getProjectId())
 				.create()
 				.iterateAndStream()
+				.map(IssueRepository::ofRecord)
 				.collect(ImmutableList.toImmutableList());
 	}
 
 	@NonNull
+	public static IssueEntity ofRecord(@NonNull final I_S_Issue record)
 	{
 		final IssueType issueType = IssueType
 				.getTypeByValue(record.getIssueType())
@@ -312,6 +301,17 @@ private static IssueEntity buildIssueEntity(@NonNull final I_S_Issue record)
 				.build();
 	}
 
+	@Nullable
+	private I_S_Issue getRecordOrNull(@NonNull final IssueId issueId)
+	{
+		return queryBL
+				.createQueryBuilder(I_S_Issue.class)
+				.addOnlyActiveRecordsFilter()
+				.addEqualsFilter(I_S_Issue.COLUMNNAME_S_Issue_ID, issueId.getRepoId())
+				.create()
+				.firstOnly(I_S_Issue.class);
+	}
+
 	@NonNull
 	private static I_S_Issue buildRecord(@NonNull final IssueEntity issueEntity)
 	{
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>142355</refactoring_id><commit_sha>b1a45f536500eb1c069a2e3e785b38114bff8213</commit_sha><commit_link>https://github.com/bisq-network/bisq/commit/b1a45f536500eb1c069a2e3e785b38114bff8213</commit_link><file_path>core/src/main/java/io/bisq/core/payment/AccountAgeWitness.java</file_path><description>Rename Method public isTradeDateValid() : boolean renamed to public isDateValid() : boolean in class io.bisq.core.payment.AccountAgeWitness</description><code_before>@@ -35,16 +35,16 @@
 import java.util.Optional;
 import java.util.concurrent.TimeUnit;
 
-// Object has 118 raw bytes (not PB size)
 @Slf4j
 @EqualsAndHashCode(exclude = {"signaturePubKey"})
 @Value
 public class AccountAgeWitness implements LazyProcessedStoragePayload, PersistedStoragePayload {
 
     private final byte[] hash;                      // 32 bytes
-    private final byte[] sigPubKey;                 // ? bytes
     private final byte[] signature;                 // 46 bytes
-    private final long tradeDate;                   // 8 byte
 
 
     // Only used as cache for getOwnerPubKey
@@ -58,29 +58,28 @@ public class AccountAgeWitness implements LazyProcessedStoragePayload, Persisted
 
     public AccountAgeWitness(byte[] hash,
                              byte[] sigPubKey,
-                             byte[] signature,
-                             long tradeDate) {
 
         this(hash,
                 sigPubKey,
                 signature,
-                tradeDate,
                 null);
     }
 
     ///////////////////////////////////////////////////////////////////////////////////////////
     // PROTO BUFFER
     ///////////////////////////////////////////////////////////////////////////////////////////
 
-    AccountAgeWitness(byte[] hash,
-                      byte[] sigPubKey,
-                      byte[] signature,
-                      long tradeDate,
-                      @Nullable Map&lt;String, String&gt; extraDataMap) {
         this.hash = hash;
         this.sigPubKey = sigPubKey;
         this.signature = signature;
-        this.tradeDate = tradeDate;
         this.extraDataMap = extraDataMap;
 
         signaturePubKey = Sig.getPublicKeyFromBytes(sigPubKey);
@@ -92,7 +91,7 @@ public PB.StoragePayload toProtoMessage() {
                 .setHash(ByteString.copyFrom(hash))
                 .setSigPubKey(ByteString.copyFrom(sigPubKey))
                 .setSignature(ByteString.copyFrom(signature))
-                .setTradeDate(tradeDate);
         Optional.ofNullable(extraDataMap).ifPresent(builder::putAllExtraData);
         return PB.StoragePayload.newBuilder().setAccountAgeWitness(builder).build();
     }
@@ -106,7 +105,7 @@ public static AccountAgeWitness fromProto(PB.AccountAgeWitness proto) {
                 proto.getHash().toByteArray(),
                 proto.getSigPubKey().toByteArray(),
                 proto.getSignature().toByteArray(),
-                proto.getTradeDate(),
                 CollectionUtils.isEmpty(proto.getExtraDataMap()) ? null : proto.getExtraDataMap());
     }
 
@@ -128,8 +127,8 @@ public PublicKey getOwnerPubKey() {
 
     //TODO impl. here or in caller?
     // We allow max 1 day time difference
-    public boolean isTradeDateValid() {
-        return new Date().getTime() - tradeDate &lt; TimeUnit.DAYS.toMillis(1);
     }
 
     public String getHashAsHex() {
</code_before><code_after>@@ -35,16 +35,16 @@
 import java.util.Optional;
 import java.util.concurrent.TimeUnit;
 
+// Object has 529 raw bytes (535 bytes is size of PB.AccountAgeWitness -&gt; extraDataMap is null)
 @Slf4j
 @EqualsAndHashCode(exclude = {"signaturePubKey"})
 @Value
 public class AccountAgeWitness implements LazyProcessedStoragePayload, PersistedStoragePayload {
 
     private final byte[] hash;                      // 32 bytes
+    private final byte[] sigPubKey;                 // about 443 bytes
     private final byte[] signature;                 // 46 bytes
+    private final long date;                        // 8 byte
 
 
     // Only used as cache for getOwnerPubKey
@@ -58,29 +58,28 @@ public class AccountAgeWitness implements LazyProcessedStoragePayload, Persisted
 
     public AccountAgeWitness(byte[] hash,
                              byte[] sigPubKey,
+                             byte[] signature) {
 
         this(hash,
                 sigPubKey,
                 signature,
+                new Date().getTime(),
                 null);
     }
 
     ///////////////////////////////////////////////////////////////////////////////////////////
     // PROTO BUFFER
     ///////////////////////////////////////////////////////////////////////////////////////////
 
+    private AccountAgeWitness(byte[] hash,
+                              byte[] sigPubKey,
+                              byte[] signature,
+                              long date,
+                              @Nullable Map&lt;String, String&gt; extraDataMap) {
         this.hash = hash;
         this.sigPubKey = sigPubKey;
         this.signature = signature;
+        this.date = date;
         this.extraDataMap = extraDataMap;
 
         signaturePubKey = Sig.getPublicKeyFromBytes(sigPubKey);
@@ -92,7 +91,7 @@ public PB.StoragePayload toProtoMessage() {
                 .setHash(ByteString.copyFrom(hash))
                 .setSigPubKey(ByteString.copyFrom(sigPubKey))
                 .setSignature(ByteString.copyFrom(signature))
+                .setDate(date);
         Optional.ofNullable(extraDataMap).ifPresent(builder::putAllExtraData);
         return PB.StoragePayload.newBuilder().setAccountAgeWitness(builder).build();
     }
@@ -106,7 +105,7 @@ public static AccountAgeWitness fromProto(PB.AccountAgeWitness proto) {
                 proto.getHash().toByteArray(),
                 proto.getSigPubKey().toByteArray(),
                 proto.getSignature().toByteArray(),
+                proto.getDate(),
                 CollectionUtils.isEmpty(proto.getExtraDataMap()) ? null : proto.getExtraDataMap());
     }
 
@@ -128,8 +127,8 @@ public PublicKey getOwnerPubKey() {
 
     //TODO impl. here or in caller?
     // We allow max 1 day time difference
+    public boolean isDateValid() {
+        return new Date().getTime() - date &lt; TimeUnit.DAYS.toMillis(1);
     }
 
     public String getHashAsHex() {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>231008</refactoring_id><commit_sha>986a271a7d6d2f27f0c5a934a87994978bbc237a</commit_sha><commit_link>https://github.com/apache/druid/commit/986a271a7d6d2f27f0c5a934a87994978bbc237a</commit_link><file_path>indexing-service/src/test/java/org/apache/druid/indexing/common/task/batch/parallel/AbstractParallelIndexSupervisorTaskTest.java</file_path><description>Rename Method public fetchUsedSegmentsInDataSourceForIntervals(dataSource String, intervals List&lt;Interval&gt;) : Collection&lt;DataSegment&gt; renamed to public fetchUsedSegments(dataSource String, intervals List&lt;Interval&gt;) : ListenableFuture&lt;List&lt;DataSegment&gt;&gt; in class org.apache.druid.indexing.common.task.batch.parallel.AbstractParallelIndexSupervisorTaskTest.LocalCoordinatorClient</description><code_before>@@ -33,6 +33,7 @@
 import com.google.common.util.concurrent.MoreExecutors;
 import org.apache.druid.client.ImmutableDruidDataSource;
 import org.apache.druid.client.coordinator.CoordinatorClient;
 import org.apache.druid.client.indexing.NoopOverlordClient;
 import org.apache.druid.client.indexing.TaskStatusResponse;
 import org.apache.druid.data.input.InputFormat;
@@ -116,7 +117,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -1012,34 +1012,30 @@ private ParallelIndexSupervisorTask findSupervisorTask(TaskContainer taskContain
     }
   }
 
-  class LocalCoordinatorClient extends CoordinatorClient
   {
-    private final ExecutorService exec;
 
     LocalCoordinatorClient(ExecutorService exec)
     {
-      super(null, null);
-      this.exec = exec;
     }
 
     @Override
-    public Collection&lt;DataSegment&gt; fetchUsedSegmentsInDataSourceForIntervals(
         String dataSource,
         List&lt;Interval&gt; intervals
     )
     {
-      try {
-        return exec.submit(
-            () -&gt; getStorageCoordinator().retrieveUsedSegmentsForIntervals(dataSource, intervals, Segments.ONLY_VISIBLE)
-        ).get();
-      }
-      catch (InterruptedException | ExecutionException e) {
-        throw new RuntimeException(e);
-      }
     }
 
     @Override
-    public DataSegment fetchUsedSegment(String dataSource, String segmentId)
     {
       ImmutableDruidDataSource druidDataSource;
       try {
@@ -1057,7 +1053,7 @@ public DataSegment fetchUsedSegment(String dataSource, String segmentId)
       for (SegmentId possibleSegmentId : SegmentId.iteratePossibleParsingsWithDataSource(dataSource, segmentId)) {
         DataSegment segment = druidDataSource.getSegment(possibleSegmentId);
         if (segment != null) {
-          return segment;
         }
       }
       throw new ISE("Can't find segment for id[%s]", segmentId);
</code_before><code_after>@@ -33,6 +33,7 @@
 import com.google.common.util.concurrent.MoreExecutors;
 import org.apache.druid.client.ImmutableDruidDataSource;
 import org.apache.druid.client.coordinator.CoordinatorClient;
+import org.apache.druid.client.coordinator.NoopCoordinatorClient;
 import org.apache.druid.client.indexing.NoopOverlordClient;
 import org.apache.druid.client.indexing.TaskStatusResponse;
 import org.apache.druid.data.input.InputFormat;
@@ -116,7 +117,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -1012,34 +1012,30 @@ private ParallelIndexSupervisorTask findSupervisorTask(TaskContainer taskContain
     }
   }
 
+  class LocalCoordinatorClient extends NoopCoordinatorClient
   {
+    private final ListeningExecutorService exec;
 
     LocalCoordinatorClient(ExecutorService exec)
     {
+      this.exec = MoreExecutors.listeningDecorator(exec);
     }
 
     @Override
+    public ListenableFuture&lt;List&lt;DataSegment&gt;&gt; fetchUsedSegments(
         String dataSource,
         List&lt;Interval&gt; intervals
     )
     {
+      return exec.submit(
+          () -&gt; ImmutableList.copyOf(
+              getStorageCoordinator().retrieveUsedSegmentsForIntervals(dataSource, intervals, Segments.ONLY_VISIBLE)
+          )
+      );
     }
 
     @Override
+    public ListenableFuture&lt;DataSegment&gt; fetchUsedSegment(String dataSource, String segmentId)
     {
       ImmutableDruidDataSource druidDataSource;
       try {
@@ -1057,7 +1053,7 @@ public DataSegment fetchUsedSegment(String dataSource, String segmentId)
       for (SegmentId possibleSegmentId : SegmentId.iteratePossibleParsingsWithDataSource(dataSource, segmentId)) {
         DataSegment segment = druidDataSource.getSegment(possibleSegmentId);
         if (segment != null) {
+          return Futures.immediateFuture(segment);
         }
       }
       throw new ISE("Can't find segment for id[%s]", segmentId);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>277878</refactoring_id><commit_sha>66e4e47e1a16246a2c21c17c1e567a0896e3385c</commit_sha><commit_link>https://github.com/google/exoplayer/commit/66e4e47e1a16246a2c21c17c1e567a0896e3385c</commit_link><file_path>library/common/src/test/java/com/google/android/exoplayer2/TimelineTest.java</file_path><description>Rename Method public roundtripViaBundle_ofPeriod_yieldsEqualInstanceExceptIds() : void renamed to public roundTripViaBundle_ofPeriod_yieldsEqualInstanceExceptIds() : void in class com.google.android.exoplayer2.TimelineTest</description><code_before>@@ -209,7 +209,7 @@ public void periodHashCode() {
   }
 
   @Test
-  public void roundtripViaBundle_ofTimeline_yieldsEqualInstanceExceptIdsAndManifest() {
     Timeline timeline =
         new FakeTimeline(
             new TimelineWindowDefinition(
@@ -244,7 +244,7 @@ public void roundtripViaBundle_ofTimeline_yieldsEqualInstanceExceptIdsAndManifes
   }
 
   @Test
-  public void roundtripViaBundle_ofTimeline_preservesWindowIndices() {
     int windowCount = 10;
     FakeTimeline timeline = new FakeTimeline(windowCount);
 
@@ -285,12 +285,12 @@ public void roundtripViaBundle_ofTimeline_preservesWindowIndices() {
   }
 
   @Test
-  public void roundtripViaBundle_ofEmptyTimeline_returnsEmptyTimeline() {
     TimelineAsserts.assertEmpty(Timeline.CREATOR.fromBundle(Timeline.EMPTY.toBundle()));
   }
 
   @Test
-  public void roundtripViaBundle_ofWindow_yieldsEqualInstanceExceptUidAndManifest() {
     Timeline.Window window = new Timeline.Window();
     window.uid = new Object();
     window.mediaItem = new MediaItem.Builder().setMediaId("mediaId").build();
@@ -322,7 +322,7 @@ public void roundtripViaBundle_ofWindow_yieldsEqualInstanceExceptUidAndManifest(
   }
 
   @Test
-  public void roundtripViaBundle_ofPeriod_yieldsEqualInstanceExceptIds() {
     Timeline.Period period = new Timeline.Period();
     period.id = new Object();
     period.uid = new Object();
</code_before><code_after>@@ -209,7 +209,7 @@ public void periodHashCode() {
   }
 
   @Test
+  public void roundTripViaBundle_ofTimeline_yieldsEqualInstanceExceptIdsAndManifest() {
     Timeline timeline =
         new FakeTimeline(
             new TimelineWindowDefinition(
@@ -244,7 +244,7 @@ public void roundtripViaBundle_ofTimeline_yieldsEqualInstanceExceptIdsAndManifes
   }
 
   @Test
+  public void roundTripViaBundle_ofTimeline_preservesWindowIndices() {
     int windowCount = 10;
     FakeTimeline timeline = new FakeTimeline(windowCount);
 
@@ -285,12 +285,12 @@ public void roundtripViaBundle_ofTimeline_preservesWindowIndices() {
   }
 
   @Test
+  public void roundTripViaBundle_ofEmptyTimeline_returnsEmptyTimeline() {
     TimelineAsserts.assertEmpty(Timeline.CREATOR.fromBundle(Timeline.EMPTY.toBundle()));
   }
 
   @Test
+  public void roundTripViaBundle_ofWindow_yieldsEqualInstanceExceptUidAndManifest() {
     Timeline.Window window = new Timeline.Window();
     window.uid = new Object();
     window.mediaItem = new MediaItem.Builder().setMediaId("mediaId").build();
@@ -322,7 +322,7 @@ public void roundtripViaBundle_ofWindow_yieldsEqualInstanceExceptUidAndManifest(
   }
 
   @Test
+  public void roundTripViaBundle_ofPeriod_yieldsEqualInstanceExceptIds() {
     Timeline.Period period = new Timeline.Period();
     period.id = new Object();
     period.uid = new Object();
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>312928</refactoring_id><commit_sha>9de80abe8c1910a82eac02b798a6ee306984a886</commit_sha><commit_link>https://github.com/apereo/cas/commit/9de80abe8c1910a82eac02b798a6ee306984a886</commit_link><file_path>core/cas-server-core-util/src/main/java/org/apereo/cas/util/serialization/SerializationUtils.java</file_path><description>Rename Method public decodeAndSerializeObject(object byte[], cipher CipherExecutor, type Class&lt;? extends Serializable&gt;) : T renamed to public decodeAndDeserializeObject(object byte[], cipher CipherExecutor, type Class&lt;? extends Serializable&gt;) : T in class org.apereo.cas.util.serialization.SerializationUtils</description><code_before>@@ -46,7 +46,7 @@ public static byte[] serialize(final Serializable object) {
      * @since 5.0.0
      */
     public static void serialize(final Serializable object, final OutputStream outputStream) {
-        try(ObjectOutputStream out = new ObjectOutputStream(outputStream)) {
             out.writeObject(object);
         } catch (final IOException e) {
             throw Throwables.propagate(e);
@@ -117,11 +117,15 @@ public static byte[] serializeAndEncodeObject(final CipherExecutor cipher,
      * @return the t
      * @since 4.2
      */
-    public static &lt;T&gt; T decodeAndSerializeObject(final byte[] object,
-                                                 final CipherExecutor cipher,
-                                                 final Class&lt;? extends Serializable&gt; type) {
-        final byte[] decoded = (byte[]) cipher.decode(object);
-        return deserializeAndCheckObject(decoded, type);
     }
 
     /**
</code_before><code_after>@@ -46,7 +46,7 @@ public static byte[] serialize(final Serializable object) {
      * @since 5.0.0
      */
     public static void serialize(final Serializable object, final OutputStream outputStream) {
+        try (ObjectOutputStream out = new ObjectOutputStream(outputStream)) {
             out.writeObject(object);
         } catch (final IOException e) {
             throw Throwables.propagate(e);
@@ -117,11 +117,15 @@ public static byte[] serializeAndEncodeObject(final CipherExecutor cipher,
      * @return the t
      * @since 4.2
      */
+    public static &lt;T&gt; T decodeAndDeserializeObject(final byte[] object,
+                                                   final CipherExecutor cipher,
+                                                   final Class&lt;? extends Serializable&gt; type) {
+        try {
+            final byte[] decoded = (byte[]) cipher.decode(object);
+            return deserializeAndCheckObject(decoded, type);
+        } catch (final Exception e) {
+            throw Throwables.propagate(e);
+        }
     }
 
     /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>310640</refactoring_id><commit_sha>f54db78eac1bd23baed89423725921ec7830e5ad</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/f54db78eac1bd23baed89423725921ec7830e5ad</commit_link><file_path>engine-tests/src/test/java/org/terasology/world/EntityAwareWorldProviderTest.java</file_path><description>Rename Method public retainedComponentsNotAltered() : void renamed to public testRetainedComponentsNotAltered() : void in class org.terasology.world.EntityAwareWorldProviderTest</description><code_before>@@ -332,7 +332,7 @@ public void testChangedComponentsRevertedBeforeCleanUp() {
     }
 
     @Test
-    public void allComponentsNotMarkedAsRetainedRemovedOnBlockChange() {
         worldStub.setBlock(Vector3i.zero(), blockWithString);
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new ForceBlockActiveComponent());
@@ -345,7 +345,7 @@ public void allComponentsNotMarkedAsRetainedRemovedOnBlockChange() {
     }
 
     @Test
-    public void retainedComponentsNotAltered() {
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new RetainedOnBlockChangeComponent(2));
 
@@ -355,7 +355,7 @@ public void retainedComponentsNotAltered() {
     }
 
     @Test
-    public void networkComponentAddedWhenChangedToNonTemporary() {
         LifecycleEventChecker checker = new LifecycleEventChecker(entityManager.getEventSystem(), NetworkComponent.class);
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new RetainedOnBlockChangeComponent(2));
@@ -366,7 +366,7 @@ public void networkComponentAddedWhenChangedToNonTemporary() {
     }
 
     @Test
-    public void networkComponentRemovedWhenTemporaryCleanedUp() {
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new RetainedOnBlockChangeComponent(2));
 
@@ -380,7 +380,7 @@ public void networkComponentRemovedWhenTemporaryCleanedUp() {
     }
 
     @Test
-    public void componentsNotAlteredIfBlockInSameFamily() {
         worldProvider.setBlock(Vector3i.zero(), blockInFamilyOne);
         EntityRef entity = worldProvider.getBlockEntityAt(Vector3i.zero());
         entity.addComponent(new IntegerComponent());
@@ -389,7 +389,7 @@ public void componentsNotAlteredIfBlockInSameFamily() {
     }
 
     @Test
-    public void componentsAlteredIfBlockInSameFamilyWhenForced() {
         worldProvider.setBlock(Vector3i.zero(), blockInFamilyOne);
         EntityRef entity = worldProvider.getBlockEntityAt(Vector3i.zero());
         entity.addComponent(new IntegerComponent());
@@ -398,7 +398,7 @@ public void componentsAlteredIfBlockInSameFamilyWhenForced() {
     }
 
     @Test
-    public void componentUntouchedIfRetainRequested() {
         worldProvider.setBlock(Vector3i.zero(), blockInFamilyOne);
         EntityRef entity = worldProvider.getBlockEntityAt(Vector3i.zero());
         entity.addComponent(new IntegerComponent());
</code_before><code_after>@@ -332,7 +332,7 @@ public void testChangedComponentsRevertedBeforeCleanUp() {
     }
 
     @Test
+    public void testAllComponentsNotMarkedAsRetainedRemovedOnBlockChange() {
         worldStub.setBlock(Vector3i.zero(), blockWithString);
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new ForceBlockActiveComponent());
@@ -345,7 +345,7 @@ public void allComponentsNotMarkedAsRetainedRemovedOnBlockChange() {
     }
 
     @Test
+    public void testRetainedComponentsNotAltered() {
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new RetainedOnBlockChangeComponent(2));
 
@@ -355,7 +355,7 @@ public void retainedComponentsNotAltered() {
     }
 
     @Test
+    public void testMetworkComponentAddedWhenChangedToNonTemporary() {
         LifecycleEventChecker checker = new LifecycleEventChecker(entityManager.getEventSystem(), NetworkComponent.class);
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new RetainedOnBlockChangeComponent(2));
@@ -366,7 +366,7 @@ public void networkComponentAddedWhenChangedToNonTemporary() {
     }
 
     @Test
+    public void testNetworkComponentRemovedWhenTemporaryCleanedUp() {
         EntityRef entity = worldProvider.getBlockEntityAt(new Vector3i(0, 0, 0));
         entity.addComponent(new RetainedOnBlockChangeComponent(2));
 
@@ -380,7 +380,7 @@ public void networkComponentRemovedWhenTemporaryCleanedUp() {
     }
 
     @Test
+    public void testComponentsNotAlteredIfBlockInSameFamily() {
         worldProvider.setBlock(Vector3i.zero(), blockInFamilyOne);
         EntityRef entity = worldProvider.getBlockEntityAt(Vector3i.zero());
         entity.addComponent(new IntegerComponent());
@@ -389,7 +389,7 @@ public void componentsNotAlteredIfBlockInSameFamily() {
     }
 
     @Test
+    public void testComponentsAlteredIfBlockInSameFamilyWhenForced() {
         worldProvider.setBlock(Vector3i.zero(), blockInFamilyOne);
         EntityRef entity = worldProvider.getBlockEntityAt(Vector3i.zero());
         entity.addComponent(new IntegerComponent());
@@ -398,7 +398,7 @@ public void componentsAlteredIfBlockInSameFamilyWhenForced() {
     }
 
     @Test
+    public void testComponentUntouchedIfRetainRequested() {
         worldProvider.setBlock(Vector3i.zero(), blockInFamilyOne);
         EntityRef entity = worldProvider.getBlockEntityAt(Vector3i.zero());
         entity.addComponent(new IntegerComponent());
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>138616</refactoring_id><commit_sha>da723df4be3c39fbafd5365ed596469fb36489a4</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/da723df4be3c39fbafd5365ed596469fb36489a4</commit_link><file_path>src/main/java/vazkii/botania/common/block/BlockSpecialFlower.java</file_path><description>Rename Method public getShape(state BlockState, world IBlockReader, pos BlockPos, ctx ISelectionContext) : VoxelShape renamed to public getOutlineShape(state BlockState, world BlockView, pos BlockPos, ctx ShapeContext) : VoxelShape in class vazkii.botania.common.block.BlockSpecialFlower</description><code_before>@@ -8,30 +8,26 @@
  */
 package vazkii.botania.common.block;
 
-import com.mojang.blaze3d.matrix.MatrixStack;
-
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
 import net.minecraft.block.FlowerBlock;
-import net.minecraft.block.ITileEntityProvider;
-import net.minecraft.client.Minecraft;
 import net.minecraft.entity.LivingEntity;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.item.ItemStack;
-import net.minecraft.loot.LootContext;
-import net.minecraft.loot.LootParameters;
-import net.minecraft.potion.Effect;
-import net.minecraft.potion.Effects;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.util.ActionResultType;
-import net.minecraft.util.Direction;
 import net.minecraft.util.Hand;
 import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.BlockRayTraceResult;
-import net.minecraft.util.math.shapes.ISelectionContext;
-import net.minecraft.util.math.shapes.VoxelShape;
-import net.minecraft.util.math.vector.Vector3d;
-import net.minecraft.world.IBlockReader;
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
@@ -46,55 +42,55 @@
 import java.util.List;
 import java.util.function.Supplier;
 
-public class BlockSpecialFlower extends FlowerBlock implements ITileEntityProvider, IWandable, IWandHUD {
-	private static final VoxelShape SHAPE = makeCuboidShape(4.8, 0, 4.8, 12.8, 16, 12.8);
 	private final Supplier&lt;? extends TileEntitySpecialFlower&gt; teProvider;
 
-	protected BlockSpecialFlower(Effect stewEffect, int stewDuration, Properties props, Supplier&lt;? extends TileEntitySpecialFlower&gt; teProvider) {
 		super(stewEffect, stewDuration, props);
 		this.teProvider = teProvider;
 	}
 
 	@Nonnull
 	@Override
-	public VoxelShape getShape(BlockState state, @Nonnull IBlockReader world, @Nonnull BlockPos pos, ISelectionContext ctx) {
-		Vector3d shift = state.getOffset(world, pos);
-		return SHAPE.withOffset(shift.x, shift.y, shift.z);
 	}
 
 	@Override
-	protected boolean isValidGround(BlockState state, IBlockReader worldIn, BlockPos pos) {
 		return state.getBlock() == ModBlocks.redStringRelay
 				|| state.getBlock() == Blocks.MYCELIUM
-				|| super.isValidGround(state, worldIn, pos);
 	}
 
 	@Override
-	public boolean eventReceived(BlockState state, World world, BlockPos pos, int event, int param) {
-		super.eventReceived(state, world, pos, event, param);
-		TileEntity tileentity = world.getTileEntity(pos);
-		return tileentity != null &amp;&amp; tileentity.receiveClientEvent(event, param);
 	}
 
 	@Nonnull
 	@Override
-	public TileEntity createNewTileEntity(@Nonnull IBlockReader world) {
 		return teProvider.get();
 	}
 
 	@Override
 	public boolean onUsedByWand(PlayerEntity player, ItemStack stack, World world, BlockPos pos, Direction side) {
-		return ((TileEntitySpecialFlower) world.getTileEntity(pos)).onWanded(player, stack);
 	}
 
 	@Override
-	public void onBlockPlacedBy(World world, BlockPos pos, BlockState state, @Nullable LivingEntity entity, ItemStack stack) {
-		((TileEntitySpecialFlower) world.getTileEntity(pos)).onBlockPlacedBy(world, pos, state, entity, stack);
 	}
 
-	@OnlyIn(Dist.CLIENT)
 	@Override
-	public void renderHUD(MatrixStack ms, Minecraft mc, World world, BlockPos pos) {
-		((TileEntitySpecialFlower) world.getTileEntity(pos)).renderHUD(ms, mc);
 	}
 }
</code_before><code_after>@@ -8,30 +8,26 @@
  */
 package vazkii.botania.common.block;
 
+import net.fabricmc.api.EnvType;
+import net.fabricmc.api.Environment;
+import net.minecraft.block.BlockEntityProvider;
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
 import net.minecraft.block.FlowerBlock;
+import net.minecraft.block.ShapeContext;
+import net.minecraft.block.entity.BlockEntity;
+import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.util.math.MatrixStack;
 import net.minecraft.entity.LivingEntity;
+import net.minecraft.entity.effect.StatusEffect;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.Hand;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.Direction;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.shape.VoxelShape;
+import net.minecraft.world.BlockView;
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
@@ -46,55 +42,55 @@
 import java.util.List;
 import java.util.function.Supplier;
 
+public class BlockSpecialFlower extends FlowerBlock implements BlockEntityProvider, IWandable, IWandHUD {
+	private static final VoxelShape SHAPE = createCuboidShape(4.8, 0, 4.8, 12.8, 16, 12.8);
 	private final Supplier&lt;? extends TileEntitySpecialFlower&gt; teProvider;
 
+	protected BlockSpecialFlower(StatusEffect stewEffect, int stewDuration, Settings props, Supplier&lt;? extends TileEntitySpecialFlower&gt; teProvider) {
 		super(stewEffect, stewDuration, props);
 		this.teProvider = teProvider;
 	}
 
 	@Nonnull
 	@Override
+	public VoxelShape getOutlineShape(BlockState state, @Nonnull BlockView world, @Nonnull BlockPos pos, ShapeContext ctx) {
+		Vec3d shift = state.getModelOffset(world, pos);
+		return SHAPE.offset(shift.x, shift.y, shift.z);
 	}
 
 	@Override
+	protected boolean canPlantOnTop(BlockState state, BlockView worldIn, BlockPos pos) {
 		return state.getBlock() == ModBlocks.redStringRelay
 				|| state.getBlock() == Blocks.MYCELIUM
+				|| super.canPlantOnTop(state, worldIn, pos);
 	}
 
 	@Override
+	public boolean onSyncedBlockEvent(BlockState state, World world, BlockPos pos, int event, int param) {
+		super.onSyncedBlockEvent(state, world, pos, event, param);
+		BlockEntity tileentity = world.getBlockEntity(pos);
+		return tileentity != null &amp;&amp; tileentity.onSyncedBlockEvent(event, param);
 	}
 
 	@Nonnull
 	@Override
+	public BlockEntity createBlockEntity(@Nonnull BlockView world) {
 		return teProvider.get();
 	}
 
 	@Override
 	public boolean onUsedByWand(PlayerEntity player, ItemStack stack, World world, BlockPos pos, Direction side) {
+		return ((TileEntitySpecialFlower) world.getBlockEntity(pos)).onWanded(player, stack);
 	}
 
 	@Override
+	public void onPlaced(World world, BlockPos pos, BlockState state, @Nullable LivingEntity entity, ItemStack stack) {
+		((TileEntitySpecialFlower) world.getBlockEntity(pos)).onBlockPlacedBy(world, pos, state, entity, stack);
 	}
 
+	@Environment(EnvType.CLIENT)
 	@Override
+	public void renderHUD(MatrixStack ms, MinecraftClient mc, World world, BlockPos pos) {
+		((TileEntitySpecialFlower) world.getBlockEntity(pos)).renderHUD(ms, mc);
 	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>331453</refactoring_id><commit_sha>4ad73db80eb985c715d7336285eb362cdba11066</commit_sha><commit_link>https://github.com/oracle/graal/commit/4ad73db80eb985c715d7336285eb362cdba11066</commit_link><file_path>truffle/com.oracle.truffle.api.vm/src/com/oracle/truffle/api/vm/PolyglotEngine.java</file_path><description>Rename Method public parseForEval(l TruffleLanguage&lt;?&gt;, s Source) : CallTarget renamed to public eval(l TruffleLanguage&lt;?&gt;, s Source) : Object in class com.oracle.truffle.api.vm.PolyglotEngine.SPIAccessor</description><code_before>@@ -37,7 +37,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.WeakHashMap;
 import java.util.concurrent.Executor;
 import java.util.logging.Logger;
 
@@ -62,7 +61,6 @@
 import com.oracle.truffle.api.nodes.Node;
 import com.oracle.truffle.api.nodes.RootNode;
 import com.oracle.truffle.api.source.Source;
-
 import java.util.logging.Level;
 
 /**
@@ -115,7 +113,6 @@ public class PolyglotEngine {
     private final Map&lt;String, Object&gt; globals;
     private final Instrumenter instrumenter;
     private final Debugger debugger;
-    private final Map&lt;Source, CallTarget&gt; cache = new WeakHashMap&lt;&gt;();
     private boolean disposed;
 
     /**
@@ -425,16 +422,7 @@ private Object evalImpl(TruffleLanguage&lt;?&gt;[] fillLang, Source s, Language l) thr
         try (Closeable d = SPI.executionStart(this, -1, debugger, s)) {
             TruffleLanguage&lt;?&gt; langImpl = l.getImpl(true);
             fillLang[0] = langImpl;
-            CallTarget cachedTarget = cache.get(s);
-            if (cachedTarget == null) {
-                cachedTarget = SPI.parseForEval(langImpl, s);
-                cache.put(s, cachedTarget);
-            }
-            try {
-                return cachedTarget.call();
-            } catch (Throwable ex) {
-                throw new IOException(ex);
-            }
         }
     }
 
@@ -897,8 +885,8 @@ protected Env attachEnv(Object obj, TruffleLanguage&lt;?&gt; language, OutputStream st
         }
 
         @Override
-        public CallTarget parseForEval(TruffleLanguage&lt;?&gt; l, Source s) throws IOException {
-            return super.parseForEval(l, s);
         }
 
         @Override
</code_before><code_after>@@ -37,7 +37,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.logging.Logger;
 
@@ -62,7 +61,6 @@
 import com.oracle.truffle.api.nodes.Node;
 import com.oracle.truffle.api.nodes.RootNode;
 import com.oracle.truffle.api.source.Source;
 import java.util.logging.Level;
 
 /**
@@ -115,7 +113,6 @@ public class PolyglotEngine {
     private final Map&lt;String, Object&gt; globals;
     private final Instrumenter instrumenter;
     private final Debugger debugger;
     private boolean disposed;
 
     /**
@@ -425,16 +422,7 @@ private Object evalImpl(TruffleLanguage&lt;?&gt;[] fillLang, Source s, Language l) thr
         try (Closeable d = SPI.executionStart(this, -1, debugger, s)) {
             TruffleLanguage&lt;?&gt; langImpl = l.getImpl(true);
             fillLang[0] = langImpl;
+            return SPI.eval(langImpl, s);
         }
     }
 
@@ -897,8 +885,8 @@ protected Env attachEnv(Object obj, TruffleLanguage&lt;?&gt; language, OutputStream st
         }
 
         @Override
+        public Object eval(TruffleLanguage&lt;?&gt; l, Source s) throws IOException {
+            return super.eval(l, s);
         }
 
         @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>215124</refactoring_id><commit_sha>8dfc187f1f21485778146500040385db38855909</commit_sha><commit_link>https://github.com/apache/beam/commit/8dfc187f1f21485778146500040385db38855909</commit_link><file_path>runners/core-java/src/main/java/org/apache/beam/runners/core/StatefulDoFnRunner.java</file_path><description>Rename Method private setupFlushTimerAndWatermarkHold(namespace StateNamespace, window BoundedWindow, flush Instant) : void renamed to private setupFlushTimer(namespace StateNamespace, window BoundedWindow, flush Instant) : void in class org.apache.beam.runners.core.StatefulDoFnRunner</description><code_before>@@ -177,7 +177,7 @@ private void processElementOrdered(BoundedWindow window, WindowedValue&lt;InputT&gt; v
       if (value.getTimestamp().isBefore(minStamp)) {
         minStamp = value.getTimestamp();
         minStampState.write(minStamp);
-        setupFlushTimerAndWatermarkHold(namespace, window, minStamp);
       }
     } else {
       reportDroppedElement(value, window);
@@ -262,7 +262,7 @@ private void onSortFlushTimer(BoundedWindow window, Instant timestamp) {
     keep.forEach(sortBuffer::add);
     minStampState.write(newMinStamp);
     if (newMinStamp.isBefore(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
-      setupFlushTimerAndWatermarkHold(namespace, window, newMinStamp);
     } else {
       clearWatermarkHold(namespace);
     }
@@ -275,10 +275,10 @@ private void onSortFlushTimer(BoundedWindow window, Instant timestamp) {
    * &lt;p&gt;Note that this is equivalent to {@link org.apache.beam.sdk.state.Timer#withOutputTimestamp}
    * and should be reworked to use that feature once that is stable.
    */
-  private void setupFlushTimerAndWatermarkHold(
-      StateNamespace namespace, BoundedWindow window, Instant flush) {
     Instant flushWithLateness = flush.plus(windowingStrategy.getAllowedLateness());
-    Instant windowGcTime = window.maxTimestamp().plus(windowingStrategy.getAllowedLateness());
     if (flushWithLateness.isAfter(windowGcTime)) {
       flushWithLateness = windowGcTime;
     }
@@ -292,8 +292,12 @@ private void setupFlushTimerAndWatermarkHold(
             flushWithLateness,
             flush,
             TimeDomain.EVENT_TIME);
-    watermark.clear();
-    watermark.add(flush);
   }
 
   private void clearWatermarkHold(StateNamespace namespace) {
</code_before><code_after>@@ -177,7 +177,7 @@ private void processElementOrdered(BoundedWindow window, WindowedValue&lt;InputT&gt; v
       if (value.getTimestamp().isBefore(minStamp)) {
         minStamp = value.getTimestamp();
         minStampState.write(minStamp);
+        setupFlushTimer(namespace, window, minStamp);
       }
     } else {
       reportDroppedElement(value, window);
@@ -262,7 +262,7 @@ private void onSortFlushTimer(BoundedWindow window, Instant timestamp) {
     keep.forEach(sortBuffer::add);
     minStampState.write(newMinStamp);
     if (newMinStamp.isBefore(BoundedWindow.TIMESTAMP_MAX_VALUE)) {
+      setupFlushTimer(namespace, window, newMinStamp);
     } else {
       clearWatermarkHold(namespace);
     }
@@ -275,10 +275,10 @@ private void onSortFlushTimer(BoundedWindow window, Instant timestamp) {
    * &lt;p&gt;Note that this is equivalent to {@link org.apache.beam.sdk.state.Timer#withOutputTimestamp}
    * and should be reworked to use that feature once that is stable.
    */
+  private void setupFlushTimer(StateNamespace namespace, BoundedWindow window, Instant flush) {
     Instant flushWithLateness = flush.plus(windowingStrategy.getAllowedLateness());
+    Instant windowGcTime =
+        LateDataUtils.garbageCollectionTime(window, windowingStrategy.getAllowedLateness());
     if (flushWithLateness.isAfter(windowGcTime)) {
       flushWithLateness = windowGcTime;
     }
@@ -292,8 +292,12 @@ private void setupFlushTimerAndWatermarkHold(
             flushWithLateness,
             flush,
             TimeDomain.EVENT_TIME);
+    // [BEAM-10533] check if the hold is set (pipelines before release of [BEAM-10533]
+    // this can be removed in soe future versions, when we can assume there is no
+    // running with this state (beam 2.23.0 and older)
+    if (!watermark.isEmpty().read()) {
+      watermark.clear();
+    }
   }
 
   private void clearWatermarkHold(StateNamespace namespace) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>228902</refactoring_id><commit_sha>69e0318d6747fda5eb4c7e19923de83f33a4eca8</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/69e0318d6747fda5eb4c7e19923de83f33a4eca8</commit_link><file_path>js-karma/src/com/intellij/javascript/karma/execution/KarmaServerSettings.java</file_path><description>Rename Method public setNodeInterpreterPath(nodeInterpreterPath String) : Builder renamed to public setNodeInterpreter(interpreter NodeJsLocalInterpreter) : Builder in class com.intellij.javascript.karma.execution.KarmaServerSettings.Builder</description><code_before>@@ -1,32 +1,27 @@
 package com.intellij.javascript.karma.execution;
 
 import org.jetbrains.annotations.NotNull;
 
 import java.io.File;
 
-/**
- * @author Sergey Simonchik
- */
 public class KarmaServerSettings {
 
-  private final String myNodeInterpreterPath;
   private final String myKarmaPackageDirPath;
   private final KarmaRunSettings myRunSettings;
   private final boolean myWithCoverage;
 
-  private KarmaServerSettings(@NotNull String nodeInterpreterPath,
-                              @NotNull String karmaPackageDirPath,
-                              @NotNull KarmaRunSettings runSettings,
-                              boolean withCoverage) {
-    myNodeInterpreterPath = nodeInterpreterPath;
-    myKarmaPackageDirPath = karmaPackageDirPath;
-    myRunSettings = runSettings;
-    myWithCoverage = withCoverage;
   }
 
   @NotNull
-  public String getNodeInterpreterPath() {
-    return myNodeInterpreterPath;
   }
 
   @NotNull
@@ -61,29 +56,29 @@ public boolean equals(Object o) {
     KarmaServerSettings that = (KarmaServerSettings)o;
 
     return myKarmaPackageDirPath.equals(that.myKarmaPackageDirPath) &amp;&amp;
-           myNodeInterpreterPath.equals(that.myNodeInterpreterPath) &amp;&amp;
            myRunSettings.equals(that.myRunSettings) &amp;&amp;
            myWithCoverage == that.myWithCoverage;
   }
 
   @Override
   public int hashCode() {
-    int result = myNodeInterpreterPath.hashCode();
     result = 31 * result + myKarmaPackageDirPath.hashCode();
     result = 31 * result + myRunSettings.hashCode();
     result = 31 * result + (myWithCoverage ? 1 : 0);
     return result;
   }
 
   public static class Builder {
-    private String myNodeInterpreterPath;
     private String myKarmaPackageDirPath;
     private KarmaRunSettings myRunSettings;
     private boolean myWithCoverage;
 
     @NotNull
-    public Builder setNodeInterpreterPath(@NotNull String nodeInterpreterPath) {
-      myNodeInterpreterPath = nodeInterpreterPath;
       return this;
     }
 
@@ -107,17 +102,16 @@ public Builder setWithCoverage(boolean withCoverage) {
 
     @NotNull
     public KarmaServerSettings build() {
-      if (myNodeInterpreterPath == null) {
-        throw new RuntimeException("Path to node interpreter isn't set!");
       }
       if (myKarmaPackageDirPath == null) {
         throw new RuntimeException("Path to karma package isn't set!");
       }
       if (myRunSettings == null) {
         throw new RuntimeException("Run settings aren't set!");
       }
-      return new KarmaServerSettings(myNodeInterpreterPath, myKarmaPackageDirPath, myRunSettings, myWithCoverage);
     }
   }
-
 }
</code_before><code_after>@@ -1,32 +1,27 @@
 package com.intellij.javascript.karma.execution;
 
+import com.intellij.javascript.nodejs.interpreter.local.NodeJsLocalInterpreter;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.File;
 
 public class KarmaServerSettings {
 
+  private final NodeJsLocalInterpreter myNodeInterpreter;
   private final String myKarmaPackageDirPath;
   private final KarmaRunSettings myRunSettings;
   private final boolean myWithCoverage;
 
+  private KarmaServerSettings(@NotNull Builder builder) {
+    myNodeInterpreter = builder.myNodeInterpreter;
+    myKarmaPackageDirPath = builder.myKarmaPackageDirPath;
+    myRunSettings = builder.myRunSettings;
+    myWithCoverage = builder.myWithCoverage;
   }
 
   @NotNull
+  public NodeJsLocalInterpreter getNodeInterpreter() {
+    return myNodeInterpreter;
   }
 
   @NotNull
@@ -61,29 +56,29 @@ public boolean equals(Object o) {
     KarmaServerSettings that = (KarmaServerSettings)o;
 
     return myKarmaPackageDirPath.equals(that.myKarmaPackageDirPath) &amp;&amp;
+           myNodeInterpreter.getInterpreterSystemIndependentPath().equals(that.myNodeInterpreter.getInterpreterSystemIndependentPath()) &amp;&amp;
            myRunSettings.equals(that.myRunSettings) &amp;&amp;
            myWithCoverage == that.myWithCoverage;
   }
 
   @Override
   public int hashCode() {
+    int result = myNodeInterpreter.getInterpreterSystemIndependentPath().hashCode();
     result = 31 * result + myKarmaPackageDirPath.hashCode();
     result = 31 * result + myRunSettings.hashCode();
     result = 31 * result + (myWithCoverage ? 1 : 0);
     return result;
   }
 
   public static class Builder {
+    private NodeJsLocalInterpreter myNodeInterpreter;
     private String myKarmaPackageDirPath;
     private KarmaRunSettings myRunSettings;
     private boolean myWithCoverage;
 
     @NotNull
+    public Builder setNodeInterpreter(@NotNull NodeJsLocalInterpreter interpreter) {
+      myNodeInterpreter = interpreter;
       return this;
     }
 
@@ -107,17 +102,16 @@ public Builder setWithCoverage(boolean withCoverage) {
 
     @NotNull
     public KarmaServerSettings build() {
+      if (myNodeInterpreter == null) {
+        throw new RuntimeException("Unspecified Node.js interpreter");
       }
       if (myKarmaPackageDirPath == null) {
         throw new RuntimeException("Path to karma package isn't set!");
       }
       if (myRunSettings == null) {
         throw new RuntimeException("Run settings aren't set!");
       }
+      return new KarmaServerSettings(this);
     }
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>156976</refactoring_id><commit_sha>9d08a215ca67bbf79330cf6ee1e4588fc29f92ff</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/9d08a215ca67bbf79330cf6ee1e4588fc29f92ff</commit_link><file_path>clustercontroller-core/src/test/java/com/yahoo/vespa/clustercontroller/core/NodeStateChangeCheckerTest.java</file_path><description>Rename Method public testWhenOtherStorageNodeIsSuspended() : void renamed to public testSafeMaintenanceDisallowedWhenOtherStorageNodeInFlatClusterIsSuspended() : void in class com.yahoo.vespa.clustercontroller.core.NodeStateChangeCheckerTest</description><code_before>@@ -147,7 +147,7 @@ public void testUnknownStorageNode() {
     }
 
     @Test
-    public void testWhenOtherStorageNodeIsSuspended() {
         // Nodes 0-3, storage node 0 being in maintenance with "Orchestrator" description.
         ContentCluster cluster = createCluster(createNodes(4));
         cluster.clusterInfo().getStorageNodeInfo(0).setWantedState(new NodeState(NodeType.STORAGE, State.MAINTENANCE).setDescription("Orchestrator"));
@@ -167,7 +167,7 @@ public void testWhenOtherStorageNodeIsSuspended() {
     }
 
     @Test
-    public void testWhenOtherDistributorIsDown() {
         // Nodes 0-3, storage node 0 being in maintenance with "Orchestrator" description.
         ContentCluster cluster = createCluster(createNodes(4));
         cluster.clusterInfo().getDistributorNodeInfo(0)
@@ -188,7 +188,7 @@ public void testWhenOtherDistributorIsDown() {
     }
 
     @Test
-    public void testWhenOtherDistributorInOtherGroupIsDown() {
         // Nodes 0-3, distributor 0 being in maintenance with "Orchestrator" description.
         // 2 groups: nodes 0-1 is group 0, 2-3 is group 1.
         ContentCluster cluster = createCluster(createNodes(4));
@@ -224,7 +224,7 @@ public void testWhenOtherDistributorInOtherGroupIsDown() {
     }
 
     @Test
-    public void testWhenOtherStorageNodeInOtherGroupIsSuspended() {
         // Nodes 0-3, storage node 0 being in maintenance with "Orchestrator" description.
         // 2 groups: nodes 0-1 is group 0, 2-3 is group 1.
         ContentCluster cluster = createCluster(createNodes(4));
</code_before><code_after>@@ -147,7 +147,7 @@ public void testUnknownStorageNode() {
     }
 
     @Test
+    public void testSafeMaintenanceDisallowedWhenOtherStorageNodeInFlatClusterIsSuspended() {
         // Nodes 0-3, storage node 0 being in maintenance with "Orchestrator" description.
         ContentCluster cluster = createCluster(createNodes(4));
         cluster.clusterInfo().getStorageNodeInfo(0).setWantedState(new NodeState(NodeType.STORAGE, State.MAINTENANCE).setDescription("Orchestrator"));
@@ -167,7 +167,7 @@ public void testWhenOtherStorageNodeIsSuspended() {
     }
 
     @Test
+    public void testSafeMaintenanceDisallowedWhenOtherDistributorInFlatClusterIsSuspended() {
         // Nodes 0-3, storage node 0 being in maintenance with "Orchestrator" description.
         ContentCluster cluster = createCluster(createNodes(4));
         cluster.clusterInfo().getDistributorNodeInfo(0)
@@ -188,7 +188,7 @@ public void testWhenOtherDistributorIsDown() {
     }
 
     @Test
+    public void testSafeMaintenanceDisallowedWhenDistributorInGroupIsDown() {
         // Nodes 0-3, distributor 0 being in maintenance with "Orchestrator" description.
         // 2 groups: nodes 0-1 is group 0, 2-3 is group 1.
         ContentCluster cluster = createCluster(createNodes(4));
@@ -224,7 +224,7 @@ public void testWhenOtherDistributorInOtherGroupIsDown() {
     }
 
     @Test
+    public void testSafeMaintenanceWhenOtherStorageNodeInGroupIsSuspended() {
         // Nodes 0-3, storage node 0 being in maintenance with "Orchestrator" description.
         // 2 groups: nodes 0-1 is group 0, 2-3 is group 1.
         ContentCluster cluster = createCluster(createNodes(4));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>192033</refactoring_id><commit_sha>39a418aa5503ac68d90b3c239637e241e445ca05</commit_sha><commit_link>https://github.com/jabref/jabref/commit/39a418aa5503ac68d90b3c239637e241e445ca05</commit_link><file_path>src/test/java/net/sf/jabref/logic/layout/format/CompositeFormatTest.java</file_path><description>Rename Method public testComposite() : void renamed to public testDoubleComposite() : void in class net.sf.jabref.logic.layout.format.CompositeFormatTest</description><code_before>@@ -8,28 +8,30 @@
 public class CompositeFormatTest {
 
     @Test
-    public void testComposite() {
-
-        {
-            LayoutFormatter f = new CompositeFormat();
-            Assert.assertEquals("No Change", f.format("No Change"));
-        }
-        {
-            LayoutFormatter f = new CompositeFormat(new LayoutFormatter[] {
-                    fieldText -&gt; fieldText + fieldText,
-                    fieldText -&gt; "A" + fieldText,
-                    fieldText -&gt; "B" + fieldText});
-
-            Assert.assertEquals("BAff", f.format("f"));
-        }
-
-        LayoutFormatter f = new CompositeFormat(new AuthorOrgSci(),
-                new NoSpaceBetweenAbbreviations());
         LayoutFormatter first = new AuthorOrgSci();
         LayoutFormatter second = new NoSpaceBetweenAbbreviations();
 
-        Assert.assertEquals(second.format(first.format("John Flynn and Sabine Gartska")), f.format("John Flynn and Sabine Gartska"));
-        Assert.assertEquals(second.format(first.format("Sa Makridakis and Sa Ca Wheelwright and Va Ea McGee")), f.format("Sa Makridakis and Sa Ca Wheelwright and Va Ea McGee"));
     }
 
 }
</code_before><code_after>@@ -8,28 +8,30 @@
 public class CompositeFormatTest {
 
     @Test
+    public void testEmptyComposite() {
+        LayoutFormatter f = new CompositeFormat();
+        Assert.assertEquals("No Change", f.format("No Change"));
+    }
+
+    @Test
+    public void testArrayComposite() {
+        LayoutFormatter f = new CompositeFormat(new LayoutFormatter[] {fieldText -&gt; fieldText + fieldText,
+                fieldText -&gt; "A" + fieldText, fieldText -&gt; "B" + fieldText});
+
+        Assert.assertEquals("BAff", f.format("f"));
+    }
+
+    @Test
+    public void testDoubleComposite() {
+
+        LayoutFormatter f = new CompositeFormat(new AuthorOrgSci(), new NoSpaceBetweenAbbreviations());
         LayoutFormatter first = new AuthorOrgSci();
         LayoutFormatter second = new NoSpaceBetweenAbbreviations();
 
+        Assert.assertEquals(second.format(first.format("John Flynn and Sabine Gartska")),
+                f.format("John Flynn and Sabine Gartska"));
+        Assert.assertEquals(second.format(first.format("Sa Makridakis and Sa Ca Wheelwright and Va Ea McGee")),
+                f.format("Sa Makridakis and Sa Ca Wheelwright and Va Ea McGee"));
     }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>241705</refactoring_id><commit_sha>1e3235d9e6b244f6e92ca0be562edbbb29370162</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/1e3235d9e6b244f6e92ca0be562edbbb29370162</commit_link><file_path>exceptiontrace/exceptiontrace-web/src/main/java/com/navercorp/pinpoint/exceptiontrace/web/dao/PinotExceptionTraceDao.java</file_path><description>Rename Method public getValueViews(exceptionTraceQueryParameter ExceptionTraceQueryParameter) : List&lt;ExceptionTraceValueView&gt; renamed to public getChartValueViews(exceptionTraceQueryParameter ExceptionTraceQueryParameter) : List&lt;ExceptionChartValueView&gt; in class com.navercorp.pinpoint.exceptiontrace.web.dao.PinotExceptionTraceDao</description><code_before>@@ -17,14 +17,14 @@
 package com.navercorp.pinpoint.exceptiontrace.web.dao;
 
 import com.navercorp.pinpoint.exceptiontrace.common.model.ExceptionMetaData;
 import com.navercorp.pinpoint.exceptiontrace.web.entity.ExceptionMetaDataEntity;
-import com.navercorp.pinpoint.exceptiontrace.web.entity.ExceptionTraceSummaryEntity;
-import com.navercorp.pinpoint.exceptiontrace.web.entity.ExceptionTraceValueViewEntity;
-import com.navercorp.pinpoint.exceptiontrace.web.mapper.ExceptionMetaDataEntityMapper;
-import com.navercorp.pinpoint.exceptiontrace.web.model.ExceptionTraceSummary;
-import com.navercorp.pinpoint.exceptiontrace.web.model.ExceptionTraceValueView;
 import com.navercorp.pinpoint.exceptiontrace.web.util.ExceptionTraceQueryParameter;
-import com.navercorp.pinpoint.exceptiontrace.web.view.ExceptionMetaDataView;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.mybatis.spring.SqlSessionTemplate;
@@ -47,34 +47,34 @@ public class PinotExceptionTraceDao implements ExceptionTraceDao {
     private static final String SELECT_QUERY = "selectExceptions";
     private static final String SELECT_SUMMARIZED_QUERY = "selectSummarizedExceptions";
     private static final String SELECT_EXACT_QUERY = "selectExactException";
-    private static final String SELECT_SUMMARIES_QUERY = "selectSummaries";
-    private static final String SELECT_VALUEVIEWS_QUERY = "selectValueViews";
 
     private final SqlSessionTemplate sqlPinotSessionTemplate;
 
-    private final ExceptionMetaDataEntityMapper mapper;
 
     public PinotExceptionTraceDao(
             @Qualifier("exceptionTracePinotSessionTemplate") SqlSessionTemplate sqlPinotSessionTemplate,
-            ExceptionMetaDataEntityMapper mapper
     ) {
         this.sqlPinotSessionTemplate = Objects.requireNonNull(sqlPinotSessionTemplate, "sqlPinotSessionTemplate");
         this.mapper = Objects.requireNonNull(mapper, "mapper");
     }
 
     @Override
-    public List&lt;ExceptionMetaDataView&gt; getExceptions(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
         List&lt;ExceptionMetaDataEntity&gt; dataEntities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_QUERY, exceptionTraceQueryParameter);
         return dataEntities.stream()
-                .map(mapper::toView)
                 .collect(Collectors.toList());
     }
 
     @Override
-    public List&lt;ExceptionMetaDataView&gt; getSummarizedExceptions(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
         List&lt;ExceptionMetaDataEntity&gt; dataEntities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_SUMMARIZED_QUERY, exceptionTraceQueryParameter);
         return dataEntities.stream()
-                .map(mapper::toView)
                 .collect(Collectors.toList());
     }
 
@@ -85,22 +85,27 @@ public ExceptionMetaData getException(ExceptionTraceQueryParameter exceptionTrac
     }
 
     @Override
-    public List&lt;ExceptionTraceSummary&gt; getSummaries(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
-        List&lt;ExceptionTraceSummaryEntity&gt; entities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_SUMMARIES_QUERY, exceptionTraceQueryParameter);
         return entities.stream()
-                .map((ExceptionTraceSummaryEntity e) -&gt;
                         mapper.toSummary(
                                 e, exceptionTraceQueryParameter.getGroupByAttributes()
                         )
                 ).collect(Collectors.toList());
     }
 
     @Override
-    public List&lt;ExceptionTraceValueView&gt; getValueViews(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
-        List&lt;ExceptionTraceValueViewEntity&gt; valueViewEntities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_VALUEVIEWS_QUERY, exceptionTraceQueryParameter);
         return valueViewEntities.stream()
-                .map((ExceptionTraceValueViewEntity e) -&gt;
-                        mapper.toValueView(
                                 e, exceptionTraceQueryParameter.getGroupByAttributes()
                         )
                 ).collect(Collectors.toList());
</code_before><code_after>@@ -17,14 +17,14 @@
 package com.navercorp.pinpoint.exceptiontrace.web.dao;
 
 import com.navercorp.pinpoint.exceptiontrace.common.model.ExceptionMetaData;
+import com.navercorp.pinpoint.exceptiontrace.web.entity.ExceptionGroupSummaryEntity;
 import com.navercorp.pinpoint.exceptiontrace.web.entity.ExceptionMetaDataEntity;
+import com.navercorp.pinpoint.exceptiontrace.web.entity.ExceptionChartValueViewEntity;
+import com.navercorp.pinpoint.exceptiontrace.web.mapper.ExceptionEntityMapper;
+import com.navercorp.pinpoint.exceptiontrace.web.model.ExceptionGroupSummary;
 import com.navercorp.pinpoint.exceptiontrace.web.util.ExceptionTraceQueryParameter;
+import com.navercorp.pinpoint.exceptiontrace.web.view.ExceptionChartValueView;
+import com.navercorp.pinpoint.exceptiontrace.web.view.ExceptionDetailView;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.mybatis.spring.SqlSessionTemplate;
@@ -47,34 +47,34 @@ public class PinotExceptionTraceDao implements ExceptionTraceDao {
     private static final String SELECT_QUERY = "selectExceptions";
     private static final String SELECT_SUMMARIZED_QUERY = "selectSummarizedExceptions";
     private static final String SELECT_EXACT_QUERY = "selectExactException";
+    private static final String SELECT_GROUP_SUMMARIES_QUERY = "selectGroupSummaries";
+    private static final String SELECT_CHART_QUERY = "selectChartValueViews";
 
     private final SqlSessionTemplate sqlPinotSessionTemplate;
 
+    private final ExceptionEntityMapper mapper;
 
     public PinotExceptionTraceDao(
             @Qualifier("exceptionTracePinotSessionTemplate") SqlSessionTemplate sqlPinotSessionTemplate,
+            ExceptionEntityMapper mapper
     ) {
         this.sqlPinotSessionTemplate = Objects.requireNonNull(sqlPinotSessionTemplate, "sqlPinotSessionTemplate");
         this.mapper = Objects.requireNonNull(mapper, "mapper");
     }
 
     @Override
+    public List&lt;ExceptionDetailView&gt; getExceptions(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
         List&lt;ExceptionMetaDataEntity&gt; dataEntities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_QUERY, exceptionTraceQueryParameter);
         return dataEntities.stream()
+                .map(mapper::toDetailView)
                 .collect(Collectors.toList());
     }
 
     @Override
+    public List&lt;ExceptionDetailView&gt; getSummarizedExceptions(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
         List&lt;ExceptionMetaDataEntity&gt; dataEntities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_SUMMARIZED_QUERY, exceptionTraceQueryParameter);
         return dataEntities.stream()
+                .map(mapper::toDetailView)
                 .collect(Collectors.toList());
     }
 
@@ -85,22 +85,27 @@ public ExceptionMetaData getException(ExceptionTraceQueryParameter exceptionTrac
     }
 
     @Override
+    public List&lt;ExceptionGroupSummary&gt; getGroupSummaries(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
+        List&lt;ExceptionGroupSummaryEntity&gt; entities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_GROUP_SUMMARIES_QUERY, exceptionTraceQueryParameter);
         return entities.stream()
+                .map((ExceptionGroupSummaryEntity e) -&gt;
                         mapper.toSummary(
                                 e, exceptionTraceQueryParameter.getGroupByAttributes()
                         )
                 ).collect(Collectors.toList());
     }
 
     @Override
+    public List&lt;ExceptionChartValueView&gt; getChartValueViews(ExceptionTraceQueryParameter exceptionTraceQueryParameter) {
+        List&lt;ExceptionChartValueViewEntity&gt; valueViewEntities = this.sqlPinotSessionTemplate.selectList(NAMESPACE + SELECT_CHART_QUERY, exceptionTraceQueryParameter);
+        for (int i = 0; i &lt; valueViewEntities.size(); i++) {
+            ExceptionChartValueViewEntity view = valueViewEntities.get(i);
+            view.setRowNum(i + 1);
+        }
+
         return valueViewEntities.stream()
+                .map((ExceptionChartValueViewEntity e) -&gt;
+                        mapper.toChartView(
                                 e, exceptionTraceQueryParameter.getGroupByAttributes()
                         )
                 ).collect(Collectors.toList());
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>206166</refactoring_id><commit_sha>eec3456933ce9f04dfdec17cb64455b2aaa8526d</commit_sha><commit_link>https://github.com/apache/ignite/commit/eec3456933ce9f04dfdec17cb64455b2aaa8526d</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/visor/cache/VisorCache.java</file_path><description>Rename Method public swapSize() : long renamed to public backupSize() : long in class org.apache.ignite.internal.visor.cache.VisorCache</description><code_before>@@ -67,28 +67,19 @@ public class VisorCache implements Serializable, LessNamingBean {
     private long indexesSize;
 
     /** Number of all entries in cache. */
-    private int size;
 
     /** Number of all entries in near cache. */
     private int nearSize;
 
-    /** Number of all entries in DHT cache. */
-    private int dhtSize;
-
     /** Number of primary entries in cache. */
-    private int primarySize;
-
-    /** Memory size allocated in off-heap. */
-    private long offHeapAllocatedSize;
 
-    /** Number of cache entries stored in off-heap memory. */
-    private long offHeapEntriesCnt;
 
-    /** Size in bytes for swap space. */
-    private long swapSize;
-
-    /** Number of cache entries stored in swap space. */
-    private long swapKeys;
 
     /** Number of partitions. */
     private int partitions;
@@ -140,19 +131,17 @@ else if (ca instanceof GridDhtCacheAdapter)
             if (dca != null) {
                 GridDhtPartitionTopology top = dca.topology();
 
-                if (cfg.getCacheMode() != CacheMode.LOCAL &amp;&amp; cfg.getBackups() &gt; 0) {
                     partitionsMap = top.localPartitionMap();
-                }
             }
         }
 
         dynamicDeploymentId = cctx.dynamicDeploymentId();
-        size = ca.localSize(PEEK_NO_NEAR);
-        primarySize = ca.primarySize();
-        dhtSize = size - nearSize; // This is backup size.
         nearSize = ca.nearSize();
-        offHeapAllocatedSize = 0; // Memory is allocated globally.
-        offHeapEntriesCnt = 0; // Need to rename on ON-heap entries count, see GG-11148
         partitions = ca.affinity().partitions();
         metrics = new VisorCacheMetrics().from(ignite, cacheName);
         near = cctx.isNear();
@@ -171,6 +160,7 @@ else if (ca instanceof GridDhtCacheAdapter)
      * @throws IgniteCheckedException If estimation failed.
      */
     protected void estimateMemorySize(IgniteEx ignite, GridCacheAdapter ca, int sample) throws IgniteCheckedException {
         int size = ca.size();
 
         Iterable&lt;GridCacheEntryEx&gt; set = ca.context().isNear()
@@ -195,6 +185,8 @@ protected void estimateMemorySize(IgniteEx ignite, GridCacheAdapter ca, int samp
             memSz = (long)((double)memSz / cnt * size);
 
         memorySize = memSz;
     }
 
     /**
@@ -209,12 +201,9 @@ public VisorCache history() {
         c.indexesSize = indexesSize;
         c.size = size;
         c.nearSize = nearSize;
-        c.dhtSize = dhtSize;
         c.primarySize = primarySize;
-        c.offHeapAllocatedSize = offHeapAllocatedSize;
-        c.offHeapEntriesCnt = offHeapEntriesCnt;
-        c.swapSize = swapSize;
-        c.swapKeys = swapKeys;
         c.partitions = partitions;
         c.metrics = metrics;
         c.near = near;
@@ -269,7 +258,7 @@ public long indexesSize() {
     /**
      * @return Number of all entries in cache.
      */
-    public int size() {
         return size;
     }
 
@@ -281,45 +270,24 @@ public int nearSize() {
     }
 
     /**
-     * @return Number of all entries in DHT cache.
      */
-    public int dhtSize() {
-        return dhtSize;
     }
 
     /**
      * @return Number of primary entries in cache.
      */
-    public int primarySize() {
         return primarySize;
     }
 
     /**
-     * @return Memory size allocated in off-heap.
-     */
-    public long offHeapAllocatedSize() {
-        return offHeapAllocatedSize;
-    }
-
-    /**
-     * @return Number of cache entries stored in off-heap memory.
-     */
-    public long offHeapEntriesCount() {
-        return offHeapEntriesCnt;
-    }
-
-    /**
-     * @return Size in bytes for swap space.
-     */
-    public long swapSize() {
-        return swapSize;
-    }
-
-    /**
-     * @return Number of cache entries stored in swap space.
      */
-    public long swapKeys() {
-        return swapKeys;
     }
 
     /**
</code_before><code_after>@@ -67,28 +67,19 @@ public class VisorCache implements Serializable, LessNamingBean {
     private long indexesSize;
 
     /** Number of all entries in cache. */
+    private long size;
 
     /** Number of all entries in near cache. */
     private int nearSize;
 
     /** Number of primary entries in cache. */
+    private long primarySize;
 
+    /** Number of backup entries in cache. */
+    private long backupSize;
 
+    /** Number of cache entries stored in heap memory. */
+    private long onHeapEntriesCnt;
 
     /** Number of partitions. */
     private int partitions;
@@ -140,19 +131,17 @@ else if (ca instanceof GridDhtCacheAdapter)
             if (dca != null) {
                 GridDhtPartitionTopology top = dca.topology();
 
+                if (cfg.getCacheMode() != CacheMode.LOCAL &amp;&amp; cfg.getBackups() &gt; 0)
                     partitionsMap = top.localPartitionMap();
             }
         }
 
         dynamicDeploymentId = cctx.dynamicDeploymentId();
+        size = ca.localSizeLong(PEEK_NO_NEAR);
+        primarySize = ca.primarySizeLong();
+        backupSize = size - primarySize; // This is backup size.
         nearSize = ca.nearSize();
+        onHeapEntriesCnt = 0; // TODO GG-11148 Need to rename on ON-heap entries count, see
         partitions = ca.affinity().partitions();
         metrics = new VisorCacheMetrics().from(ignite, cacheName);
         near = cctx.isNear();
@@ -171,6 +160,7 @@ else if (ca instanceof GridDhtCacheAdapter)
      * @throws IgniteCheckedException If estimation failed.
      */
     protected void estimateMemorySize(IgniteEx ignite, GridCacheAdapter ca, int sample) throws IgniteCheckedException {
+        /* TODO Fix after GG-11739 implemented.
         int size = ca.size();
 
         Iterable&lt;GridCacheEntryEx&gt; set = ca.context().isNear()
@@ -195,6 +185,8 @@ protected void estimateMemorySize(IgniteEx ignite, GridCacheAdapter ca, int samp
             memSz = (long)((double)memSz / cnt * size);
 
         memorySize = memSz;
+        */
+        memorySize = 0;
     }
 
     /**
@@ -209,12 +201,9 @@ public VisorCache history() {
         c.indexesSize = indexesSize;
         c.size = size;
         c.nearSize = nearSize;
+        c.backupSize = backupSize;
         c.primarySize = primarySize;
+        c.onHeapEntriesCnt = onHeapEntriesCnt;
         c.partitions = partitions;
         c.metrics = metrics;
         c.near = near;
@@ -269,7 +258,7 @@ public long indexesSize() {
     /**
      * @return Number of all entries in cache.
      */
+    public long size() {
         return size;
     }
 
@@ -281,45 +270,24 @@ public int nearSize() {
     }
 
     /**
+     * @return Number of backup entries in cache.
      */
+    public long backupSize() {
+        return backupSize;
     }
 
     /**
      * @return Number of primary entries in cache.
      */
+    public long primarySize() {
         return primarySize;
     }
 
     /**
+     * @return Number of cache entries stored in heap memory.
      */
+    public long onHeapEntriesCount() {
+        return onHeapEntriesCnt;
     }
 
     /**
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>324198</refactoring_id><commit_sha>300f98cd9357a76c174b513f8da9824d9118697a</commit_sha><commit_link>https://github.com/StarRocks/starrocks/commit/300f98cd9357a76c174b513f8da9824d9118697a</commit_link><file_path>fe/fe-core/src/main/java/com/starrocks/sql/optimizer/RowOutputInfo.java</file_path><description>Rename Method public createEmptyDescriptor() : RowOutputInfo renamed to public createEmptyInfo() : RowOutputInfo in class com.starrocks.sql.optimizer.RowOutputInfo</description><code_before>@@ -46,7 +46,7 @@ public class RowOutputInfo {
 
     private final Map&lt;Integer, ColumnOutputInfo&gt; columnOutputInfoMap;
 
-    public static RowOutputInfo createEmptyDescriptor() {
         return new RowOutputInfo();
     }
 
@@ -74,6 +74,10 @@ public List&lt;ColumnOutputInfo&gt; getColumnEntries() {
         return Lists.newArrayList(columnOutputInfoMap.values());
     }
 
     public Map&lt;ColumnRefOperator, ScalarOperator&gt; getColumnRefMap() {
         return columnOutputInfoMap.values().stream()
                 .collect(Collectors.toMap(ColumnOutputInfo::getColumnRef, ColumnOutputInfo::getScalarOp));
</code_before><code_after>@@ -46,7 +46,7 @@ public class RowOutputInfo {
 
     private final Map&lt;Integer, ColumnOutputInfo&gt; columnOutputInfoMap;
 
+    public static RowOutputInfo createEmptyInfo() {
         return new RowOutputInfo();
     }
 
@@ -74,6 +74,10 @@ public List&lt;ColumnOutputInfo&gt; getColumnEntries() {
         return Lists.newArrayList(columnOutputInfoMap.values());
     }
 
+    public List&lt;ColumnRefOperator&gt; getColumnRefOps() {
+        return columnOutputInfoMap.values().stream().map(e -&gt; e.getColumnRef()).collect(Collectors.toList());
+    }
+
     public Map&lt;ColumnRefOperator, ScalarOperator&gt; getColumnRefMap() {
         return columnOutputInfoMap.values().stream()
                 .collect(Collectors.toMap(ColumnOutputInfo::getColumnRef, ColumnOutputInfo::getScalarOp));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>143957</refactoring_id><commit_sha>bddc273bb27ba73f93ed9e9cea4defa598c9f28c</commit_sha><commit_link>https://github.com/bisq-network/bisq/commit/bddc273bb27ba73f93ed9e9cea4defa598c9f28c</commit_link><file_path>cli/src/main/java/bisq/cli/TradeFormat.java</file_path><description>Rename Method private shouldShowBqsBuyerAddress(tradeInfo TradeInfo, isTaker boolean) : boolean renamed to private shouldShowBsqBuyerAddress(tradeInfo TradeInfo, isTaker boolean) : boolean in class bisq.cli.TradeFormat</description><code_before>@@ -59,7 +59,7 @@ public static String format(TradeInfo tradeInfo) {
                 "%" + (COL_HEADER_TRADE_TAKER_FEE.length() + 2) + "s"
                 : "";
 
-        boolean showBsqBuyerAddress = shouldShowBqsBuyerAddress(tradeInfo, isTaker);
         Supplier&lt;String&gt; bsqBuyerAddressHeader = () -&gt; showBsqBuyerAddress ? COL_HEADER_TRADE_BSQ_BUYER_ADDRESS : "";
         Supplier&lt;String&gt; bsqBuyerAddressHeaderSpec = () -&gt; showBsqBuyerAddress ? "%s" : "";
 
@@ -203,7 +203,7 @@ private static String formatTradeData(String format,
         }
     };
 
-    private static boolean shouldShowBqsBuyerAddress(TradeInfo tradeInfo, boolean isTaker) {
         if (tradeInfo.getOffer().getBaseCurrencyCode().equals("BTC")) {
             return false;
         } else {
</code_before><code_after>@@ -59,7 +59,7 @@ public static String format(TradeInfo tradeInfo) {
                 "%" + (COL_HEADER_TRADE_TAKER_FEE.length() + 2) + "s"
                 : "";
 
+        boolean showBsqBuyerAddress = shouldShowBsqBuyerAddress(tradeInfo, isTaker);
         Supplier&lt;String&gt; bsqBuyerAddressHeader = () -&gt; showBsqBuyerAddress ? COL_HEADER_TRADE_BSQ_BUYER_ADDRESS : "";
         Supplier&lt;String&gt; bsqBuyerAddressHeaderSpec = () -&gt; showBsqBuyerAddress ? "%s" : "";
 
@@ -203,7 +203,7 @@ private static String formatTradeData(String format,
         }
     };
 
+    private static boolean shouldShowBsqBuyerAddress(TradeInfo tradeInfo, boolean isTaker) {
         if (tradeInfo.getOffer().getBaseCurrencyCode().equals("BTC")) {
             return false;
         } else {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>160610</refactoring_id><commit_sha>8ceaf9ff1d531b74c01a541cb6feeb319f4f8d6d</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/8ceaf9ff1d531b74c01a541cb6feeb319f4f8d6d</commit_link><file_path>community/cypher/literal-interpreter/src/main/java/org/neo4j/cypher/internal/ast/factory/empty/NullAstFactory.java</file_path><description>Rename Method public nodePattern(p NULL, v NULL, labels List&lt;StringPos&lt;NULL&gt;&gt;, aNull NULL, properties NULL, predicate NULL) : NULL renamed to public labelColonConjunction(p NULL, lhs NULL, rhs NULL) : NULL in class org.neo4j.cypher.internal.ast.factory.empty.NullAstFactory</description><code_before>@@ -227,6 +227,18 @@ public NULL labelAtom( NULL p, String e )
         return null;
     }
 
     @Override
     public NULL ands( List&lt;NULL&gt; exprs )
     {
@@ -704,7 +716,7 @@ public NULL everyPathPattern( List&lt;NULL&gt; nodes, List&lt;NULL&gt; relationships )
     }
 
     @Override
-    public NULL nodePattern( NULL p, NULL v, List&lt;StringPos&lt;NULL&gt;&gt; labels, NULL aNull, NULL properties, NULL predicate )
     {
         return null;
     }
</code_before><code_after>@@ -227,6 +227,18 @@ public NULL labelAtom( NULL p, String e )
         return null;
     }
 
+    @Override
+    public NULL labelColonConjunction( NULL p, NULL lhs, NULL rhs )
+    {
+        return null;
+    }
+
+    @Override
+    public NULL labelExpressionPredicate( NULL subject, NULL exp )
+    {
+        return null;
+    }
+
     @Override
     public NULL ands( List&lt;NULL&gt; exprs )
     {
@@ -704,7 +716,7 @@ public NULL everyPathPattern( List&lt;NULL&gt; nodes, List&lt;NULL&gt; relationships )
     }
 
     @Override
+    public NULL nodePattern( NULL p, NULL v, NULL aNull, NULL properties, NULL predicate )
     {
         return null;
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>278858</refactoring_id><commit_sha>8d0afd73aa355d78505a1755315514b0c405b93a</commit_sha><commit_link>https://github.com/oracle/visualvm/commit/8d0afd73aa355d78505a1755315514b0c405b93a</commit_link><file_path>lib.profiler/src/org/netbeans/lib/profiler/results/cpu/cct/TimeCollector.java</file_path><description>Rename Method public endTrans() : void renamed to public onStop() : void in class org.netbeans.lib.profiler.results.cpu.cct.TimeCollector</description><code_before>@@ -46,16 +46,18 @@
 import org.netbeans.lib.profiler.results.cpu.TimingAdjusterOld;
 import org.netbeans.lib.profiler.results.cpu.cct.nodes.MethodCPUCCTNode;
 import org.netbeans.lib.profiler.marker.Mark;
-import org.netbeans.lib.profiler.results.cpu.marking.MarkBasedNodeVisitor;
 import java.util.HashMap;
 import java.util.Map;
 
 
 /**
  *
  * @author Jaroslav Bachorik
  */
-public class TimeCollector extends MarkBasedNodeVisitor {
     //~ Inner Classes ------------------------------------------------------------------------------------------------------------
 
     private static class TimingData {
@@ -110,20 +112,22 @@ public synchronized long getNetTime1(Mark mark) {
         return (time &gt; 0) ? time : 0;
     }
 
-    public void beforeWalk() {
-        super.beforeWalk();
         timing.clear();
     }
 
-    public void endTrans() {
         if (isReset()) {
             this.timing = new HashMap();
         }
-
-        super.endTrans();
     }
 
-    public void visit(final MethodCPUCCTNode node) {
         if (isReset()) {
             return;
         }
</code_before><code_after>@@ -46,16 +46,18 @@
 import org.netbeans.lib.profiler.results.cpu.TimingAdjusterOld;
 import org.netbeans.lib.profiler.results.cpu.cct.nodes.MethodCPUCCTNode;
 import org.netbeans.lib.profiler.marker.Mark;
 import java.util.HashMap;
 import java.util.Map;
+import org.netbeans.lib.profiler.results.RuntimeCCTNode;
+import org.netbeans.lib.profiler.results.cpu.cct.nodes.MarkedCPUCCTNode;
+import org.netbeans.lib.profiler.results.cpu.marking.MarkAwareNodeProcessorPlugin;
 
 
 /**
  *
  * @author Jaroslav Bachorik
  */
+public class TimeCollector extends MarkAwareNodeProcessorPlugin {
     //~ Inner Classes ------------------------------------------------------------------------------------------------------------
 
     private static class TimingData {
@@ -110,20 +112,22 @@ public synchronized long getNetTime1(Mark mark) {
         return (time &gt; 0) ? time : 0;
     }
 
+    @Override
+    public void onStart() {
+        super.onStart();
         timing.clear();
     }
 
+    @Override
+    public void onStop() {
         if (isReset()) {
             this.timing = new HashMap();
         }
+        super.onStop();
     }
 
+    @Override
+    public void onNode(MethodCPUCCTNode node) {
         if (isReset()) {
             return;
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>272191</refactoring_id><commit_sha>b0380df84865427d853e61c931132330087bb843</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/b0380df84865427d853e61c931132330087bb843</commit_link><file_path>test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java</file_path><description>Rename Method public testBug545() : void renamed to public testBug545a() : void in class com.google.javascript.jscomp.InlineObjectLiteralsTest</description><code_before>@@ -30,7 +30,6 @@ public InlineObjectLiteralsTest() {
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    validateAstChangeMarking(false);
   }
 
   @Override
@@ -333,8 +332,11 @@ public void testObject26() {
          "new JSCompiler_object_inline_b_0.c");
   }
 
-  public void testBug545() {
     testLocal("var a = {}", "");
     testLocal("var a; a = {}", "true");
   }
 
</code_before><code_after>@@ -30,7 +30,6 @@ public InlineObjectLiteralsTest() {
   @Override
   protected void setUp() throws Exception {
     super.setUp();
   }
 
   @Override
@@ -333,8 +332,11 @@ public void testObject26() {
          "new JSCompiler_object_inline_b_0.c");
   }
 
+  public void testBug545a() {
     testLocal("var a = {}", "");
+  }
+
+  public void testBug545b() {
     testLocal("var a; a = {}", "true");
   }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>196636</refactoring_id><commit_sha>7b24ceaa534f32df6b2fbb7846603b03503153be</commit_sha><commit_link>https://github.com/camunda/camunda/commit/7b24ceaa534f32df6b2fbb7846603b03503153be</commit_link><file_path>backend/src/it/java/org/camunda/optimize/service/es/report/AbstractAutomaticIntervalSelectionGroupByDateReportEvaluationIT.java</file_path><description>Rename Method protected getReportData(key String, version String) : ProcessReportDataDto renamed to protected getGroupByStartDateReportData(key String, version String) : ProcessReportDataDto in class org.camunda.optimize.service.es.report.AbstractAutomaticIntervalSelectionGroupByDateReportEvaluationIT</description><code_before>@@ -25,6 +25,8 @@
 import org.camunda.optimize.test.it.rule.EmbeddedOptimizeRule;
 import org.camunda.optimize.test.it.rule.EngineDatabaseRule;
 import org.camunda.optimize.test.it.rule.EngineIntegrationRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.RuleChain;
@@ -40,8 +42,6 @@
 
 import static org.camunda.optimize.test.util.DateModificationHelper.truncateToStartOfUnit;
 import static org.camunda.optimize.test.util.ProcessReportDataBuilderHelper.createCombinedReport;
-import static org.camunda.optimize.test.util.ProcessReportDataBuilderHelper.createCountProcessInstanceFrequencyGroupByEndDate;
-import static org.camunda.optimize.test.util.ProcessReportDataBuilderHelper.createCountProcessInstanceFrequencyGroupByStartDate;
 import static org.camunda.optimize.upgrade.es.ElasticsearchConstants.NUMBER_OF_DATA_POINTS_FOR_AUTOMATIC_INTERVAL_SELECTION;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -82,7 +82,7 @@ public void automaticIntervalSelectionWorks() throws SQLException {
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
-    ProcessReportDataDto reportData = getReportData(
       processInstanceDto1.getProcessDefinitionKey(),
       processInstanceDto1.getProcessDefinitionVersion()
     );
@@ -95,8 +95,14 @@ public void automaticIntervalSelectionWorks() throws SQLException {
     assertThat(resultData.get(resultData.size() - 1).getValue(), is(1L));
   }
 
-  protected ProcessReportDataDto getReportData(String key, String version) {
-    return createCountProcessInstanceFrequencyGroupByStartDate(key, version, GroupByDateUnit.AUTOMATIC);
   }
 
   @Test
@@ -118,7 +124,7 @@ public void automaticIntervalSelectionTakesAllProcessInstancesIntoAccount() thro
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
-    ProcessReportDataDto reportData = getReportData(
       processInstanceDto1.getProcessDefinitionKey(),
       processInstanceDto1.getProcessDefinitionVersion()
     );
@@ -140,7 +146,7 @@ public void automaticIntervalSelectionForNoData() {
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
-    ProcessReportDataDto reportData = getReportData(engineDto.getKey(), engineDto.getVersionAsString());
     ProcessCountReportMapResultDto result = evaluateReportAndReturnResult(reportData);
 
     // then
@@ -156,7 +162,7 @@ public void automaticIntervalSelectionForOneDataPoint() {
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
-    ProcessReportDataDto reportData = getReportData(
       engineDto.getProcessDefinitionKey(),
       engineDto.getProcessDefinitionVersion()
     );
@@ -245,18 +251,22 @@ public void combinedReportsGroupedByStartAndEndDate() throws Exception {
     changeProcessInstanceDates(procInstMax, now.plusDays(3), now.plusDays(6));
 
 
-    ProcessReportDataDto reportDataDto = createCountProcessInstanceFrequencyGroupByEndDate(
-      processDefinition.getKey(),
-      processDefinition.getVersionAsString(),
-      GroupByDateUnit.AUTOMATIC
-    );
     String singleReportId = createNewSingleReport(reportDataDto);
 
-    ProcessReportDataDto reportDataDto2 = createCountProcessInstanceFrequencyGroupByStartDate(
-      processDefinition.getKey(),
-      processDefinition.getVersionAsString(),
-      GroupByDateUnit.AUTOMATIC
-    );
     String singleReportId2 = createNewSingleReport(reportDataDto2);
 
     embeddedOptimizeRule.importAllEngineEntitiesFromScratch();
@@ -272,9 +282,9 @@ public void combinedReportsGroupedByStartAndEndDate() throws Exception {
     assertResultIsInCorrectRanges(now.plusDays(1), now.plusDays(6), resultMap, 2);
   }
 
-  protected void changeProcessInstanceDates(final ProcessInstanceEngineDto procInstMin,
-                                            final ZonedDateTime startDate,
-                                            final ZonedDateTime endDate) throws
                                                                          SQLException {
     engineDatabaseRule.changeProcessInstanceStartDate(procInstMin.getId(), startDate.toOffsetDateTime());
     engineDatabaseRule.changeProcessInstanceEndDate(procInstMin.getId(), endDate.toOffsetDateTime());
@@ -307,7 +317,7 @@ private void assertIsInRangeOfLastInterval(String lastIntervalAsString,
   }
 
   private String createNewSingleReport(ProcessDefinitionEngineDto engineDto) {
-    return createNewSingleReport(getReportData(engineDto.getKey(), engineDto.getVersionAsString()));
   }
 
   private String createNewSingleReport(ProcessReportDataDto reportDataDto) {
</code_before><code_after>@@ -25,6 +25,8 @@
 import org.camunda.optimize.test.it.rule.EmbeddedOptimizeRule;
 import org.camunda.optimize.test.it.rule.EngineDatabaseRule;
 import org.camunda.optimize.test.it.rule.EngineIntegrationRule;
+import org.camunda.optimize.test.util.ProcessReportDataBuilder;
+import org.camunda.optimize.test.util.ProcessReportDataType;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.RuleChain;
@@ -40,8 +42,6 @@
 
 import static org.camunda.optimize.test.util.DateModificationHelper.truncateToStartOfUnit;
 import static org.camunda.optimize.test.util.ProcessReportDataBuilderHelper.createCombinedReport;
 import static org.camunda.optimize.upgrade.es.ElasticsearchConstants.NUMBER_OF_DATA_POINTS_FOR_AUTOMATIC_INTERVAL_SELECTION;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -82,7 +82,7 @@ public void automaticIntervalSelectionWorks() throws SQLException {
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
+    ProcessReportDataDto reportData = getGroupByStartDateReportData(
       processInstanceDto1.getProcessDefinitionKey(),
       processInstanceDto1.getProcessDefinitionVersion()
     );
@@ -95,8 +95,14 @@ public void automaticIntervalSelectionWorks() throws SQLException {
     assertThat(resultData.get(resultData.size() - 1).getValue(), is(1L));
   }
 
+  protected ProcessReportDataDto getGroupByStartDateReportData(String key, String version) {
+    return ProcessReportDataBuilder
+      .createReportData()
+      .setProcessDefinitionKey(key)
+      .setProcessDefinitionVersion(version)
+      .setDateInterval(GroupByDateUnit.AUTOMATIC)
+      .setReportDataType(ProcessReportDataType.COUNT_PROC_INST_FREQ_GROUP_BY_START_DATE)
+      .build();
   }
 
   @Test
@@ -118,7 +124,7 @@ public void automaticIntervalSelectionTakesAllProcessInstancesIntoAccount() thro
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
+    ProcessReportDataDto reportData = getGroupByStartDateReportData(
       processInstanceDto1.getProcessDefinitionKey(),
       processInstanceDto1.getProcessDefinitionVersion()
     );
@@ -140,7 +146,7 @@ public void automaticIntervalSelectionForNoData() {
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
+    ProcessReportDataDto reportData = getGroupByStartDateReportData(engineDto.getKey(), engineDto.getVersionAsString());
     ProcessCountReportMapResultDto result = evaluateReportAndReturnResult(reportData);
 
     // then
@@ -156,7 +162,7 @@ public void automaticIntervalSelectionForOneDataPoint() {
     elasticSearchRule.refreshAllOptimizeIndices();
 
     // when
+    ProcessReportDataDto reportData = getGroupByStartDateReportData(
       engineDto.getProcessDefinitionKey(),
       engineDto.getProcessDefinitionVersion()
     );
@@ -245,18 +251,22 @@ public void combinedReportsGroupedByStartAndEndDate() throws Exception {
     changeProcessInstanceDates(procInstMax, now.plusDays(3), now.plusDays(6));
 
 
+    ProcessReportDataDto reportDataDto = ProcessReportDataBuilder
+      .createReportData()
+      .setProcessDefinitionKey(processDefinition.getKey())
+      .setProcessDefinitionVersion(processDefinition.getVersionAsString())
+      .setDateInterval(GroupByDateUnit.AUTOMATIC)
+      .setReportDataType(ProcessReportDataType.COUNT_PROC_INST_FREQ_GROUP_BY_END_DATE)
+      .build();
     String singleReportId = createNewSingleReport(reportDataDto);
 
+    ProcessReportDataDto reportDataDto2 = ProcessReportDataBuilder
+      .createReportData()
+      .setProcessDefinitionKey(processDefinition.getKey())
+      .setProcessDefinitionVersion(processDefinition.getVersionAsString())
+      .setDateInterval(GroupByDateUnit.AUTOMATIC)
+      .setReportDataType(ProcessReportDataType.COUNT_PROC_INST_FREQ_GROUP_BY_START_DATE)
+      .build();
     String singleReportId2 = createNewSingleReport(reportDataDto2);
 
     embeddedOptimizeRule.importAllEngineEntitiesFromScratch();
@@ -272,9 +282,9 @@ public void combinedReportsGroupedByStartAndEndDate() throws Exception {
     assertResultIsInCorrectRanges(now.plusDays(1), now.plusDays(6), resultMap, 2);
   }
 
+  private void changeProcessInstanceDates(final ProcessInstanceEngineDto procInstMin,
+                                          final ZonedDateTime startDate,
+                                          final ZonedDateTime endDate) throws
                                                                          SQLException {
     engineDatabaseRule.changeProcessInstanceStartDate(procInstMin.getId(), startDate.toOffsetDateTime());
     engineDatabaseRule.changeProcessInstanceEndDate(procInstMin.getId(), endDate.toOffsetDateTime());
@@ -307,7 +317,7 @@ private void assertIsInRangeOfLastInterval(String lastIntervalAsString,
   }
 
   private String createNewSingleReport(ProcessDefinitionEngineDto engineDto) {
+    return createNewSingleReport(getGroupByStartDateReportData(engineDto.getKey(), engineDto.getVersionAsString()));
   }
 
   private String createNewSingleReport(ProcessReportDataDto reportDataDto) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>159262</refactoring_id><commit_sha>e47e18cacb66a950f4ceafaa6cde0486e62690a0</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/e47e18cacb66a950f4ceafaa6cde0486e62690a0</commit_link><file_path>enterprise/com/src/main/java/org/neo4j/com/RequestContext.java</file_path><description>Rename Method public getSessionId() : long renamed to public getEpoch() : long in class org.neo4j.com.RequestContext</description><code_before>@@ -29,7 +29,6 @@
  */
 public final class RequestContext
 {
-
     public static class Tx
     {
         private final String dataSourceName;
@@ -68,21 +67,21 @@ public static Tx lastAppliedTx( String dataSourceName, long txId )
     private final Tx[] lastAppliedTransactions;
     private final int eventIdentifier;
     private final int hashCode;
-    private final long sessionId;
     private final int masterId;
     private final long checksum;
 
-    public RequestContext( long sessionId, int machineId, int eventIdentifier,
             Tx[] lastAppliedTransactions, int masterId, long checksum )
     {
-        this.sessionId = sessionId;
         this.machineId = machineId;
         this.eventIdentifier = eventIdentifier;
         this.lastAppliedTransactions = lastAppliedTransactions;
         this.masterId = masterId;
         this.checksum = checksum;
 
-        long hash = sessionId;
         hash = ( 31 * hash ) ^ eventIdentifier;
         hash = ( 31 * hash ) ^ machineId;
         this.hashCode = (int) ( ( hash &gt;&gt;&gt; 32 ) ^ hash );
@@ -103,9 +102,9 @@ public int getEventIdentifier()
         return eventIdentifier;
     }
 
-    public long getSessionId()
     {
-        return sessionId;
     }
 
     public int getMasterId()
@@ -121,7 +120,7 @@ public long getChecksum()
     @Override
     public String toString()
     {
-        return "RequestContext[session: " + sessionId + ", ID:" + machineId + ", eventIdentifier:" + eventIdentifier
                + ", " + Arrays.asList( lastAppliedTransactions ) + "]";
     }
 
@@ -133,7 +132,7 @@ public boolean equals( Object obj )
             return false;
         }
         RequestContext o = (RequestContext) obj;
-        return o.eventIdentifier == eventIdentifier &amp;&amp; o.machineId == machineId &amp;&amp; o.sessionId == sessionId;
     }
 
     @Override
@@ -146,7 +145,7 @@ public int hashCode()
 
     public static RequestContext anonymous( Tx[] lastAppliedTransactions )
     {
-        return new RequestContext( EMPTY.sessionId, EMPTY.machineId, EMPTY.eventIdentifier,
                 lastAppliedTransactions, EMPTY.masterId, EMPTY.checksum );
     }
 }
</code_before><code_after>@@ -29,7 +29,6 @@
  */
 public final class RequestContext
 {
     public static class Tx
     {
         private final String dataSourceName;
@@ -68,21 +67,21 @@ public static Tx lastAppliedTx( String dataSourceName, long txId )
     private final Tx[] lastAppliedTransactions;
     private final int eventIdentifier;
     private final int hashCode;
+    private final long epoch;
     private final int masterId;
     private final long checksum;
 
+    public RequestContext( long epoch, int machineId, int eventIdentifier,
             Tx[] lastAppliedTransactions, int masterId, long checksum )
     {
+        this.epoch = epoch;
         this.machineId = machineId;
         this.eventIdentifier = eventIdentifier;
         this.lastAppliedTransactions = lastAppliedTransactions;
         this.masterId = masterId;
         this.checksum = checksum;
 
+        long hash = epoch;
         hash = ( 31 * hash ) ^ eventIdentifier;
         hash = ( 31 * hash ) ^ machineId;
         this.hashCode = (int) ( ( hash &gt;&gt;&gt; 32 ) ^ hash );
@@ -103,9 +102,9 @@ public int getEventIdentifier()
         return eventIdentifier;
     }
 
+    public long getEpoch()
     {
+        return epoch;
     }
 
     public int getMasterId()
@@ -121,7 +120,7 @@ public long getChecksum()
     @Override
     public String toString()
     {
+        return "RequestContext[session: " + epoch + ", ID:" + machineId + ", eventIdentifier:" + eventIdentifier
                + ", " + Arrays.asList( lastAppliedTransactions ) + "]";
     }
 
@@ -133,7 +132,7 @@ public boolean equals( Object obj )
             return false;
         }
         RequestContext o = (RequestContext) obj;
+        return o.eventIdentifier == eventIdentifier &amp;&amp; o.machineId == machineId &amp;&amp; o.epoch == epoch;
     }
 
     @Override
@@ -146,7 +145,7 @@ public int hashCode()
 
     public static RequestContext anonymous( Tx[] lastAppliedTransactions )
     {
+        return new RequestContext( EMPTY.epoch, EMPTY.machineId, EMPTY.eventIdentifier,
                 lastAppliedTransactions, EMPTY.masterId, EMPTY.checksum );
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>286264</refactoring_id><commit_sha>160ca4b8a23f543c9af9f77a5fe836823c7d04da</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/160ca4b8a23f543c9af9f77a5fe836823c7d04da</commit_link><file_path>quickstep/recents_ui_overrides/src/com/android/quickstep/views/OverviewActionsView.java</file_path><description>Rename Method public updateVerticalMarginForNavModeChange(mode Mode) : void renamed to public updateVerticalMargin(mode Mode) : void in class com.android.quickstep.views.OverviewActionsView</description><code_before>@@ -21,6 +21,7 @@
 import static com.android.quickstep.SysUINavigationMode.removeShelfFromOverview;
 
 import android.content.Context;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.view.View;
@@ -33,6 +34,7 @@
 import com.android.launcher3.R;
 import com.android.launcher3.util.MultiValueAlpha;
 import com.android.launcher3.util.MultiValueAlpha.AlphaProperty;
 import com.android.quickstep.SysUINavigationMode.Mode;
 import com.android.quickstep.TaskOverlayFactory.OverlayUICallbacks;
 
@@ -129,6 +131,12 @@ protected void onAttachedToWindow() {
         updateHiddenFlags(HIDDEN_UNSUPPORTED_NAVIGATION, !removeShelfFromOverview(getContext()));
     }
 
     public void updateHiddenFlags(@ActionsHiddenFlags int visibilityFlags, boolean enable) {
         if (enable) {
             mHiddenFlags |= visibilityFlags;
@@ -152,10 +160,13 @@ public AlphaProperty getFullscreenAlpha() {
         return mMultiValueAlpha.getProperty(INDEX_FULLSCREEN_ALPHA);
     }
 
-    /** Updates vertical margins for different navigation mode. */
-    public void updateVerticalMarginForNavModeChange(Mode mode) {
-        int bottomMargin = 0;
-        if (mode == Mode.THREE_BUTTONS) {
             bottomMargin = getResources()
                     .getDimensionPixelSize(R.dimen.overview_actions_bottom_margin_three_button);
         } else {
</code_before><code_after>@@ -21,6 +21,7 @@
 import static com.android.quickstep.SysUINavigationMode.removeShelfFromOverview;
 
 import android.content.Context;
+import android.content.res.Configuration;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.view.View;
@@ -33,6 +34,7 @@
 import com.android.launcher3.R;
 import com.android.launcher3.util.MultiValueAlpha;
 import com.android.launcher3.util.MultiValueAlpha.AlphaProperty;
+import com.android.quickstep.SysUINavigationMode;
 import com.android.quickstep.SysUINavigationMode.Mode;
 import com.android.quickstep.TaskOverlayFactory.OverlayUICallbacks;
 
@@ -129,6 +131,12 @@ protected void onAttachedToWindow() {
         updateHiddenFlags(HIDDEN_UNSUPPORTED_NAVIGATION, !removeShelfFromOverview(getContext()));
     }
 
+    @Override
+    protected void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        updateVerticalMargin(SysUINavigationMode.getMode(getContext()));
+    }
+
     public void updateHiddenFlags(@ActionsHiddenFlags int visibilityFlags, boolean enable) {
         if (enable) {
             mHiddenFlags |= visibilityFlags;
@@ -152,10 +160,13 @@ public AlphaProperty getFullscreenAlpha() {
         return mMultiValueAlpha.getProperty(INDEX_FULLSCREEN_ALPHA);
     }
 
+    /** Updates vertical margins for different navigation mode or configuration changes. */
+    public void updateVerticalMargin(Mode mode) {
+        int bottomMargin;
+        int orientation = getResources().getConfiguration().orientation;
+        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
+            bottomMargin = 0;
+        } else if (mode == Mode.THREE_BUTTONS) {
             bottomMargin = getResources()
                     .getDimensionPixelSize(R.dimen.overview_actions_bottom_margin_three_button);
         } else {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>156809</refactoring_id><commit_sha>eb5edbb2f09a1c596edc2f2744e4e9740fe6d129</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/eb5edbb2f09a1c596edc2f2744e4e9740fe6d129</commit_link><file_path>configserver/src/test/java/com/yahoo/vespa/config/server/rpc/ConfigResponseFactoryTest.java</file_path><description>Rename Method public testLZ4CompressedFacory() : void renamed to public testLZ4CompressedFactory() : void in class com.yahoo.vespa.config.server.rpc.ConfigResponseFactoryTest</description><code_before>@@ -30,7 +30,7 @@ public void setup() {
     }
 
     @Test
-    public void testUncompressedFacory() {
         UncompressedConfigResponseFactory responseFactory = new UncompressedConfigResponseFactory();
         ConfigResponse response = responseFactory.createResponse(ConfigPayload.empty(), def, 3, false);
         assertEquals(CompressionType.UNCOMPRESSED, response.getCompressionInfo().getCompressionType());
@@ -39,7 +39,7 @@ public void testUncompressedFacory() {
     }
 
     @Test
-    public void testLZ4CompressedFacory() {
         LZ4ConfigResponseFactory responseFactory = new LZ4ConfigResponseFactory();
         ConfigResponse response = responseFactory.createResponse(ConfigPayload.empty(), def, 3, false);
         assertEquals(CompressionType.LZ4, response.getCompressionInfo().getCompressionType());
</code_before><code_after>@@ -30,7 +30,7 @@ public void setup() {
     }
 
     @Test
+    public void testUncompressedFactory() {
         UncompressedConfigResponseFactory responseFactory = new UncompressedConfigResponseFactory();
         ConfigResponse response = responseFactory.createResponse(ConfigPayload.empty(), def, 3, false);
         assertEquals(CompressionType.UNCOMPRESSED, response.getCompressionInfo().getCompressionType());
@@ -39,7 +39,7 @@ public void testUncompressedFacory() {
     }
 
     @Test
+    public void testLZ4CompressedFactory() {
         LZ4ConfigResponseFactory responseFactory = new LZ4ConfigResponseFactory();
         ConfigResponse response = responseFactory.createResponse(ConfigPayload.empty(), def, 3, false);
         assertEquals(CompressionType.LZ4, response.getCompressionInfo().getCompressionType());
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>180437</refactoring_id><commit_sha>b88bd72d36c5ce930a7811e569a2fc8d7db58468</commit_sha><commit_link>https://github.com/noear/solon/commit/b88bd72d36c5ce930a7811e569a2fc8d7db58468</commit_link><file_path>_test/src/main/java/webapp/demo9_multiple_view/BeetlView.java</file_path><description>Rename Method public dock() : ModelAndView renamed to public view() : ModelAndView in class webapp.demo9_multiple_view.BeetlView</description><code_before>@@ -4,12 +4,14 @@
 import org.noear.solon.annotation.Mapping;
 import org.noear.solon.annotation.Singleton;
 import org.noear.solon.core.handle.ModelAndView;
 
 @Singleton(false)
 @Controller
 public class BeetlView {
     @Mapping("/demo9/view/beetl")
-    public ModelAndView dock(){
         ModelAndView model = new ModelAndView("beetl.htm");
         model.put("title","dock");
         model.put("msg","&#x4F60;&#x597D; world! in XController");
</code_before><code_after>@@ -4,12 +4,14 @@
 import org.noear.solon.annotation.Mapping;
 import org.noear.solon.annotation.Singleton;
 import org.noear.solon.core.handle.ModelAndView;
+import org.noear.solon.i18n.annotation.I18n;
 
+@I18n
 @Singleton(false)
 @Controller
 public class BeetlView {
     @Mapping("/demo9/view/beetl")
+    public ModelAndView view(){
         ModelAndView model = new ModelAndView("beetl.htm");
         model.put("title","dock");
         model.put("msg","&#x4F60;&#x597D; world! in XController");
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>163052</refactoring_id><commit_sha>2eea218520958fb773a9b1ea2728d7179b718e44</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/2eea218520958fb773a9b1ea2728d7179b718e44</commit_link><file_path>community/security/src/main/java/org/neo4j/server/security/auth/BasicAuthSubject.java</file_path><description>Rename Method private validatePassword(password String) : void renamed to package credentialsMatchesPassword(password String) : boolean in class org.neo4j.server.security.auth.BasicAuthSubject</description><code_before>@@ -33,6 +33,15 @@ public class BasicAuthSubject implements AuthSubject
     private AuthenticationResult authenticationResult;
     private final AccessMode.Static accessMode;
 
     public BasicAuthSubject( BasicAuthManager authManager, User user, AuthenticationResult authenticationResult )
     {
         this.authManager = authManager;
@@ -72,8 +81,6 @@ public AuthenticationResult getAuthenticationResult()
     @Override
     public void setPassword( String password ) throws IOException, IllegalCredentialsException
     {
-        validatePassword( password );
-
         authManager.setPassword( this, user.name(), password );
     }
 
@@ -106,19 +113,8 @@ public String name()
         return accessMode.name();
     }
 
-    /*
-     * This is really some very basic password policy and that functionality should probably be
-     * refactored out of the BasicAuthSubject.
-     */
-    private void validatePassword( String password ) throws IllegalCredentialsException
     {
-        if ( password == null || password.isEmpty() )
-        {
-            throw new IllegalCredentialsException( "Password cannot be empty." );
-        }
-        if ( user.credentials().matchesPassword( password ) )
-        {
-            throw new IllegalCredentialsException( "Old password and new password cannot be the same." );
-        }
     }
 }
</code_before><code_after>@@ -33,6 +33,15 @@ public class BasicAuthSubject implements AuthSubject
     private AuthenticationResult authenticationResult;
     private final AccessMode.Static accessMode;
 
+    public static BasicAuthSubject castOrFail( AuthSubject authSubject )
+    {
+        if ( !(authSubject instanceof BasicAuthSubject) )
+        {
+            throw new IllegalArgumentException( "Incorrect AuthSubject type " + authSubject.getClass().getTypeName() );
+        }
+        return (BasicAuthSubject) authSubject;
+    }
+
     public BasicAuthSubject( BasicAuthManager authManager, User user, AuthenticationResult authenticationResult )
     {
         this.authManager = authManager;
@@ -72,8 +81,6 @@ public AuthenticationResult getAuthenticationResult()
     @Override
     public void setPassword( String password ) throws IOException, IllegalCredentialsException
     {
         authManager.setPassword( this, user.name(), password );
     }
 
@@ -106,19 +113,8 @@ public String name()
         return accessMode.name();
     }
 
+    boolean credentialsMatchesPassword( String password )
     {
+        return user.credentials().matchesPassword( password );
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>187797</refactoring_id><commit_sha>9b67a72fa3d1c93c6a0cb1e1d463a3d3b149bdef</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/9b67a72fa3d1c93c6a0cb1e1d463a3d3b149bdef</commit_link><file_path>core/src/test/java/org/infinispan/api/WithClassLoaderTest.java</file_path><description>Rename Method public testReadingWithCorrectClassLoader() : void renamed to public testReadingWithCorrectClassLoaderAfterReplication() : void in class org.infinispan.api.WithClassLoaderTest</description><code_before>@@ -46,16 +46,16 @@ protected void createCacheManagers() throws Throwable {
       cacheManagers.add(cm1);
    }
 
-   public void testReadingWithCorrectClassLoader() {
       Cache&lt;Integer, Car&gt; cache0 = cache(0);
       Car value = new Car().plateNumber("1234");
       cache0.put(1, value);
 
-      Cache&lt;Integer, Car&gt; cache1 = cache(1);
-
       try {
          cache1.get(1);
-         fail("Expected a class ClassNotFoundException");
       } catch (CacheException e) {
          if (!(e.getCause() instanceof ClassNotFoundException))
             throw e;
@@ -64,6 +64,9 @@ public void testReadingWithCorrectClassLoader() {
       assertEquals(value, cache1.getAdvancedCache().with(systemCl).get(1));
    }
 
    public static class Car implements Serializable {
       String plateNumber;
       Car plateNumber(String s) { plateNumber = s; return this; }
</code_before><code_after>@@ -46,16 +46,16 @@ protected void createCacheManagers() throws Throwable {
       cacheManagers.add(cm1);
    }
 
+   public void testReadingWithCorrectClassLoaderAfterReplication() {
       Cache&lt;Integer, Car&gt; cache0 = cache(0);
+      Cache&lt;Integer, Car&gt; cache1 = cache(1);
+
       Car value = new Car().plateNumber("1234");
       cache0.put(1, value);
 
       try {
          cache1.get(1);
+         fail("Expected a ClassNotFoundException");
       } catch (CacheException e) {
          if (!(e.getCause() instanceof ClassNotFoundException))
             throw e;
@@ -64,6 +64,9 @@ public void testReadingWithCorrectClassLoader() {
       assertEquals(value, cache1.getAdvancedCache().with(systemCl).get(1));
    }
 
+   // TODO: Add test where contents come from state transfer rather than replication
+   // TODO: For that to work, memory state might need wrapping in a cache rpc command (i.e. state transfer command)
+
    public static class Car implements Serializable {
       String plateNumber;
       Car plateNumber(String s) { plateNumber = s; return this; }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>330339</refactoring_id><commit_sha>5e4dcfd11f9a3494486d4381080c2247db3594a5</commit_sha><commit_link>https://github.com/oracle/graal/commit/5e4dcfd11f9a3494486d4381080c2247db3594a5</commit_link><file_path>graal/org.graalvm.compiler.serviceprovider.processor/src/org/graalvm/compiler/serviceprovider/processor/ServiceProviderProcessor.java</file_path><description>Rename Method private createProviderFile(serviceProvider TypeElement, interfaceName String) : void renamed to private writeProviderFile(serviceProvider TypeElement, interfaceName String) : void in class org.graalvm.compiler.serviceprovider.processor.ServiceProviderProcessor</description><code_before>@@ -25,7 +25,10 @@
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.HashSet;
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
@@ -53,6 +56,7 @@
 public class ServiceProviderProcessor extends AbstractProcessor {
 
     private final Set&lt;TypeElement&gt; processed = new HashSet&lt;&gt;();
 
     @Override
     public SourceVersion getSupportedSourceVersion() {
@@ -82,23 +86,22 @@ private void processElement(TypeElement serviceProvider) {
             } catch (MirroredTypeException ex) {
                 TypeMirror serviceInterface = ex.getTypeMirror();
                 if (verifyAnnotation(serviceInterface, serviceProvider)) {
-                    String interfaceName = ex.getTypeMirror().toString();
-                    createProviderFile(serviceProvider, interfaceName);
                 }
             }
         }
     }
 
-    private void createProviderFile(TypeElement serviceProvider, String interfaceName) {
-        if (serviceProvider.getNestingKind().isNested()) {
-            // This is a simplifying constraint that means we don't have to
-            // processed the qualified name to insert '$' characters at
-            // the relevant positions.
-            String msg = String.format("Service provider class %s must be a top level class", serviceProvider.getSimpleName());
-            processingEnv.getMessager().printMessage(Kind.ERROR, msg, serviceProvider);
-            return;
-        }
-
         String filename = "META-INF/providers/" + serviceProvider.getQualifiedName();
         try {
             FileObject file = processingEnv.getFiler().createResource(StandardLocation.CLASS_OUTPUT, "", filename, serviceProvider);
@@ -114,7 +117,7 @@ private void createProviderFile(TypeElement serviceProvider, String interfaceNam
      * Determines if a given exception is (most likely) caused by
      * &lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=367599"&gt;Bug 367599&lt;/a&gt;.
      */
-    public static boolean isBug367599(Throwable t) {
         if (t instanceof FilerException) {
             for (StackTraceElement ste : t.getStackTrace()) {
                 if (ste.toString().contains("org.eclipse.jdt.internal.apt.pluggable.core.filer.IdeFilerImpl.create")) {
@@ -123,15 +126,16 @@ public static boolean isBug367599(Throwable t) {
                 }
             }
         }
-        if (t.getCause() != null) {
-            return isBug367599(t.getCause());
-        }
-        return false;
     }
 
     @Override
     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
         if (roundEnv.processingOver()) {
             return true;
         }
 
</code_before><code_after>@@ -25,7 +25,10 @@
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
+import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
@@ -53,6 +56,7 @@
 public class ServiceProviderProcessor extends AbstractProcessor {
 
     private final Set&lt;TypeElement&gt; processed = new HashSet&lt;&gt;();
+    private final Map&lt;TypeElement, String&gt; serviceProviders = new HashMap&lt;&gt;();
 
     @Override
     public SourceVersion getSupportedSourceVersion() {
@@ -82,23 +86,22 @@ private void processElement(TypeElement serviceProvider) {
             } catch (MirroredTypeException ex) {
                 TypeMirror serviceInterface = ex.getTypeMirror();
                 if (verifyAnnotation(serviceInterface, serviceProvider)) {
+                    if (serviceProvider.getNestingKind().isNested()) {
+                        /*
+                         * This is a simplifying constraint that means we don't have to process the
+                         * qualified name to insert '$' characters at the relevant positions.
+                         */
+                        String msg = String.format("Service provider class %s must be a top level class", serviceProvider.getSimpleName());
+                        processingEnv.getMessager().printMessage(Kind.ERROR, msg, serviceProvider);
+                    } else {
+                        serviceProviders.put(serviceProvider, ex.getTypeMirror().toString());
+                    }
                 }
             }
         }
     }
 
+    private void writeProviderFile(TypeElement serviceProvider, String interfaceName) {
         String filename = "META-INF/providers/" + serviceProvider.getQualifiedName();
         try {
             FileObject file = processingEnv.getFiler().createResource(StandardLocation.CLASS_OUTPUT, "", filename, serviceProvider);
@@ -114,7 +117,7 @@ private void createProviderFile(TypeElement serviceProvider, String interfaceNam
      * Determines if a given exception is (most likely) caused by
      * &lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=367599"&gt;Bug 367599&lt;/a&gt;.
      */
+    private static boolean isBug367599(Throwable t) {
         if (t instanceof FilerException) {
             for (StackTraceElement ste : t.getStackTrace()) {
                 if (ste.toString().contains("org.eclipse.jdt.internal.apt.pluggable.core.filer.IdeFilerImpl.create")) {
@@ -123,15 +126,16 @@ public static boolean isBug367599(Throwable t) {
                 }
             }
         }
+        return t.getCause() != null &amp;&amp; isBug367599(t.getCause());
     }
 
     @Override
     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
         if (roundEnv.processingOver()) {
+            for (Entry&lt;TypeElement, String&gt; e : serviceProviders.entrySet()) {
+                writeProviderFile(e.getKey(), e.getValue());
+            }
+            serviceProviders.clear();
             return true;
         }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>284830</refactoring_id><commit_sha>d90f826d03d10b6f11d5ef05234dd820fa4cd61f</commit_sha><commit_link>https://github.com/primefaces/primefaces/commit/d90f826d03d10b6f11d5ef05234dd820fa4cd61f</commit_link><file_path>primefaces-integration-tests/src/test/java/org/primefaces/integrationtests/autocomplete/AutoComplete004Test.java</file_path><description>Rename Method public testAjaxClear(page Page) : void renamed to package ajaxClear(page Page) : void in class org.primefaces.integrationtests.autocomplete.AutoComplete004Test</description><code_before>@@ -23,8 +23,10 @@
  */
 package org.primefaces.integrationtests.autocomplete;
 
 import org.json.JSONObject;
-import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.Test;
@@ -34,47 +36,47 @@
 import org.primefaces.selenium.AbstractPrimePageTest;
 import org.primefaces.selenium.component.AutoComplete;
 
-public class AutoComplete004Test extends AbstractPrimePageTest {
 
     @Test
     @Order(1)
     @DisplayName("AutoComplete: GitHub #6711 AJAX change event in CSP and non CSP mode")
-    public void testAjaxChange(Page page) {
         // Arrange
         AutoComplete autoComplete = page.autoComplete;
-        Assertions.assertEquals("", autoComplete.getValue());
         assertNotDisplayed(autoComplete.getPanel());
 
         // Act
         autoComplete.setValue("Nintendo");
 
         // Assert
-        Assertions.assertEquals("Nintendo", page.output.getText());
         assertConfiguration(autoComplete.getWidgetConfiguration());
     }
 
     @Test
     @Order(2)
     @DisplayName("AutoComplete: AJAX clear event when clearing out the input")
-    public void testAjaxClear(Page page) {
         // Arrange
         AutoComplete autoComplete = page.autoComplete;
-        Assertions.assertEquals("", autoComplete.getValue());
         assertNotDisplayed(autoComplete.getPanel());
 
         // Act
         autoComplete.setValue("PlayStation");
         autoComplete.clear();
 
         // Assert
-        Assertions.assertEquals("", page.output.getText());
         assertConfiguration(autoComplete.getWidgetConfiguration());
     }
 
     private void assertConfiguration(JSONObject cfg) {
         assertNoJavascriptErrors();
         System.out.println("AutoComplete Config = " + cfg);
-        Assertions.assertTrue(cfg.has("appendTo"));
     }
 
     public static class Page extends AbstractPrimePage {
</code_before><code_after>@@ -23,8 +23,10 @@
  */
 package org.primefaces.integrationtests.autocomplete;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
 import org.json.JSONObject;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.Test;
@@ -34,47 +36,47 @@
 import org.primefaces.selenium.AbstractPrimePageTest;
 import org.primefaces.selenium.component.AutoComplete;
 
+class AutoComplete004Test extends AbstractPrimePageTest {
 
     @Test
     @Order(1)
     @DisplayName("AutoComplete: GitHub #6711 AJAX change event in CSP and non CSP mode")
+    void ajaxChange(Page page) {
         // Arrange
         AutoComplete autoComplete = page.autoComplete;
+        assertEquals("", autoComplete.getValue());
         assertNotDisplayed(autoComplete.getPanel());
 
         // Act
         autoComplete.setValue("Nintendo");
 
         // Assert
+        assertEquals("Nintendo", page.output.getText());
         assertConfiguration(autoComplete.getWidgetConfiguration());
     }
 
     @Test
     @Order(2)
     @DisplayName("AutoComplete: AJAX clear event when clearing out the input")
+    void ajaxClear(Page page) {
         // Arrange
         AutoComplete autoComplete = page.autoComplete;
+        assertEquals("", autoComplete.getValue());
         assertNotDisplayed(autoComplete.getPanel());
 
         // Act
         autoComplete.setValue("PlayStation");
         autoComplete.clear();
 
         // Assert
+        assertEquals("", page.output.getText());
         assertConfiguration(autoComplete.getWidgetConfiguration());
     }
 
     private void assertConfiguration(JSONObject cfg) {
         assertNoJavascriptErrors();
         System.out.println("AutoComplete Config = " + cfg);
+        assertTrue(cfg.has("appendTo"));
     }
 
     public static class Page extends AbstractPrimePage {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>234531</refactoring_id><commit_sha>c8a53f363d2e5114af8a48a7f1c798528ec5891b</commit_sha><commit_link>https://github.com/apache/tinkerpop/commit/c8a53f363d2e5114af8a48a7f1c798528ec5891b</commit_link><file_path>gremlin-test/src/main/java/com/tinkerpop/gremlin/process/graph/step/map/MinTest.java</file_path><description>Rename Method public g_V_age_max() : void renamed to public g_V_age_min() : void in class com.tinkerpop.gremlin.process.graph.step.map.MinTest</description><code_before>@@ -23,7 +23,7 @@ public abstract class MinTest extends AbstractGremlinProcessTest {
 
     @Test
     @LoadGraphWith(MODERN)
-    public void g_V_age_max() {
         final List&lt;Traversal&lt;Vertex, Integer&gt;&gt; traversals = Arrays.asList(
                 get_g_V_age_min(),
                 get_g_V_repeatXbothX_timesX5X_age_min());
</code_before><code_after>@@ -23,7 +23,7 @@ public abstract class MinTest extends AbstractGremlinProcessTest {
 
     @Test
     @LoadGraphWith(MODERN)
+    public void g_V_age_min() {
         final List&lt;Traversal&lt;Vertex, Integer&gt;&gt; traversals = Arrays.asList(
                 get_g_V_age_min(),
                 get_g_V_repeatXbothX_timesX5X_age_min());
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>133175</refactoring_id><commit_sha>24e60747b694ab4d03e8e1cbf8e4da764337ff48</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/24e60747b694ab4d03e8e1cbf8e4da764337ff48</commit_link><file_path>core/src/main/java/org/keycloak/representations/idm/KeysMetadataRepresentation.java</file_path><description>Rename Method public setAlgorithms(algorithms Set&lt;String&gt;) : void renamed to public setAlgorithm(algorithm String) : void in class org.keycloak.representations.idm.KeysMetadataRepresentation.KeyMetadataRepresentation</description><code_before>@@ -55,7 +55,7 @@ public static class KeyMetadataRepresentation {
         private String status;
 
         private String type;
-        private Set&lt;String&gt; algorithms;
 
         private String publicKey;
         private String certificate;
@@ -100,12 +100,12 @@ public void setType(String type) {
             this.type = type;
         }
 
-        public Set&lt;String&gt; getAlgorithms() {
-            return algorithms;
         }
 
-        public void setAlgorithms(Set&lt;String&gt; algorithms) {
-            this.algorithms = algorithms;
         }
 
         public String getPublicKey() {
</code_before><code_after>@@ -55,7 +55,7 @@ public static class KeyMetadataRepresentation {
         private String status;
 
         private String type;
+        private String algorithm;
 
         private String publicKey;
         private String certificate;
@@ -100,12 +100,12 @@ public void setType(String type) {
             this.type = type;
         }
 
+        public String getAlgorithm() {
+            return algorithm;
         }
 
+        public void setAlgorithm(String algorithm) {
+            this.algorithm = algorithm;
         }
 
         public String getPublicKey() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>149084</refactoring_id><commit_sha>e62290c30518de92cc25a7357d6576e5ba5d8f14</commit_sha><commit_link>https://github.com/pentaho/pentaho-kettle/commit/e62290c30518de92cc25a7357d6576e5ba5d8f14</commit_link><file_path>engine/src/main/java/org/pentaho/di/core/compress/CompressionPluginType.java</file_path><description>Rename Method protected extractSuggestedStep(annotation Annotation) : String renamed to protected extractSuggestion(annotation Annotation) : String in class org.pentaho.di.core.compress.CompressionPluginType</description><code_before>@@ -136,7 +136,7 @@ protected String extractImageFile( Annotation annotation ) {
   }
 
   @Override
-  protected String extractSuggestedStep( Annotation annotation ) {
     return null;
   }
 
</code_before><code_after>@@ -136,7 +136,7 @@ protected String extractImageFile( Annotation annotation ) {
   }
 
   @Override
+  protected String extractSuggestion( Annotation annotation ) {
     return null;
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>229170</refactoring_id><commit_sha>854ca84dc7ce0b2788380141298a71ec4b6b6d57</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/854ca84dc7ce0b2788380141298a71ec4b6b6d57</commit_link><file_path>Dart/src/com/jetbrains/lang/dart/ide/runner/util/TestUtil.java</file_path><description>Rename Method public findTestName(expression DartCallExpression) : String renamed to public findGroupOrTestName(expression DartCallExpression) : String in class com.jetbrains.lang.dart.ide.runner.util.TestUtil</description><code_before>@@ -3,8 +3,6 @@
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.util.PsiTreeUtil;
-import com.intellij.util.PathUtil;
-import com.jetbrains.lang.dart.DartBundle;
 import com.jetbrains.lang.dart.psi.DartArgumentList;
 import com.jetbrains.lang.dart.psi.DartArguments;
 import com.jetbrains.lang.dart.psi.DartCallExpression;
@@ -15,7 +13,7 @@
 public class TestUtil {
 
   @Nullable
-  public static String findTestName(@Nullable DartCallExpression expression) {
     String testName;
     final DartArguments arguments = expression == null ? null : expression.getArguments();
     final DartArgumentList dartArgumentList = arguments == null ? null : arguments.getArgumentList();
@@ -50,36 +48,4 @@ public static boolean isGroup(@NotNull final DartCallExpression expression) {
   private static boolean checkCalledFunctionName(@NotNull final DartCallExpression callExpression, @NotNull final String expectedName) {
     return expectedName.equals(callExpression.getExpression().getText());
   }
-
-  public static String suggestedName(@Nullable final String path, @NotNull final Scope scope, @Nullable final String testName) {
-    if (path != null) {
-      final String fileOrDirName = PathUtil.getFileName(path);
-      switch (scope) {
-        case METHOD:
-          if (testName != null) {
-            return DartBundle.message("test.0.in.1", testName, fileOrDirName);
-          }
-          // fall through
-        case GROUP:
-          if (testName != null) {
-            return DartBundle.message("test.group.0.in.1", testName, fileOrDirName);
-          }
-          // fall through
-        case FILE:
-          return DartBundle.message("all.tests.in.0", fileOrDirName);
-        case FOLDER:
-          final String dirName;
-          if ("test".equals(fileOrDirName)) {
-            final String parentPath = PathUtil.getParentPath(path);
-            final String parentDirName = PathUtil.getFileName(parentPath);
-            dirName = parentDirName.isEmpty() ? fileOrDirName : parentDirName + "/" + fileOrDirName;
-          }
-          else {
-            dirName = fileOrDirName;
-          }
-          return DartBundle.message("all.tests.in.0", dirName);
-      }
-    }
-    return null;
-  }
 }
</code_before><code_after>@@ -3,8 +3,6 @@
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.util.PsiTreeUtil;
 import com.jetbrains.lang.dart.psi.DartArgumentList;
 import com.jetbrains.lang.dart.psi.DartArguments;
 import com.jetbrains.lang.dart.psi.DartCallExpression;
@@ -15,7 +13,7 @@
 public class TestUtil {
 
   @Nullable
+  public static String findGroupOrTestName(@Nullable final DartCallExpression expression) {
     String testName;
     final DartArguments arguments = expression == null ? null : expression.getArguments();
     final DartArgumentList dartArgumentList = arguments == null ? null : arguments.getArgumentList();
@@ -50,36 +48,4 @@ public static boolean isGroup(@NotNull final DartCallExpression expression) {
   private static boolean checkCalledFunctionName(@NotNull final DartCallExpression callExpression, @NotNull final String expectedName) {
     return expectedName.equals(callExpression.getExpression().getText());
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>268902</refactoring_id><commit_sha>1ca80741e5504670cdf3e42de54ae2f5cdfa2bef</commit_sha><commit_link>https://github.com/androidx/media/commit/1ca80741e5504670cdf3e42de54ae2f5cdfa2bef</commit_link><file_path>libraries/transformer/src/androidTest/java/androidx/media3/transformer/mh/TranscodeQualityTest.java</file_path><description>Rename Method public singleTranscode_ssimIsGreaterThan90Percent() : void renamed to public transformWithDecodeEncode_ssimIsGreaterThan90Percent() : void in class androidx.media3.transformer.mh.TranscodeQualityTest</description><code_before>@@ -33,13 +33,15 @@
 /** Checks transcoding quality. */
 @RunWith(AndroidJUnit4.class)
 public final class TranscodeQualityTest {
   @Test
-  public void singleTranscode_ssimIsGreaterThan90Percent() throws Exception {
     Context context = ApplicationProvider.getApplicationContext();
     Transformer transformer =
         new Transformer.Builder(context)
             .setTransformationRequest(
-                new TransformationRequest.Builder().setVideoMimeType(MimeTypes.VIDEO_H265).build())
             .setRemoveAudio(true)
             .build();
 
</code_before><code_after>@@ -33,13 +33,15 @@
 /** Checks transcoding quality. */
 @RunWith(AndroidJUnit4.class)
 public final class TranscodeQualityTest {
+  // TODO(b/228455984) Add test that calculates SSIM for transcoding to H265.
   @Test
+  public void transformWithDecodeEncode_ssimIsGreaterThan90Percent() throws Exception {
     Context context = ApplicationProvider.getApplicationContext();
     Transformer transformer =
         new Transformer.Builder(context)
             .setTransformationRequest(
+                new TransformationRequest.Builder().setVideoMimeType(MimeTypes.VIDEO_H264).build())
+            .setEncoderFactory(AndroidTestUtil.FORCE_ENCODE_ENCODER_FACTORY)
             .setRemoveAudio(true)
             .build();
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>217478</refactoring_id><commit_sha>d45681120f58f7dbaf13d41b9515aa8b680b4ba4</commit_sha><commit_link>https://github.com/opensolon/solon/commit/d45681120f58f7dbaf13d41b9515aa8b680b4ba4</commit_link><file_path>solon-projects-cloud/solon-cloud-event/rocketmq5-solon-cloud-plugin/src/main/java/org/noear/solon/cloud/extend/rocketmq/impl/RocketmqProducer.java</file_path><description>Rename Method private init(cloudProps CloudProps) : void renamed to private lazyInit(cloudProps CloudProps) : void in class org.noear.solon.cloud.extend.rocketmq.impl.RocketmqProducer</description><code_before>@@ -25,7 +25,7 @@ public RocketmqProducer(RocketmqConfig config) {
         this.config = config;
     }
 
-    private void init(CloudProps cloudProps) throws ClientException {
         if (producer != null) {
             return;
         }
@@ -75,18 +75,18 @@ public Transaction beginTransaction() throws ClientException {
     }
 
     public boolean publish(CloudProps cloudProps, Event event, String topic) throws ClientException {
-        init(cloudProps);
 
         //&#x666E;&#x901A;&#x6D88;&#x606F;&#x53D1;&#x9001;&#x3002;
         Message message = MessageUtil.buildNewMeaage(serviceProvider, event, topic);
 
         //&#x53D1;&#x9001;&#x6D88;&#x606F;&#xFF0C;&#x9700;&#x8981;&#x5173;&#x6CE8;&#x53D1;&#x9001;&#x7ED3;&#x679C;&#xFF0C;&#x5E76;&#x6355;&#x83B7;&#x5931;&#x8D25;&#x7B49;&#x5F02;&#x5E38;&#x3002;
         SendReceipt sendReceipt = null;
 
-        if (event.transaction() == null) {
             sendReceipt = producer.send(message);
         } else {
-            Transaction transaction = event.transaction().getListener(RocketmqTransactionListener.class).getTransaction();
             sendReceipt = producer.send(message, transaction);
         }
 
</code_before><code_after>@@ -25,7 +25,7 @@ public RocketmqProducer(RocketmqConfig config) {
         this.config = config;
     }
 
+    private void lazyInit(CloudProps cloudProps) throws ClientException {
         if (producer != null) {
             return;
         }
@@ -75,18 +75,18 @@ public Transaction beginTransaction() throws ClientException {
     }
 
     public boolean publish(CloudProps cloudProps, Event event, String topic) throws ClientException {
+        lazyInit(cloudProps);
 
         //&#x666E;&#x901A;&#x6D88;&#x606F;&#x53D1;&#x9001;&#x3002;
         Message message = MessageUtil.buildNewMeaage(serviceProvider, event, topic);
 
         //&#x53D1;&#x9001;&#x6D88;&#x606F;&#xFF0C;&#x9700;&#x8981;&#x5173;&#x6CE8;&#x53D1;&#x9001;&#x7ED3;&#x679C;&#xFF0C;&#x5E76;&#x6355;&#x83B7;&#x5931;&#x8D25;&#x7B49;&#x5F02;&#x5E38;&#x3002;
         SendReceipt sendReceipt = null;
 
+        if (event.tran() == null) {
             sendReceipt = producer.send(message);
         } else {
+            Transaction transaction = event.tran().getListener(RocketmqTransactionListener.class).getTransaction();
             sendReceipt = producer.send(message, transaction);
         }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>329871</refactoring_id><commit_sha>3a7239761a5aea3ab94c41e9019547ded34a35da</commit_sha><commit_link>https://github.com/oracle/graal/commit/3a7239761a5aea3ab94c41e9019547ded34a35da</commit_link><file_path>wasm/src/org.graalvm.wasm/src/org/graalvm/wasm/predefined/testutil/CompareContextsNode.java</file_path><description>Rename Method public execute(frame VirtualFrame) : Object renamed to public executeWithContext(frame VirtualFrame, context WasmContext) : Object in class org.graalvm.wasm.predefined.testutil.CompareContextsNode</description><code_before>@@ -43,6 +43,7 @@
 import com.oracle.truffle.api.CompilerDirectives;
 import com.oracle.truffle.api.frame.VirtualFrame;
 import org.graalvm.wasm.Globals;
 import org.graalvm.wasm.WasmLanguage;
 import org.graalvm.wasm.WasmModule;
 import org.graalvm.wasm.WasmVoidResult;
@@ -60,7 +61,7 @@ public CompareContextsNode(WasmLanguage language, WasmModule module) {
     }
 
     @Override
-    public Object execute(VirtualFrame frame) {
         final ContextState firstState = (ContextState) frame.getArguments()[0];
         final ContextState lastState = (ContextState) frame.getArguments()[0];
         compareContexts(firstState, lastState);
</code_before><code_after>@@ -43,6 +43,7 @@
 import com.oracle.truffle.api.CompilerDirectives;
 import com.oracle.truffle.api.frame.VirtualFrame;
 import org.graalvm.wasm.Globals;
+import org.graalvm.wasm.WasmContext;
 import org.graalvm.wasm.WasmLanguage;
 import org.graalvm.wasm.WasmModule;
 import org.graalvm.wasm.WasmVoidResult;
@@ -60,7 +61,7 @@ public CompareContextsNode(WasmLanguage language, WasmModule module) {
     }
 
     @Override
+    public Object executeWithContext(VirtualFrame frame, WasmContext context) {
         final ContextState firstState = (ContextState) frame.getArguments()[0];
         final ContextState lastState = (ContextState) frame.getArguments()[0];
         compareContexts(firstState, lastState);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>269378</refactoring_id><commit_sha>a6d0caaa3c95746beb4e82c1005c06cbb14b6f6c</commit_sha><commit_link>https://github.com/androidx/media/commit/a6d0caaa3c95746beb4e82c1005c06cbb14b6f6c</commit_link><file_path>library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java</file_path><description>Rename Method public testDownloadMultipleRepresentations() : void renamed to public downloadMultipleRepresentations() : void in class com.google.android.exoplayer2.source.hls.offline.HlsDownloaderTest</description><code_before>@@ -96,7 +96,7 @@ public void tearDown() {
   }
 
   @Test
-  public void testCreateWithDefaultDownloaderFactory() {
     DownloaderConstructorHelper constructorHelper =
         new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
     DownloaderFactory factory = new DefaultDownloaderFactory(constructorHelper);
@@ -114,7 +114,7 @@ public void testCreateWithDefaultDownloaderFactory() {
   }
 
   @Test
-  public void testCounterMethods() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(MASTER_PLAYLIST_URI, getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX));
     downloader.download(progressListener);
@@ -123,7 +123,7 @@ public void testCounterMethods() throws Exception {
   }
 
   @Test
-  public void testDownloadRepresentation() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(MASTER_PLAYLIST_URI, getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX));
     downloader.download(progressListener);
@@ -140,7 +140,7 @@ public void testDownloadRepresentation() throws Exception {
   }
 
   @Test
-  public void testDownloadMultipleRepresentations() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(
             MASTER_PLAYLIST_URI,
@@ -151,7 +151,7 @@ public void testDownloadMultipleRepresentations() throws Exception {
   }
 
   @Test
-  public void testDownloadAllRepresentations() throws Exception {
     // Add data for the rest of the playlists
     fakeDataSet
         .setData(MEDIA_PLAYLIST_0_URI, MEDIA_PLAYLIST_DATA)
@@ -170,7 +170,7 @@ public void testDownloadAllRepresentations() throws Exception {
   }
 
   @Test
-  public void testRemove() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(
             MASTER_PLAYLIST_URI,
@@ -182,7 +182,7 @@ public void testRemove() throws Exception {
   }
 
   @Test
-  public void testDownloadMediaPlaylist() throws Exception {
     HlsDownloader downloader = getHlsDownloader(MEDIA_PLAYLIST_1_URI, getKeys());
     downloader.download(progressListener);
 
@@ -197,7 +197,7 @@ public void testDownloadMediaPlaylist() throws Exception {
   }
 
   @Test
-  public void testDownloadEncMediaPlaylist() throws Exception {
     fakeDataSet =
         new FakeDataSet()
             .setData(ENC_MEDIA_PLAYLIST_URI, ENC_MEDIA_PLAYLIST_DATA)
</code_before><code_after>@@ -96,7 +96,7 @@ public void tearDown() {
   }
 
   @Test
+  public void createWithDefaultDownloaderFactory() {
     DownloaderConstructorHelper constructorHelper =
         new DownloaderConstructorHelper(Mockito.mock(Cache.class), DummyDataSource.FACTORY);
     DownloaderFactory factory = new DefaultDownloaderFactory(constructorHelper);
@@ -114,7 +114,7 @@ public void testCreateWithDefaultDownloaderFactory() {
   }
 
   @Test
+  public void counterMethods() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(MASTER_PLAYLIST_URI, getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX));
     downloader.download(progressListener);
@@ -123,7 +123,7 @@ public void testCounterMethods() throws Exception {
   }
 
   @Test
+  public void downloadRepresentation() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(MASTER_PLAYLIST_URI, getKeys(MASTER_MEDIA_PLAYLIST_1_INDEX));
     downloader.download(progressListener);
@@ -140,7 +140,7 @@ public void testDownloadRepresentation() throws Exception {
   }
 
   @Test
+  public void downloadMultipleRepresentations() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(
             MASTER_PLAYLIST_URI,
@@ -151,7 +151,7 @@ public void testDownloadMultipleRepresentations() throws Exception {
   }
 
   @Test
+  public void downloadAllRepresentations() throws Exception {
     // Add data for the rest of the playlists
     fakeDataSet
         .setData(MEDIA_PLAYLIST_0_URI, MEDIA_PLAYLIST_DATA)
@@ -170,7 +170,7 @@ public void testDownloadAllRepresentations() throws Exception {
   }
 
   @Test
+  public void remove() throws Exception {
     HlsDownloader downloader =
         getHlsDownloader(
             MASTER_PLAYLIST_URI,
@@ -182,7 +182,7 @@ public void testRemove() throws Exception {
   }
 
   @Test
+  public void downloadMediaPlaylist() throws Exception {
     HlsDownloader downloader = getHlsDownloader(MEDIA_PLAYLIST_1_URI, getKeys());
     downloader.download(progressListener);
 
@@ -197,7 +197,7 @@ public void testDownloadMediaPlaylist() throws Exception {
   }
 
   @Test
+  public void downloadEncMediaPlaylist() throws Exception {
     fakeDataSet =
         new FakeDataSet()
             .setData(ENC_MEDIA_PLAYLIST_URI, ENC_MEDIA_PLAYLIST_DATA)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>208510</refactoring_id><commit_sha>98b6fabf43ed2bd205ab51bf56ae7b16ca1aa414</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/98b6fabf43ed2bd205ab51bf56ae7b16ca1aa414</commit_link><file_path>core/common/src/test/java/alluxio/util/HFSUtilsTest.java</file_path><description>Rename Method public getSectorTest5() : void renamed to public getSectorTestGB() : void in class alluxio.util.HFSUtilsTest</description><code_before>@@ -24,55 +24,55 @@ public class HFSUtilsTest {
    * Tests the {@link HFSUtils#getNumSector(String, String)} method.
    */
   @Test
-  public void getSectorTest1() {
     String testRequestSize = "0";
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("1"), result);
   }
 
   @Test
-  public void getSectorTest2() {
     String testRequestSize = "20";
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("1"), result);
   }
 
   @Test
-  public void getSectorTest3() {
     String testRequestSize = "512";
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("2"), result);
   }
 
   @Test
-  public void getSectorTest4() {
     String testRequestSize = "1048576"; // 1MB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("2080"), result); // 1MB/512B = 2048
   }
 
   @Test
-  public void getSectorTest5() {
     String testRequestSize = "1073741824"; // 1GB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("2128667"), result); // 1GB/512B = 2097152
   }
 
   @Test
-  public void getSectorTest6() {
     String testRequestSize = "107374182400"; // 100GB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("212866577"), result); // 100GB/512B = 209715200
   }
 
   @Test
-  public void getSectorTest7() {
     String testRequestSize = "1099511627776"; // 1TB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
</code_before><code_after>@@ -24,55 +24,55 @@ public class HFSUtilsTest {
    * Tests the {@link HFSUtils#getNumSector(String, String)} method.
    */
   @Test
+  public void getSectorTest0() {
     String testRequestSize = "0";
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("1"), result);
   }
 
   @Test
+  public void getSectorTest20() {
     String testRequestSize = "20";
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("1"), result);
   }
 
   @Test
+  public void getSectorTest512() {
     String testRequestSize = "512";
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("2"), result);
   }
 
   @Test
+  public void getSectorTestMB() {
     String testRequestSize = "1048576"; // 1MB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("2080"), result); // 1MB/512B = 2048
   }
 
   @Test
+  public void getSectorTestGB() {
     String testRequestSize = "1073741824"; // 1GB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("2128667"), result); // 1GB/512B = 2097152
   }
 
   @Test
+  public void getSectorTest100GB() {
     String testRequestSize = "107374182400"; // 100GB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
     Assert.assertEquals(new BigDecimal("212866577"), result); // 100GB/512B = 209715200
   }
 
   @Test
+  public void getSectorTestTB() {
     String testRequestSize = "1099511627776"; // 1TB
     String testSectorSize = "512";
     BigDecimal result = HFSUtils.getNumSector(testRequestSize, testSectorSize);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>191721</refactoring_id><commit_sha>f7c10f53345c9fb7eb7d6814a4cd3767c164f7de</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/f7c10f53345c9fb7eb7d6814a4cd3767c164f7de</commit_link><file_path>OsmAnd/src/net/osmand/plus/settings/backend/backup/exporttype/GlobalExportType.java</file_path><description>Rename Method public getId() : String renamed to public relatedPluginClass() : Class&lt;? extends OsmandPlugin&gt; in class net.osmand.plus.settings.backend.backup.exporttype.GlobalExportType</description><code_before>@@ -1,19 +1,62 @@
 package net.osmand.plus.settings.backend.backup.exporttype;
 
 import androidx.annotation.NonNull;
 
 import net.osmand.plus.R;
 import net.osmand.plus.settings.backend.backup.SettingsItemType;
 
-class GlobalExportType extends ExportType {
 
-	public GlobalExportType() {
-		super(R.string.osmand_settings, R.drawable.ic_action_settings, SettingsItemType.GLOBAL);
 	}
 
 	@NonNull
 	@Override
-	public String getId() {
-		return "GLOBAL";
 	}
 }
</code_before><code_after>@@ -1,19 +1,62 @@
 package net.osmand.plus.settings.backend.backup.exporttype;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import net.osmand.plus.R;
+import net.osmand.plus.download.local.LocalItemType;
+import net.osmand.plus.plugins.OsmandPlugin;
+import net.osmand.plus.settings.backend.ExportSettingsCategory;
 import net.osmand.plus.settings.backend.backup.SettingsItemType;
+import net.osmand.plus.settings.backend.backup.items.FileSettingsItem.FileSubtype;
 
+import java.util.Collections;
+import java.util.List;
 
+class GlobalExportType extends AbstractExportType {
+
+	@Override
+	public int getTitleId() {
+		return R.string.osmand_settings;
+	}
+
+	@Override
+	public int getIconId() {
+		return R.drawable.ic_action_settings;
+	}
+
+	@NonNull
+	@Override
+	public ExportSettingsCategory relatedExportCategory() {
+		return ExportSettingsCategory.SETTINGS;
+	}
+
+	@NonNull
+	@Override
+	public SettingsItemType relatedSettingsItemType() {
+		return SettingsItemType.GLOBAL;
 	}
 
 	@NonNull
 	@Override
+	public List&lt;FileSubtype&gt; relatedFileSubtypes() {
+		return Collections.emptyList();
+	}
+
+	@Nullable
+	@Override
+	public LocalItemType relatedLocalItemType() {
+		return null;
+	}
+
+	@Nullable
+	@Override
+	public Class&lt;? extends OsmandPlugin&gt; relatedPluginClass() {
+		return null;
+	}
+
+	@Override
+	public boolean isAllowedInFreeVersion() {
+		return true;
 	}
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>145094</refactoring_id><commit_sha>dbe670bf85edd9c38608ade2817cac0ac4143d10</commit_sha><commit_link>https://github.com/nationalsecurityagency/ghidra/commit/dbe670bf85edd9c38608ade2817cac0ac4143d10</commit_link><file_path>Ghidra/Debug/Framework-TraceModeling/src/main/java/ghidra/trace/model/time/schedule/PatchStep.java</file_path><description>Rename Method public generateSleigh(language Language, address Address, data byte[], length int) : String renamed to public generateSleighLine(language Language, address Address, data byte[], length int) : String in class ghidra.trace.model.time.schedule.PatchStep</description><code_before>@@ -44,7 +44,21 @@ public class PatchStep implements Step {
 	protected String sleigh;
 	protected int hashCode;
 
-	public static String generateSleigh(Language language, Address address, byte[] data,
 			int length) {
 		BigInteger value = Utils.bytesToBigInteger(data, length, language.isBigEndian(), false);
 		if (address.isMemoryAddress()) {
@@ -67,8 +81,34 @@ public static String generateSleigh(Language language, Address address, byte[] d
 		return String.format("%s=0x%s", register, value.toString(16));
 	}
 
-	public static String generateSleigh(Language language, Address address, byte[] data) {
-		return generateSleigh(language, address, data, data.length);
 	}
 
 	protected static List&lt;String&gt; generateSleigh(Language language,
@@ -102,7 +142,7 @@ protected static void generateMemorySleigh(List&lt;String&gt; result, Language languag
 				Address min = chunk.getMinAddress();
 				int length = (int) chunk.getLength();
 				array.getData(min.getOffset(), data, 0, length);
-				result.add(generateSleigh(language, min, data, length));
 			}
 		}
 	}
</code_before><code_after>@@ -44,7 +44,21 @@ public class PatchStep implements Step {
 	protected String sleigh;
 	protected int hashCode;
 
+	/**
+	 * Generate a single line of Sleigh
+	 * 
+	 * &lt;p&gt;
+	 * Note that when length is greater than 8, this will generate constants which are too large for
+	 * the Java implementation of Sleigh. Use {@link #generateSleigh(Language, Address, byte[])}
+	 * instead to write the variable in chunks.
+	 * 
+	 * @param language the target language
+	 * @param address the (start) address of the variable
+	 * @param data the bytes to write to the variable
+	 * @param length the length of the variable
+	 * @return the Sleigh code
+	 */
+	public static String generateSleighLine(Language language, Address address, byte[] data,
 			int length) {
 		BigInteger value = Utils.bytesToBigInteger(data, length, language.isBigEndian(), false);
 		if (address.isMemoryAddress()) {
@@ -67,8 +81,34 @@ public static String generateSleigh(Language language, Address address, byte[] d
 		return String.format("%s=0x%s", register, value.toString(16));
 	}
 
+	/**
+	 * Generate a single line of Sleigh
+	 * 
+	 * @see #generateSleighLine(Language, Address, byte[], int)
+	 */
+	public static String generateSleighLine(Language language, Address address, byte[] data) {
+		return generateSleighLine(language, address, data, data.length);
+	}
+
+	/**
+	 * Generate multiple lines of Sleigh, all to set a single variable
+	 * 
+	 * @param language the target language
+	 * @param address the (start) address of the variable
+	 * @param data the bytes to write to the variable
+	 * @return the lines of Sleigh code
+	 */
+	public static List&lt;String&gt; generateSleigh(Language language, Address address, byte[] data) {
+		List&lt;String&gt; result = new ArrayList&lt;&gt;();
+		generateSleigh(result, language, address, data);
+		return result;
+	}
+
+	protected static void generateSleigh(List&lt;String&gt; result, Language language, Address address,
+			byte[] data) {
+		SemisparseByteArray array = new SemisparseByteArray(); // TODO: Seems heavy-handed
+		array.putData(address.getOffset(), data);
+		generateSleigh(result, language, address.getAddressSpace(), array);
 	}
 
 	protected static List&lt;String&gt; generateSleigh(Language language,
@@ -102,7 +142,7 @@ protected static void generateMemorySleigh(List&lt;String&gt; result, Language languag
 				Address min = chunk.getMinAddress();
 				int length = (int) chunk.getLength();
 				array.getData(min.getOffset(), data, 0, length);
+				result.add(generateSleighLine(language, min, data, length));
 			}
 		}
 	}
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>300070</refactoring_id><commit_sha>35862c21a13a958af2a59628dc5db5ef7ff8f237</commit_sha><commit_link>https://github.com/cuba-platform/cuba/commit/35862c21a13a958af2a59628dc5db5ef7ff8f237</commit_link><file_path>modules/web/src/com/haulmont/cuba/web/gui/components/WebPickerField.java</file_path><description>Rename Method public checkPropertyDatasource(datasource Datasource, property String) : void renamed to public checkDatasourceProperty(datasource Datasource, property String) : void in class com.haulmont.cuba.web.gui.components.WebPickerField</description><code_before>@@ -149,7 +149,7 @@ public PickerField.OpenAction addOpenAction() {
         return action;
     }
 
-    public void checkPropertyDatasource(Datasource datasource, String property){
         Preconditions.checkNotNullArgument(datasource);
         Preconditions.checkNotNullArgument(property);
 
@@ -161,7 +161,7 @@ public void checkPropertyDatasource(Datasource datasource, String property){
 
     @Override
     public void setDatasource(Datasource datasource, String property) {
-        this.checkPropertyDatasource(datasource, property);
 
         this.datasource = datasource;
         metaPropertyPath = getResolvedMetaPropertyPath(datasource.getMetaClass(), property);
</code_before><code_after>@@ -149,7 +149,7 @@ public PickerField.OpenAction addOpenAction() {
         return action;
     }
 
+    public void checkDatasourceProperty(Datasource datasource, String property){
         Preconditions.checkNotNullArgument(datasource);
         Preconditions.checkNotNullArgument(property);
 
@@ -161,7 +161,7 @@ public void checkPropertyDatasource(Datasource datasource, String property){
 
     @Override
     public void setDatasource(Datasource datasource, String property) {
+        checkDatasourceProperty(datasource, property);
 
         this.datasource = datasource;
         metaPropertyPath = getResolvedMetaPropertyPath(datasource.getMetaClass(), property);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>237304</refactoring_id><commit_sha>ab638b796e7080ee2b8db4cf94ef22f4126e566b</commit_sha><commit_link>https://github.com/apache/accumulo/commit/ab638b796e7080ee2b8db4cf94ef22f4126e566b</commit_link><file_path>server/base/src/main/java/org/apache/accumulo/server/util/ChangeSecret.java</file_path><description>Rename Method public changeSecret(context ServerContext, conf AccumuloConfiguration) : void renamed to public execute(context ServerContext, conf AccumuloConfiguration) : void in class org.apache.accumulo.server.util.ChangeSecret</description><code_before>@@ -27,7 +27,6 @@
 import java.util.UUID;
 
 import org.apache.accumulo.core.conf.AccumuloConfiguration;
-import org.apache.accumulo.core.conf.SiteConfiguration;
 import org.apache.accumulo.core.data.InstanceId;
 import org.apache.accumulo.core.trace.TraceUtil;
 import org.apache.accumulo.core.volume.Volume;
@@ -37,7 +36,6 @@
 import org.apache.accumulo.fate.zookeeper.ZooUtil.NodeMissingPolicy;
 import org.apache.accumulo.server.ServerContext;
 import org.apache.accumulo.server.ServerDirs;
-import org.apache.accumulo.server.cli.ServerUtilOpts;
 import org.apache.accumulo.server.fs.VolumeManager;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.hadoop.conf.Configuration;
@@ -55,16 +53,7 @@
 
 public class ChangeSecret {
 
-  public static void main(String[] args) throws Exception {
-    var siteConfig = SiteConfiguration.auto();
-    ServerUtilOpts opts = new ServerUtilOpts();
-    opts.parseArgs(ChangeSecret.class.getName(), args);
-
-    ServerContext context = opts.getServerContext();
-    changeSecret(context, siteConfig);
-  }
-
-  public static void changeSecret(final ServerContext context, final AccumuloConfiguration conf)
       throws Exception {
 
     try (var fs = context.getVolumeManager()) {
</code_before><code_after>@@ -27,7 +27,6 @@
 import java.util.UUID;
 
 import org.apache.accumulo.core.conf.AccumuloConfiguration;
 import org.apache.accumulo.core.data.InstanceId;
 import org.apache.accumulo.core.trace.TraceUtil;
 import org.apache.accumulo.core.volume.Volume;
@@ -37,7 +36,6 @@
 import org.apache.accumulo.fate.zookeeper.ZooUtil.NodeMissingPolicy;
 import org.apache.accumulo.server.ServerContext;
 import org.apache.accumulo.server.ServerDirs;
 import org.apache.accumulo.server.fs.VolumeManager;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.hadoop.conf.Configuration;
@@ -55,16 +53,7 @@
 
 public class ChangeSecret {
 
+  public static void execute(final ServerContext context, final AccumuloConfiguration conf)
       throws Exception {
 
     try (var fs = context.getVolumeManager()) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>274581</refactoring_id><commit_sha>bac8dfea12d307c45cb59dcca55f725f043b258e</commit_sha><commit_link>https://github.com/google/exoplayer/commit/bac8dfea12d307c45cb59dcca55f725f043b258e</commit_link><file_path>library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java</file_path><description>Rename Method private notifyListenersRequirementsStateChange(notMetRequirements int) : void renamed to private onRequirementsStateChanged(notMetRequirements int) : void in class com.google.android.exoplayer2.offline.DownloadManager</description><code_before>@@ -26,6 +26,7 @@
 import static com.google.android.exoplayer2.offline.DownloadState.STATE_RESTARTING;
 import static com.google.android.exoplayer2.offline.DownloadState.STATE_STOPPED;
 import static com.google.android.exoplayer2.offline.DownloadState.STOP_FLAG_DOWNLOAD_MANAGER_NOT_READY;
 import static com.google.android.exoplayer2.offline.DownloadState.STOP_FLAG_STOPPED;
 
 import android.content.Context;
@@ -119,6 +120,7 @@ void onRequirementsStateChanged(
   private boolean initialized;
   private boolean released;
   @DownloadState.StopFlags private int stickyStopFlags;
   private RequirementsWatcher requirementsWatcher;
 
   /**
@@ -194,7 +196,7 @@ public void setRequirements(Requirements requirements) {
       return;
     }
     requirementsWatcher.stop();
-    notifyListenersRequirementsStateChange(watchRequirements(requirements));
   }
 
   /** Returns the requirements needed to be met to start downloads. */
@@ -349,7 +351,8 @@ private void addDownloadForAction(DownloadAction action) {
       }
     }
     Download download =
-        new Download(this, downloaderFactory, action, minRetryCount, stickyStopFlags);
     downloads.add(download);
     logd("Download is added", download);
   }
@@ -401,13 +404,16 @@ private void notifyListenersDownloadStateChange(Download download) {
     }
   }
 
-  private void notifyListenersRequirementsStateChange(
-      @Requirements.RequirementFlags int notMetRequirements) {
     logdFlags("Not met requirements are changed", notMetRequirements);
     for (Listener listener : listeners) {
       listener.onRequirementsStateChanged(
           DownloadManager.this, requirementsWatcher.getRequirements(), notMetRequirements);
     }
   }
 
   private void loadActions() {
@@ -486,7 +492,9 @@ private static void logdFlags(String message, int flags) {
 
   @Requirements.RequirementFlags
   private int watchRequirements(Requirements requirements) {
-    requirementsWatcher = new RequirementsWatcher(context, new RequirementListener(), requirements);
     @Requirements.RequirementFlags int notMetRequirements = requirementsWatcher.start();
     if (notMetRequirements == 0) {
       startDownloads();
@@ -511,17 +519,23 @@ private static final class Download {
     @MonotonicNonNull private DownloadThread downloadThread;
     @MonotonicNonNull @DownloadState.FailureReason private int failureReason;
     @DownloadState.StopFlags private int stopFlags;
 
     private Download(
         DownloadManager downloadManager,
         DownloaderFactory downloaderFactory,
         DownloadAction action,
         int minRetryCount,
-        int stopFlags) {
       this.id = action.id;
       this.downloadManager = downloadManager;
       this.downloaderFactory = downloaderFactory;
       this.minRetryCount = minRetryCount;
       this.stopFlags = stopFlags;
       this.startTimeMs = System.currentTimeMillis();
       actionQueue = new ArrayDeque&lt;&gt;();
@@ -579,6 +593,7 @@ public DownloadState getDownloadState() {
           totalBytes,
           failureReason,
           stopFlags,
           startTimeMs,
           /* updateTimeMs= */ System.currentTimeMillis(),
           action.keys.toArray(new StreamKey[0]),
@@ -628,6 +643,13 @@ public void updateStopFlags(int flags, int values) {
       }
     }
 
     private void initialize(boolean restart) {
       DownloadAction action = actionQueue.peek();
       if (action.isRemoveAction) {
@@ -770,19 +792,4 @@ private int getRetryDelayMillis(int errorCount) {
     }
   }
 
-  private class RequirementListener implements RequirementsWatcher.Listener {
-    @Override
-    public void requirementsMet(RequirementsWatcher requirementsWatcher) {
-      startDownloads();
-      notifyListenersRequirementsStateChange(0);
-    }
-
-    @Override
-    public void requirementsNotMet(
-        RequirementsWatcher requirementsWatcher,
-        @Requirements.RequirementFlags int notMetRequirements) {
-      stopDownloads();
-      notifyListenersRequirementsStateChange(notMetRequirements);
-    }
-  }
 }
</code_before><code_after>@@ -26,6 +26,7 @@
 import static com.google.android.exoplayer2.offline.DownloadState.STATE_RESTARTING;
 import static com.google.android.exoplayer2.offline.DownloadState.STATE_STOPPED;
 import static com.google.android.exoplayer2.offline.DownloadState.STOP_FLAG_DOWNLOAD_MANAGER_NOT_READY;
+import static com.google.android.exoplayer2.offline.DownloadState.STOP_FLAG_REQUIREMENTS_NOT_MET;
 import static com.google.android.exoplayer2.offline.DownloadState.STOP_FLAG_STOPPED;
 
 import android.content.Context;
@@ -119,6 +120,7 @@ void onRequirementsStateChanged(
   private boolean initialized;
   private boolean released;
   @DownloadState.StopFlags private int stickyStopFlags;
+  @Requirements.RequirementFlags private int notMetRequirements;
   private RequirementsWatcher requirementsWatcher;
 
   /**
@@ -194,7 +196,7 @@ public void setRequirements(Requirements requirements) {
       return;
     }
     requirementsWatcher.stop();
+    onRequirementsStateChanged(watchRequirements(requirements));
   }
 
   /** Returns the requirements needed to be met to start downloads. */
@@ -349,7 +351,8 @@ private void addDownloadForAction(DownloadAction action) {
       }
     }
     Download download =
+        new Download(
+            this, downloaderFactory, action, minRetryCount, stickyStopFlags, notMetRequirements);
     downloads.add(download);
     logd("Download is added", download);
   }
@@ -401,13 +404,16 @@ private void notifyListenersDownloadStateChange(Download download) {
     }
   }
 
+  private void onRequirementsStateChanged(@Requirements.RequirementFlags int notMetRequirements) {
+    this.notMetRequirements = notMetRequirements;
     logdFlags("Not met requirements are changed", notMetRequirements);
     for (Listener listener : listeners) {
       listener.onRequirementsStateChanged(
           DownloadManager.this, requirementsWatcher.getRequirements(), notMetRequirements);
     }
+    for (int i = 0; i &lt; downloads.size(); i++) {
+      downloads.get(i).setNotMetRequirements(notMetRequirements);
+    }
   }
 
   private void loadActions() {
@@ -486,7 +492,9 @@ private static void logdFlags(String message, int flags) {
 
   @Requirements.RequirementFlags
   private int watchRequirements(Requirements requirements) {
+    RequirementsWatcher.Listener listener =
+        (requirementsWatcher, notMetRequirements) -&gt; onRequirementsStateChanged(notMetRequirements);
+    requirementsWatcher = new RequirementsWatcher(context, listener, requirements);
     @Requirements.RequirementFlags int notMetRequirements = requirementsWatcher.start();
     if (notMetRequirements == 0) {
       startDownloads();
@@ -511,17 +519,23 @@ private static final class Download {
     @MonotonicNonNull private DownloadThread downloadThread;
     @MonotonicNonNull @DownloadState.FailureReason private int failureReason;
     @DownloadState.StopFlags private int stopFlags;
+    @Requirements.RequirementFlags private int notMetRequirements;
 
     private Download(
         DownloadManager downloadManager,
         DownloaderFactory downloaderFactory,
         DownloadAction action,
         int minRetryCount,
+        @DownloadState.StopFlags int stopFlags,
+        @Requirements.RequirementFlags int notMetRequirements) {
       this.id = action.id;
       this.downloadManager = downloadManager;
       this.downloaderFactory = downloaderFactory;
       this.minRetryCount = minRetryCount;
+      this.notMetRequirements = notMetRequirements;
+      if (notMetRequirements != 0) {
+        stopFlags |= STOP_FLAG_REQUIREMENTS_NOT_MET;
+      }
       this.stopFlags = stopFlags;
       this.startTimeMs = System.currentTimeMillis();
       actionQueue = new ArrayDeque&lt;&gt;();
@@ -579,6 +593,7 @@ public DownloadState getDownloadState() {
           totalBytes,
           failureReason,
           stopFlags,
+          notMetRequirements,
           startTimeMs,
           /* updateTimeMs= */ System.currentTimeMillis(),
           action.keys.toArray(new StreamKey[0]),
@@ -628,6 +643,13 @@ public void updateStopFlags(int flags, int values) {
       }
     }
 
+    public void setNotMetRequirements(@Requirements.RequirementFlags int notMetRequirements) {
+      this.notMetRequirements = notMetRequirements;
+      updateStopFlags(
+          STOP_FLAG_REQUIREMENTS_NOT_MET,
+          notMetRequirements != 0 ? STOP_FLAG_REQUIREMENTS_NOT_MET : 0);
+    }
+
     private void initialize(boolean restart) {
       DownloadAction action = actionQueue.peek();
       if (action.isRemoveAction) {
@@ -770,19 +792,4 @@ private int getRetryDelayMillis(int errorCount) {
     }
   }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>301170</refactoring_id><commit_sha>8dd448e6b83f143be8b8c85495cf46f5d5faad48</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/8dd448e6b83f143be8b8c85495cf46f5d5faad48</commit_link><file_path>jdk/src/solaris/classes/sun/awt/X11/XButtonPeer.java</file_path><description>Rename Method public paint(g Graphics, c Component) : void renamed to package paintPeer(g Graphics) : void in class sun.awt.X11.XButtonPeer</description><code_before>@@ -33,12 +33,9 @@
 import javax.swing.plaf.basic.*;
 import javax.swing.SwingUtilities;
 import javax.swing.SwingConstants;
-
 public class XButtonPeer extends XComponentPeer implements ButtonPeer {
-
-    boolean pressed;
-    boolean armed;
-
     private Insets focusInsets;
     private Insets borderInsets;
     private Insets contentAreaInsets;
@@ -86,11 +83,6 @@ public void  setLabel(java.lang.String label) {
         this.label = label;
         repaint();
     }
-
-    public void paint(Graphics g) {
-        paint(g,target);
-    }
-
     public void setBackground(Color c) {
         updateMotifColors(c);
         super.setBackground(c);
@@ -133,16 +125,10 @@ void handleJavaMouseEvent(MouseEvent e) {
           case  MouseEvent.MOUSE_ENTERED:
               if (pressed)
                   armed = true;
-//                 repaint();
-
               break;
-
           case MouseEvent.MOUSE_EXITED:
               armed = false;
-//                 repaint();
-
               break;
-
         }
     }
 
@@ -209,18 +195,14 @@ public Dimension getMinimumSize() {
     public Dimension minimumSize() {
         return getMinimumSize();
     }
-
-
-    /*
-       This method is called from Toolkit Thread and so it should not call any client code
-
-    */
-    public void paint(Graphics g, Component c)
-    {
-        if (!disposed &amp;&amp; (g != null))
-        {
             Dimension size = getPeerSize();
-
             g.setColor( getPeerBackground() );   /* erase the existing button remains */
             g.fillRect(0,0, size.width , size.height);
             paintBorder(g,borderInsets.left,
@@ -239,11 +221,9 @@ public void paint(Graphics g, Component c)
 
             viewRect.width = size.width - (contentAreaInsets.left+contentAreaInsets.right);
             viewRect.height = size.height - (contentAreaInsets.top+contentAreaInsets.bottom);
-
             viewRect.x = contentAreaInsets.left;
-            viewRect.y = contentAreaInsets.right;
             String llabel = (label != null) ? label : "";
-
             // layout the text and icon
             String text = SwingUtilities.layoutCompoundLabel(
                                                              fm, llabel, null,
@@ -309,10 +289,9 @@ protected void paintText(Graphics g, Component c, Rectangle textRect, String tex
         else {
             /*** paint the text disabled ***/
             g.setColor(getPeerBackground().brighter());
-
             BasicGraphicsUtils.drawStringUnderlineCharAt(g,text, mnemonicIndex,
                                                          textRect.x, textRect.y + fm.getAscent());
-            g.setColor(c.getBackground().darker());
             BasicGraphicsUtils.drawStringUnderlineCharAt(g,text, mnemonicIndex,
                                                          textRect.x - 1, textRect.y + fm.getAscent() - 1);
         }
</code_before><code_after>@@ -33,12 +33,9 @@
 import javax.swing.plaf.basic.*;
 import javax.swing.SwingUtilities;
 import javax.swing.SwingConstants;
 public class XButtonPeer extends XComponentPeer implements ButtonPeer {
+    private boolean pressed;
+    private boolean armed;
     private Insets focusInsets;
     private Insets borderInsets;
     private Insets contentAreaInsets;
@@ -86,11 +83,6 @@ public void  setLabel(java.lang.String label) {
         this.label = label;
         repaint();
     }
     public void setBackground(Color c) {
         updateMotifColors(c);
         super.setBackground(c);
@@ -133,16 +125,10 @@ void handleJavaMouseEvent(MouseEvent e) {
           case  MouseEvent.MOUSE_ENTERED:
               if (pressed)
                   armed = true;
               break;
           case MouseEvent.MOUSE_EXITED:
               armed = false;
               break;
         }
     }
 
@@ -209,18 +195,14 @@ public Dimension getMinimumSize() {
     public Dimension minimumSize() {
         return getMinimumSize();
     }
+    /**
+     * This method is called from Toolkit Thread and so it should not call any
+     * client code.
+     */
+    @Override
+    void paintPeer(final Graphics g) {
+        if (!disposed) {
             Dimension size = getPeerSize();
             g.setColor( getPeerBackground() );   /* erase the existing button remains */
             g.fillRect(0,0, size.width , size.height);
             paintBorder(g,borderInsets.left,
@@ -239,11 +221,9 @@ public void paint(Graphics g, Component c)
 
             viewRect.width = size.width - (contentAreaInsets.left+contentAreaInsets.right);
             viewRect.height = size.height - (contentAreaInsets.top+contentAreaInsets.bottom);
             viewRect.x = contentAreaInsets.left;
+            viewRect.y = contentAreaInsets.top;
             String llabel = (label != null) ? label : "";
             // layout the text and icon
             String text = SwingUtilities.layoutCompoundLabel(
                                                              fm, llabel, null,
@@ -309,10 +289,9 @@ protected void paintText(Graphics g, Component c, Rectangle textRect, String tex
         else {
             /*** paint the text disabled ***/
             g.setColor(getPeerBackground().brighter());
             BasicGraphicsUtils.drawStringUnderlineCharAt(g,text, mnemonicIndex,
                                                          textRect.x, textRect.y + fm.getAscent());
+            g.setColor(getPeerBackground().darker());
             BasicGraphicsUtils.drawStringUnderlineCharAt(g,text, mnemonicIndex,
                                                          textRect.x - 1, textRect.y + fm.getAscent() - 1);
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>136934</refactoring_id><commit_sha>55bb48484304bc29ed0fdfc31986a3ed9b10de7a</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/55bb48484304bc29ed0fdfc31986a3ed9b10de7a</commit_link><file_path>plugins/org.jkiss.dbeaver.core/src/org/jkiss/dbeaver/ui/editors/sql/SQLEditor.java</file_path><description>Rename Method public propertyChange(event PropertyChangeEvent) : void renamed to public preferenceChange(event PreferenceChangeEvent) : void in class org.jkiss.dbeaver.ui.editors.sql.SQLEditor</description><code_before>@@ -28,8 +28,6 @@
 import org.eclipse.jface.action.IMenuManager;
 import org.eclipse.jface.action.MenuManager;
 import org.eclipse.jface.text.*;
-import org.eclipse.jface.util.IPropertyChangeListener;
-import org.eclipse.jface.util.PropertyChangeEvent;
 import org.eclipse.jface.viewers.ISelectionProvider;
 import org.eclipse.jface.viewers.StructuredSelection;
 import org.eclipse.swt.SWT;
@@ -52,7 +50,6 @@
 import org.jkiss.dbeaver.core.DBeaverActivator;
 import org.jkiss.dbeaver.core.DBeaverCore;
 import org.jkiss.dbeaver.core.DBeaverUI;
-import org.jkiss.dbeaver.model.IDataSourceContainerProviderEx;
 import org.jkiss.dbeaver.model.*;
 import org.jkiss.dbeaver.model.data.DBDDataFilter;
 import org.jkiss.dbeaver.model.data.DBDDataReceiver;
@@ -106,7 +103,7 @@ public class SQLEditor extends SQLEditorBase implements
     IResultSetContainer,
     DBPDataSourceUser,
     DBPDataSourceHandler,
-    IPropertyChangeListener
 {
     private static final long SCRIPT_UI_UPDATE_PERIOD = 100;
 
@@ -951,7 +948,7 @@ private QueryProcessor createQueryProcessor(boolean setSelection)
     }
 
     @Override
-    public void propertyChange(PropertyChangeEvent event) {
         if (event.getProperty().equals(DBeaverPreferences.SCRIPT_STATEMENT_DELIMITER) ||
             event.getProperty().equals(DBeaverPreferences.SCRIPT_IGNORE_NATIVE_DELIMITER))
         {
</code_before><code_after>@@ -28,8 +28,6 @@
 import org.eclipse.jface.action.IMenuManager;
 import org.eclipse.jface.action.MenuManager;
 import org.eclipse.jface.text.*;
 import org.eclipse.jface.viewers.ISelectionProvider;
 import org.eclipse.jface.viewers.StructuredSelection;
 import org.eclipse.swt.SWT;
@@ -52,7 +50,6 @@
 import org.jkiss.dbeaver.core.DBeaverActivator;
 import org.jkiss.dbeaver.core.DBeaverCore;
 import org.jkiss.dbeaver.core.DBeaverUI;
 import org.jkiss.dbeaver.model.*;
 import org.jkiss.dbeaver.model.data.DBDDataFilter;
 import org.jkiss.dbeaver.model.data.DBDDataReceiver;
@@ -106,7 +103,7 @@ public class SQLEditor extends SQLEditorBase implements
     IResultSetContainer,
     DBPDataSourceUser,
     DBPDataSourceHandler,
+    DBPPreferenceListener
 {
     private static final long SCRIPT_UI_UPDATE_PERIOD = 100;
 
@@ -951,7 +948,7 @@ private QueryProcessor createQueryProcessor(boolean setSelection)
     }
 
     @Override
+    public void preferenceChange(PreferenceChangeEvent event) {
         if (event.getProperty().equals(DBeaverPreferences.SCRIPT_STATEMENT_DELIMITER) ||
             event.getProperty().equals(DBeaverPreferences.SCRIPT_IGNORE_NATIVE_DELIMITER))
         {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>126824</refactoring_id><commit_sha>461c4dfaae3a6cb4b79e07df9f3bc955a2dc9458</commit_sha><commit_link>https://github.com/apache/doris/commit/461c4dfaae3a6cb4b79e07df9f3bc955a2dc9458</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/catalog/Replica.java</file_path><description>Rename Method public getWatermarkTxnId() : long renamed to public getPreWatermarkTxnId() : long in class org.apache.doris.catalog.Replica</description><code_before>@@ -129,9 +129,16 @@ public enum ReplicaStatus {
     private long furtherRepairSetTime = -1;
     private static final long FURTHER_REPAIR_TIMEOUT_MS = 20 * 60 * 1000L; // 20min
 
-    // if this watermarkTxnId is set, which means before deleting a replica,
-    // we should ensure that all txns on this replicas are finished.
-    private long watermarkTxnId = -1;
 
     public Replica() {
     }
@@ -568,12 +575,20 @@ public int compare(T replica1, T replica2) {
         }
     }
 
-    public void setWatermarkTxnId(long watermarkTxnId) {
-        this.watermarkTxnId = watermarkTxnId;
     }
 
-    public long getWatermarkTxnId() {
-        return watermarkTxnId;
     }
 
     public boolean isAlive() {
</code_before><code_after>@@ -129,9 +129,16 @@ public enum ReplicaStatus {
     private long furtherRepairSetTime = -1;
     private static final long FURTHER_REPAIR_TIMEOUT_MS = 20 * 60 * 1000L; // 20min
 
+
+    /* Decommission a backend B, steps are as follow:
+     * 1. wait peer backends catchup with B;
+     * 2. B change state to DECOMMISSION, set preWatermarkTxnId. B can load data now.
+     * 3. wait txn before preWatermarkTxnId finished, set postWatermarkTxnId. B can't load data now.
+     * 4. wait txn before postWatermarkTxnId finished, delete B.
+     *
+     */
+    private long preWatermarkTxnId = -1;
+    private long postWatermarkTxnId = -1;
 
     public Replica() {
     }
@@ -568,12 +575,20 @@ public int compare(T replica1, T replica2) {
         }
     }
 
+    public void setPreWatermarkTxnId(long preWatermarkTxnId) {
+        this.preWatermarkTxnId = preWatermarkTxnId;
+    }
+
+    public long getPreWatermarkTxnId() {
+        return preWatermarkTxnId;
+    }
+
+    public void setPostWatermarkTxnId(long postWatermarkTxnId) {
+        this.postWatermarkTxnId = postWatermarkTxnId;
     }
 
+    public long getPostWatermarkTxnId() {
+        return postWatermarkTxnId;
     }
 
     public boolean isAlive() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>196029</refactoring_id><commit_sha>e68ba1d0d1b162065753b0c83ad9417211d7e5ed</commit_sha><commit_link>https://github.com/camunda/camunda/commit/e68ba1d0d1b162065753b0c83ad9417211d7e5ed</commit_link><file_path>gossip/src/main/java/io/zeebe/gossip/membership/MembershipList.java</file_path><description>Rename Method private calculateSuspictionTimeout() : long renamed to private calculateSuspicionTimeout() : long in class io.zeebe.gossip.membership.MembershipList</description><code_before>@@ -139,11 +139,11 @@ public void suspectMember(SocketAddress address, GossipTerm gossipTerm)
             member
                 .setStatus(MembershipStatus.SUSPECT)
                 .setGossipTerm(gossipTerm)
-                .setSuspicionTimeout(calculateSuspictionTimeout());
         }
     }
 
-    private long calculateSuspictionTimeout()
     {
         final int multiplier = configuration.getSuspicionMultiplier();
         final int clusterSize = 1 + size();
</code_before><code_after>@@ -139,11 +139,11 @@ public void suspectMember(SocketAddress address, GossipTerm gossipTerm)
             member
                 .setStatus(MembershipStatus.SUSPECT)
                 .setGossipTerm(gossipTerm)
+                .setSuspicionTimeout(calculateSuspicionTimeout());
         }
     }
 
+    private long calculateSuspicionTimeout()
     {
         final int multiplier = configuration.getSuspicionMultiplier();
         final int clusterSize = 1 + size();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>320454</refactoring_id><commit_sha>6b1411ae8dbbea974e9bacfb003b0148b6bcb8f3</commit_sha><commit_link>https://github.com/cloudfoundry/uaa/commit/6b1411ae8dbbea974e9bacfb003b0148b6bcb8f3</commit_link><file_path>common/src/main/java/org/cloudfoundry/identity/uaa/config/PasswordPolicy.java</file_path><description>Rename Method public setRequireAtLeastOneSpecialCharacter(requireAtLeastOneSpecialCharacter boolean) : void renamed to public setRequireSpecialCharacter(requireSpecialCharacter int) : void in class org.cloudfoundry.identity.uaa.config.PasswordPolicy</description><code_before>@@ -16,57 +16,89 @@
  */
 public class PasswordPolicy {
 
-    public static String PASSWORD_POLICY_FIELD = "passwordPolicy";
 
-    private Integer minLength;
-    private Integer maxLength;
-    private boolean requireAtLeastOneUpperCaseCharacter;
-    private boolean requireAtLeastOneLowerCaseCharacter;
-    private boolean requireAtLeastOneDigit;
-    private boolean requireAtLeastOneSpecialCharacter;
 
     public PasswordPolicy() {
     }
 
-    public PasswordPolicy(Integer minLength, Integer maxLength,
-                          boolean requireAtLeastOneUpperCaseCharacter,
-                          boolean requireAtLeastOneLowerCaseCharacter,
-                          boolean requireAtLeastOneDigit,
-                          boolean requireAtLeastOneSpecialCharacter) {
         this.minLength = minLength;
         this.maxLength = maxLength;
-        this.requireAtLeastOneUpperCaseCharacter = requireAtLeastOneUpperCaseCharacter;
-        this.requireAtLeastOneLowerCaseCharacter = requireAtLeastOneLowerCaseCharacter;
-        this.requireAtLeastOneDigit = requireAtLeastOneDigit;
-        this.requireAtLeastOneSpecialCharacter = requireAtLeastOneSpecialCharacter;
     }
 
-    public Integer getMinLength() {
         return minLength;
     }
 
-    public Integer getMaxLength() {
         return maxLength;
     }
 
-    public boolean isRequireAtLeastOneUpperCaseCharacter() {
-        return requireAtLeastOneUpperCaseCharacter;
     }
 
-    public boolean isRequireAtLeastOneLowerCaseCharacter() {
-        return requireAtLeastOneLowerCaseCharacter;
     }
 
-    public boolean isRequireAtLeastOneDigit() {
-        return requireAtLeastOneDigit;
     }
 
-    public boolean isRequireAtLeastOneSpecialCharacter() {
-        return requireAtLeastOneSpecialCharacter;
     }
 
-    public void setRequireAtLeastOneSpecialCharacter(boolean requireAtLeastOneSpecialCharacter) {
-        this.requireAtLeastOneSpecialCharacter = requireAtLeastOneSpecialCharacter;
     }
 
 }
</code_before><code_after>@@ -16,57 +16,89 @@
  */
 public class PasswordPolicy {
 
+    public static final String PASSWORD_POLICY_FIELD = "passwordPolicy";
 
+    private String specialCharacters;
+    private int minLength;
+    private int maxLength;
+    private int requireUpperCaseCharacter;
+    private int requireLowerCaseCharacter;
+    private int requireDigit;
+    private int requireSpecialCharacter;
 
     public PasswordPolicy() {
     }
 
+    public PasswordPolicy(int minLength,
+                          int maxLength,
+                          int requireUpperCaseCharacter,
+                          int requireLowerCaseCharacter,
+                          int requireDigit,
+                          int requireSpecialCharacter,
+                          String specialCharacterRegex) {
         this.minLength = minLength;
         this.maxLength = maxLength;
+        this.requireUpperCaseCharacter = requireUpperCaseCharacter;
+        this.requireLowerCaseCharacter = requireLowerCaseCharacter;
+        this.requireDigit = requireDigit;
+        this.requireSpecialCharacter = requireSpecialCharacter;
+        this.specialCharacters = specialCharacterRegex;
     }
 
+    public int getMinLength() {
         return minLength;
     }
 
+    public int getMaxLength() {
         return maxLength;
     }
 
+    public int getRequireUpperCaseCharacter() {
+        return requireUpperCaseCharacter;
     }
 
+    public int getRequireLowerCaseCharacter() {
+        return requireLowerCaseCharacter;
     }
 
+    public int getRequireDigit() {
+        return requireDigit;
     }
 
+    public void setMaxLength(int maxLength) {
+        this.maxLength = maxLength;
+    }
+
+    public void setMinLength(int minLength) {
+        this.minLength = minLength;
+    }
+
+    public void setRequireDigit(int requireDigit) {
+        this.requireDigit = requireDigit;
+    }
+
+    public void setRequireLowerCaseCharacter(int requireLowerCaseCharacter) {
+        this.requireLowerCaseCharacter = requireLowerCaseCharacter;
+    }
+
+    public void setRequireUpperCaseCharacter(int requireUpperCaseCharacter) {
+        this.requireUpperCaseCharacter = requireUpperCaseCharacter;
+    }
+
+    public int getRequireSpecialCharacter() {
+        return requireSpecialCharacter;
+    }
+
+    public void setRequireSpecialCharacter(int requireSpecialCharacter) {
+        this.requireSpecialCharacter = requireSpecialCharacter;
+    }
+
+    public String getSpecialCharacters() {
+        return specialCharacters;
     }
 
+    public void setSpecialCharacters(String specialCharacters) {
+        this.specialCharacters = specialCharacters;
     }
 
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>139646</refactoring_id><commit_sha>75a4dd16cce2ab4682ceda53485f49ee79cdf45e</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/75a4dd16cce2ab4682ceda53485f49ee79cdf45e</commit_link><file_path>src/main/java/vazkii/botania/common/block/mana/BlockSpawnerClaw.java</file_path><description>Rename Method public createTileEntity(state BlockState, world IBlockReader) : TileEntity renamed to public createNewTileEntity(world IBlockReader) : TileEntity in class vazkii.botania.common.block.mana.BlockSpawnerClaw</description><code_before>@@ -10,6 +10,7 @@
 
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
 import net.minecraft.item.ItemGroup;
 import net.minecraft.item.ItemStack;
 import net.minecraft.tileentity.TileEntity;
@@ -24,7 +25,7 @@
 
 import javax.annotation.Nonnull;
 
-public class BlockSpawnerClaw extends BlockModWaterloggable {
 
 	private static final VoxelShape SHAPE = makeCuboidShape(2, 0, 2, 14, 2, 14);
 
@@ -44,14 +45,9 @@ public void fillItemGroup(ItemGroup group, NonNullList&lt;ItemStack&gt; list) {
 		list.add(new ItemStack(Blocks.SPAWNER));
 	}
 
-	@Override
-	public boolean hasTileEntity(BlockState state) {
-		return true;
-	}
-
 	@Nonnull
 	@Override
-	public TileEntity createTileEntity(@Nonnull BlockState state, IBlockReader world) {
 		return new TileSpawnerClaw();
 	}
 
</code_before><code_after>@@ -10,6 +10,7 @@
 
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
+import net.minecraft.block.ITileEntityProvider;
 import net.minecraft.item.ItemGroup;
 import net.minecraft.item.ItemStack;
 import net.minecraft.tileentity.TileEntity;
@@ -24,7 +25,7 @@
 
 import javax.annotation.Nonnull;
 
+public class BlockSpawnerClaw extends BlockModWaterloggable implements ITileEntityProvider {
 
 	private static final VoxelShape SHAPE = makeCuboidShape(2, 0, 2, 14, 2, 14);
 
@@ -44,14 +45,9 @@ public void fillItemGroup(ItemGroup group, NonNullList&lt;ItemStack&gt; list) {
 		list.add(new ItemStack(Blocks.SPAWNER));
 	}
 
 	@Nonnull
 	@Override
+	public TileEntity createNewTileEntity(IBlockReader world) {
 		return new TileSpawnerClaw();
 	}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>285640</refactoring_id><commit_sha>01f2d7fa4b24b21543012060305d693899b4beaa</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/01f2d7fa4b24b21543012060305d693899b4beaa</commit_link><file_path>src/com/android/launcher3/CellLayout.java</file_path><description>Rename Method public enableHardwareLayers() : void renamed to public enableHardwareLayer(hasLayer boolean) : void in class com.android.launcher3.CellLayout</description><code_before>@@ -296,12 +296,8 @@ public void onAnimationEnd(Animator animation) {
         addView(mShortcutsAndWidgets);
     }
 
-    public void enableHardwareLayers() {
-        mShortcutsAndWidgets.setLayerType(LAYER_TYPE_HARDWARE, sPaint);
-    }
-
-    public void disableHardwareLayers() {
-        mShortcutsAndWidgets.setLayerType(LAYER_TYPE_NONE, sPaint);
     }
 
     public void buildHardwareLayer() {
</code_before><code_after>@@ -296,12 +296,8 @@ public void onAnimationEnd(Animator animation) {
         addView(mShortcutsAndWidgets);
     }
 
+    public void enableHardwareLayer(boolean hasLayer) {
+        mShortcutsAndWidgets.setLayerType(hasLayer ? LAYER_TYPE_HARDWARE : LAYER_TYPE_NONE, sPaint);
     }
 
     public void buildHardwareLayer() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>155878</refactoring_id><commit_sha>f9e15817be23063f91c6bff21b61cf63db2279c9</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/f9e15817be23063f91c6bff21b61cf63db2279c9</commit_link><file_path>config-model/src/test/java/com/yahoo/vespa/model/content/ContentSchemaClusterTest.java</file_path><description>Rename Method public verifyControlOfDocStoreCompression() : void renamed to public verifyDefaultDocStoreCompression() : void in class com.yahoo.vespa.model.content.ContentSchemaClusterTest</description><code_before>@@ -33,7 +33,7 @@
  */
 public class ContentSchemaClusterTest {
 
-    private static double EPSILON = 0.000001;
 
     private static ContentCluster createClusterWithOneDocumentType() throws Exception {
         return createCluster(new ContentClusterBuilder().getXml());
@@ -261,13 +261,8 @@ public void fsync_is_controllable() throws Exception {
     }
 
     @Test
-    public void verifyControlOfDocStoreCompression() throws Exception {
         ProtonConfig cfg = getProtonConfig(createCluster(new ContentClusterBuilder().getXml()));
-        assertEquals(9, cfg.summary().log().chunk().compression().level());
-        assertEquals(9, cfg.summary().log().compact().compression().level());
-
-        cfg = getProtonConfig(createCluster(new ContentClusterBuilder().getXml(),
-                new DeployState.Builder().properties(new TestProperties().docstoreCompressionLevel(3))));
         assertEquals(3, cfg.summary().log().chunk().compression().level());
         assertEquals(3, cfg.summary().log().compact().compression().level());
     }
</code_before><code_after>@@ -33,7 +33,7 @@
  */
 public class ContentSchemaClusterTest {
 
+    private static final double EPSILON = 0.000001;
 
     private static ContentCluster createClusterWithOneDocumentType() throws Exception {
         return createCluster(new ContentClusterBuilder().getXml());
@@ -261,13 +261,8 @@ public void fsync_is_controllable() throws Exception {
     }
 
     @Test
+    public void verifyDefaultDocStoreCompression() throws Exception {
         ProtonConfig cfg = getProtonConfig(createCluster(new ContentClusterBuilder().getXml()));
         assertEquals(3, cfg.summary().log().chunk().compression().level());
         assertEquals(3, cfg.summary().log().compact().compression().level());
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>240691</refactoring_id><commit_sha>a6b71174bf5e050c347d677d7c903e1b1cb352aa</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/a6b71174bf5e050c347d677d7c903e1b1cb352aa</commit_link><file_path>profiler/src/main/java/com/navercorp/pinpoint/test/PluginTestAgent.java</file_path><description>Rename Method public verifyDiscreteTraceBlock(expectations ExpectedTrace...) : void renamed to public verifyDiscreteTrace(expectations ExpectedTrace...) : void in class com.navercorp.pinpoint.test.PluginTestAgent</description><code_before>@@ -215,7 +215,7 @@ private Class&lt;?&gt; resolveSpanClass(TraceType type) {
     }
     
     @Override
-    public void verifyDiscreteTraceBlock(ExpectedTrace... expectations) {
         verifyDiscreteTraceBlock(expectations, null);
     }
         
</code_before><code_after>@@ -215,7 +215,7 @@ private Class&lt;?&gt; resolveSpanClass(TraceType type) {
     }
     
     @Override
+    public void verifyDiscreteTrace(ExpectedTrace... expectations) {
         verifyDiscreteTraceBlock(expectations, null);
     }
         
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>162762</refactoring_id><commit_sha>ade59b924120da34bfe2a2e814d3c93e5676e47b</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/ade59b924120da34bfe2a2e814d3c93e5676e47b</commit_link><file_path>community/kernel-api/src/main/java/org/neo4j/internal/kernel/api/security/AccessMode.java</file_path><description>Rename Method public allowsTraverseNodeLabels(labels long...) : boolean renamed to public allowsTraverseNode(labels long...) : boolean in class org.neo4j.internal.kernel.api.security.AccessMode</description><code_before>@@ -112,13 +112,13 @@ public boolean allowsTraverseAllLabels()
         }
 
         @Override
-        public boolean allowsTraverseLabel( long label )
         {
             return read;
         }
 
         @Override
-        public boolean allowsLabel( long label )
         {
             return read;
         }
@@ -130,13 +130,7 @@ public boolean disallowsTraverseLabel( long label )
         }
 
         @Override
-        public boolean disallowsTraverseType( long type )
-        {
-            return false;
-        }
-
-        @Override
-        public boolean allowsTraverseNodeLabels( long... labels )
         {
             return read;
         }
@@ -184,7 +178,7 @@ public boolean allowsReadRelationshipProperty( IntSupplier relType, int property
         }
 
         @Override
-        public boolean allowsPropertyReads( int propertyKey )
         {
             return read;
         }
@@ -209,18 +203,15 @@ public AuthorizationViolationException onViolation( String msg )
 
     /** true if all nodes can be traversed */
     boolean allowsTraverseAllLabels();
-    /** true if all nodes with this label can be traversed */
-    boolean allowsTraverseLabel( long label );
     /** true if this label is visible */
-    boolean allowsLabel( long label );
     /** true if this label is blacklisted for traversal */
     boolean disallowsTraverseLabel( long label );
 
-    /** true if this type is blacklisted for traversal */
-    boolean disallowsTraverseType( long type );
-
     /** true if a particular node with exactly these labels can be traversed */
-    boolean allowsTraverseNodeLabels( long... labels );
 
     boolean allowsTraverseAllRelTypes();
     boolean allowsTraverseRelType( int relType );
@@ -232,7 +223,7 @@ public AuthorizationViolationException onViolation( String msg )
     boolean allowsReadPropertyAllRelTypes( int propertyKey );
     boolean allowsReadRelationshipProperty( IntSupplier relType, int propertyKey );
 
-    boolean allowsPropertyReads( int propertyKey );
 
     /**
      * Determines whether this mode allows execution of a procedure with the parameter string array in its
</code_before><code_after>@@ -112,13 +112,13 @@ public boolean allowsTraverseAllLabels()
         }
 
         @Override
+        public boolean allowsTraverseAllNodesWithLabel( long label )
         {
             return read;
         }
 
         @Override
+        public boolean allowsSeeLabelToken( long label )
         {
             return read;
         }
@@ -130,13 +130,7 @@ public boolean disallowsTraverseLabel( long label )
         }
 
         @Override
+        public boolean allowsTraverseNode( long... labels )
         {
             return read;
         }
@@ -184,7 +178,7 @@ public boolean allowsReadRelationshipProperty( IntSupplier relType, int property
         }
 
         @Override
+        public boolean allowsSeePropertyKeyToken( int propertyKey )
         {
             return read;
         }
@@ -209,18 +203,15 @@ public AuthorizationViolationException onViolation( String msg )
 
     /** true if all nodes can be traversed */
     boolean allowsTraverseAllLabels();
+    /** true if all nodes with this label always can be traversed */
+    boolean allowsTraverseAllNodesWithLabel( long label );
     /** true if this label is visible */
+    boolean allowsSeeLabelToken( long label );
     /** true if this label is blacklisted for traversal */
     boolean disallowsTraverseLabel( long label );
 
     /** true if a particular node with exactly these labels can be traversed */
+    boolean allowsTraverseNode( long... labels );
 
     boolean allowsTraverseAllRelTypes();
     boolean allowsTraverseRelType( int relType );
@@ -232,7 +223,7 @@ public AuthorizationViolationException onViolation( String msg )
     boolean allowsReadPropertyAllRelTypes( int propertyKey );
     boolean allowsReadRelationshipProperty( IntSupplier relType, int propertyKey );
 
+    boolean allowsSeePropertyKeyToken( int propertyKey );
 
     /**
      * Determines whether this mode allows execution of a procedure with the parameter string array in its
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>241519</refactoring_id><commit_sha>27790dcc0209bf2cfe88206929d822bd4ebdf5ef</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/27790dcc0209bf2cfe88206929d822bd4ebdf5ef</commit_link><file_path>plugins-it/mongodb-it/src/test/java/com/navercorp/pinpoint/plugin/mongodb/MongoDBIT_3_2_x_IT.java</file_path><description>Rename Method public closeClient() : void renamed to public cleanAfterClass() : void in class com.navercorp.pinpoint.plugin.mongodb.MongoDBIT_3_2_x_IT</description><code_before>@@ -19,18 +19,26 @@
 import com.mongodb.ReadPreference;
 import com.mongodb.WriteConcern;
 
-import com.navercorp.pinpoint.bootstrap.plugin.test.PluginTestVerifier;
 import com.navercorp.pinpoint.pluginit.utils.AgentPath;
 import com.navercorp.pinpoint.test.plugin.Dependency;
 import com.navercorp.pinpoint.test.plugin.ImportPlugin;
 import com.navercorp.pinpoint.test.plugin.JvmVersion;
 import com.navercorp.pinpoint.test.plugin.PinpointAgent;
 import com.navercorp.pinpoint.test.plugin.PinpointPluginTestSuite;
 
-import com.mongodb.client.MongoCollection;
-import org.bson.Document;
 import org.junit.runner.RunWith;
 
 /**
  * @author Roy Kim
  */
@@ -40,30 +48,39 @@
 @ImportPlugin({"com.navercorp.pinpoint:pinpoint-mongodb-driver-plugin"})
 @Dependency({
         "org.mongodb:mongodb-driver:[3.2.0,3.3.max]",
-        MongoDBITConstants.EMBED_MONGODB_VERSION
 })
 public class MongoDBIT_3_2_x_IT extends MongoDBITBase {
 
     private static com.mongodb.MongoClient mongoClient;
 
-    @Override
-    Class&lt;?&gt; getMongoDatabaseClazz() throws ClassNotFoundException {
-        return Class.forName("com.mongodb.MongoCollectionImpl");
     }
 
-    @Override
-    void insertComplex(PluginTestVerifier verifier, MongoCollection&lt;Document&gt; collection, Class&lt;?&gt; mongoDatabaseImpl, String collectionInfo, String collectionOption) {
-        insertComlexBsonValueData30(verifier, collection, mongoDatabaseImpl, collectionInfo, collectionOption);
     }
 
     @Override
-    public void setClient() {
-        mongoClient = new com.mongodb.MongoClient(MongoDBITConstants.BIND_ADDRESS, mongod.getPort());
-        database = mongoClient.getDatabase("myMongoDbFake").withReadPreference(ReadPreference.secondaryPreferred()).withWriteConcern(WriteConcern.MAJORITY);
     }
 
-    @Override
-    public void closeClient() {
-        mongoClient.close();
     }
 }
</code_before><code_after>@@ -19,18 +19,26 @@
 import com.mongodb.ReadPreference;
 import com.mongodb.WriteConcern;
 
+import com.mongodb.client.MongoDatabase;
+import com.navercorp.pinpoint.pluginit.jdbc.DriverProperties;
+import com.navercorp.pinpoint.pluginit.jdbc.JDBCTestConstants;
 import com.navercorp.pinpoint.pluginit.utils.AgentPath;
+import com.navercorp.pinpoint.pluginit.utils.PluginITConstants;
+import com.navercorp.pinpoint.pluginit.utils.TestcontainersOption;
 import com.navercorp.pinpoint.test.plugin.Dependency;
 import com.navercorp.pinpoint.test.plugin.ImportPlugin;
 import com.navercorp.pinpoint.test.plugin.JvmVersion;
 import com.navercorp.pinpoint.test.plugin.PinpointAgent;
 import com.navercorp.pinpoint.test.plugin.PinpointPluginTestSuite;
 
+import com.navercorp.pinpoint.test.plugin.shared.SharedTestLifeCycleClass;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.net.URI;
+
 /**
  * @author Roy Kim
  */
@@ -40,30 +48,39 @@
 @ImportPlugin({"com.navercorp.pinpoint:pinpoint-mongodb-driver-plugin"})
 @Dependency({
         "org.mongodb:mongodb-driver:[3.2.0,3.3.max]",
+        PluginITConstants.VERSION, JDBCTestConstants.VERSION, TestcontainersOption.TEST_CONTAINER, TestcontainersOption.MONGODB
 })
+@SharedTestLifeCycleClass(MongodbServer.class)
 public class MongoDBIT_3_2_x_IT extends MongoDBITBase {
 
     private static com.mongodb.MongoClient mongoClient;
+    private static MongoDatabase database;
+    private static URI uri;
 
+    @BeforeClass
+    public static void setUpBeforeClass() throws Exception {
+        DriverProperties driverProperties = getDriverProperties();
+        uri = new URI(driverProperties.getUrl());
+        mongoClient = new com.mongodb.MongoClient(uri.getHost(), uri.getPort());
+        database = mongoClient.getDatabase("myMongoDbFake").withReadPreference(ReadPreference.secondaryPreferred()).withWriteConcern(WriteConcern.MAJORITY);
     }
 
+    @AfterClass
+    public static void cleanAfterClass() throws Exception {
+        if (mongoClient != null) {
+            mongoClient.close();
+        }
     }
 
     @Override
+    Class&lt;?&gt; getMongoDatabaseClazz() throws ClassNotFoundException {
+        return Class.forName("com.mongodb.MongoCollectionImpl");
     }
 
+    @Test
+    public void testStatements() throws Exception {
+        final MongoDBITHelper helper = new MongoDBITHelper();
+        final String address = uri.getHost() + ":" + uri.getPort();
+        helper.testConnection30(this, address, database, getMongoDatabaseClazz(), "ACKNOWLEDGED");
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>207538</refactoring_id><commit_sha>14158070bf8b3f831702061ffd657c84179fc639</commit_sha><commit_link>https://github.com/netty/netty/commit/14158070bf8b3f831702061ffd657c84179fc639</commit_link><file_path>transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java</file_path><description>Rename Method public messageReceived(ctx ChannelHandlerContext, msg SctpMessage) : void renamed to protected decode(ctx ChannelHandlerContext, msg SctpMessage, out MessageList&lt;Object&gt;) : void in class io.netty.handler.codec.sctp.SctpMessageCompletionHandler</description><code_before>@@ -19,47 +19,30 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.sctp.SctpMessage;
 
 import java.util.HashMap;
 import java.util.Map;
 
 /**
- * {@link ChannelInboundMessageHandlerAdapter} which will take care of handle fragmented {@link SctpMessage}s, so
  * only &lt;strong&gt;complete&lt;/strong&gt; {@link SctpMessage}s will be forwarded to the next
- * {@link ChannelInboundMessageHandler}.
  */
-public class SctpMessageCompletionHandler extends ChannelInboundMessageHandlerAdapter&lt;SctpMessage&gt; {
     private final Map&lt;Integer, ByteBuf&gt; fragments = new HashMap&lt;Integer, ByteBuf&gt;();
-    private boolean assembled;
 
     @Override
-    public boolean beginMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        assembled = false;
-        return super.beginMessageReceived(ctx);
-    }
-
-    @Override
-    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        if (assembled) {
-            assembled = false;
-            ctx.fireInboundBufferUpdated();
-        }
-        super.endMessageReceived(ctx);
-    }
-
-    @Override
-    public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
-
         final ByteBuf byteBuf = msg.content();
         final int protocolIdentifier = msg.protocolIdentifier();
         final int streamIdentifier = msg.streamIdentifier();
         final boolean isComplete = msg.isComplete();
 
         ByteBuf frag;
-
         if (fragments.containsKey(streamIdentifier)) {
             frag = fragments.remove(streamIdentifier);
         } else {
@@ -68,7 +51,7 @@ public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws E
 
         if (isComplete &amp;&amp; !frag.isReadable()) {
             //data chunk is not fragmented
-            handleAssembledMessage(ctx, msg);
         } else if (!isComplete &amp;&amp; frag.isReadable()) {
             //more message to complete
             fragments.put(streamIdentifier, Unpooled.wrappedBuffer(frag, byteBuf));
@@ -79,17 +62,11 @@ public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws E
                     protocolIdentifier,
                     streamIdentifier,
                     Unpooled.wrappedBuffer(frag, byteBuf));
-            handleAssembledMessage(ctx, assembledMsg);
         } else {
             //first incomplete message
             fragments.put(streamIdentifier, byteBuf);
         }
-
         byteBuf.retain();
     }
-
-    private void handleAssembledMessage(ChannelHandlerContext ctx, SctpMessage assembledMsg) {
-        ctx.nextInboundMessageBuffer().add(assembledMsg);
-        assembled = true;
-    }
 }
</code_before><code_after>@@ -19,47 +19,30 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.MessageList;
 import io.netty.channel.sctp.SctpMessage;
+import io.netty.handler.codec.MessageToMessageDecoder;
 
 import java.util.HashMap;
 import java.util.Map;
 
 /**
+ * {@link MessageToMessageDecoder} which will take care of handle fragmented {@link SctpMessage}s, so
  * only &lt;strong&gt;complete&lt;/strong&gt; {@link SctpMessage}s will be forwarded to the next
+ * {@link ChannelInboundHandler}.
  */
+public class SctpMessageCompletionHandler extends MessageToMessageDecoder&lt;SctpMessage&gt; {
     private final Map&lt;Integer, ByteBuf&gt; fragments = new HashMap&lt;Integer, ByteBuf&gt;();
 
     @Override
+    protected void decode(ChannelHandlerContext ctx, SctpMessage msg, MessageList&lt;Object&gt; out) throws Exception {
         final ByteBuf byteBuf = msg.content();
         final int protocolIdentifier = msg.protocolIdentifier();
         final int streamIdentifier = msg.streamIdentifier();
         final boolean isComplete = msg.isComplete();
 
         ByteBuf frag;
         if (fragments.containsKey(streamIdentifier)) {
             frag = fragments.remove(streamIdentifier);
         } else {
@@ -68,7 +51,7 @@ public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws E
 
         if (isComplete &amp;&amp; !frag.isReadable()) {
             //data chunk is not fragmented
+            out.add(msg);
         } else if (!isComplete &amp;&amp; frag.isReadable()) {
             //more message to complete
             fragments.put(streamIdentifier, Unpooled.wrappedBuffer(frag, byteBuf));
@@ -79,17 +62,11 @@ public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws E
                     protocolIdentifier,
                     streamIdentifier,
                     Unpooled.wrappedBuffer(frag, byteBuf));
+            out.add(assembledMsg);
         } else {
             //first incomplete message
             fragments.put(streamIdentifier, byteBuf);
         }
         byteBuf.retain();
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>317211</refactoring_id><commit_sha>2ad4e743063498fbcb3f92320a68657cb3073cde</commit_sha><commit_link>https://github.com/apache/flink/commit/2ad4e743063498fbcb3f92320a68657cb3073cde</commit_link><file_path>flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/TaskInformation.java</file_path><description>Rename Method public getMaxNumberOfSubtaks() : int renamed to public getMaxNumberOfSubtasks() : int in class org.apache.flink.runtime.executiongraph.TaskInformation</description><code_before>@@ -42,7 +42,7 @@ public class TaskInformation implements Serializable {
 	private final int numberOfSubtasks;
 
 	/** The maximum parallelism == number of key groups */
-	private final int maxNumberOfSubtaks;
 
 	/** Class name of the invokable to run */
 	private final String invokableClassName;
@@ -54,13 +54,13 @@ public TaskInformation(
 			JobVertexID jobVertexId,
 			String taskName,
 			int numberOfSubtasks,
-			int maxNumberOfSubtaks,
 			String invokableClassName,
 			Configuration taskConfiguration) {
 		this.jobVertexId = Preconditions.checkNotNull(jobVertexId);
 		this.taskName = Preconditions.checkNotNull(taskName);
 		this.numberOfSubtasks = Preconditions.checkNotNull(numberOfSubtasks);
-		this.maxNumberOfSubtaks = Preconditions.checkNotNull(maxNumberOfSubtaks);
 		this.invokableClassName = Preconditions.checkNotNull(invokableClassName);
 		this.taskConfiguration = Preconditions.checkNotNull(taskConfiguration);
 	}
@@ -77,8 +77,8 @@ public int getNumberOfSubtasks() {
 		return numberOfSubtasks;
 	}
 
-	public int getMaxNumberOfSubtaks() {
-		return maxNumberOfSubtaks;
 	}
 
 	public String getInvokableClassName() {
</code_before><code_after>@@ -42,7 +42,7 @@ public class TaskInformation implements Serializable {
 	private final int numberOfSubtasks;
 
 	/** The maximum parallelism == number of key groups */
+	private final int maxNumberOfSubtasks;
 
 	/** Class name of the invokable to run */
 	private final String invokableClassName;
@@ -54,13 +54,13 @@ public TaskInformation(
 			JobVertexID jobVertexId,
 			String taskName,
 			int numberOfSubtasks,
+			int maxNumberOfSubtasks,
 			String invokableClassName,
 			Configuration taskConfiguration) {
 		this.jobVertexId = Preconditions.checkNotNull(jobVertexId);
 		this.taskName = Preconditions.checkNotNull(taskName);
 		this.numberOfSubtasks = Preconditions.checkNotNull(numberOfSubtasks);
+		this.maxNumberOfSubtasks = Preconditions.checkNotNull(maxNumberOfSubtasks);
 		this.invokableClassName = Preconditions.checkNotNull(invokableClassName);
 		this.taskConfiguration = Preconditions.checkNotNull(taskConfiguration);
 	}
@@ -77,8 +77,8 @@ public int getNumberOfSubtasks() {
 		return numberOfSubtasks;
 	}
 
+	public int getMaxNumberOfSubtasks() {
+		return maxNumberOfSubtasks;
 	}
 
 	public String getInvokableClassName() {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>287599</refactoring_id><commit_sha>65b14ac2d6170e1b766f53a99cabd71ea79522de</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/65b14ac2d6170e1b766f53a99cabd71ea79522de</commit_link><file_path>source/ch/cyberduck/ui/cocoa/TransferController.java</file_path><description>Rename Method public startTransfer(transfer Transfer) : void renamed to public start(transfer Transfer) : void in class ch.cyberduck.ui.cocoa.TransferController</description><code_before>@@ -624,7 +624,7 @@ private void reload() {
      *
      * @param transfer Transfer
      */
-    public void addTransfer(final Transfer transfer, final BackgroundAction action) {
         final TransferCollection collection = TransferCollection.defaultCollection();
         if(collection.size() &gt; Preferences.instance().getInteger("queue.size.warn")) {
             final NSAlert alert = NSAlert.alert(
@@ -646,18 +646,18 @@ public void callback(int returncode) {
                     if(returncode == DEFAULT_OPTION) {
                         clearButtonClicked(null);
                     }
-                    addTransfer(transfer);
                     background(action);
                 }
             });
         }
         else {
-            this.addTransfer(transfer);
             this.background(action);
         }
     }
 
-    private void addTransfer(final Transfer transfer) {
         final TransferCollection collection = TransferCollection.defaultCollection();
         collection.add(transfer);
         final int row = collection.size() - 1;
@@ -669,15 +669,15 @@ private void addTransfer(final Transfer transfer) {
     /**
      * @param transfer Transfer
      */
-    public void startTransfer(final Transfer transfer) {
-        this.startTransfer(transfer, new TransferOptions());
     }
 
     /**
      * @param transfer Transfer
      */
-    public void startTransfer(final Transfer transfer, final TransferOptions options) {
-        this.startTransfer(transfer, options, new TransferCallback() {
             @Override
             public void complete(final Transfer transfer) {
                 //
@@ -688,7 +688,7 @@ public void complete(final Transfer transfer) {
     /**
      * @param transfer Transfer
      */
-    public void startTransfer(final Transfer transfer, final TransferOptions options, final TransferCallback callback) {
         final ProgressController progress = transferTableModel.getController(transfer);
         final BackgroundAction action = new TransferCollectionBackgroundAction(this,
                 progress, progress, transfer,
@@ -723,7 +723,7 @@ public void cleanup() {
             }
         };
         if(!TransferCollection.defaultCollection().contains(transfer)) {
-            this.addTransfer(transfer, action);
         }
         else {
             this.background(action);
@@ -865,7 +865,7 @@ public void paste(final ID sender) {
                         pasteboard.getSession().getHost().getDownloadFolder(),
                         download.getName()));
             }
-            this.addTransfer(new DownloadTransfer(session, pasteboard));
             pasteboard.clear();
         }
     }
@@ -919,7 +919,7 @@ public void resumeButtonClicked(final ID sender) {
                 final TransferOptions options = new TransferOptions();
                 options.resumeRequested = true;
                 options.reloadRequested = false;
-                this.startTransfer(transfer, options);
             }
         }
     }
@@ -934,7 +934,7 @@ public void reloadButtonClicked(final ID sender) {
                 final TransferOptions options = new TransferOptions();
                 options.resumeRequested = false;
                 options.reloadRequested = true;
-                this.startTransfer(transfer, options);
             }
         }
     }
</code_before><code_after>@@ -624,7 +624,7 @@ private void reload() {
      *
      * @param transfer Transfer
      */
+    public void add(final Transfer transfer, final BackgroundAction action) {
         final TransferCollection collection = TransferCollection.defaultCollection();
         if(collection.size() &gt; Preferences.instance().getInteger("queue.size.warn")) {
             final NSAlert alert = NSAlert.alert(
@@ -646,18 +646,18 @@ public void callback(int returncode) {
                     if(returncode == DEFAULT_OPTION) {
                         clearButtonClicked(null);
                     }
+                    add(transfer);
                     background(action);
                 }
             });
         }
         else {
+            this.add(transfer);
             this.background(action);
         }
     }
 
+    private void add(final Transfer transfer) {
         final TransferCollection collection = TransferCollection.defaultCollection();
         collection.add(transfer);
         final int row = collection.size() - 1;
@@ -669,15 +669,15 @@ private void addTransfer(final Transfer transfer) {
     /**
      * @param transfer Transfer
      */
+    public void start(final Transfer transfer) {
+        this.start(transfer, new TransferOptions());
     }
 
     /**
      * @param transfer Transfer
      */
+    public void start(final Transfer transfer, final TransferOptions options) {
+        this.start(transfer, options, new TransferCallback() {
             @Override
             public void complete(final Transfer transfer) {
                 //
@@ -688,7 +688,7 @@ public void complete(final Transfer transfer) {
     /**
      * @param transfer Transfer
      */
+    public void start(final Transfer transfer, final TransferOptions options, final TransferCallback callback) {
         final ProgressController progress = transferTableModel.getController(transfer);
         final BackgroundAction action = new TransferCollectionBackgroundAction(this,
                 progress, progress, transfer,
@@ -723,7 +723,7 @@ public void cleanup() {
             }
         };
         if(!TransferCollection.defaultCollection().contains(transfer)) {
+            this.add(transfer, action);
         }
         else {
             this.background(action);
@@ -865,7 +865,7 @@ public void paste(final ID sender) {
                         pasteboard.getSession().getHost().getDownloadFolder(),
                         download.getName()));
             }
+            this.add(new DownloadTransfer(session, pasteboard));
             pasteboard.clear();
         }
     }
@@ -919,7 +919,7 @@ public void resumeButtonClicked(final ID sender) {
                 final TransferOptions options = new TransferOptions();
                 options.resumeRequested = true;
                 options.reloadRequested = false;
+                this.start(transfer, options);
             }
         }
     }
@@ -934,7 +934,7 @@ public void reloadButtonClicked(final ID sender) {
                 final TransferOptions options = new TransferOptions();
                 options.resumeRequested = false;
                 options.reloadRequested = true;
+                this.start(transfer, options);
             }
         }
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>185647</refactoring_id><commit_sha>b1341bedcf55be1f5b46e0bb98ad3ed064bede70</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/b1341bedcf55be1f5b46e0bb98ad3ed064bede70</commit_link><file_path>src/test/java/com/google/devtools/build/lib/skyframe/BuiltinsInjectionTest.java</file_path><description>Rename Method public workspaceAndWorkspaceBzlDoNotUseInjection() : void renamed to public workspaceLoadedBzlUsesInjectionButNotWORKSPACE() : void in class com.google.devtools.build.lib.skyframe.BuiltinsInjectionTest</description><code_before>@@ -485,13 +485,8 @@ public void exportsBzlMayBeInErrorWhenInjectionIsDisabled() throws Exception {
     assertContainsEvent("In BUILD: overridable_rule :: &lt;built-in rule overridable_rule&gt;");
   }
 
-  // TODO(#11954): Once WORKSPACE- and BUILD-loaded bzls use the exact same environments, we'll want
-  // to apply injection to both. This is for uniformity, not because we actually care about builtins
-  // injection for WORKSPACE bzls. In the meantime, assert the status quo: WORKSPACE bzls do not use
-  // injection. WORKSPACE and BUILD files themselves probably won't be unified, so WORKSPACE will
-  // likely continue to not use injection.
   @Test
-  public void workspaceAndWorkspaceBzlDoNotUseInjection() throws Exception {
     writeExportsBzl(
         "exported_toplevels = {'overridable_symbol': 'new_value'}",
         "exported_rules = {'overridable_rule': 'new_rule'}",
@@ -510,9 +505,8 @@ public void workspaceAndWorkspaceBzlDoNotUseInjection() throws Exception {
         "print('In bzl: overridable_symbol :: %s' % overridable_symbol)");
 
     buildAndAssertSuccess();
-    // Builtins for WORKSPACE bzls are populated essentially the same as for BUILD bzls, except that
-    // injection doesn't apply.
-    assertContainsEvent("In bzl: overridable_symbol :: original_value");
     // We don't assert that the rule isn't injected because the workspace native object doesn't
     // contain our original mock rule. We can test this for WORKSPACE files at the top-level though.
     assertContainsEvent("In WORKSPACE: overridable_rule :: &lt;built-in function overridable_rule&gt;");
</code_before><code_after>@@ -485,13 +485,8 @@ public void exportsBzlMayBeInErrorWhenInjectionIsDisabled() throws Exception {
     assertContainsEvent("In BUILD: overridable_rule :: &lt;built-in rule overridable_rule&gt;");
   }
 
   @Test
+  public void workspaceLoadedBzlUsesInjectionButNotWORKSPACE() throws Exception {
     writeExportsBzl(
         "exported_toplevels = {'overridable_symbol': 'new_value'}",
         "exported_rules = {'overridable_rule': 'new_rule'}",
@@ -510,9 +505,8 @@ public void workspaceAndWorkspaceBzlDoNotUseInjection() throws Exception {
         "print('In bzl: overridable_symbol :: %s' % overridable_symbol)");
 
     buildAndAssertSuccess();
+    // Builtins for WORKSPACE bzls are populated the same as for BUILD bzls.
+    assertContainsEvent("In bzl: overridable_symbol :: new_value");
     // We don't assert that the rule isn't injected because the workspace native object doesn't
     // contain our original mock rule. We can test this for WORKSPACE files at the top-level though.
     assertContainsEvent("In WORKSPACE: overridable_rule :: &lt;built-in function overridable_rule&gt;");
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>239508</refactoring_id><commit_sha>7962a01a117a4d6f2137dd1ebf56f0651419f8be</commit_sha><commit_link>https://github.com/yuliskov/SmartTube/commit/7962a01a117a4d6f2137dd1ebf56f0651419f8be</commit_link><file_path>smartyoutubetv2/src/main/java/com/liskovsoft/smartyoutubetv2/tv/ui/common/UriBackgroundManager.java</file_path><description>Rename Method public setBackground(color int) : void renamed to public setBackgroundColor(color int) : void in class com.liskovsoft.smartyoutubetv2.tv.ui.common.UriBackgroundManager</description><code_before>@@ -30,7 +30,7 @@ public UriBackgroundManager(Activity activity) {
         mActivity = activity;
         mHandler = new Handler();
         prepareBackgroundManager();
-        setBackgroundDefault();
     }
 
     private void prepareBackgroundManager() {
@@ -57,12 +57,14 @@ public void startBackgroundTimer(String bgImageUrl) {
     public void updateBackground(Video item) {
         // ignore
         // startBackgroundTimer(item.bgImageUrl);
-        setBackgroundDefault();
     }
 
     public void onStart() {
         if (mBackgroundURI != null) {
             updateBackground(mBackgroundURI.toString());
         }
     }
 
@@ -79,11 +81,11 @@ public void removeBackground() {
         mBackgroundManager.setDrawable(null);
     }
 
-    public void setBackgroundDefault() {
         mBackgroundManager.setDrawable(mDefaultBackground);
     }
 
-    public void setBackground(int color) {
         mBackgroundManager.setColor(color);
     }
 
</code_before><code_after>@@ -30,7 +30,7 @@ public UriBackgroundManager(Activity activity) {
         mActivity = activity;
         mHandler = new Handler();
         prepareBackgroundManager();
+        setDefaultBackground();
     }
 
     private void prepareBackgroundManager() {
@@ -57,12 +57,14 @@ public void startBackgroundTimer(String bgImageUrl) {
     public void updateBackground(Video item) {
         // ignore
         // startBackgroundTimer(item.bgImageUrl);
+        setDefaultBackground();
     }
 
     public void onStart() {
         if (mBackgroundURI != null) {
             updateBackground(mBackgroundURI.toString());
+        } else {
+            setDefaultBackground();
         }
     }
 
@@ -79,11 +81,11 @@ public void removeBackground() {
         mBackgroundManager.setDrawable(null);
     }
 
+    public void setDefaultBackground() {
         mBackgroundManager.setDrawable(mDefaultBackground);
     }
 
+    public void setBackgroundColor(int color) {
         mBackgroundManager.setColor(color);
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>202503</refactoring_id><commit_sha>f7b1c375c1b354a6bee46022229963410aff24bd</commit_sha><commit_link>https://github.com/pmd/pmd/commit/f7b1c375c1b354a6bee46022229963410aff24bd</commit_link><file_path>pmd-scala-modules/pmd-scala-common/src/main/java/net/sourceforge/pmd/lang/scala/ast/ASTTermTryWithHandler.java</file_path><description>Rename Method public accept(visitor ScalaParserVisitor&lt;D,R&gt;, data D) : R renamed to protected acceptVisitor(visitor ScalaParserVisitor&lt;D,R&gt;, data D) : R in class net.sourceforge.pmd.lang.scala.ast.ASTTermTryWithHandler</description><code_before>@@ -16,7 +16,7 @@ public final class ASTTermTryWithHandler extends AbstractScalaNode&lt;Term.TryWithH
     }
 
     @Override
-    public &lt;D, R&gt; R accept(ScalaParserVisitor&lt;D, R&gt; visitor, D data) {
         return visitor.visit(this, data);
     }
 }
</code_before><code_after>@@ -16,7 +16,7 @@ public final class ASTTermTryWithHandler extends AbstractScalaNode&lt;Term.TryWithH
     }
 
     @Override
+    protected &lt;D, R&gt; R acceptVisitor(ScalaParserVisitor&lt;D, R&gt; visitor, D data) {
         return visitor.visit(this, data);
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>298538</refactoring_id><commit_sha>440f5f6c09720bb9414524781342bbf35973c281</commit_sha><commit_link>https://github.com/AutoMQ/automq/commit/440f5f6c09720bb9414524781342bbf35973c281</commit_link><file_path>clients/src/main/java/org/apache/kafka/common/record/MemoryRecords.java</file_path><description>Rename Method private createKraftControlReccordBuilder(initialOffset long, timestamp long, leaderEpoch int, buffer ByteBuffer) : MemoryRecordsBuilder renamed to private createKraftControlRecordBuilder(initialOffset long, timestamp long, leaderEpoch int, buffer ByteBuffer) : MemoryRecordsBuilder in class org.apache.kafka.common.record.MemoryRecords</description><code_before>@@ -730,7 +730,7 @@ public static MemoryRecords withLeaderChangeMessage(
         ByteBuffer buffer,
         LeaderChangeMessage leaderChangeMessage
     ) {
-        try (MemoryRecordsBuilder builder = createKraftControlReccordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -749,7 +749,7 @@ public static MemoryRecords withSnapshotHeaderRecord(
         ByteBuffer buffer,
         SnapshotHeaderRecord snapshotHeaderRecord
     ) {
-        try (MemoryRecordsBuilder builder = createKraftControlReccordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -768,7 +768,7 @@ public static MemoryRecords withSnapshotFooterRecord(
         ByteBuffer buffer,
         SnapshotFooterRecord snapshotFooterRecord
     ) {
-        try (MemoryRecordsBuilder builder = createKraftControlReccordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -787,7 +787,7 @@ public static MemoryRecords withKRaftVersionRecord(
         ByteBuffer buffer,
         KRaftVersionRecord kraftVersionRecord
     ) {
-        try (MemoryRecordsBuilder builder = createKraftControlReccordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -806,7 +806,7 @@ public static MemoryRecords withVotersRecord(
         ByteBuffer buffer,
         VotersRecord votersRecord
     ) {
-        try (MemoryRecordsBuilder builder = createKraftControlReccordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -818,7 +818,7 @@ public static MemoryRecords withVotersRecord(
         }
     }
 
-    private static MemoryRecordsBuilder createKraftControlReccordBuilder(
         long initialOffset,
         long timestamp,
         int leaderEpoch,
</code_before><code_after>@@ -730,7 +730,7 @@ public static MemoryRecords withLeaderChangeMessage(
         ByteBuffer buffer,
         LeaderChangeMessage leaderChangeMessage
     ) {
+        try (MemoryRecordsBuilder builder = createKraftControlRecordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -749,7 +749,7 @@ public static MemoryRecords withSnapshotHeaderRecord(
         ByteBuffer buffer,
         SnapshotHeaderRecord snapshotHeaderRecord
     ) {
+        try (MemoryRecordsBuilder builder = createKraftControlRecordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -768,7 +768,7 @@ public static MemoryRecords withSnapshotFooterRecord(
         ByteBuffer buffer,
         SnapshotFooterRecord snapshotFooterRecord
     ) {
+        try (MemoryRecordsBuilder builder = createKraftControlRecordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -787,7 +787,7 @@ public static MemoryRecords withKRaftVersionRecord(
         ByteBuffer buffer,
         KRaftVersionRecord kraftVersionRecord
     ) {
+        try (MemoryRecordsBuilder builder = createKraftControlRecordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -806,7 +806,7 @@ public static MemoryRecords withVotersRecord(
         ByteBuffer buffer,
         VotersRecord votersRecord
     ) {
+        try (MemoryRecordsBuilder builder = createKraftControlRecordBuilder(
                 initialOffset,
                 timestamp,
                 leaderEpoch,
@@ -818,7 +818,7 @@ public static MemoryRecords withVotersRecord(
         }
     }
 
+    private static MemoryRecordsBuilder createKraftControlRecordBuilder(
         long initialOffset,
         long timestamp,
         int leaderEpoch,
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>211077</refactoring_id><commit_sha>0d1cba4ee531b1280844b6ed27b211e552d1b651</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/0d1cba4ee531b1280844b6ed27b211e552d1b651</commit_link><file_path>servers/src/main/java/tachyon/master/next/filesystem/meta/InodeFile.java</file_path><description>Rename Method public writeJournalCheckpoint(outputStream JournalOutputStream) : void renamed to public writeToJournal(outputStream JournalOutputStream) : void in class tachyon.master.next.filesystem.meta.InodeFile</description><code_before>@@ -273,7 +273,7 @@ public String toString() {
   }
 
   @Override
-  public synchronized void writeJournalCheckpoint(JournalOutputStream outputStream)
       throws IOException {
     outputStream.writeEntry(new InodeFileEntry(getCreationTimeMs(), getId(), getName(),
         getParentId(), isPinned(), getLastModificationTimeMs(), getBlockSizeBytes(), getLength(),
</code_before><code_after>@@ -273,7 +273,7 @@ public String toString() {
   }
 
   @Override
+  public synchronized void writeToJournal(JournalOutputStream outputStream)
       throws IOException {
     outputStream.writeEntry(new InodeFileEntry(getCreationTimeMs(), getId(), getName(),
         getParentId(), isPinned(), getLastModificationTimeMs(), getBlockSizeBytes(), getLength(),
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>171164</refactoring_id><commit_sha>acca1dc9848161164364ce6f8b8abf30154372fd</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/acca1dc9848161164364ce6f8b8abf30154372fd</commit_link><file_path>broker-core/src/main/java/io/zeebe/broker/clustering/raft/RaftContext.java</file_path><description>Rename Method public getClientChannelPool() : ChannelManager renamed to public getServerTransport() : BufferingServerTransport in class io.zeebe.broker.clustering.raft.RaftContext</description><code_before>@@ -1,12 +1,10 @@
 package io.zeebe.broker.clustering.raft;
 
 import io.zeebe.broker.clustering.raft.state.LogStreamState;
-import io.zeebe.dispatcher.Dispatcher;
-import io.zeebe.dispatcher.Subscription;
 import io.zeebe.servicecontainer.ServiceContainer;
-import io.zeebe.transport.ChannelManager;
 import io.zeebe.transport.SocketAddress;
-import io.zeebe.transport.requestresponse.client.TransportConnectionPool;
 import io.zeebe.util.actor.ActorScheduler;
 
 public class RaftContext
@@ -17,10 +15,9 @@ public class RaftContext
     private ServiceContainer serviceContainer;
     private ActorScheduler actorScheduler;
     private SocketAddress raftEndpoint;
-    private Subscription subscription;
-    private ChannelManager clientChannelManager;
-    private TransportConnectionPool connections;
-    private Dispatcher sendBuffer;
 
     public Raft getRaft()
     {
@@ -52,43 +49,24 @@ public void setRaftEndpoint(SocketAddress raftEndpoint)
         this.raftEndpoint = raftEndpoint;
     }
 
-    public Subscription getSubscription()
-    {
-        return subscription;
-    }
-    public void setSubscription(Subscription subscription)
-    {
-        this.subscription = subscription;
-    }
-
-    public ChannelManager getClientChannelPool()
-    {
-        return clientChannelManager;
-    }
-
-    public void setClientChannelPool(ChannelManager clientChannelManager)
-    {
-        this.clientChannelManager = clientChannelManager;
-    }
-
-    public TransportConnectionPool getConnections()
     {
-        return connections;
     }
 
-    public void setConnections(TransportConnectionPool connections)
     {
-        this.connections = connections;
     }
 
-    public Dispatcher getSendBuffer()
     {
-        return sendBuffer;
     }
 
-    public void setSendBuffer(Dispatcher sendBuffer)
     {
-        this.sendBuffer = sendBuffer;
     }
 
     public ActorScheduler getTaskScheduler()
</code_before><code_after>@@ -1,12 +1,10 @@
 package io.zeebe.broker.clustering.raft;
 
 import io.zeebe.broker.clustering.raft.state.LogStreamState;
 import io.zeebe.servicecontainer.ServiceContainer;
+import io.zeebe.transport.BufferingServerTransport;
+import io.zeebe.transport.ClientTransport;
 import io.zeebe.transport.SocketAddress;
 import io.zeebe.util.actor.ActorScheduler;
 
 public class RaftContext
@@ -17,10 +15,9 @@ public class RaftContext
     private ServiceContainer serviceContainer;
     private ActorScheduler actorScheduler;
     private SocketAddress raftEndpoint;
+
+    protected ClientTransport clientTransport;
+    protected BufferingServerTransport serverTransport;
 
     public Raft getRaft()
     {
@@ -52,43 +49,24 @@ public void setRaftEndpoint(SocketAddress raftEndpoint)
         this.raftEndpoint = raftEndpoint;
     }
 
+    public ClientTransport getClientTransport()
     {
+        return clientTransport;
     }
 
+    public void setClientTransport(ClientTransport clientTransport)
     {
+        this.clientTransport = clientTransport;
     }
 
+    public BufferingServerTransport getServerTransport()
     {
+        return serverTransport;
     }
 
+    public void setServerTransport(BufferingServerTransport serverTransport)
     {
+        this.serverTransport = serverTransport;
     }
 
     public ActorScheduler getTaskScheduler()
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>309704</refactoring_id><commit_sha>a510e3bff1bfdbc13e04f94182776d4955bdcb22</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/a510e3bff1bfdbc13e04f94182776d4955bdcb22</commit_link><file_path>engine/src/main/java/org/terasology/rendering/assets/font/FontImpl.java</file_path><description>Rename Method public dispose() : void renamed to public onDispose() : void in class org.terasology.rendering.assets.font.FontImpl</description><code_before>@@ -99,7 +99,7 @@ public FontCharacter getCharacterData(Character c) {
     }
 
     @Override
-    public void dispose() {
         this.data = null;
     }
 
</code_before><code_after>@@ -99,7 +99,7 @@ public FontCharacter getCharacterData(Character c) {
     }
 
     @Override
+    public void onDispose() {
         this.data = null;
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>267690</refactoring_id><commit_sha>0eb0267131ec378dc7ca65e8442802cad9f26424</commit_sha><commit_link>https://github.com/androidx/media/commit/0eb0267131ec378dc7ca65e8442802cad9f26424</commit_link><file_path>library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java</file_path><description>Rename Method public onLoadingChanged(isLoading boolean) : void renamed to public onIsLoadingChanged(isLoading boolean) : void in class com.google.android.exoplayer2.SimpleExoPlayer.ComponentListener</description><code_before>@@ -1931,7 +1931,7 @@ public void onAudioBecomingNoisy() {
     // Player.EventListener implementation.
 
     @Override
-    public void onLoadingChanged(boolean isLoading) {
       if (priorityTaskManager != null) {
         if (isLoading &amp;&amp; !isPriorityTaskManagerRegistered) {
           priorityTaskManager.add(C.PRIORITY_PLAYBACK);
</code_before><code_after>@@ -1931,7 +1931,7 @@ public void onAudioBecomingNoisy() {
     // Player.EventListener implementation.
 
     @Override
+    public void onIsLoadingChanged(boolean isLoading) {
       if (priorityTaskManager != null) {
         if (isLoading &amp;&amp; !isPriorityTaskManagerRegistered) {
           priorityTaskManager.add(C.PRIORITY_PLAYBACK);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>143134</refactoring_id><commit_sha>3f398755adf5d3ab2044098fbe75423f14244943</commit_sha><commit_link>https://github.com/bisq-network/bisq/commit/3f398755adf5d3ab2044098fbe75423f14244943</commit_link><file_path>src/main/java/io/bitsquare/bank/BankAccount.java</file_path><description>Rename Method public getShortName() : String renamed to public getAccountTitle() : String in class io.bitsquare.bank.BankAccount</description><code_before>@@ -18,23 +18,26 @@ public class BankAccount implements Serializable
     private Currency currency;
     private String uid;
 
-    // TODO just for mock yet
-    public BankAccount(BankAccountType bankAccountType)
-    {
-        this.bankAccountType = bankAccountType;
 
-    }
 
-    public BankAccount(BankAccountType bankAccountType, String accountPrimaryID, String accountSecondaryID, String accountHolderName, Locale countryLocale, Currency currency)
     {
         this.bankAccountType = bankAccountType;
         this.accountPrimaryID = accountPrimaryID;
         this.accountSecondaryID = accountSecondaryID;
-        this.accountHolderName = accountHolderName;
-        this.countryLocale = countryLocale;
-        this.currency = currency;
 
-        uid = bankAccountType + "_" + accountPrimaryID + "_" + accountSecondaryID + "_" + accountHolderName + "_" + countryLocale.getISO3Country();
     }
 
     public String getAccountPrimaryID()
@@ -72,6 +75,11 @@ public String getUid()
         return uid;
     }
 
     // Changes of that structure must be reflected in VERSION updates
     public String getStringifiedBankAccount()
     {
@@ -81,15 +89,9 @@ public String getStringifiedBankAccount()
                 ", secondaryID='" + accountSecondaryID + '\'' +
                 ", holderName='" + accountHolderName + '\'' +
                 ", currency='" + currency.getCurrencyCode() + '\'' +
-                ", country='" + countryLocale.getISO3Country() + '\'' +
                 ", v='" + VERSION + '\'' +
                 '}';
     }
 
-    public String getShortName()
-    {
-        return bankAccountType + " " + accountPrimaryID + " / " + accountSecondaryID + " / " + currency.getCurrencyCode();
-    }
-
-
 }
</code_before><code_after>@@ -18,23 +18,26 @@ public class BankAccount implements Serializable
     private Currency currency;
     private String uid;
 
 
+    private String accountTitle;
 
+    public BankAccount(BankAccountType bankAccountType,
+                       Currency currency,
+                       Locale countryLocale,
+                       String accountTitle,
+                       String accountHolderName,
+                       String accountPrimaryID,
+                       String accountSecondaryID)
     {
         this.bankAccountType = bankAccountType;
+        this.currency = currency;
+        this.countryLocale = countryLocale;
+        this.accountTitle = accountTitle;
+        this.accountHolderName = accountHolderName;
         this.accountPrimaryID = accountPrimaryID;
         this.accountSecondaryID = accountSecondaryID;
 
+        uid = bankAccountType + "_" + accountPrimaryID + "_" + accountSecondaryID + "_" + accountHolderName + "_" + countryLocale.getCountry();
     }
 
     public String getAccountPrimaryID()
@@ -72,6 +75,11 @@ public String getUid()
         return uid;
     }
 
+    public String getAccountTitle()
+    {
+        return accountTitle;
+    }
+
     // Changes of that structure must be reflected in VERSION updates
     public String getStringifiedBankAccount()
     {
@@ -81,15 +89,9 @@ public String getStringifiedBankAccount()
                 ", secondaryID='" + accountSecondaryID + '\'' +
                 ", holderName='" + accountHolderName + '\'' +
                 ", currency='" + currency.getCurrencyCode() + '\'' +
+                ", country='" + countryLocale.getCountry() + '\'' +
                 ", v='" + VERSION + '\'' +
                 '}';
     }
 
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>244291</refactoring_id><commit_sha>b3e36a335d98945f8bf04ebb80ebe31664283720</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/b3e36a335d98945f8bf04ebb80ebe31664283720</commit_link><file_path>org.springframework.core/src/main/java/org/springframework/core/env/AbstractEnvironment.java</file_path><description>Rename Method public setDefaultProfile(defaultProfile String) : void renamed to public setDefaultProfiles(profiles String...) : void in class org.springframework.core.env.AbstractEnvironment</description><code_before>@@ -40,6 +40,7 @@
 import org.springframework.core.convert.support.ConversionServiceFactory;
 import org.springframework.util.PropertyPlaceholderHelper;
 import org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver;
 
 
 /**
@@ -51,32 +52,23 @@
 public abstract class AbstractEnvironment implements ConfigurableEnvironment {
 
 	public static final String ACTIVE_PROFILES_PROPERTY_NAME = "spring.profile.active";
 
-	public static final String DEFAULT_PROFILE_PROPERTY_NAME = "spring.profile.default";
 
-	/**
-	 * Default name of the default profile. Override with
-	 * {@link #setDefaultProfile(String)}.
-	 *
-	 * @see #setDefaultProfile(String)
-	 */
-	public static final String DEFAULT_PROFILE_NAME = "default";
 
-	protected final Log logger = LogFactory.getLog(getClass());
 
 	private final PropertyPlaceholderHelper nonStrictHelper =
 		new PropertyPlaceholderHelper(PLACEHOLDER_PREFIX, PLACEHOLDER_SUFFIX, VALUE_SEPARATOR, true);
 
 	private final PropertyPlaceholderHelper strictHelper =
 		new PropertyPlaceholderHelper(PLACEHOLDER_PREFIX, PLACEHOLDER_SUFFIX, VALUE_SEPARATOR, false);
 
-	private Set&lt;String&gt; activeProfiles = new LinkedHashSet&lt;String&gt;();
-	private LinkedList&lt;PropertySource&lt;?&gt;&gt; propertySources = new LinkedList&lt;PropertySource&lt;?&gt;&gt;();
-	private ConversionService conversionService = ConversionServiceFactory.createDefaultConversionService();
 
-	private boolean explicitlySetProfiles;
-
-	private String defaultProfile = DEFAULT_PROFILE_NAME;
 
 
 	public void addPropertySource(PropertySource&lt;?&gt; propertySource) {
@@ -187,26 +179,33 @@ public Properties asProperties() {
 	}
 
 	public Set&lt;String&gt; getActiveProfiles() {
-		doGetProfiles();
 		return Collections.unmodifiableSet(activeProfiles);
 	}
 
-	private void doGetProfiles() {
-		if (explicitlySetProfiles)
-			return;
 
-		String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);
-		if (profiles == null || profiles.equals("")) {
-			return;
 		}
-
-		this.activeProfiles = commaDelimitedListToSet(trimAllWhitespace(profiles));
 	}
 
-	public void setActiveProfiles(String... profiles) {
-		explicitlySetProfiles = true;
-		this.activeProfiles.clear();
-		this.activeProfiles.addAll(Arrays.asList(profiles));
 	}
 
 	public Map&lt;String, String&gt; getSystemEnvironment() {
@@ -282,28 +281,17 @@ public String resolveRequiredPlaceholders(String text) {
 	public boolean acceptsProfiles(String[] specifiedProfiles) {
 		boolean activeProfileFound = false;
 		Set&lt;String&gt; activeProfiles = this.getActiveProfiles();
 		for (String profile : specifiedProfiles) {
 			if (activeProfiles.contains(profile)
-					|| (activeProfiles.isEmpty() &amp;&amp; profile.equals(this.getDefaultProfile()))) {
 				activeProfileFound = true;
 				break;
 			}
 		}
 		return activeProfileFound;
 	}
 
-	public String getDefaultProfile() {
-		String defaultProfileProperty = getProperty(DEFAULT_PROFILE_PROPERTY_NAME);
-		if (defaultProfileProperty != null) {
-			return defaultProfileProperty;
-		}
-		return defaultProfile;
-	}
-
-	public void setDefaultProfile(String defaultProfile) {
-		this.defaultProfile = defaultProfile;
-	}
-
 	private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {
 		return helper.replacePlaceholders(text, new PlaceholderResolver() {
 			public String resolvePlaceholder(String placeholderName) {
@@ -314,8 +302,8 @@ public String resolvePlaceholder(String placeholderName) {
 
 	@Override
 	public String toString() {
-		return getClass().getSimpleName() + " [activeProfiles=" + activeProfiles
-			+ ", propertySources=" + propertySources + "]";
 	}
 
 }
</code_before><code_after>@@ -40,6 +40,7 @@
 import org.springframework.core.convert.support.ConversionServiceFactory;
 import org.springframework.util.PropertyPlaceholderHelper;
 import org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver;
+import org.springframework.util.StringUtils;
 
 
 /**
@@ -51,32 +52,23 @@
 public abstract class AbstractEnvironment implements ConfigurableEnvironment {
 
 	public static final String ACTIVE_PROFILES_PROPERTY_NAME = "spring.profile.active";
+	public static final String DEFAULT_PROFILES_PROPERTY_NAME = "spring.profile.default";
 
+	protected final Log logger = LogFactory.getLog(getClass());
 
+	private Set&lt;String&gt; activeProfiles = new LinkedHashSet&lt;String&gt;();
+	private Set&lt;String&gt; defaultProfiles = new LinkedHashSet&lt;String&gt;();
 
+	private LinkedList&lt;PropertySource&lt;?&gt;&gt; propertySources = new LinkedList&lt;PropertySource&lt;?&gt;&gt;();
+	private ConversionService conversionService = ConversionServiceFactory.createDefaultConversionService();
 
 	private final PropertyPlaceholderHelper nonStrictHelper =
 		new PropertyPlaceholderHelper(PLACEHOLDER_PREFIX, PLACEHOLDER_SUFFIX, VALUE_SEPARATOR, true);
 
 	private final PropertyPlaceholderHelper strictHelper =
 		new PropertyPlaceholderHelper(PLACEHOLDER_PREFIX, PLACEHOLDER_SUFFIX, VALUE_SEPARATOR, false);
 
 
 
 
 	public void addPropertySource(PropertySource&lt;?&gt; propertySource) {
@@ -187,26 +179,33 @@ public Properties asProperties() {
 	}
 
 	public Set&lt;String&gt; getActiveProfiles() {
+		if (this.activeProfiles.isEmpty()) {
+			String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);
+			if (StringUtils.hasText(profiles)) {
+				this.activeProfiles = commaDelimitedListToSet(trimAllWhitespace(profiles));
+			}
+		}
 		return Collections.unmodifiableSet(activeProfiles);
 	}
 
+	public void setActiveProfiles(String... profiles) {
+		this.activeProfiles.clear();
+		this.activeProfiles.addAll(Arrays.asList(profiles));
+	}
 
+	public Set&lt;String&gt; getDefaultProfiles() {
+		if (this.defaultProfiles.isEmpty()) {
+			String profiles = getProperty(DEFAULT_PROFILES_PROPERTY_NAME);
+			if (StringUtils.hasText(profiles)) {
+				this.defaultProfiles = commaDelimitedListToSet(profiles);
+			}
 		}
+		return Collections.unmodifiableSet(this.defaultProfiles);
 	}
 
+	public void setDefaultProfiles(String... profiles) {
+		this.defaultProfiles.clear();
+		this.defaultProfiles.addAll(Arrays.asList(profiles));
 	}
 
 	public Map&lt;String, String&gt; getSystemEnvironment() {
@@ -282,28 +281,17 @@ public String resolveRequiredPlaceholders(String text) {
 	public boolean acceptsProfiles(String[] specifiedProfiles) {
 		boolean activeProfileFound = false;
 		Set&lt;String&gt; activeProfiles = this.getActiveProfiles();
+		Set&lt;String&gt; defaultProfiles = this.getDefaultProfiles();
 		for (String profile : specifiedProfiles) {
 			if (activeProfiles.contains(profile)
+					|| (activeProfiles.isEmpty() &amp;&amp; defaultProfiles.contains(profile))) {
 				activeProfileFound = true;
 				break;
 			}
 		}
 		return activeProfileFound;
 	}
 
 	private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {
 		return helper.replacePlaceholders(text, new PlaceholderResolver() {
 			public String resolvePlaceholder(String placeholderName) {
@@ -314,8 +302,8 @@ public String resolvePlaceholder(String placeholderName) {
 
 	@Override
 	public String toString() {
+		return String.format("%s [activeProfiles=%s, defaultProfiles=%s, propertySources=%s]",
+				getClass().getSimpleName(), activeProfiles, defaultProfiles, propertySources);
 	}
 
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>133796</refactoring_id><commit_sha>6b485b8603610e33be63069881a9806dc0ba424e</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/6b485b8603610e33be63069881a9806dc0ba424e</commit_link><file_path>operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakStatus.java</file_path><description>Rename Method public clone() : KeycloakStatus renamed to public equals(o Object) : boolean in class org.keycloak.operator.v2alpha1.crds.KeycloakStatus</description><code_before>@@ -16,46 +16,33 @@
  */
 package org.keycloak.operator.v2alpha1.crds;
 
-public class KeycloakStatus {
-    public enum State {
-        READY,
-        ERROR,
-        UNKNOWN
-    }
-
-    private State state = State.UNKNOWN;
-    private boolean error;
-    private String message;
-
-    public State getState() {
-        return state;
-    }
 
-    public void setState(State state) {
-        this.state = state;
-    }
-
-    public boolean isError() {
-        return error;
-    }
 
-    public void setError(boolean error) {
-        this.error = error;
     }
 
-    public String getMessage() {
-        return message;
     }
 
-    public void setMessage(String message) {
-        this.message = message;
     }
 
-    public KeycloakStatus clone() {
-        var status = new KeycloakStatus();
-        status.setMessage(this.message);
-        status.setState(this.state);
-        status.setError(this.error);
-        return status;
     }
 }
</code_before><code_after>@@ -16,46 +16,33 @@
  */
 package org.keycloak.operator.v2alpha1.crds;
 
+import java.util.List;
+import java.util.Objects;
 
+/**
+ * @author Vaclav Muzikar &lt;vmuzikar@redhat.com&gt;
+ */
+public class KeycloakStatus {
+    private List&lt;KeycloakStatusCondition&gt; conditions;
 
+    public List&lt;KeycloakStatusCondition&gt; getConditions() {
+        return conditions;
     }
 
+    public void setConditions(List&lt;KeycloakStatusCondition&gt; conditions) {
+        this.conditions = conditions;
     }
 
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        KeycloakStatus status = (KeycloakStatus) o;
+        return Objects.equals(getConditions(), status.getConditions());
     }
 
+    @Override
+    public int hashCode() {
+        return Objects.hash(getConditions());
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>312452</refactoring_id><commit_sha>94cf5fbf95f1e4951ad138da799fd5c24e11368b</commit_sha><commit_link>https://github.com/apereo/cas/commit/94cf5fbf95f1e4951ad138da799fd5c24e11368b</commit_link><file_path>cas-server-support-x509/src/test/java/org/jasig/cas/adaptors/x509/authentication/principal/X509SubjectDNPrincipalResolverTests.java</file_path><description>Rename Method public testResolvePrincipalInternal() : void renamed to public verifyResolvePrincipalInternal() : void in class org.jasig.cas.adaptors.x509.authentication.principal.X509SubjectDNPrincipalResolverTests</description><code_before>@@ -37,20 +37,20 @@ public class X509SubjectDNPrincipalResolverTests extends AbstractX509Certificate
         resolver = new X509SubjectDNPrincipalResolver();
 
     @Test
-    public void testResolvePrincipalInternal() {
         final X509CertificateCredential c = new X509CertificateCredential(new X509Certificate[] {VALID_CERTIFICATE});
         c.setCertificate(VALID_CERTIFICATE);
         assertEquals(VALID_CERTIFICATE.getSubjectDN().getName(), this.resolver.resolve(c).getId());
     }
 
     @Test
-    public void testSupport() {
         final X509CertificateCredential c = new X509CertificateCredential(new X509Certificate[] {VALID_CERTIFICATE});
         assertTrue(this.resolver.supports(c));
     }
 
     @Test
-    public void testSupportFalse() {
         assertFalse(this.resolver.supports(new UsernamePasswordCredential()));
     }
 
</code_before><code_after>@@ -37,20 +37,20 @@ public class X509SubjectDNPrincipalResolverTests extends AbstractX509Certificate
         resolver = new X509SubjectDNPrincipalResolver();
 
     @Test
+    public void verifyResolvePrincipalInternal() {
         final X509CertificateCredential c = new X509CertificateCredential(new X509Certificate[] {VALID_CERTIFICATE});
         c.setCertificate(VALID_CERTIFICATE);
         assertEquals(VALID_CERTIFICATE.getSubjectDN().getName(), this.resolver.resolve(c).getId());
     }
 
     @Test
+    public void verifySupport() {
         final X509CertificateCredential c = new X509CertificateCredential(new X509Certificate[] {VALID_CERTIFICATE});
         assertTrue(this.resolver.supports(c));
     }
 
     @Test
+    public void verifySupportFalse() {
         assertFalse(this.resolver.supports(new UsernamePasswordCredential()));
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>258484</refactoring_id><commit_sha>3b914b0d7df19dc0d53bcb480f9322c1184aa215</commit_sha><commit_link>https://github.com/micronaut-projects/micronaut-core/commit/3b914b0d7df19dc0d53bcb480f9322c1184aa215</commit_link><file_path>router/src/main/groovy/org/particleframework/context/router/RouteBuilder.java</file_path><description>Rename Method public PUT(uri String, type Class, method String) : Route renamed to public DELETE(uri String, type Class, method String, parameterTypes Class...) : Route in class org.particleframework.context.router.RouteBuilder</description><code_before>@@ -18,6 +18,8 @@
 import org.particleframework.core.naming.conventions.PropertyConvention;
 import org.particleframework.core.naming.conventions.TypeConvention;
 
 import static org.particleframework.core.naming.conventions.MethodConvention.*;
 /**
  *
@@ -32,7 +34,10 @@ public interface RouteBuilder {
      */
     PropertyConvention ID = PropertyConvention.ID;
 
-
     /**
      * @return The URI naming strategy
      */
@@ -209,7 +214,7 @@ default Route GET(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route GET(String uri, Object target, String method);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -221,7 +226,7 @@ default Route GET(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route GET(String uri, Class&lt;?&gt; type, String method);
 
     /**
      * Route the specified URI to the specified target for an HTTP POST. Since the method to execute is not
@@ -231,7 +236,7 @@ default Route GET(Class type, PropertyConvention id) {
      * @param target The target object
      * @return The route
      */
-    default Route POST(String uri, Object target) {
         return POST(uri, target, SAVE.lowerCaseName());
     }
 
@@ -287,7 +292,7 @@ default Route POST(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route POST(String uri, Object target, String method);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -299,7 +304,7 @@ default Route POST(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route POST(String uri, Class type, String method);
 
     /**
      * Route the specified URI to the specified target for an HTTP PUT. Since the method to execute is not
@@ -365,7 +370,7 @@ default Route PUT(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route PUT(String uri, Object target, String method);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -377,7 +382,7 @@ default Route PUT(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route PUT(String uri, Class type, String method);
 
     /**
      * Route the specified URI to the specified target for an HTTP PATCH. Since the method to execute is not
@@ -443,7 +448,7 @@ default Route PATCH(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route PATCH(String uri, Object target, String method);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -455,7 +460,7 @@ default Route PATCH(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route PATCH(String uri, Class type, String method);
 
     /**
      * Route the specified URI to the specified target for an HTTP DELETE. Since the method to execute is not
@@ -521,7 +526,7 @@ default Route DELETE(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route DELETE(String uri, Object target, String method);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -533,7 +538,7 @@ default Route DELETE(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route DELETE(String uri, Class type, String method);
 
     /**
      * Route the specified URI to the specified target for an HTTP OPTIONS. Since the method to execute is not
@@ -599,7 +604,7 @@ default Route OPTIONS(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route OPTIONS(String uri, Object target, String method);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -611,7 +616,7 @@ default Route OPTIONS(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route OPTIONS(String uri, Class type, String method);
 
     /**
      * Route the specified URI to the specified target for an HTTP GET. Since the method to execute is not
@@ -677,7 +682,7 @@ default Route HEAD(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route HEAD(String uri, Object target, String method);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -689,7 +694,7 @@ default Route HEAD(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
-    Route HEAD(String uri, Class type, String method);
 
     /**
      * &lt;p&gt;A URI naming strategy is used to dictate the default name to use when building a URI for a class&lt;/p&gt;
</code_before><code_after>@@ -18,6 +18,8 @@
 import org.particleframework.core.naming.conventions.PropertyConvention;
 import org.particleframework.core.naming.conventions.TypeConvention;
 
+import java.util.List;
+
 import static org.particleframework.core.naming.conventions.MethodConvention.*;
 /**
  *
@@ -32,7 +34,10 @@ public interface RouteBuilder {
      */
     PropertyConvention ID = PropertyConvention.ID;
 
+    /**
+     * @return Obtain a list of constructed routes
+     */
+    List&lt;Route&gt; getConstructedRoutes();
     /**
      * @return The URI naming strategy
      */
@@ -209,7 +214,7 @@ default Route GET(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route GET(String uri, Object target, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -221,7 +226,7 @@ default Route GET(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route GET(String uri, Class&lt;?&gt; type, String method, Class...parameterTypes);
 
     /**
      * Route the specified URI to the specified target for an HTTP POST. Since the method to execute is not
@@ -231,7 +236,7 @@ default Route GET(Class type, PropertyConvention id) {
      * @param target The target object
      * @return The route
      */
+    default Route POST(String uri, Object target, Class...parameterTypes) {
         return POST(uri, target, SAVE.lowerCaseName());
     }
 
@@ -287,7 +292,7 @@ default Route POST(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route POST(String uri, Object target, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -299,7 +304,7 @@ default Route POST(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route POST(String uri, Class type, String method, Class...parameterTypes);
 
     /**
      * Route the specified URI to the specified target for an HTTP PUT. Since the method to execute is not
@@ -365,7 +370,7 @@ default Route PUT(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route PUT(String uri, Object target, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -377,7 +382,7 @@ default Route PUT(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route PUT(String uri, Class type, String method, Class...parameterTypes);
 
     /**
      * Route the specified URI to the specified target for an HTTP PATCH. Since the method to execute is not
@@ -443,7 +448,7 @@ default Route PATCH(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route PATCH(String uri, Object target, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -455,7 +460,7 @@ default Route PATCH(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route PATCH(String uri, Class type, String method, Class...parameterTypes);
 
     /**
      * Route the specified URI to the specified target for an HTTP DELETE. Since the method to execute is not
@@ -521,7 +526,7 @@ default Route DELETE(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route DELETE(String uri, Object target, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -533,7 +538,7 @@ default Route DELETE(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route DELETE(String uri, Class type, String method, Class...parameterTypes);
 
     /**
      * Route the specified URI to the specified target for an HTTP OPTIONS. Since the method to execute is not
@@ -599,7 +604,7 @@ default Route OPTIONS(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route OPTIONS(String uri, Object target, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -611,7 +616,7 @@ default Route OPTIONS(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route OPTIONS(String uri, Class type, String method, Class...parameterTypes);
 
     /**
      * Route the specified URI to the specified target for an HTTP GET. Since the method to execute is not
@@ -677,7 +682,7 @@ default Route HEAD(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route HEAD(String uri, Object target, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;Route the specified URI template to the specified target.&lt;/p&gt;
@@ -689,7 +694,7 @@ default Route HEAD(Class type, PropertyConvention id) {
      * @param method The method
      * @return The route
      */
+    Route HEAD(String uri, Class type, String method, Class...parameterTypes);
 
     /**
      * &lt;p&gt;A URI naming strategy is used to dictate the default name to use when building a URI for a class&lt;/p&gt;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>167650</refactoring_id><commit_sha>9c9726c65edc64b7fdd6ebcb198e6eec10df2a4b</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/9c9726c65edc64b7fdd6ebcb198e6eec10df2a4b</commit_link><file_path>backend/src/it/java/org/camunda/optimize/service/es/retrieval/SingleReportHandlingIT.java</file_path><description>Rename Method private getAllReportsWithQueryParam(queryParams Map&lt;String,Object&gt;) : List&lt;ReportDefinitionDto&gt; renamed to private getAllPrivateReportsWithQueryParam(queryParams Map&lt;String,Object&gt;) : List&lt;ReportDefinitionDto&gt; in class org.camunda.optimize.service.es.retrieval.SingleReportHandlingIT</description><code_before>@@ -112,7 +112,7 @@ public void writeAndThenReadGivesTheSameResult() {
     String id = createNewReport();
 
     // when
-    List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports, is(notNullValue()));
@@ -130,7 +130,7 @@ public void createAndGetSeveralReports() {
     ids.add(id2);
 
     // when
-    List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports, is(notNullValue()));
@@ -146,7 +146,7 @@ public void createAndGetSeveralReports() {
   public void noReportAvailableReturnsEmptyList() {
 
     // when
-    List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports, is(notNullValue()));
@@ -181,7 +181,7 @@ public void testUpdateProcessReport() {
 
     // when
     updateSingleProcessReport(id, report);
-    List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -223,7 +223,7 @@ public void testUpdateProcessReportRemoveHeatMapTargetValue() {
     // when
     configuration.getHeatmapTargetValue().setValues(new HashMap&lt;&gt;());
     updateSingleProcessReport(id, report);
-    final List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -255,7 +255,7 @@ public void testUpdateDecisionReportWithGroupByInputVariableName() {
 
     // when
     updateSingleDecisionReport(id, report);
-    List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -332,7 +332,7 @@ public void updateReportWithFilters() {
 
     // when
     updateSingleProcessReport(id, report);
-    List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -370,7 +370,7 @@ public void doNotUpdateNullFieldsInReport() {
 
     // when
     updateSingleProcessReport(id, report);
-    List&lt;ReportDefinitionDto&gt; reports = getAllReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -452,7 +452,7 @@ public void resultListIsSortedByName() {
     // when
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("orderBy", "name");
-    List&lt;ReportDefinitionDto&gt; reports = getAllReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -462,7 +462,7 @@ public void resultListIsSortedByName() {
 
     // when
     queryParam.put("sortOrder", "desc");
-    reports = getAllReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -485,7 +485,7 @@ public void resultListIsSortedByLastModified() {
     // when
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("orderBy", "lastModified");
-    List&lt;ReportDefinitionDto&gt; reports = getAllReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -495,7 +495,7 @@ public void resultListIsSortedByLastModified() {
 
     //when
     queryParam.put("sortOrder", "desc");
-    reports = getAllReportsWithQueryParam(queryParam);
     // then
     assertThat(reports.size(), is(3));
     assertThat(reports.get(0).getId(), is(id2));
@@ -518,7 +518,7 @@ public void resultListIsReversed() {
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("orderBy", "lastModified");
     queryParam.put("sortOrder", "desc");
-    List&lt;ReportDefinitionDto&gt; reports = getAllReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -542,7 +542,7 @@ public void resultListIsCutByAnOffset() {
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("resultOffset", 1);
     queryParam.put("orderBy", "lastModified");
-    List&lt;ReportDefinitionDto&gt; reports = getAllReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(2));
@@ -574,7 +574,7 @@ public void resultListIsCutByMaxResults() {
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("numResults", 2);
     queryParam.put("orderBy", "lastModified");
-    List&lt;ReportDefinitionDto&gt; reports = getAllReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(2));
@@ -599,7 +599,7 @@ public void combineAllResultListQueryParameterRestrictions() {
     queryParam.put("orderBy", "lastModified");
     queryParam.put("reverseOrder", true);
     queryParam.put("resultOffset", 1);
-    List&lt;ReportDefinitionDto&gt; reports = getAllReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(1));
@@ -651,14 +651,14 @@ private AuthorizedProcessReportEvaluationResultDto&lt;RawDataProcessReportResultDto
     // @formatter:on
   }
 
-  private List&lt;ReportDefinitionDto&gt; getAllReports() {
-    return getAllReportsWithQueryParam(new HashMap&lt;&gt;());
   }
 
-  private List&lt;ReportDefinitionDto&gt; getAllReportsWithQueryParam(Map&lt;String, Object&gt; queryParams) {
     return embeddedOptimizeExtensionRule
       .getRequestExecutor()
-      .buildGetAllReportsRequest()
       .addQueryParams(queryParams)
       .executeAndReturnList(ReportDefinitionDto.class, 200);
   }
</code_before><code_after>@@ -112,7 +112,7 @@ public void writeAndThenReadGivesTheSameResult() {
     String id = createNewReport();
 
     // when
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports, is(notNullValue()));
@@ -130,7 +130,7 @@ public void createAndGetSeveralReports() {
     ids.add(id2);
 
     // when
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports, is(notNullValue()));
@@ -146,7 +146,7 @@ public void createAndGetSeveralReports() {
   public void noReportAvailableReturnsEmptyList() {
 
     // when
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports, is(notNullValue()));
@@ -181,7 +181,7 @@ public void testUpdateProcessReport() {
 
     // when
     updateSingleProcessReport(id, report);
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -223,7 +223,7 @@ public void testUpdateProcessReportRemoveHeatMapTargetValue() {
     // when
     configuration.getHeatmapTargetValue().setValues(new HashMap&lt;&gt;());
     updateSingleProcessReport(id, report);
+    final List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -255,7 +255,7 @@ public void testUpdateDecisionReportWithGroupByInputVariableName() {
 
     // when
     updateSingleDecisionReport(id, report);
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -332,7 +332,7 @@ public void updateReportWithFilters() {
 
     // when
     updateSingleProcessReport(id, report);
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -370,7 +370,7 @@ public void doNotUpdateNullFieldsInReport() {
 
     // when
     updateSingleProcessReport(id, report);
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReports();
 
     // then
     assertThat(reports.size(), is(1));
@@ -452,7 +452,7 @@ public void resultListIsSortedByName() {
     // when
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("orderBy", "name");
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -462,7 +462,7 @@ public void resultListIsSortedByName() {
 
     // when
     queryParam.put("sortOrder", "desc");
+    reports = getAllPrivateReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -485,7 +485,7 @@ public void resultListIsSortedByLastModified() {
     // when
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("orderBy", "lastModified");
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -495,7 +495,7 @@ public void resultListIsSortedByLastModified() {
 
     //when
     queryParam.put("sortOrder", "desc");
+    reports = getAllPrivateReportsWithQueryParam(queryParam);
     // then
     assertThat(reports.size(), is(3));
     assertThat(reports.get(0).getId(), is(id2));
@@ -518,7 +518,7 @@ public void resultListIsReversed() {
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("orderBy", "lastModified");
     queryParam.put("sortOrder", "desc");
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(3));
@@ -542,7 +542,7 @@ public void resultListIsCutByAnOffset() {
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("resultOffset", 1);
     queryParam.put("orderBy", "lastModified");
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(2));
@@ -574,7 +574,7 @@ public void resultListIsCutByMaxResults() {
     Map&lt;String, Object&gt; queryParam = new HashMap&lt;&gt;();
     queryParam.put("numResults", 2);
     queryParam.put("orderBy", "lastModified");
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(2));
@@ -599,7 +599,7 @@ public void combineAllResultListQueryParameterRestrictions() {
     queryParam.put("orderBy", "lastModified");
     queryParam.put("reverseOrder", true);
     queryParam.put("resultOffset", 1);
+    List&lt;ReportDefinitionDto&gt; reports = getAllPrivateReportsWithQueryParam(queryParam);
 
     // then
     assertThat(reports.size(), is(1));
@@ -651,14 +651,14 @@ private AuthorizedProcessReportEvaluationResultDto&lt;RawDataProcessReportResultDto
     // @formatter:on
   }
 
+  private List&lt;ReportDefinitionDto&gt; getAllPrivateReports() {
+    return getAllPrivateReportsWithQueryParam(new HashMap&lt;&gt;());
   }
 
+  private List&lt;ReportDefinitionDto&gt; getAllPrivateReportsWithQueryParam(Map&lt;String, Object&gt; queryParams) {
     return embeddedOptimizeExtensionRule
       .getRequestExecutor()
+      .buildGetAllPrivateReportsRequest()
       .addQueryParams(queryParams)
       .executeAndReturnList(ReportDefinitionDto.class, 200);
   }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>187039</refactoring_id><commit_sha>29cb373eef48b659058f6e0bc0da0204cf8863da</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/29cb373eef48b659058f6e0bc0da0204cf8863da</commit_link><file_path>core/src/main/java/org/infinispan/context/SingleKeyNonTxInvocationContext.java</file_path><description>Rename Method public lookedUpEntriesSize() : int renamed to public lookedUpEntriesCount() : int in class org.infinispan.context.SingleKeyNonTxInvocationContext</description><code_before>@@ -108,14 +108,14 @@ public Map&lt;Object, CacheEntry&gt; getLookedUpEntries() {
    }
 
    @Override
-   public void forEachEntry(BiConsumer&lt;Object, CacheEntry&gt; consumer) {
       if (cacheEntry != null) {
-         consumer.accept(key, cacheEntry);
       }
    }
 
    @Override
-   public int lookedUpEntriesSize() {
       return cacheEntry != null ? 1 : 0;
    }
 
</code_before><code_after>@@ -108,14 +108,14 @@ public Map&lt;Object, CacheEntry&gt; getLookedUpEntries() {
    }
 
    @Override
+   public void forEachEntry(BiConsumer&lt;Object, CacheEntry&gt; action) {
       if (cacheEntry != null) {
+         action.accept(key, cacheEntry);
       }
    }
 
    @Override
+   public int lookedUpEntriesCount() {
       return cacheEntry != null ? 1 : 0;
    }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>126309</refactoring_id><commit_sha>1c6c28b8fb05bba6a0bcde65fa85a4d31d4c282b</commit_sha><commit_link>https://github.com/apache/doris/commit/1c6c28b8fb05bba6a0bcde65fa85a4d31d4c282b</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/system/Backend.java</file_path><description>Rename Method public getHost() : String renamed to public getIp() : String in class org.apache.doris.system.Backend</description><code_before>@@ -192,7 +192,7 @@ public long getId() {
         return id;
     }
 
-    public String getHost() {
         return ip;
     }
 
@@ -289,7 +289,7 @@ public void setBackendState(BackendState state) {
         this.backendState = state.ordinal();
     }
 
-    public void setHost(String ip) {
         this.ip = ip;
     }
 
@@ -784,7 +784,7 @@ public Map&lt;String, String&gt; getTagMap() {
     }
 
     public TNetworkAddress getBrpcAdress() {
-        return new TNetworkAddress(getHost(), getBrpcPort());
     }
 
     public String getTagMapString() {
</code_before><code_after>@@ -192,7 +192,7 @@ public long getId() {
         return id;
     }
 
+    public String getIp() {
         return ip;
     }
 
@@ -289,7 +289,7 @@ public void setBackendState(BackendState state) {
         this.backendState = state.ordinal();
     }
 
+    public void setIp(String ip) {
         this.ip = ip;
     }
 
@@ -784,7 +784,7 @@ public Map&lt;String, String&gt; getTagMap() {
     }
 
     public TNetworkAddress getBrpcAdress() {
+        return new TNetworkAddress(getIp(), getBrpcPort());
     }
 
     public String getTagMapString() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>262292</refactoring_id><commit_sha>75bf1a58ef09caea99f683f73f34c974903de5e6</commit_sha><commit_link>https://github.com/libgdx/libgdx/commit/75bf1a58ef09caea99f683f73f34c974903de5e6</commit_link><file_path>extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCompoundShapeData.java</file_path><description>Rename Method public getM_numChildShapes() : int renamed to public getNumChildShapes() : int in class com.badlogic.gdx.physics.bullet.btCompoundShapeData</description><code_before>@@ -13,65 +13,73 @@
 import com.badlogic.gdx.math.Matrix3;
 import com.badlogic.gdx.math.Matrix4;
 
-public class btCompoundShapeData {
-  private long swigCPtr;
-  protected boolean swigCMemOwn;
-
-  protected btCompoundShapeData(long cPtr, boolean cMemoryOwn) {
-    swigCMemOwn = cMemoryOwn;
-    swigCPtr = cPtr;
-  }
-
-  public static long getCPtr(btCompoundShapeData obj) {
-    return (obj == null) ? 0 : obj.swigCPtr;
-  }
-
-  protected void finalize() {
-    delete();
-  }
-
-  public synchronized void delete() {
-    if (swigCPtr != 0) {
-      if (swigCMemOwn) {
-        swigCMemOwn = false;
-        gdxBulletJNI.delete_btCompoundShapeData(swigCPtr);
-      }
-      swigCPtr = 0;
-    }
-  }
-
-  public void setM_collisionShapeData(btCollisionShapeData value) {
-    gdxBulletJNI.btCompoundShapeData_m_collisionShapeData_set(swigCPtr, this, btCollisionShapeData.getCPtr(value), value);
   }
 
-  public btCollisionShapeData getM_collisionShapeData() {
-    long cPtr = gdxBulletJNI.btCompoundShapeData_m_collisionShapeData_get(swigCPtr, this);
     return (cPtr == 0) ? null : new btCollisionShapeData(cPtr, false);
   }
 
-  public void setM_childShapePtr(btCompoundShapeChildData value) {
-    gdxBulletJNI.btCompoundShapeData_m_childShapePtr_set(swigCPtr, this, btCompoundShapeChildData.getCPtr(value), value);
   }
 
-  public btCompoundShapeChildData getM_childShapePtr() {
-    long cPtr = gdxBulletJNI.btCompoundShapeData_m_childShapePtr_get(swigCPtr, this);
     return (cPtr == 0) ? null : new btCompoundShapeChildData(cPtr, false);
   }
 
-  public void setM_numChildShapes(int value) {
-    gdxBulletJNI.btCompoundShapeData_m_numChildShapes_set(swigCPtr, this, value);
   }
 
-  public int getM_numChildShapes() {
-    return gdxBulletJNI.btCompoundShapeData_m_numChildShapes_get(swigCPtr, this);
   }
 
-  public void setM_collisionMargin(float value) {
-    gdxBulletJNI.btCompoundShapeData_m_collisionMargin_set(swigCPtr, this, value);
   }
 
-  public float getM_collisionMargin() {
-    return gdxBulletJNI.btCompoundShapeData_m_collisionMargin_get(swigCPtr, this);
   }
 
   public btCompoundShapeData() {
</code_before><code_after>@@ -13,65 +13,73 @@
 import com.badlogic.gdx.math.Matrix3;
 import com.badlogic.gdx.math.Matrix4;
 
+public class btCompoundShapeData extends BulletBase {
+	private long swigCPtr;
+	
+	protected btCompoundShapeData(final String className, long cPtr, boolean cMemoryOwn) {
+		super(className, cPtr, cMemoryOwn);
+		swigCPtr = cPtr;
+	}
+	
+	protected btCompoundShapeData(long cPtr, boolean cMemoryOwn) {
+		this("btCompoundShapeData", cPtr, cMemoryOwn);
+		construct();
+	}
+	
+	public static long getCPtr(btCompoundShapeData obj) {
+		return (obj == null) ? 0 : obj.swigCPtr;
+	}
+
+	@Override
+	protected void finalize() throws Throwable {
+		if (!destroyed)
+			destroy();
+		super.finalize();
+	}
+
+  @Override protected synchronized void delete() {
+		if (swigCPtr != 0) {
+			if (swigCMemOwn) {
+				swigCMemOwn = false;
+				gdxBulletJNI.delete_btCompoundShapeData(swigCPtr);
+			}
+			swigCPtr = 0;
+		}
+		super.delete();
+	}
+
+  public void setCollisionShapeData(btCollisionShapeData value) {
+    gdxBulletJNI.btCompoundShapeData_collisionShapeData_set(swigCPtr, this, btCollisionShapeData.getCPtr(value), value);
   }
 
+  public btCollisionShapeData getCollisionShapeData() {
+    long cPtr = gdxBulletJNI.btCompoundShapeData_collisionShapeData_get(swigCPtr, this);
     return (cPtr == 0) ? null : new btCollisionShapeData(cPtr, false);
   }
 
+  public void setChildShapePtr(btCompoundShapeChildData value) {
+    gdxBulletJNI.btCompoundShapeData_childShapePtr_set(swigCPtr, this, btCompoundShapeChildData.getCPtr(value), value);
   }
 
+  public btCompoundShapeChildData getChildShapePtr() {
+    long cPtr = gdxBulletJNI.btCompoundShapeData_childShapePtr_get(swigCPtr, this);
     return (cPtr == 0) ? null : new btCompoundShapeChildData(cPtr, false);
   }
 
+  public void setNumChildShapes(int value) {
+    gdxBulletJNI.btCompoundShapeData_numChildShapes_set(swigCPtr, this, value);
   }
 
+  public int getNumChildShapes() {
+    return gdxBulletJNI.btCompoundShapeData_numChildShapes_get(swigCPtr, this);
   }
 
+  public void setCollisionMargin(float value) {
+    gdxBulletJNI.btCompoundShapeData_collisionMargin_set(swigCPtr, this, value);
   }
 
+  public float getCollisionMargin() {
+    return gdxBulletJNI.btCompoundShapeData_collisionMargin_get(swigCPtr, this);
   }
 
   public btCompoundShapeData() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>137942</refactoring_id><commit_sha>2dcdd74b807a349fe1a2bcb9a1d984cdc00dd711</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/2dcdd74b807a349fe1a2bcb9a1d984cdc00dd711</commit_link><file_path>plugins/org.jkiss.dbeaver.model/src/org/jkiss/dbeaver/model/navigator/fs/DBNFileSystems.java</file_path><description>Rename Method public getNodeName() : String renamed to public getNodeDisplayName() : String in class org.jkiss.dbeaver.model.navigator.fs.DBNFileSystems</description><code_before>@@ -70,14 +70,20 @@ public String getNodeType() {
         return NodePathType.dbvfs.name();
     }
 
     @Override
     public String getNodeTypeLabel() {
         return ModelMessages.fs_root;
     }
 
     @Override
     @Property(id = DBConstants.PROP_ID_NAME, viewable = true, order = 1)
-    public String getNodeName() {
         return "Remote file systems";
     }
 
@@ -167,7 +173,7 @@ protected DBNFileSystem[] readChildNodes(
             result.add(newChild);
         }
 
-        result.sort((o1, o2) -&gt; o1.getNodeName().compareToIgnoreCase(o2.getNodeName()));
         monitor.done();
         return result.toArray(new DBNFileSystem[0]);
     }
@@ -248,6 +254,7 @@ private void disposeFileSystems() {
         }
     }
 
     @Override
     public String getNodeItemPath() {
         return NodePathType.ext.getPrefix() + ((DBNProject) getParentNode()).getProject().getId() + "/" + getName();
@@ -281,7 +288,7 @@ public void resourceChanged(EFSNIOResource resource, Action action) {
                         String itemName = pathSegments[i];
                         DBNPathBase childNode = parentNode.getChild(itemName);
                         if (childNode == null) {
-                            log.debug("Cannot find child node '" + itemName + "' in '" + parentNode.getNodeItemPath() + "'");
                             return;
                         }
                         parentNode = childNode;
</code_before><code_after>@@ -70,14 +70,20 @@ public String getNodeType() {
         return NodePathType.dbvfs.name();
     }
 
+    @NotNull
+    @Override
+    public String getNodeId() {
+        return NodePathType.dbvfs.name();
+    }
+
     @Override
     public String getNodeTypeLabel() {
         return ModelMessages.fs_root;
     }
 
     @Override
     @Property(id = DBConstants.PROP_ID_NAME, viewable = true, order = 1)
+    public String getNodeDisplayName() {
         return "Remote file systems";
     }
 
@@ -167,7 +173,7 @@ protected DBNFileSystem[] readChildNodes(
             result.add(newChild);
         }
 
+        result.sort((o1, o2) -&gt; o1.getNodeDisplayName().compareToIgnoreCase(o2.getNodeDisplayName()));
         monitor.done();
         return result.toArray(new DBNFileSystem[0]);
     }
@@ -248,6 +254,7 @@ private void disposeFileSystems() {
         }
     }
 
+    @Deprecated(forRemoval = true)
     @Override
     public String getNodeItemPath() {
         return NodePathType.ext.getPrefix() + ((DBNProject) getParentNode()).getProject().getId() + "/" + getName();
@@ -281,7 +288,7 @@ public void resourceChanged(EFSNIOResource resource, Action action) {
                         String itemName = pathSegments[i];
                         DBNPathBase childNode = parentNode.getChild(itemName);
                         if (childNode == null) {
+                            log.debug("Cannot find child node '" + itemName + "' in '" + parentNode.getNodeUri() + "'");
                             return;
                         }
                         parentNode = childNode;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>203938</refactoring_id><commit_sha>c4ec543a8b0da9c5d9a2e25739ac31fd68d13a5d</commit_sha><commit_link>https://github.com/apache/ignite/commit/c4ec543a8b0da9c5d9a2e25739ac31fd68d13a5d</commit_link><file_path>modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IgniteClientCacheInitializationFailTest.java</file_path><description>Rename Method public queryDistributedSql(schemaName String, cacheName String, qry SqlQuery, keepBinary boolean) : QueryCursor&lt;Cache.Entry&lt;K,V&gt;&gt; renamed to public generateFieldsQuery(cacheName String, qry SqlQuery) : SqlFieldsQuery in class org.apache.ignite.internal.processors.cache.IgniteClientCacheInitializationFailTest.FailedIndexing</description><code_before>@@ -26,15 +26,13 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.Callable;
-import javax.cache.Cache;
 import javax.cache.CacheException;
 import org.apache.ignite.Ignite;
 import org.apache.ignite.IgniteCache;
 import org.apache.ignite.IgniteCheckedException;
 import org.apache.ignite.IgniteDataStreamer;
 import org.apache.ignite.cache.CacheAtomicityMode;
 import org.apache.ignite.cache.query.FieldsQueryCursor;
-import org.apache.ignite.cache.query.QueryCursor;
 import org.apache.ignite.cache.query.SqlFieldsQuery;
 import org.apache.ignite.cache.query.SqlQuery;
 import org.apache.ignite.configuration.CacheConfiguration;
@@ -231,19 +229,18 @@ private static class FailedIndexing implements GridQueryIndexing {
         }
 
         /** {@inheritDoc} */
-        @Override public void start(GridKernalContext ctx, GridSpinBusyLock busyLock) throws IgniteCheckedException {
-            // No-op
         }
 
         /** {@inheritDoc} */
-        @Override public void stop() throws IgniteCheckedException {
             // No-op
         }
 
         /** {@inheritDoc} */
-        @Override public &lt;K, V&gt; QueryCursor&lt;Cache.Entry&lt;K, V&gt;&gt; queryDistributedSql(String schemaName, String cacheName,
-            SqlQuery qry, boolean keepBinary) throws IgniteCheckedException {
-            return null;
         }
 
         /** {@inheritDoc} */
@@ -264,12 +261,6 @@ private static class FailedIndexing implements GridQueryIndexing {
             return 0;
         }
 
-        /** {@inheritDoc} */
-        @Override public &lt;K, V&gt; QueryCursor&lt;Cache.Entry&lt;K, V&gt;&gt; queryLocalSql(String schemaName, String cacheName,
-            SqlQuery qry, IndexingQueryFilter filter, boolean keepBinary) throws IgniteCheckedException {
-            return null;
-        }
-
         /** {@inheritDoc} */
         @Override public FieldsQueryCursor&lt;List&lt;?&gt;&gt; queryLocalSqlFields(String schemaName, SqlFieldsQuery qry,
             boolean keepBinary, IndexingQueryFilter filter, GridQueryCancel cancel) throws IgniteCheckedException {
</code_before><code_after>@@ -26,15 +26,13 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import javax.cache.CacheException;
 import org.apache.ignite.Ignite;
 import org.apache.ignite.IgniteCache;
 import org.apache.ignite.IgniteCheckedException;
 import org.apache.ignite.IgniteDataStreamer;
 import org.apache.ignite.cache.CacheAtomicityMode;
 import org.apache.ignite.cache.query.FieldsQueryCursor;
 import org.apache.ignite.cache.query.SqlFieldsQuery;
 import org.apache.ignite.cache.query.SqlQuery;
 import org.apache.ignite.configuration.CacheConfiguration;
@@ -231,19 +229,18 @@ private static class FailedIndexing implements GridQueryIndexing {
         }
 
         /** {@inheritDoc} */
+        @Override public SqlFieldsQuery generateFieldsQuery(String cacheName, SqlQuery qry) {
+            return null;
         }
 
         /** {@inheritDoc} */
+        @Override public void start(GridKernalContext ctx, GridSpinBusyLock busyLock) throws IgniteCheckedException {
             // No-op
         }
 
         /** {@inheritDoc} */
+        @Override public void stop() throws IgniteCheckedException {
+            // No-op
         }
 
         /** {@inheritDoc} */
@@ -264,12 +261,6 @@ private static class FailedIndexing implements GridQueryIndexing {
             return 0;
         }
 
         /** {@inheritDoc} */
         @Override public FieldsQueryCursor&lt;List&lt;?&gt;&gt; queryLocalSqlFields(String schemaName, SqlFieldsQuery qry,
             boolean keepBinary, IndexingQueryFilter filter, GridQueryCancel cancel) throws IgniteCheckedException {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>164698</refactoring_id><commit_sha>d66726166f4305613c8472be1c381a1cdb5af044</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/d66726166f4305613c8472be1c381a1cdb5af044</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/api/txstate/TxStateVisitor.java</file_path><description>Rename Method public visitRemovedNodeMandatoryPropertyConstraint(element MandatoryNodePropertyConstraint) : void renamed to public visitRemovedNodePropertyExistenceConstraint(element NodePropertyExistenceConstraint) : void in class org.neo4j.kernel.api.txstate.TxStateVisitor</description><code_before>@@ -23,8 +23,8 @@
 import java.util.Map;
 import java.util.Set;
 
-import org.neo4j.kernel.api.constraints.MandatoryNodePropertyConstraint;
-import org.neo4j.kernel.api.constraints.MandatoryRelationshipPropertyConstraint;
 import org.neo4j.kernel.api.constraints.UniquenessConstraint;
 import org.neo4j.kernel.api.exceptions.schema.ConstraintValidationKernelException;
 import org.neo4j.kernel.api.index.IndexDescriptor;
@@ -68,13 +68,13 @@ void visitNodeLabelChanges( long id, Set&lt;Integer&gt; added, Set&lt;Integer&gt; removed )
 
     void visitRemovedUniquePropertyConstraint( UniquenessConstraint element );
 
-    void visitAddedNodeMandatoryPropertyConstraint( MandatoryNodePropertyConstraint element );
 
-    void visitRemovedNodeMandatoryPropertyConstraint( MandatoryNodePropertyConstraint element );
 
-    void visitAddedRelationshipMandatoryPropertyConstraint( MandatoryRelationshipPropertyConstraint element );
 
-    void visitRemovedRelationshipMandatoryPropertyConstraint( MandatoryRelationshipPropertyConstraint element );
 
     void visitCreatedLabelToken( String name, int id );
 
@@ -226,38 +226,39 @@ public void visitRemovedUniquePropertyConstraint( UniquenessConstraint element )
         }
 
         @Override
-        public void visitAddedNodeMandatoryPropertyConstraint( MandatoryNodePropertyConstraint element )
         {
             if ( next != null )
             {
-                next.visitAddedNodeMandatoryPropertyConstraint( element );
             }
         }
 
         @Override
-        public void visitRemovedNodeMandatoryPropertyConstraint( MandatoryNodePropertyConstraint element )
         {
             if ( next != null )
             {
-                next.visitRemovedNodeMandatoryPropertyConstraint( element );
             }
         }
 
         @Override
-        public void visitAddedRelationshipMandatoryPropertyConstraint( MandatoryRelationshipPropertyConstraint element )
         {
             if ( next != null )
             {
-                next.visitAddedRelationshipMandatoryPropertyConstraint( element );
             }
         }
 
         @Override
-        public void visitRemovedRelationshipMandatoryPropertyConstraint( MandatoryRelationshipPropertyConstraint element )
         {
             if ( next != null )
             {
-                next.visitRemovedRelationshipMandatoryPropertyConstraint( element );
             }
         }
 
</code_before><code_after>@@ -23,8 +23,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import org.neo4j.kernel.api.constraints.NodePropertyExistenceConstraint;
+import org.neo4j.kernel.api.constraints.RelationshipPropertyExistenceConstraint;
 import org.neo4j.kernel.api.constraints.UniquenessConstraint;
 import org.neo4j.kernel.api.exceptions.schema.ConstraintValidationKernelException;
 import org.neo4j.kernel.api.index.IndexDescriptor;
@@ -68,13 +68,13 @@ void visitNodeLabelChanges( long id, Set&lt;Integer&gt; added, Set&lt;Integer&gt; removed )
 
     void visitRemovedUniquePropertyConstraint( UniquenessConstraint element );
 
+    void visitAddedNodePropertyExistenceConstraint( NodePropertyExistenceConstraint element );
 
+    void visitRemovedNodePropertyExistenceConstraint( NodePropertyExistenceConstraint element );
 
+    void visitAddedRelationshipPropertyExistenceConstraint( RelationshipPropertyExistenceConstraint element );
 
+    void visitRemovedRelationshipPropertyExistenceConstraint( RelationshipPropertyExistenceConstraint element );
 
     void visitCreatedLabelToken( String name, int id );
 
@@ -226,38 +226,39 @@ public void visitRemovedUniquePropertyConstraint( UniquenessConstraint element )
         }
 
         @Override
+        public void visitAddedNodePropertyExistenceConstraint( NodePropertyExistenceConstraint element )
         {
             if ( next != null )
             {
+                next.visitAddedNodePropertyExistenceConstraint( element );
             }
         }
 
         @Override
+        public void visitRemovedNodePropertyExistenceConstraint( NodePropertyExistenceConstraint element )
         {
             if ( next != null )
             {
+                next.visitRemovedNodePropertyExistenceConstraint( element );
             }
         }
 
         @Override
+        public void visitAddedRelationshipPropertyExistenceConstraint( RelationshipPropertyExistenceConstraint element )
         {
             if ( next != null )
             {
+                next.visitAddedRelationshipPropertyExistenceConstraint( element );
             }
         }
 
         @Override
+        public void visitRemovedRelationshipPropertyExistenceConstraint(
+                RelationshipPropertyExistenceConstraint element )
         {
             if ( next != null )
             {
+                next.visitRemovedRelationshipPropertyExistenceConstraint( element );
             }
         }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>259783</refactoring_id><commit_sha>42ca0b2fcce1ccbeae2bbdcf8c68b14d16b2cf62</commit_sha><commit_link>https://github.com/openmrs/openmrs-core/commit/42ca0b2fcce1ccbeae2bbdcf8c68b14d16b2cf62</commit_link><file_path>test/api/org/openmrs/test/reporting/CachingPatientFilterTest.java</file_path><description>Rename Method public testShouldCachingPatientFilter() : void renamed to public shouldCachingPatientFilter() : void in class org.openmrs.test.reporting.CachingPatientFilterTest</description><code_before>@@ -13,6 +13,11 @@
  */
 package org.openmrs.test.reporting;
 
 import org.openmrs.Cohort;
 import org.openmrs.report.EvaluationContext;
 import org.openmrs.reporting.CachingPatientFilter;
@@ -24,7 +29,8 @@
  */
 public class CachingPatientFilterTest extends BaseContextSensitiveTest {
 
-	public void testShouldCachingPatientFilter() throws Exception {
 		initializeInMemoryDatabase();
 		executeDataSet("org/openmrs/test/reporting/include/PatientFilterTest.xml");
 		authenticate();
</code_before><code_after>@@ -13,6 +13,11 @@
  */
 package org.openmrs.test.reporting;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
+import org.junit.Test;
 import org.openmrs.Cohort;
 import org.openmrs.report.EvaluationContext;
 import org.openmrs.reporting.CachingPatientFilter;
@@ -24,7 +29,8 @@
  */
 public class CachingPatientFilterTest extends BaseContextSensitiveTest {
 
+	@Test
+	public void shouldCachingPatientFilter() throws Exception {
 		initializeInMemoryDatabase();
 		executeDataSet("org/openmrs/test/reporting/include/PatientFilterTest.xml");
 		authenticate();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>249018</refactoring_id><commit_sha>e0d7c6be00ed855e473f19f405ddbbcdb6cbb885</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/e0d7c6be00ed855e473f19f405ddbbcdb6cbb885</commit_link><file_path>spring-web/src/main/java/org/springframework/web/method/annotation/AbstractNamedValueMethodArgumentResolver.java</file_path><description>Rename Method private resolveDefaultValue(defaultValue String) : Object renamed to private resolveStringValue(value String) : Object in class org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver</description><code_before>@@ -89,18 +89,24 @@ public final Object resolveArgument(MethodParameter parameter, ModelAndViewConta
 		NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);
 		MethodParameter nestedParameter = parameter.nestedIfOptional();
 
-		Object arg = resolveName(namedValueInfo.name, nestedParameter, webRequest);
 		if (arg == null) {
 			if (namedValueInfo.defaultValue != null) {
-				arg = resolveDefaultValue(namedValueInfo.defaultValue);
 			}
 			else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) {
 				handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);
 			}
 			arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());
 		}
 		else if ("".equals(arg) &amp;&amp; namedValueInfo.defaultValue != null) {
-			arg = resolveDefaultValue(namedValueInfo.defaultValue);
 		}
 
 		if (binderFactory != null) {
@@ -162,6 +168,22 @@ private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValu
 		return new NamedValueInfo(name, info.required, defaultValue);
 	}
 
 	/**
 	 * Resolve the given parameter type and value name into an argument value.
 	 * @param name the name of the value being resolved
@@ -174,21 +196,6 @@ private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValu
 	protected abstract Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)
 			throws Exception;
 
-	/**
-	 * Resolve the given default value into an argument value.
-	 */
-	private Object resolveDefaultValue(String defaultValue) {
-		if (this.configurableBeanFactory == null) {
-			return defaultValue;
-		}
-		String placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(defaultValue);
-		BeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver();
-		if (exprResolver == null) {
-			return defaultValue;
-		}
-		return exprResolver.evaluate(placeholdersResolved, this.expressionContext);
-	}
-
 	/**
 	 * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}
 	 * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.
</code_before><code_after>@@ -89,18 +89,24 @@ public final Object resolveArgument(MethodParameter parameter, ModelAndViewConta
 		NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);
 		MethodParameter nestedParameter = parameter.nestedIfOptional();
 
+		Object resolvedName = resolveStringValue(namedValueInfo.name);
+		if (resolvedName == null) {
+			throw new IllegalArgumentException(
+					"Specified name must not resolve to null: [" + namedValueInfo.name + "]");
+		}
+
+		Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);
 		if (arg == null) {
 			if (namedValueInfo.defaultValue != null) {
+				arg = resolveStringValue(namedValueInfo.defaultValue);
 			}
 			else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) {
 				handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);
 			}
 			arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());
 		}
 		else if ("".equals(arg) &amp;&amp; namedValueInfo.defaultValue != null) {
+			arg = resolveStringValue(namedValueInfo.defaultValue);
 		}
 
 		if (binderFactory != null) {
@@ -162,6 +168,22 @@ private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValu
 		return new NamedValueInfo(name, info.required, defaultValue);
 	}
 
+	/**
+	 * Resolve the given annotation-specified value,
+	 * potentially containing placeholders and expressions.
+	 */
+	private Object resolveStringValue(String value) {
+		if (this.configurableBeanFactory == null) {
+			return value;
+		}
+		String placeholdersResolved = this.configurableBeanFactory.resolveEmbeddedValue(value);
+		BeanExpressionResolver exprResolver = this.configurableBeanFactory.getBeanExpressionResolver();
+		if (exprResolver == null) {
+			return value;
+		}
+		return exprResolver.evaluate(placeholdersResolved, this.expressionContext);
+	}
+
 	/**
 	 * Resolve the given parameter type and value name into an argument value.
 	 * @param name the name of the value being resolved
@@ -174,21 +196,6 @@ private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValu
 	protected abstract Object resolveName(String name, MethodParameter parameter, NativeWebRequest request)
 			throws Exception;
 
 	/**
 	 * Invoked when a named value is required, but {@link #resolveName(String, MethodParameter, NativeWebRequest)}
 	 * returned {@code null} and there is no default value. Subclasses typically throw an exception in this case.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>245436</refactoring_id><commit_sha>2c1dca5b5e5089af3ed092ffb1fd2b7fd65db776</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/2c1dca5b5e5089af3ed092ffb1fd2b7fd65db776</commit_link><file_path>spring-core/src/main/java/org/springframework/util/unit/DataSize.java</file_path><description>Rename Method public toMegaBytes() : long renamed to public toMegabytes() : long in class org.springframework.util.unit.DataSize</description><code_before>@@ -39,22 +39,22 @@ public final class DataSize implements Comparable&lt;DataSize&gt; {
 	private static final Pattern PATTERN = Pattern.compile("^([+\\-]?\\d+)([a-zA-Z]{0,2})$");
 
 	/**
-	 * Bytes per KiloByte.
 	 */
 	private static long BYTES_PER_KB = 1024;
 
 	/**
-	 * Bytes per MegaByte.
 	 */
 	private static long BYTES_PER_MB = BYTES_PER_KB * 1024;
 
 	/**
-	 * Bytes per GigaByte.
 	 */
 	private static long BYTES_PER_GB = BYTES_PER_MB * 1024;
 
 	/**
-	 * Bytes per TeraByte.
 	 */
 	private static long BYTES_PER_TB = BYTES_PER_GB * 1024;
 
@@ -78,38 +78,38 @@ public static DataSize ofBytes(long bytes) {
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of kilobytes.
-	 * @param kiloBytes the number of kilobytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
-	public static DataSize ofKiloBytes(long kiloBytes) {
-		return new DataSize(Math.multiplyExact(kiloBytes, BYTES_PER_KB));
 	}
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of megabytes.
-	 * @param megaBytes the number of megabytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
-	public static DataSize ofMegaBytes(long megaBytes) {
-		return new DataSize(Math.multiplyExact(megaBytes, BYTES_PER_MB));
 	}
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of gigabytes.
-	 * @param gigaBytes the number of gigabytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
-	public static DataSize ofGigaBytes(long gigaBytes) {
-		return new DataSize(Math.multiplyExact(gigaBytes, BYTES_PER_GB));
 	}
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of terabytes.
-	 * @param teraBytes the number of terabytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
-	public static DataSize ofTeraBytes(long teraBytes) {
-		return new DataSize(Math.multiplyExact(teraBytes, BYTES_PER_TB));
 	}
 
 	/**
@@ -196,31 +196,31 @@ public long toBytes() {
 	 * Return the number of kilobytes in this instance.
 	 * @return the number of kilobytes
 	 */
-	public long toKiloBytes() {
 		return this.bytes / BYTES_PER_KB;
 	}
 
 	/**
 	 * Return the number of megabytes in this instance.
 	 * @return the number of megabytes
 	 */
-	public long toMegaBytes() {
 		return this.bytes / BYTES_PER_MB;
 	}
 
 	/**
 	 * Return the number of gigabytes in this instance.
 	 * @return the number of gigabytes
 	 */
-	public long toGigaBytes() {
 		return this.bytes / BYTES_PER_GB;
 	}
 
 	/**
 	 * Return the number of terabytes in this instance.
 	 * @return the number of terabytes
 	 */
-	public long toTeraBytes() {
 		return this.bytes / BYTES_PER_TB;
 	}
 
</code_before><code_after>@@ -39,22 +39,22 @@ public final class DataSize implements Comparable&lt;DataSize&gt; {
 	private static final Pattern PATTERN = Pattern.compile("^([+\\-]?\\d+)([a-zA-Z]{0,2})$");
 
 	/**
+	 * Bytes per Kilobyte.
 	 */
 	private static long BYTES_PER_KB = 1024;
 
 	/**
+	 * Bytes per Megabyte.
 	 */
 	private static long BYTES_PER_MB = BYTES_PER_KB * 1024;
 
 	/**
+	 * Bytes per Gigabyte.
 	 */
 	private static long BYTES_PER_GB = BYTES_PER_MB * 1024;
 
 	/**
+	 * Bytes per Terabyte.
 	 */
 	private static long BYTES_PER_TB = BYTES_PER_GB * 1024;
 
@@ -78,38 +78,38 @@ public static DataSize ofBytes(long bytes) {
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of kilobytes.
+	 * @param kilobytes the number of kilobytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
+	public static DataSize ofKilobytes(long kilobytes) {
+		return new DataSize(Math.multiplyExact(kilobytes, BYTES_PER_KB));
 	}
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of megabytes.
+	 * @param megabytes the number of megabytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
+	public static DataSize ofMegabytes(long megabytes) {
+		return new DataSize(Math.multiplyExact(megabytes, BYTES_PER_MB));
 	}
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of gigabytes.
+	 * @param gigabytes the number of gigabytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
+	public static DataSize ofGigabytes(long gigabytes) {
+		return new DataSize(Math.multiplyExact(gigabytes, BYTES_PER_GB));
 	}
 
 	/**
 	 * Obtain a {@link DataSize} representing the specified number of terabytes.
+	 * @param terabytes the number of terabytes, positive or negative
 	 * @return a {@link DataSize}
 	 */
+	public static DataSize ofTerabytes(long terabytes) {
+		return new DataSize(Math.multiplyExact(terabytes, BYTES_PER_TB));
 	}
 
 	/**
@@ -196,31 +196,31 @@ public long toBytes() {
 	 * Return the number of kilobytes in this instance.
 	 * @return the number of kilobytes
 	 */
+	public long toKilobytes() {
 		return this.bytes / BYTES_PER_KB;
 	}
 
 	/**
 	 * Return the number of megabytes in this instance.
 	 * @return the number of megabytes
 	 */
+	public long toMegabytes() {
 		return this.bytes / BYTES_PER_MB;
 	}
 
 	/**
 	 * Return the number of gigabytes in this instance.
 	 * @return the number of gigabytes
 	 */
+	public long toGigabytes() {
 		return this.bytes / BYTES_PER_GB;
 	}
 
 	/**
 	 * Return the number of terabytes in this instance.
 	 * @return the number of terabytes
 	 */
+	public long toTerabytes() {
 		return this.bytes / BYTES_PER_TB;
 	}
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>301293</refactoring_id><commit_sha>275e77646dba39dd6906819404b5f8c331327f00</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/275e77646dba39dd6906819404b5f8c331327f00</commit_link><file_path>langtools/src/share/classes/com/sun/tools/doclets/formats/html/AbstractTreeWriter.java</file_path><description>Rename Method protected printPartialInfo(cd ClassDoc) : void renamed to protected addPartialInfo(cd ClassDoc, contentTree Content) : void in class com.sun.tools.doclets.formats.html.AbstractTreeWriter</description><code_before>@@ -25,11 +25,12 @@
 
 package com.sun.tools.doclets.formats.html;
 
-import com.sun.tools.doclets.internal.toolkit.util.*;
-
-import com.sun.javadoc.*;
 import java.io.*;
 import java.util.*;
 
 /**
  * Abstract class to print the class hierarchy page for all the Classes. This
@@ -46,6 +47,8 @@ public abstract class AbstractTreeWriter extends HtmlDocletWriter {
      */
     protected final ClassTree classtree;
 
     /**
      * Constructor initilises classtree variable. This constructor will be used
      * while generating global tree file "overview-tree.html".
@@ -87,55 +90,64 @@ protected AbstractTreeWriter(ConfigurationImpl configuration,
     }
 
     /**
-     * Generate each level of the class tree. For each sub-class or
      * sub-interface indents the next level information.
-     * Recurses itself to generate subclasses info.
-     * To iterate is human, to recurse is divine - L. Peter Deutsch.
      *
-     * @param parent the superclass or superinterface of the list.
-     * @param list list of the sub-classes at this level.
-     * @param isEnum true if we are generating a tree for enums.
      */
-    protected void generateLevelInfo(ClassDoc parent, List&lt;ClassDoc&gt; list,
-            boolean isEnum) {
-        if (list.size() &gt; 0) {
-            ul();
-            for (int i = 0; i &lt; list.size(); i++) {
                 ClassDoc local = list.get(i);
-                printPartialInfo(local);
-                printExtendsImplements(parent, local);
-                generateLevelInfo(local, classtree.subs(local, isEnum),
-                    isEnum);   // Recurse
             }
-            ulEnd();
         }
     }
 
     /**
-     * Generate the heading for the tree depending upon tree type if it's a
-     * Class Tree or Interface tree and also print the tree.
      *
      * @param list List of classes which are at the most base level, all the
-     * other classes in this run will derive from these classes.
-     * @param heading Heading for the tree.
      */
-    protected void generateTree(List&lt;ClassDoc&gt; list, String heading) {
         if (list.size() &gt; 0) {
             ClassDoc firstClassDoc = list.get(0);
-            printTreeHeading(heading);
-            generateLevelInfo(!firstClassDoc.isInterface()? firstClassDoc : null,
-                list,
-                list == classtree.baseEnums());
         }
     }
 
     /**
-     * Print the information regarding the classes which this class extends or
      * implements.
      *
-     * @param cd The classdoc under consideration.
      */
-    protected void printExtendsImplements(ClassDoc parent, ClassDoc cd) {
         ClassDoc[] interfaces = cd.interfaces();
         if (interfaces.length &gt; (cd.isInterface()? 1 : 0)) {
             Arrays.sort(interfaces);
@@ -148,53 +160,43 @@ protected void printExtendsImplements(ClassDoc parent, ClassDoc cd) {
                     }
                     if (counter == 0) {
                         if (cd.isInterface()) {
-                            print(" (" + configuration.getText("doclet.also") + " extends ");
                         } else {
-                            print(" (implements ");
                         }
                     } else {
-                        print(", ");
                     }
-                    printPreQualifiedClassLink(LinkInfoImpl.CONTEXT_TREE,
-                        interfaces[i]);
                     counter++;
                 }
             }
             if (counter &gt; 0) {
-                println(")");
             }
         }
     }
 
     /**
-     * Print information about the class kind, if it's a "class" or "interface".
      *
-     * @param cd classdoc.
      */
-    protected void printPartialInfo(ClassDoc cd) {
-        li("circle");
-        printPreQualifiedStrongClassLink(LinkInfoImpl.CONTEXT_TREE, cd);
     }
 
     /**
-     * Print the heading for the tree.
      *
-     * @param heading Heading for the tree.
-     */
-    protected void printTreeHeading(String heading) {
-        h2();
-        println(configuration.getText(heading));
-        h2End();
-    }
-
-    /**
-     * Highlight "Tree" word in the navigation bar, since this is the tree page.
      */
-    protected void navLinkTree() {
-        navCellRevStart();
-        fontStyle("NavBarFont1Rev");
-        strongText("doclet.Tree");
-        fontEnd();
-        navCellEnd();
     }
 }
</code_before><code_after>@@ -25,11 +25,12 @@
 
 package com.sun.tools.doclets.formats.html;
 
 import java.io.*;
 import java.util.*;
+import com.sun.tools.doclets.internal.toolkit.util.*;
+import com.sun.tools.doclets.internal.toolkit.*;
+import com.sun.tools.doclets.formats.html.markup.*;
+import com.sun.javadoc.*;
 
 /**
  * Abstract class to print the class hierarchy page for all the Classes. This
@@ -46,6 +47,8 @@ public abstract class AbstractTreeWriter extends HtmlDocletWriter {
      */
     protected final ClassTree classtree;
 
+    private static final String LI_CIRCLE  = "circle";
+
     /**
      * Constructor initilises classtree variable. This constructor will be used
      * while generating global tree file "overview-tree.html".
@@ -87,55 +90,64 @@ protected AbstractTreeWriter(ConfigurationImpl configuration,
     }
 
     /**
+     * Add each level of the class tree. For each sub-class or
      * sub-interface indents the next level information.
+     * Recurses itself to add subclasses info.
      *
+     * @param parent the superclass or superinterface of the list
+     * @param list list of the sub-classes at this level
+     * @param isEnum true if we are generating a tree for enums
+     * @param contentTree the content tree to which the level information will be added
      */
+    protected void addLevelInfo(ClassDoc parent, List&lt;ClassDoc&gt; list,
+            boolean isEnum, Content contentTree) {
+        int size = list.size();
+        if (size &gt; 0) {
+            Content ul = new HtmlTree(HtmlTag.UL);
+            for (int i = 0; i &lt; size; i++) {
                 ClassDoc local = list.get(i);
+                HtmlTree li = new HtmlTree(HtmlTag.LI);
+                li.addAttr(HtmlAttr.TYPE, LI_CIRCLE);
+                addPartialInfo(local, li);
+                addExtendsImplements(parent, local, li);
+                addLevelInfo(local, classtree.subs(local, isEnum),
+                        isEnum, li);   // Recurse
+                ul.addContent(li);
             }
+            contentTree.addContent(ul);
         }
     }
 
     /**
+     * Add the heading for the tree depending upon tree type if it's a
+     * Class Tree or Interface tree.
      *
      * @param list List of classes which are at the most base level, all the
+     * other classes in this run will derive from these classes
+     * @param heading heading for the tree
+     * @param div the content tree to which the tree will be added
      */
+    protected void addTree(List&lt;ClassDoc&gt; list, String heading, Content div) {
         if (list.size() &gt; 0) {
             ClassDoc firstClassDoc = list.get(0);
+            Content headingContent = getResource(heading);
+            div.addContent(HtmlTree.HEADING(HtmlConstants.CONTENT_HEADING, true,
+                    headingContent));
+            addLevelInfo(!firstClassDoc.isInterface()? firstClassDoc : null,
+                    list, list == classtree.baseEnums(), div);
         }
     }
 
     /**
+     * Add information regarding the classes which this class extends or
      * implements.
      *
+     * @param parent the parent class of the class being documented
+     * @param cd the classdoc under consideration
+     * @param contentTree the content tree to which the information will be added
      */
+    protected void addExtendsImplements(ClassDoc parent, ClassDoc cd,
+            Content contentTree) {
         ClassDoc[] interfaces = cd.interfaces();
         if (interfaces.length &gt; (cd.isInterface()? 1 : 0)) {
             Arrays.sort(interfaces);
@@ -148,53 +160,43 @@ protected void printExtendsImplements(ClassDoc parent, ClassDoc cd) {
                     }
                     if (counter == 0) {
                         if (cd.isInterface()) {
+                            contentTree.addContent(" (");
+                            contentTree.addContent(getResource("doclet.also"));
+                            contentTree.addContent(" extends ");
                         } else {
+                            contentTree.addContent(" (implements ");
                         }
                     } else {
+                        contentTree.addContent(", ");
                     }
+                    addPreQualifiedClassLink(LinkInfoImpl.CONTEXT_TREE,
+                            interfaces[i], contentTree);
                     counter++;
                 }
             }
             if (counter &gt; 0) {
+                contentTree.addContent(")");
             }
         }
     }
 
     /**
+     * Add information about the class kind, if it's a "class" or "interface".
      *
+     * @param cd the class being documented
+     * @param contentTree the content tree to which the information will be added
      */
+    protected void addPartialInfo(ClassDoc cd, Content contentTree) {
+        addPreQualifiedStrongClassLink(LinkInfoImpl.CONTEXT_TREE, cd, contentTree);
     }
 
     /**
+     * Get the tree label for the navigation bar.
      *
+     * @return a content tree for the tree label
      */
+    protected Content getNavLinkTree() {
+        Content li = HtmlTree.LI(HtmlStyle.navBarCell1Rev, treeLabel);
+        return li;
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>206407</refactoring_id><commit_sha>cbd88179051a51e66abac4c65d4af865c203c337</commit_sha><commit_link>https://github.com/netty/netty/commit/cbd88179051a51e66abac4c65d4af865c203c337</commit_link><file_path>testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java</file_path><description>Rename Method public messageReceived(ctx ChannelHandlerContext, in ByteBuf) : void renamed to public messageReceived0(ctx ChannelHandlerContext, in ByteBuf) : void in class io.netty.testsuite.transport.socket.SocketSslEchoTest.EchoHandler</description><code_before>@@ -101,7 +101,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         Channel sc = sb.bind().sync().channel();
         Channel cc = cb.connect().sync().channel();
         Future&lt;Channel&gt; hf = cc.pipeline().get(SslHandler.class).handshakeFuture();
-        cc.write(Unpooled.wrappedBuffer(data, 0, FIRST_MESSAGE_SIZE));
         final AtomicBoolean firstByteWriteFutureDone = new AtomicBoolean();
 
         hf.sync();
@@ -110,7 +110,7 @@ public void initChannel(SocketChannel sch) throws Exception {
 
         for (int i = FIRST_MESSAGE_SIZE; i &lt; data.length;) {
             int length = Math.min(random.nextInt(1024 * 64), data.length - i);
-            ChannelFuture future = cc.write(Unpooled.wrappedBuffer(data, i, length));
             future.sync();
             i += length;
         }
@@ -180,7 +180,7 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
             byte[] actual = new byte[in.readableBytes()];
             in.readBytes(actual);
 
@@ -196,6 +196,11 @@ public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Except
             counter += actual.length;
         }
 
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx,
                 Throwable cause) throws Exception {
</code_before><code_after>@@ -101,7 +101,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         Channel sc = sb.bind().sync().channel();
         Channel cc = cb.connect().sync().channel();
         Future&lt;Channel&gt; hf = cc.pipeline().get(SslHandler.class).handshakeFuture();
+        cc.write(Unpooled.wrappedBuffer(data, 0, FIRST_MESSAGE_SIZE)).flush();
         final AtomicBoolean firstByteWriteFutureDone = new AtomicBoolean();
 
         hf.sync();
@@ -110,7 +110,7 @@ public void initChannel(SocketChannel sch) throws Exception {
 
         for (int i = FIRST_MESSAGE_SIZE; i &lt; data.length;) {
             int length = Math.min(random.nextInt(1024 * 64), data.length - i);
+            ChannelFuture future = cc.write(Unpooled.wrappedBuffer(data, i, length)).flush();
             future.sync();
             i += length;
         }
@@ -180,7 +180,7 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
+        public void messageReceived0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
             byte[] actual = new byte[in.readableBytes()];
             in.readBytes(actual);
 
@@ -196,6 +196,11 @@ public void messageReceived(ChannelHandlerContext ctx, ByteBuf in) throws Except
             counter += actual.length;
         }
 
+        @Override
+        public void messageReceivedLast(ChannelHandlerContext ctx) throws Exception {
+            ctx.flush();
+        }
+
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx,
                 Throwable cause) throws Exception {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>293983</refactoring_id><commit_sha>ac3c906a9b4570c1c7a592a95315572109efe8bd</commit_sha><commit_link>https://github.com/h2database/h2database/commit/ac3c906a9b4570c1c7a592a95315572109efe8bd</commit_link><file_path>h2/src/main/org/h2/server/TcpServer.java</file_path><description>Rename Method package logError(e Throwable) : void renamed to package traceError(e Throwable) : void in class org.h2.server.TcpServer</description><code_before>@@ -22,9 +22,11 @@
 import java.util.Set;
 
 import org.h2.Driver;
 import org.h2.engine.Constants;
 import org.h2.message.Message;
 import org.h2.message.TraceSystem;
 import org.h2.util.JdbcUtils;
 import org.h2.util.MathUtils;
 import org.h2.util.NetUtils;
@@ -47,10 +49,9 @@ public class TcpServer implements Service {
     public static final int DEFAULT_PORT = 9092;
     private static final int SHUTDOWN_NORMAL = 0;
     private static final int SHUTDOWN_FORCE = 1;
-    public static boolean logInternalErrors;
 
     private int port;
-    private boolean log;
     private boolean ssl;
     private boolean stop;
     private ServerSocket serverSocket;
@@ -147,20 +148,38 @@ public void init(String[] args) throws Exception {
         port = DEFAULT_PORT;
         for (int i = 0; i &lt; args.length; i++) {
             String a = args[i];
-            if ("-log".equals(a)) {
-                log = Boolean.valueOf(args[++i]).booleanValue();
             } else if ("-tcpSSL".equals(a)) {
-                ssl = Boolean.valueOf(args[++i]).booleanValue();
             } else if ("-tcpPort".equals(a)) {
                 port = MathUtils.decodeInt(args[++i]);
             } else if ("-tcpPassword".equals(a)) {
                 managementPassword = args[++i];
             } else if ("-baseDir".equals(a)) {
                 baseDir = args[++i];
             } else if ("-tcpAllowOthers".equals(a)) {
-                allowOthers = Boolean.valueOf(args[++i]).booleanValue();
             } else if ("-ifExists".equals(a)) {
-                ifExists = Boolean.valueOf(args[++i]).booleanValue();
             }
         }
         org.h2.Driver.load();
@@ -287,15 +306,14 @@ String getBaseDir() {
         return baseDir;
     }
 
-    void log(String s) {
-        // TODO log: need concept for server log
-        if (log) {
             System.out.println(s);
         }
     }
 
-    void logError(Throwable e) {
-        if (log) {
             e.printStackTrace();
         }
     }
@@ -312,13 +330,6 @@ public String getName() {
         return "H2 TCP Server";
     }
 
-    public void logInternalError(String string) {
-        if (logInternalErrors) {
-            System.out.println(string);
-            new Error(string).printStackTrace();
-        }
-    }
-
     public boolean getIfExists() {
         return ifExists;
     }
</code_before><code_after>@@ -22,9 +22,11 @@
 import java.util.Set;
 
 import org.h2.Driver;
+import org.h2.constant.SysProperties;
 import org.h2.engine.Constants;
 import org.h2.message.Message;
 import org.h2.message.TraceSystem;
+import org.h2.tools.Server;
 import org.h2.util.JdbcUtils;
 import org.h2.util.MathUtils;
 import org.h2.util.NetUtils;
@@ -47,10 +49,9 @@ public class TcpServer implements Service {
     public static final int DEFAULT_PORT = 9092;
     private static final int SHUTDOWN_NORMAL = 0;
     private static final int SHUTDOWN_FORCE = 1;
 
     private int port;
+    private boolean trace;
     private boolean ssl;
     private boolean stop;
     private ServerSocket serverSocket;
@@ -147,20 +148,38 @@ public void init(String[] args) throws Exception {
         port = DEFAULT_PORT;
         for (int i = 0; i &lt; args.length; i++) {
             String a = args[i];
+            if ("-trace".equals(a)) {
+                trace = true;
+            } else if ("-log".equals(a) &amp;&amp; SysProperties.OLD_COMMAND_LINE_OPTIONS) {
+                trace = Server.readArgBoolean(args, i) == 1;
+                i++;
             } else if ("-tcpSSL".equals(a)) {
+                if (Server.readArgBoolean(args, i) != 0) {
+                    ssl = Server.readArgBoolean(args, i) == 1;
+                    i++;
+                } else {
+                    ssl = true;
+                }
             } else if ("-tcpPort".equals(a)) {
                 port = MathUtils.decodeInt(args[++i]);
             } else if ("-tcpPassword".equals(a)) {
                 managementPassword = args[++i];
             } else if ("-baseDir".equals(a)) {
                 baseDir = args[++i];
             } else if ("-tcpAllowOthers".equals(a)) {
+                if (Server.readArgBoolean(args, i) != 0) {
+                    allowOthers = Server.readArgBoolean(args, i) == 1;
+                    i++;
+                } else {
+                    allowOthers = true;
+                }
             } else if ("-ifExists".equals(a)) {
+                if (Server.readArgBoolean(args, i) != 0) {
+                    ifExists = Server.readArgBoolean(args, i) == 1;
+                    i++;
+                } else {
+                    ifExists = true;
+                }
             }
         }
         org.h2.Driver.load();
@@ -287,15 +306,14 @@ String getBaseDir() {
         return baseDir;
     }
 
+    void trace(String s) {
+        if (trace) {
             System.out.println(s);
         }
     }
 
+    void traceError(Throwable e) {
+        if (trace) {
             e.printStackTrace();
         }
     }
@@ -312,13 +330,6 @@ public String getName() {
         return "H2 TCP Server";
     }
 
     public boolean getIfExists() {
         return ifExists;
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>321275</refactoring_id><commit_sha>7111df2af9896f4ef20ed0a08d45023df79e3193</commit_sha><commit_link>https://github.com/bcgit/bc-java/commit/7111df2af9896f4ef20ed0a08d45023df79e3193</commit_link><file_path>test/src/test/java/org/bouncycastle/test/est/TestServerKeyGeneration.java</file_path><description>Rename Method public serverGenWithoutEncryption() : void renamed to public testServerGenWithoutEncryption() : void in class org.bouncycastle.test.est.TestServerKeyGeneration</description><code_before>@@ -21,24 +21,20 @@
 import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;
 import org.bouncycastle.util.io.Streams;
 import org.bouncycastle.util.test.SimpleTest;
 
 public class TestServerKeyGeneration
     extends SimpleTest
 {
 
 
-    private static final String ca = "-----BEGIN CERTIFICATE-----\n" +
-        "MIIBuDCCAV+gAwIBAgIBATAKBggqhkjOPQQDAjAyMTAwLgYDVQQDEydOb24tUHJv\n" +
-        "ZHVjdGlvbiBUZXN0aW5nIFJvb3QgQ0EgaDlCaDhUWWkwHhcNMjIwNDA4MDAwMDQ1\n" +
-        "WhcNMjIwNDA5MDAwMDQ1WjAyMTAwLgYDVQQDEydOb24tUHJvZHVjdGlvbiBUZXN0\n" +
-        "aW5nIFJvb3QgQ0EgaDlCaDhUWWkwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAR5\n" +
-        "+kq7LlVAr1HWAIB4w8lfiiwi+cRrCbxR7tjyBXAkeA3wQ+ErkC9f8qge8OAHKNZ6\n" +
-        "R09m1oMbBzWUrmyl8gkQo2YwZDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgw\n" +
-        "BgEB/wIBATAdBgNVHQ4EFgQUb3fqxptJnhpKRWgz+lK4LCSbdF0wHwYDVR0jBBgw\n" +
-        "FoAUb3fqxptJnhpKRWgz+lK4LCSbdF0wCgYIKoZIzj0EAwIDRwAwRAIgG5JG0jrQ\n" +
-        "+TcS9jSyKnK0UOyM8Oq+ZVViOZuOviXYlKgCIAE2nMK2OBJZR3rnkw924Q5rr+cg\n" +
-        "F2GpHhBxbbwSNfGN\n" +
-        "-----END CERTIFICATE-----\n";
 
     public String getName()
     {
@@ -48,11 +44,12 @@ public String getName()
     public void performTest()
         throws Exception
     {
-        serverGenWithoutEncryption();
     }
 
 
-    public void serverGenWithoutEncryption()
         throws Exception
     {
         //
@@ -70,7 +67,8 @@ public void serverGenWithoutEncryption()
         }
         catch (ESTException ex)
         {
-            skip("skipping, unable to fetch CA certs, assume no EST server.");
         }
 
 
</code_before><code_after>@@ -21,24 +21,20 @@
 import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;
 import org.bouncycastle.util.io.Streams;
 import org.bouncycastle.util.test.SimpleTest;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
 
 public class TestServerKeyGeneration
     extends SimpleTest
 {
 
 
+    @Before
+    public void before()
+    {
+        ESTTestUtils.ensureProvider();
+    }
 
     public String getName()
     {
@@ -48,11 +44,12 @@ public String getName()
     public void performTest()
         throws Exception
     {
+        testServerGenWithoutEncryption();
     }
 
 
+    @Test
+    public void testServerGenWithoutEncryption()
         throws Exception
     {
         //
@@ -70,7 +67,8 @@ public void serverGenWithoutEncryption()
         }
         catch (ESTException ex)
         {
+            // Skip if server cannot be reached.
+            Assume.assumeNoException(ex);
         }
 
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>150946</refactoring_id><commit_sha>c310daad65ed65a28a172cb04f8578cdf41c4ed1</commit_sha><commit_link>https://github.com/batfish/batfish/commit/c310daad65ed65a28a172cb04f8578cdf41c4ed1</commit_link><file_path>projects/batfish/src/test/java/org/batfish/representation/fortios/PolicyTest.java</file_path><description>Rename Method public testInvalidReason_missingSrcIntf() : void renamed to public testPolicyValid_missingSrcIntf() : void in class org.batfish.grammar.fortios.FortiosConfigurationBuilderTest</description><code_before>@@ -1,69 +0,0 @@
-package org.batfish.representation.fortios;
-
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertNull;
-
-import org.junit.Test;
-
-/** Tests of {@link Policy} */
-public class PolicyTest {
-
-  private static Policy buildCompletePolicy() {
-    Policy p = new Policy("1");
-    p.getSrcIntf().add("srcIntf");
-    p.getDstIntf().add("dstIntf");
-    p.getSrcAddrUUIDs().add(new BatfishUUID(1));
-    p.getDstAddrUUIDs().add(new BatfishUUID(2));
-    p.getServiceUUIDs().add(new BatfishUUID(3));
-    p.setValid(true);
-    return p;
-  }
-
-  @Test
-  public void testInvalidReason_validPolicy() {
-    assertNull(buildCompletePolicy().getInvalidReason());
-  }
-
-  @Test
-  public void testInvalidReason_markedInvalid() {
-    Policy p = buildCompletePolicy();
-    p.setValid(false);
-    assertThat(p.getInvalidReason(), equalTo("name is invalid"));
-  }
-
-  @Test
-  public void testInvalidReason_missingSrcIntf() {
-    Policy p = buildCompletePolicy();
-    p.getSrcIntf().clear();
-    assertThat(p.getInvalidReason(), equalTo("srcintf must be set"));
-  }
-
-  @Test
-  public void testInvalidReason_missingDstIntf() {
-    Policy p = buildCompletePolicy();
-    p.getDstIntf().clear();
-    assertThat(p.getInvalidReason(), equalTo("dstintf must be set"));
-  }
-
-  @Test
-  public void testInvalidReason_missingSrcAddr() {
-    Policy p = buildCompletePolicy();
-    p.getSrcAddrUUIDs().clear();
-    assertThat(p.getInvalidReason(), equalTo("srcaddr must be set"));
-  }
-
-  @Test
-  public void testInvalidReason_missingDstAddr() {
-    Policy p = buildCompletePolicy();
-    p.getDstAddrUUIDs().clear();
-    assertThat(p.getInvalidReason(), equalTo("dstaddr must be set"));
-  }
-
-  @Test
-  public void testInvalidReason_missingService() {
-    Policy p = buildCompletePolicy();
-    p.getServiceUUIDs().clear();
-    assertThat(p.getInvalidReason(), equalTo("service must be set"));
-  }
-}
</code_before><code_after>@@ -1,69 +0,0 @@
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>194119</refactoring_id><commit_sha>f8954bd93d4580cc4ae73496b8d98245754fb5d2</commit_sha><commit_link>https://github.com/jabref/jabref/commit/f8954bd93d4580cc4ae73496b8d98245754fb5d2</commit_link><file_path>src/test/java/net/sf/jabref/logic/importer/fetcher/IsbnFetcherTest.java</file_path><description>Rename Method public testFetcher10ShortISBN() : void renamed to public searchByIdThrowsExceptionForShortInvalidISBN() : void in class net.sf.jabref.logic.importer.fetcher.IsbnFetcherTest</description><code_before>@@ -45,38 +45,35 @@ public void testHelpPage() {
     }
 
     @Test
-    public void testFetcher10() throws FetcherException {
         Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("0321356683");
         assertEquals(Optional.of(bibEntry), fetchedEntry);
     }
 
     @Test
-    public void testFetcher13() throws FetcherException {
         Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("978-0321356680");
         assertEquals(Optional.of(bibEntry), fetchedEntry);
     }
 
     @Test
-    public void testFetcher10Empty() throws FetcherException {
         Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("");
         assertEquals(Optional.empty(), fetchedEntry);
     }
 
-    @Test
-    public void testFetcher10ShortISBN() throws FetcherException {
-        Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("123456789");
-        assertEquals(Optional.empty(), fetchedEntry);
     }
 
-    @Test
-    public void testFetcher10LongISBN() throws FetcherException {
-        Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("012345678910");
-        assertEquals(Optional.empty(), fetchedEntry);
     }
 
-    @Test
-    public void testFetcher10InvalidISBN() throws FetcherException {
-        Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("jabref-4-ever");
-        assertEquals(Optional.empty(), fetchedEntry);
     }
 }
</code_before><code_after>@@ -45,38 +45,35 @@ public void testHelpPage() {
     }
 
     @Test
+    public void searchByIdSuccessfulWithShortISBN() throws FetcherException {
         Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("0321356683");
         assertEquals(Optional.of(bibEntry), fetchedEntry);
     }
 
     @Test
+    public void searchByIdSuccessfulWithLongISBN() throws FetcherException {
         Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("978-0321356680");
         assertEquals(Optional.of(bibEntry), fetchedEntry);
     }
 
     @Test
+    public void searchByIdReturnsEmptyWithEmptyISBN() throws FetcherException {
         Optional&lt;BibEntry&gt; fetchedEntry = fetcher.performSearchById("");
         assertEquals(Optional.empty(), fetchedEntry);
     }
 
+    @Test(expected = FetcherException.class)
+    public void searchByIdThrowsExceptionForShortInvalidISBN() throws FetcherException {
+        fetcher.performSearchById("123456789");
     }
 
+    @Test(expected = FetcherException.class)
+    public void searchByIdThrowsExceptionForLongInvalidISB() throws FetcherException {
+        fetcher.performSearchById("012345678910");
     }
 
+    @Test(expected = FetcherException.class)
+    public void searchByIdThrowsExceptionForInvalidISBN() throws FetcherException {
+        fetcher.performSearchById("jabref-4-ever");
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>138530</refactoring_id><commit_sha>f3cce3d24ecc59453c8cab6014260e0e2703f1a9</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/f3cce3d24ecc59453c8cab6014260e0e2703f1a9</commit_link><file_path>src/main/java/vazkii/botania/common/block/tile/TileLightRelay.java</file_path><description>Rename Method public update() : void renamed to public updateEntity() : void in class vazkii.botania.common.block.tile.TileLightRelay</description><code_before>@@ -37,7 +37,7 @@
 import vazkii.botania.common.core.helper.MathHelper;
 import vazkii.botania.common.core.helper.Vector3;
 
-public class TileLightRelay extends TileMod implements IWandBindable, ITickable {
 
 	private static final int MAX_DIST = 20;
 
@@ -63,7 +63,7 @@ public void mountEntity(Entity e) {
 	}
 
 	@Override
-	public void update() {
 		ticksElapsed++;
 
 		if(bindPos.getY() &gt; -1 &amp;&amp; isValidBinding()) {
</code_before><code_after>@@ -37,7 +37,7 @@
 import vazkii.botania.common.core.helper.MathHelper;
 import vazkii.botania.common.core.helper.Vector3;
 
+public class TileLightRelay extends TileMod implements IWandBindable {
 
 	private static final int MAX_DIST = 20;
 
@@ -63,7 +63,7 @@ public void mountEntity(Entity e) {
 	}
 
 	@Override
+	public void updateEntity() {
 		ticksElapsed++;
 
 		if(bindPos.getY() &gt; -1 &amp;&amp; isValidBinding()) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>184373</refactoring_id><commit_sha>151a323a9d206ce6d6277fcf2afeb04fa3a0d88d</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/151a323a9d206ce6d6277fcf2afeb04fa3a0d88d</commit_link><file_path>src/main/java/com/google/devtools/build/lib/rules/python/PyInfo.java</file_path><description>Rename Method public getCreationLoc() : Location renamed to public getCreationLocation() : Location in class com.google.devtools.build.lib.rules.python.PyInfo</description><code_before>@@ -103,7 +103,7 @@ public PyInfoProvider getProvider() {
   }
 
   @Override
-  public Location getCreationLoc() {
     return location;
   }
 
</code_before><code_after>@@ -103,7 +103,7 @@ public PyInfoProvider getProvider() {
   }
 
   @Override
+  public Location getCreationLocation() {
     return location;
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>191336</refactoring_id><commit_sha>b0bb03fa8f71b127e452644845ad50d22d09c721</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/b0bb03fa8f71b127e452644845ad50d22d09c721</commit_link><file_path>OsmAnd/src/net/osmand/plus/quickaction/SwitchableAction.java</file_path><description>Rename Method protected getItemIconColorRes(app OsmandApplication, item T) : int renamed to protected getItemIconColor(app OsmandApplication, item T) : int in class net.osmand.plus.quickaction.SwitchableAction</description><code_before>@@ -12,10 +12,12 @@
 import android.widget.ImageView;
 import android.widget.TextView;
 
 import androidx.annotation.ColorRes;
 import androidx.annotation.DrawableRes;
 import androidx.annotation.StringRes;
 import androidx.appcompat.widget.SwitchCompat;
 import androidx.fragment.app.FragmentManager;
 import androidx.recyclerview.widget.ItemTouchHelper;
 import androidx.recyclerview.widget.RecyclerView;
@@ -161,8 +163,8 @@ public void onBindViewHolder(final Adapter.ItemHolder holder, final int position
 
 			OsmandApplication app = (OsmandApplication) context.getApplicationContext();
 
-			Drawable icon = app.getUIUtilities().getIcon(
-					getItemIconRes(app, item), getItemIconColorRes(app, item));
 			holder.icon.setImageDrawable(icon);
 
 			holder.title.setText(getItemName(context, item));
@@ -310,10 +312,11 @@ protected int getItemIconRes(Context context, T item) {
 		return R.drawable.ic_map;
 	}
 
-	@ColorRes
-	protected int getItemIconColorRes(OsmandApplication app, T item) {
 		boolean nightMode = !app.getSettings().isLightContent();
-		return nightMode ? R.color.icon_color_default_dark : R.color.icon_color_default_light;
 	}
 
 	protected abstract
</code_before><code_after>@@ -12,10 +12,12 @@
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import androidx.annotation.ColorInt;
 import androidx.annotation.ColorRes;
 import androidx.annotation.DrawableRes;
 import androidx.annotation.StringRes;
 import androidx.appcompat.widget.SwitchCompat;
+import androidx.core.content.ContextCompat;
 import androidx.fragment.app.FragmentManager;
 import androidx.recyclerview.widget.ItemTouchHelper;
 import androidx.recyclerview.widget.RecyclerView;
@@ -161,8 +163,8 @@ public void onBindViewHolder(final Adapter.ItemHolder holder, final int position
 
 			OsmandApplication app = (OsmandApplication) context.getApplicationContext();
 
+			Drawable icon = app.getUIUtilities().getPaintedIcon(
+					getItemIconRes(app, item), getItemIconColor(app, item));
 			holder.icon.setImageDrawable(icon);
 
 			holder.title.setText(getItemName(context, item));
@@ -310,10 +312,11 @@ protected int getItemIconRes(Context context, T item) {
 		return R.drawable.ic_map;
 	}
 
+	@ColorInt
+	protected int getItemIconColor(OsmandApplication app, T item) {
 		boolean nightMode = !app.getSettings().isLightContent();
+		int colorRes = nightMode ? R.color.icon_color_default_dark : R.color.icon_color_default_light;
+		return ContextCompat.getColor(app, colorRes);
 	}
 
 	protected abstract
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>172958</refactoring_id><commit_sha>7035a1b922a2fd468f445e5faa59a5aa7a6fd418</commit_sha><commit_link>https://github.com/activiti/activiti/commit/7035a1b922a2fd468f445e5faa59a5aa7a6fd418</commit_link><file_path>modules/activiti-engine/src/main/java/org/activiti/pvm/ProcessDefinitionBuilder.java</file_path><description>Rename Method public createProcessDefinition() : ProcessDefinitionBuilder renamed to public createProcessDefinitionBuilder() : ProcessDefinitionBuilder in class org.activiti.pvm.ProcessDefinitionBuilder</description><code_before>@@ -41,14 +41,11 @@ private ProcessDefinitionBuilder(VariableTypes variableTypes) {
     this.unresolvedTransitions = new ArrayList&lt;UnresolvedTransition&gt;();
   }
 
-  /**
-   * Creates a new process definition with an unspecified id.
-   */
-  public static ProcessDefinitionBuilder createProcessDefinition() {
     return new ProcessDefinitionBuilder(new DefaultVariableTypes());
   }
 
-  public ObjectProcessDefinition endProcessDefinition() {
     resolveTransitions();
     return processDefinition;
   }
</code_before><code_after>@@ -41,14 +41,11 @@ private ProcessDefinitionBuilder(VariableTypes variableTypes) {
     this.unresolvedTransitions = new ArrayList&lt;UnresolvedTransition&gt;();
   }
 
+  public static ProcessDefinitionBuilder createProcessDefinitionBuilder() {
     return new ProcessDefinitionBuilder(new DefaultVariableTypes());
   }
 
+  public ObjectProcessDefinition build() {
     resolveTransitions();
     return processDefinition;
   }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>247628</refactoring_id><commit_sha>d5ee787e1e6653257720afe31ee3f8819cd4605c</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/d5ee787e1e6653257720afe31ee3f8819cd4605c</commit_link><file_path>spring-beans/src/test/java/org/springframework/beans/factory/support/ManagedSetTests.java</file_path><description>Rename Method public testMergeWithNonCompatibleParentType() : void renamed to public mergeWithNonCompatibleParentType() : void in class org.springframework.beans.factory.support.ManagedSetTests</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,15 +18,20 @@
 
 import java.util.Set;
 
-import junit.framework.TestCase;
 
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
  */
-public class ManagedSetTests extends TestCase {
 
-	public void testMergeSunnyDay() {
 		ManagedSet parent = new ManagedSet();
 		parent.add("one");
 		parent.add("two");
@@ -37,36 +42,29 @@ public void testMergeSunnyDay() {
 		assertEquals("merge() obviously did not work.", 3, mergedSet.size());
 	}
 
-	public void testMergeWithNullParent() {
 		ManagedSet child = new ManagedSet();
 		child.add("one");
 		child.setMergeEnabled(true);
 		assertSame(child, child.merge(null));
 	}
 
-	public void testMergeNotAllowedWhenMergeNotEnabled() {
-		ManagedSet child = new ManagedSet();
-		try {
-			child.merge(null);
-			fail("Must have failed by this point (cannot merge() when the mergeEnabled property is false.");
-		}
-		catch (IllegalStateException expected) {
-		}
 	}
 
-	public void testMergeWithNonCompatibleParentType() {
 		ManagedSet child = new ManagedSet();
 		child.add("one");
 		child.setMergeEnabled(true);
-		try {
-			child.merge("hello");
-			fail("Must have failed by this point.");
-		}
-		catch (IllegalArgumentException expected) {
-		}
 	}
 
-	public void testMergeEmptyChild() {
 		ManagedSet parent = new ManagedSet();
 		parent.add("one");
 		parent.add("two");
@@ -76,7 +74,8 @@ public void testMergeEmptyChild() {
 		assertEquals("merge() obviously did not work.", 2, mergedSet.size());
 	}
 
-	public void testMergeChildValuesOverrideTheParents() {
 		// asserts that the set contract is not violated during a merge() operation...
 		ManagedSet parent = new ManagedSet();
 		parent.add("one");
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright 2002-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,15 +18,20 @@
 
 import java.util.Set;
 
+import org.junit.Test;
+
+import static org.junit.Assert.*;
 
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
+ * @author Sam Brannen
  */
+@SuppressWarnings({ "rawtypes", "unchecked" })
+public class ManagedSetTests {
 
+	@Test
+	public void mergeSunnyDay() {
 		ManagedSet parent = new ManagedSet();
 		parent.add("one");
 		parent.add("two");
@@ -37,36 +42,29 @@ public void testMergeSunnyDay() {
 		assertEquals("merge() obviously did not work.", 3, mergedSet.size());
 	}
 
+	@Test
+	public void mergeWithNullParent() {
 		ManagedSet child = new ManagedSet();
 		child.add("one");
 		child.setMergeEnabled(true);
 		assertSame(child, child.merge(null));
 	}
 
+	@Test(expected = IllegalStateException.class)
+	public void mergeNotAllowedWhenMergeNotEnabled() {
+		new ManagedSet().merge(null);
 	}
 
+	@Test(expected = IllegalArgumentException.class)
+	public void mergeWithNonCompatibleParentType() {
 		ManagedSet child = new ManagedSet();
 		child.add("one");
 		child.setMergeEnabled(true);
+		child.merge("hello");
 	}
 
+	@Test
+	public void mergeEmptyChild() {
 		ManagedSet parent = new ManagedSet();
 		parent.add("one");
 		parent.add("two");
@@ -76,7 +74,8 @@ public void testMergeEmptyChild() {
 		assertEquals("merge() obviously did not work.", 2, mergedSet.size());
 	}
 
+	@Test
+	public void mergeChildValuesOverrideTheParents() {
 		// asserts that the set contract is not violated during a merge() operation...
 		ManagedSet parent = new ManagedSet();
 		parent.add("one");
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>213624</refactoring_id><commit_sha>33616cc2c1753172b29e1caeebf98baa3fd7f90d</commit_sha><commit_link>https://github.com/apache/beam/commit/33616cc2c1753172b29e1caeebf98baa3fd7f90d</commit_link><file_path>sdks/java/fn-execution/src/main/java/org/apache/beam/sdk/fn/channel/ManagedChannelFactory.java</file_path><description>Rename Method public abstract forDescriptor(apiServiceDescriptor ApiServiceDescriptor) : ManagedChannel renamed to protected abstract builderFor(descriptor ApiServiceDescriptor) : ManagedChannelBuilder&lt;?&gt; in class org.apache.beam.sdk.fn.channel.ManagedChannelFactory</description><code_before>@@ -18,6 +18,7 @@
 
 package org.apache.beam.sdk.fn.channel;
 
 import io.grpc.ManagedChannel;
 import io.grpc.ManagedChannelBuilder;
 import io.grpc.netty.NettyChannelBuilder;
@@ -26,11 +27,10 @@
 import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.unix.DomainSocketAddress;
 import java.net.SocketAddress;
 import org.apache.beam.model.pipeline.v1.Endpoints.ApiServiceDescriptor;
 
-/**
- * A Factory which creates an underlying {@link ManagedChannel} implementation.
- */
 public abstract class ManagedChannelFactory {
   public static ManagedChannelFactory createDefault() {
     return new Default();
@@ -41,7 +41,20 @@ public static ManagedChannelFactory createEpoll() {
     return new Epoll();
   }
 
-  public abstract ManagedChannel forDescriptor(ApiServiceDescriptor apiServiceDescriptor);
 
   /**
    * Creates a {@link ManagedChannel} backed by an {@link EpollDomainSocketChannel} if the address
@@ -50,17 +63,18 @@ public static ManagedChannelFactory createEpoll() {
    */
   private static class Epoll extends ManagedChannelFactory {
     @Override
-    public ManagedChannel forDescriptor(ApiServiceDescriptor apiServiceDescriptor) {
       SocketAddress address = SocketAddressFactory.createFrom(apiServiceDescriptor.getUrl());
       return NettyChannelBuilder.forAddress(address)
-          .channelType(address instanceof DomainSocketAddress
-              ? EpollDomainSocketChannel.class : EpollSocketChannel.class)
           .eventLoopGroup(new EpollEventLoopGroup())
           .usePlaintext(true)
           // Set the message size to max value here. The actual size is governed by the
           // buffer size in the layers above.
-          .maxInboundMessageSize(Integer.MAX_VALUE)
-          .build();
     }
   }
 
@@ -70,13 +84,38 @@ public ManagedChannel forDescriptor(ApiServiceDescriptor apiServiceDescriptor) {
    */
   private static class Default extends ManagedChannelFactory {
     @Override
-    public ManagedChannel forDescriptor(ApiServiceDescriptor apiServiceDescriptor) {
       return ManagedChannelBuilder.forTarget(apiServiceDescriptor.getUrl())
           .usePlaintext(true)
           // Set the message size to max value here. The actual size is governed by the
           // buffer size in the layers above.
-          .maxInboundMessageSize(Integer.MAX_VALUE)
-          .build();
     }
   }
 }
</code_before><code_after>@@ -18,6 +18,7 @@
 
 package org.apache.beam.sdk.fn.channel;
 
+import io.grpc.ClientInterceptor;
 import io.grpc.ManagedChannel;
 import io.grpc.ManagedChannelBuilder;
 import io.grpc.netty.NettyChannelBuilder;
@@ -26,11 +27,10 @@
 import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.unix.DomainSocketAddress;
 import java.net.SocketAddress;
+import java.util.List;
 import org.apache.beam.model.pipeline.v1.Endpoints.ApiServiceDescriptor;
 
+/** A Factory which creates an underlying {@link ManagedChannel} implementation. */
 public abstract class ManagedChannelFactory {
   public static ManagedChannelFactory createDefault() {
     return new Default();
@@ -41,7 +41,20 @@ public static ManagedChannelFactory createEpoll() {
     return new Epoll();
   }
 
+  public ManagedChannel forDescriptor(ApiServiceDescriptor apiServiceDescriptor) {
+    return builderFor(apiServiceDescriptor).build();
+  }
+
+  /** Create a {@link ManagedChannelBuilder} for the provided {@link ApiServiceDescriptor}. */
+  protected abstract ManagedChannelBuilder&lt;?&gt; builderFor(ApiServiceDescriptor descriptor);
+
+  /**
+   * Returns a {@link ManagedChannelFactory} like this one, but which will apply the provided {@link
+   * ClientInterceptor ClientInterceptors} to any channel it creates.
+   */
+  public ManagedChannelFactory withInterceptors(List&lt;ClientInterceptor&gt; interceptors) {
+    return new InterceptedManagedChannelFactory(this, interceptors);
+  }
 
   /**
    * Creates a {@link ManagedChannel} backed by an {@link EpollDomainSocketChannel} if the address
@@ -50,17 +63,18 @@ public static ManagedChannelFactory createEpoll() {
    */
   private static class Epoll extends ManagedChannelFactory {
     @Override
+    public ManagedChannelBuilder&lt;?&gt; builderFor(ApiServiceDescriptor apiServiceDescriptor) {
       SocketAddress address = SocketAddressFactory.createFrom(apiServiceDescriptor.getUrl());
       return NettyChannelBuilder.forAddress(address)
+          .channelType(
+              address instanceof DomainSocketAddress
+                  ? EpollDomainSocketChannel.class
+                  : EpollSocketChannel.class)
           .eventLoopGroup(new EpollEventLoopGroup())
           .usePlaintext(true)
           // Set the message size to max value here. The actual size is governed by the
           // buffer size in the layers above.
+          .maxInboundMessageSize(Integer.MAX_VALUE);
     }
   }
 
@@ -70,13 +84,38 @@ public ManagedChannel forDescriptor(ApiServiceDescriptor apiServiceDescriptor) {
    */
   private static class Default extends ManagedChannelFactory {
     @Override
+    public ManagedChannelBuilder&lt;?&gt; builderFor(ApiServiceDescriptor apiServiceDescriptor) {
       return ManagedChannelBuilder.forTarget(apiServiceDescriptor.getUrl())
           .usePlaintext(true)
           // Set the message size to max value here. The actual size is governed by the
           // buffer size in the layers above.
+          .maxInboundMessageSize(Integer.MAX_VALUE);
+    }
+  }
+
+  private static class InterceptedManagedChannelFactory extends ManagedChannelFactory {
+    private final ManagedChannelFactory channelFactory;
+    private final List&lt;ClientInterceptor&gt; interceptors;
+
+    private InterceptedManagedChannelFactory(
+        ManagedChannelFactory managedChannelFactory, List&lt;ClientInterceptor&gt; interceptors) {
+      this.channelFactory = managedChannelFactory;
+      this.interceptors = interceptors;
+    }
+
+    @Override
+    public ManagedChannel forDescriptor(ApiServiceDescriptor apiServiceDescriptor) {
+      return builderFor(apiServiceDescriptor).intercept(interceptors).build();
+    }
+
+    @Override
+    protected ManagedChannelBuilder&lt;?&gt; builderFor(ApiServiceDescriptor descriptor) {
+      return channelFactory.builderFor(descriptor);
+    }
+
+    @Override
+    public ManagedChannelFactory withInterceptors(List&lt;ClientInterceptor&gt; interceptors) {
+      return new InterceptedManagedChannelFactory(channelFactory, interceptors);
     }
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>145031</refactoring_id><commit_sha>1fa08a6002262b4f24047fc53d07438b928a28e6</commit_sha><commit_link>https://github.com/nationalsecurityagency/ghidra/commit/1fa08a6002262b4f24047fc53d07438b928a28e6</commit_link><file_path>Ghidra/Framework/Docking/src/main/java/docking/widgets/GComponent.java</file_path><description>Rename Method public getHTMLRenderingEnabled() : boolean renamed to public isHTMLRenderingEnabled() : boolean in class docking.widgets.GComponent</description><code_before>@@ -39,11 +39,11 @@ public default void setHTMLRenderingEnabled(boolean enabled) {
 	}
 
 	/**
-	 * Returns the current HTML rendering 'enable-ment' of this component.
-	 * 
 	 * @return boolean, true if HTML rendering is allowed
 	 */
-	public default boolean getHTMLRenderingEnabled() {
 		Object prop = ((JComponent) this).getClientProperty(HTML_DISABLE_STRING);
 		return prop == null || prop != Boolean.TRUE;
 	}
@@ -66,7 +66,7 @@ public static void warnAboutHtmlText(String text) {
 
 	/**
 	 * Sets the HTML rendering flag for the specified component.
-	 * 
 	 * @param comp the thing
 	 * @param enabled boolean, if true html rendering will be allowed
 	 */
</code_before><code_after>@@ -39,11 +39,11 @@ public default void setHTMLRenderingEnabled(boolean enabled) {
 	}
 
 	/**
+	 * Returns the current HTML rendering enablement of this component.
+	 *
 	 * @return boolean, true if HTML rendering is allowed
 	 */
+	public default boolean isHTMLRenderingEnabled() {
 		Object prop = ((JComponent) this).getClientProperty(HTML_DISABLE_STRING);
 		return prop == null || prop != Boolean.TRUE;
 	}
@@ -66,7 +66,7 @@ public static void warnAboutHtmlText(String text) {
 
 	/**
 	 * Sets the HTML rendering flag for the specified component.
+	 *
 	 * @param comp the thing
 	 * @param enabled boolean, if true html rendering will be allowed
 	 */
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>286716</refactoring_id><commit_sha>6588ed764ed75ad878c5e270961a9ffbd2b6983e</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/6588ed764ed75ad878c5e270961a9ffbd2b6983e</commit_link><file_path>source/ch/cyberduck/ui/cocoa/CDPreferencesController.java</file_path><description>Rename Method public SCAuthenticationComboClicked(sender NSPopUpButton) : void renamed to public scAuthenticationComboClicked(sender NSPopUpButton) : void in class ch.cyberduck.ui.cocoa.CDPreferencesController</description><code_before>@@ -83,13 +83,13 @@ public void publickeyComboClicked(NSPopUpButton sender) {
     private static final String aes128_cbc = "aes128-cbc";
     private static final String cast128_cbc = "cast128-cbc";
 	
-    private NSPopUpButton CSEncryptionCombo;
-    public void setCSEncryptionCombo(NSPopUpButton CSEncryptionCombo) {
-		this.CSEncryptionCombo = CSEncryptionCombo;
-		this.CSEncryptionCombo.setTarget(this);
-		this.CSEncryptionCombo.setAction(new NSSelector("CSEncryptionComboClicked", new Class[] {NSPopUpButton.class}));
-		this.CSEncryptionCombo.removeAllItems();
-		this.CSEncryptionCombo.addItemsWithTitles(
 											new NSArray(new String[]{
 												"Default",
 												des_cbc, 
@@ -103,20 +103,20 @@ public void setCSEncryptionCombo(NSPopUpButton CSEncryptionCombo) {
 												cast128_cbc
 											}));
 		
-		CSEncryptionCombo.setTitle(Preferences.instance().getProperty("ssh.CSEncryption"));
     }
     
-    public void CSEncryptionComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.CSEncryption", sender.titleOfSelectedItem());
     }    
     
-    private NSPopUpButton SCEncryptionCombo;
-    public void setSCEncryptionCombo(NSPopUpButton SCEncryptionCombo) {
-		this.SCEncryptionCombo = SCEncryptionCombo;
-		this.SCEncryptionCombo.setTarget(this);
-		this.SCEncryptionCombo.setAction(new NSSelector("SCEncryptionComboClicked", new Class[] {NSPopUpButton.class}));
-		this.SCEncryptionCombo.removeAllItems();
-		this.SCEncryptionCombo.addItemsWithTitles(
 											new NSArray(new String[]{
 												"Default",
 												des_cbc, 
@@ -130,10 +130,10 @@ public void setSCEncryptionCombo(NSPopUpButton SCEncryptionCombo) {
 												cast128_cbc
 											}));
 		
-		SCEncryptionCombo.setTitle(Preferences.instance().getProperty("ssh.SCEncryption"));
     }
     
-    public void SCEncryptionComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.SCEncryption", sender.titleOfSelectedItem());
     }    
 	
@@ -144,13 +144,13 @@ public void SCEncryptionComboClicked(NSPopUpButton sender) {
     private static final String hmac_md5 = "hmac-md5";
     private static final String hmac_md5_96 = "hmac-md5-96";
     
-    private NSPopUpButton SCAuthenticationCombo;
-    public void setSCAuthenticationCombo(NSPopUpButton SCAuthenticationCombo) {
-		this.SCAuthenticationCombo = SCAuthenticationCombo;
-		this.SCAuthenticationCombo.setTarget(this);
-		this.SCAuthenticationCombo.setAction(new NSSelector("SCAuthenticationComboClicked", new Class[] {NSPopUpButton.class}));
-		this.SCAuthenticationCombo.removeAllItems();
-		this.SCAuthenticationCombo.addItemsWithTitles(
 												new NSArray(new String[]{
 													"Default",
 													hmac_sha1,
@@ -159,21 +159,21 @@ public void setSCAuthenticationCombo(NSPopUpButton SCAuthenticationCombo) {
 													hmac_md5_96
 												}));
 		
-		SCAuthenticationCombo.setTitle(Preferences.instance().getProperty("ssh.SCAuthentication"));
     }
     
-    public void SCAuthenticationComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.SCAuthentication", sender.titleOfSelectedItem());
     }    
 	
     
-    private NSPopUpButton CSAuthenticationCombo;
-    public void setCSAuthenticationCombo(NSPopUpButton CSAuthenticationCombo) {
-		this.CSAuthenticationCombo = CSAuthenticationCombo;
-		this.CSAuthenticationCombo.setTarget(this);
-		this.CSAuthenticationCombo.setAction(new NSSelector("CSAuthenticationComboClicked", new Class[] {NSPopUpButton.class}));
-		this.CSAuthenticationCombo.removeAllItems();
-		this.CSAuthenticationCombo.addItemsWithTitles(
 												new NSArray(new String[]{
 													"Default",
 													hmac_sha1,
@@ -182,10 +182,10 @@ public void setCSAuthenticationCombo(NSPopUpButton CSAuthenticationCombo) {
 													hmac_md5_96
 												}));
 		
-		CSAuthenticationCombo.setTitle(Preferences.instance().getProperty("ssh.CSAuthentication"));
     }
     
-    public void CSAuthenticationComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.CSAuthentication", sender.titleOfSelectedItem());
     }    
 	
</code_before><code_after>@@ -83,13 +83,13 @@ public void publickeyComboClicked(NSPopUpButton sender) {
     private static final String aes128_cbc = "aes128-cbc";
     private static final String cast128_cbc = "cast128-cbc";
 	
+    private NSPopUpButton csEncryptionCombo;
+    public void setCsEncryptionCombo(NSPopUpButton csEncryptionCombo) {
+		this.csEncryptionCombo = csEncryptionCombo;
+		this.csEncryptionCombo.setTarget(this);
+		this.csEncryptionCombo.setAction(new NSSelector("csEncryptionComboClicked", new Class[] {NSPopUpButton.class}));
+		this.csEncryptionCombo.removeAllItems();
+		this.csEncryptionCombo.addItemsWithTitles(
 											new NSArray(new String[]{
 												"Default",
 												des_cbc, 
@@ -103,20 +103,20 @@ public void setCSEncryptionCombo(NSPopUpButton CSEncryptionCombo) {
 												cast128_cbc
 											}));
 		
+		csEncryptionCombo.setTitle(Preferences.instance().getProperty("ssh.CSEncryption"));
     }
     
+    public void csEncryptionComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.CSEncryption", sender.titleOfSelectedItem());
     }    
     
+    private NSPopUpButton scEncryptionCombo;
+    public void setScEncryptionCombo(NSPopUpButton scEncryptionCombo) {
+		this.scEncryptionCombo = scEncryptionCombo;
+		this.scEncryptionCombo.setTarget(this);
+		this.scEncryptionCombo.setAction(new NSSelector("scEncryptionComboClicked", new Class[] {NSPopUpButton.class}));
+		this.scEncryptionCombo.removeAllItems();
+		this.scEncryptionCombo.addItemsWithTitles(
 											new NSArray(new String[]{
 												"Default",
 												des_cbc, 
@@ -130,10 +130,10 @@ public void setSCEncryptionCombo(NSPopUpButton SCEncryptionCombo) {
 												cast128_cbc
 											}));
 		
+		scEncryptionCombo.setTitle(Preferences.instance().getProperty("ssh.SCEncryption"));
     }
     
+    public void scEncryptionComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.SCEncryption", sender.titleOfSelectedItem());
     }    
 	
@@ -144,13 +144,13 @@ public void SCEncryptionComboClicked(NSPopUpButton sender) {
     private static final String hmac_md5 = "hmac-md5";
     private static final String hmac_md5_96 = "hmac-md5-96";
     
+    private NSPopUpButton scAuthenticationCombo;
+    public void setScAuthenticationCombo(NSPopUpButton scAuthenticationCombo) {
+		this.scAuthenticationCombo = scAuthenticationCombo;
+		this.scAuthenticationCombo.setTarget(this);
+		this.scAuthenticationCombo.setAction(new NSSelector("scAuthenticationComboClicked", new Class[] {NSPopUpButton.class}));
+		this.scAuthenticationCombo.removeAllItems();
+		this.scAuthenticationCombo.addItemsWithTitles(
 												new NSArray(new String[]{
 													"Default",
 													hmac_sha1,
@@ -159,21 +159,21 @@ public void setSCAuthenticationCombo(NSPopUpButton SCAuthenticationCombo) {
 													hmac_md5_96
 												}));
 		
+		scAuthenticationCombo.setTitle(Preferences.instance().getProperty("ssh.SCAuthentication"));
     }
     
+    public void scAuthenticationComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.SCAuthentication", sender.titleOfSelectedItem());
     }    
 	
     
+    private NSPopUpButton csAuthenticationCombo;
+    public void setCsAuthenticationCombo(NSPopUpButton csAuthenticationCombo) {
+		this.csAuthenticationCombo = csAuthenticationCombo;
+		this.csAuthenticationCombo.setTarget(this);
+		this.csAuthenticationCombo.setAction(new NSSelector("csAuthenticationComboClicked", new Class[] {NSPopUpButton.class}));
+		this.csAuthenticationCombo.removeAllItems();
+		this.csAuthenticationCombo.addItemsWithTitles(
 												new NSArray(new String[]{
 													"Default",
 													hmac_sha1,
@@ -182,10 +182,10 @@ public void setCSAuthenticationCombo(NSPopUpButton CSAuthenticationCombo) {
 													hmac_md5_96
 												}));
 		
+		csAuthenticationCombo.setTitle(Preferences.instance().getProperty("ssh.CSAuthentication"));
     }
     
+    public void csAuthenticationComboClicked(NSPopUpButton sender) {
 		Preferences.instance().setProperty("ssh.CSAuthentication", sender.titleOfSelectedItem());
     }    
 	
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>174990</refactoring_id><commit_sha>94614556d1c03bde2756124596b65bcc87474f0a</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/94614556d1c03bde2756124596b65bcc87474f0a</commit_link><file_path>src/additions/java/mekanism/additions/common/entity/baby/EntityBabyEnderman.java</file_path><description>Rename Method public setChild(child boolean) : void renamed to public setBaby(child boolean) : void in class mekanism.additions.common.entity.baby.EntityBabyEnderman</description><code_before>@@ -18,53 +18,53 @@
 
 public class EntityBabyEnderman extends EndermanEntity implements IBabyEntity {
 
-    private static final DataParameter&lt;Boolean&gt; IS_CHILD = EntityDataManager.createKey(EntityBabyEnderman.class, DataSerializers.BOOLEAN);
 
     public EntityBabyEnderman(EntityType&lt;EntityBabyEnderman&gt; type, World world) {
         super(type, world);
-        setChild(true);
     }
 
     @Override
-    protected void registerData() {
-        super.registerData();
-        getDataManager().register(IS_CHILD, false);
     }
 
     @Override
-    public boolean isChild() {
-        return getDataManager().get(IS_CHILD);
     }
 
     @Override
-    public void setChild(boolean child) {
         setChild(IS_CHILD, child);
     }
 
     @Override
-    public void notifyDataManagerChange(@Nonnull DataParameter&lt;?&gt; key) {
         if (IS_CHILD.equals(key)) {
-            recalculateSize();
         }
-        super.notifyDataManagerChange(key);
     }
 
     @Override
-    protected int getExperiencePoints(@Nonnull PlayerEntity player) {
-        if (isChild()) {
-            experienceValue = (int) (experienceValue * 2.5F);
         }
-        return super.getExperiencePoints(player);
     }
 
     @Override
-    public double getYOffset() {
-        return isChild() ? 0 : super.getYOffset();
     }
 
     @Override
     protected float getStandingEyeHeight(@Nonnull Pose pose, @Nonnull EntitySize size) {
-        return this.isChild() ? 1.3F : super.getStandingEyeHeight(pose, size);
     }
 
     @Override
@@ -74,7 +74,7 @@ public ItemStack getPickedResult(RayTraceResult target) {
 
     @Nonnull
     @Override
-    public IPacket&lt;?&gt; createSpawnPacket() {
         return NetworkHooks.getEntitySpawningPacket(this);
     }
 }
\ No newline at end of file
</code_before><code_after>@@ -18,53 +18,53 @@
 
 public class EntityBabyEnderman extends EndermanEntity implements IBabyEntity {
 
+    private static final DataParameter&lt;Boolean&gt; IS_CHILD = EntityDataManager.defineId(EntityBabyEnderman.class, DataSerializers.BOOLEAN);
 
     public EntityBabyEnderman(EntityType&lt;EntityBabyEnderman&gt; type, World world) {
         super(type, world);
+        setBaby(true);
     }
 
     @Override
+    protected void defineSynchedData() {
+        super.defineSynchedData();
+        getEntityData().define(IS_CHILD, false);
     }
 
     @Override
+    public boolean isBaby() {
+        return getEntityData().get(IS_CHILD);
     }
 
     @Override
+    public void setBaby(boolean child) {
         setChild(IS_CHILD, child);
     }
 
     @Override
+    public void onSyncedDataUpdated(@Nonnull DataParameter&lt;?&gt; key) {
         if (IS_CHILD.equals(key)) {
+            refreshDimensions();
         }
+        super.onSyncedDataUpdated(key);
     }
 
     @Override
+    protected int getExperienceReward(@Nonnull PlayerEntity player) {
+        if (isBaby()) {
+            xpReward = (int) (xpReward * 2.5F);
         }
+        return super.getExperienceReward(player);
     }
 
     @Override
+    public double getMyRidingOffset() {
+        return isBaby() ? 0 : super.getMyRidingOffset();
     }
 
     @Override
     protected float getStandingEyeHeight(@Nonnull Pose pose, @Nonnull EntitySize size) {
+        return this.isBaby() ? 1.3F : super.getStandingEyeHeight(pose, size);
     }
 
     @Override
@@ -74,7 +74,7 @@ public ItemStack getPickedResult(RayTraceResult target) {
 
     @Nonnull
     @Override
+    public IPacket&lt;?&gt; getAddEntityPacket() {
         return NetworkHooks.getEntitySpawningPacket(this);
     }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>326773</refactoring_id><commit_sha>7a1172630f712790b1f00357c8179f96c7790192</commit_sha><commit_link>https://github.com/oracle/graal/commit/7a1172630f712790b1f00357c8179f96c7790192</commit_link><file_path>graal/com.oracle.graal.compiler.amd64/src/com/oracle/graal/compiler/amd64/AMD64LIRGenerator.java</file_path><description>Rename Method private asAddress(address Value) : AMD64AddressValue renamed to protected asAddressValue(address Value) : AMD64AddressValue in class com.oracle.graal.compiler.amd64.AMD64LIRGenerator</description><code_before>@@ -206,7 +206,7 @@ public AMD64AddressValue emitAddress(Value base, long displacement, Value index,
         return new AMD64AddressValue(target().wordKind, baseRegister, indexRegister, scaleEnum, displacementInt);
     }
 
-    private AMD64AddressValue asAddress(Value address) {
         if (address instanceof AMD64AddressValue) {
             return (AMD64AddressValue) address;
         } else {
@@ -216,15 +216,15 @@ private AMD64AddressValue asAddress(Value address) {
 
     @Override
     public Variable emitLoad(Kind kind, Value address, DeoptimizingNode deopting) {
-        AMD64AddressValue loadAddress = asAddress(address);
         Variable result = newVariable(kind);
         append(new LoadOp(kind, result, loadAddress, deopting != null ? state(deopting) : null));
         return result;
     }
 
     @Override
     public void emitStore(Kind kind, Value address, Value inputVal, DeoptimizingNode deopting) {
-        AMD64AddressValue storeAddress = asAddress(address);
         LIRFrameState state = deopting != null ? state(deopting) : null;
 
         if (isConstant(inputVal)) {
</code_before><code_after>@@ -206,7 +206,7 @@ public AMD64AddressValue emitAddress(Value base, long displacement, Value index,
         return new AMD64AddressValue(target().wordKind, baseRegister, indexRegister, scaleEnum, displacementInt);
     }
 
+    protected AMD64AddressValue asAddressValue(Value address) {
         if (address instanceof AMD64AddressValue) {
             return (AMD64AddressValue) address;
         } else {
@@ -216,15 +216,15 @@ private AMD64AddressValue asAddress(Value address) {
 
     @Override
     public Variable emitLoad(Kind kind, Value address, DeoptimizingNode deopting) {
+        AMD64AddressValue loadAddress = asAddressValue(address);
         Variable result = newVariable(kind);
         append(new LoadOp(kind, result, loadAddress, deopting != null ? state(deopting) : null));
         return result;
     }
 
     @Override
     public void emitStore(Kind kind, Value address, Value inputVal, DeoptimizingNode deopting) {
+        AMD64AddressValue storeAddress = asAddressValue(address);
         LIRFrameState state = deopting != null ? state(deopting) : null;
 
         if (isConstant(inputVal)) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>320295</refactoring_id><commit_sha>4a0a1447b8e633da3479b41c9c07f92c8b24f446</commit_sha><commit_link>https://github.com/cloudfoundry/uaa/commit/4a0a1447b8e633da3479b41c9c07f92c8b24f446</commit_link><file_path>uaa/src/test/java/org/cloudfoundry/identity/uaa/scim/ScimUserEndpointsTests.java</file_path><description>Rename Method public testChangePassword() : void renamed to public userCanChangeTheirOwnPasswordIfTheySupplyCorrectCurrentPassword() : void in class org.cloudfoundry.identity.uaa.scim.ScimUserEndpointsTests</description><code_before>@@ -67,19 +67,23 @@ public void setUp() {
 	}
 
 	@Test
-	public void testChangePassword() {
 		String id = users.get("jdsa").getId();
 		PasswordChangeRequest change = new PasswordChangeRequest();
 		change.setPassword("newpassword");
 		endpoints.changePassword(id, change);
 		assertTrue(new BCryptPasswordEncoder().matches("newpassword", users.get("jdsa").getPassword()));
 	}
 
-	@Test
-	public void changePasswordSucceedsForUserIfTheySupplyCorrectCurrentPassword() {
 		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
 		String id = users.get("jdsa").getId();
-		when(sca.currentUserHasId(id)).thenReturn(true);
 		endpoints.setSecurityContextAccessor(sca);
 		PasswordChangeRequest change = new PasswordChangeRequest();
 		change.setOldPassword("password");
@@ -88,10 +92,21 @@ public void changePasswordSucceedsForUserIfTheySupplyCorrectCurrentPassword() {
 	}
 
 	@Test(expected = ScimException.class)
-	public void changePasswordFailsForUserIfTheyDontSupplyCurrentPassword() {
 		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
 		String id = users.get("jdsa").getId();
-		when(sca.currentUserHasId(id)).thenReturn(true);
 		endpoints.setSecurityContextAccessor(sca);
 		PasswordChangeRequest change = new PasswordChangeRequest();
 		change.setPassword("newpassword");
@@ -102,7 +117,7 @@ public void changePasswordFailsForUserIfTheyDontSupplyCurrentPassword() {
 	public void changePasswordFailsForUserIfTheySupplyWrongCurrentPassword() {
 		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
 		String id = users.get("jdsa").getId();
-		when(sca.currentUserHasId(id)).thenReturn(true);
 		endpoints.setSecurityContextAccessor(sca);
 		PasswordChangeRequest change = new PasswordChangeRequest();
 		change.setPassword("newpassword");
</code_before><code_after>@@ -67,19 +67,23 @@ public void setUp() {
 	}
 
 	@Test
+	public void userCanChangeTheirOwnPasswordIfTheySupplyCorrectCurrentPassword() {
+		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
 		String id = users.get("jdsa").getId();
+		when(sca.getCurrentUserId()).thenReturn(id);
+		endpoints.setSecurityContextAccessor(sca);
 		PasswordChangeRequest change = new PasswordChangeRequest();
+		change.setOldPassword("password");
 		change.setPassword("newpassword");
 		endpoints.changePassword(id, change);
 		assertTrue(new BCryptPasswordEncoder().matches("newpassword", users.get("jdsa").getPassword()));
 	}
 
+	@Test(expected = ScimException.class)
+	public void userCantChangeAnotherUsersPassword() {
 		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
 		String id = users.get("jdsa").getId();
+		when(sca.getCurrentUserId()).thenReturn(id + "1");
 		endpoints.setSecurityContextAccessor(sca);
 		PasswordChangeRequest change = new PasswordChangeRequest();
 		change.setOldPassword("password");
@@ -88,10 +92,21 @@ public void changePasswordSucceedsForUserIfTheySupplyCorrectCurrentPassword() {
 	}
 
 	@Test(expected = ScimException.class)
+	public void changePasswordRequestFailsForUserWithoutCurrentPassword() {
+		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
+		String id = users.get("jdsa").getId();
+		when(sca.getCurrentUserId()).thenReturn(id);
+		endpoints.setSecurityContextAccessor(sca);
+		PasswordChangeRequest change = new PasswordChangeRequest();
+		change.setPassword("newpassword");
+		endpoints.changePassword(id, change);
+	}
+
+	@Test
+	public void clientCanChangeUserPasswordWithoutCurrentPassword() {
 		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
 		String id = users.get("jdsa").getId();
+		when(sca.currentUserIsClient()).thenReturn(true);
 		endpoints.setSecurityContextAccessor(sca);
 		PasswordChangeRequest change = new PasswordChangeRequest();
 		change.setPassword("newpassword");
@@ -102,7 +117,7 @@ public void changePasswordFailsForUserIfTheyDontSupplyCurrentPassword() {
 	public void changePasswordFailsForUserIfTheySupplyWrongCurrentPassword() {
 		SecurityContextAccessor sca = mock(SecurityContextAccessor.class);
 		String id = users.get("jdsa").getId();
+		when(sca.getCurrentUserId()).thenReturn(id);
 		endpoints.setSecurityContextAccessor(sca);
 		PasswordChangeRequest change = new PasswordChangeRequest();
 		change.setPassword("newpassword");
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>263939</refactoring_id><commit_sha>87591edbf3d531dfe73eeadfe691c785a8ba6ff0</commit_sha><commit_link>https://github.com/apache/poi/commit/87591edbf3d531dfe73eeadfe691c785a8ba6ff0</commit_link><file_path>src/java/org/apache/poi/poifs/crypt/cryptoapi/CryptoAPIEncryptor.java</file_path><description>Rename Method public getSummaryEntries(dir DirectoryNode) : OutputStream renamed to public setSummaryEntries(dir DirectoryNode, encryptedStream String, entries NPOIFSFileSystem) : void in class org.apache.poi.poifs.crypt.cryptoapi.CryptoAPIEncryptor</description><code_before>@@ -32,10 +32,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import javax.crypto.SecretKey;
 
 import org.apache.poi.EncryptedDocumentException;
-import org.apache.poi.hpsf.DocumentSummaryInformation;
-import org.apache.poi.hpsf.PropertySetFactory;
-import org.apache.poi.hpsf.SummaryInformation;
-import org.apache.poi.hpsf.WritingNotSupportedException;
 import org.apache.poi.poifs.crypt.ChunkedCipherOutputStream;
 import org.apache.poi.poifs.crypt.CryptoFunctions;
 import org.apache.poi.poifs.crypt.DataSpaceMapUtils;
@@ -46,6 +42,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
 import org.apache.poi.poifs.filesystem.DirectoryNode;
 import org.apache.poi.poifs.filesystem.DocumentInputStream;
 import org.apache.poi.util.IOUtils;
 import org.apache.poi.util.LittleEndian;
 import org.apache.poi.util.LittleEndianByteArrayOutputStream;
@@ -124,41 +122,34 @@ public CryptoAPICipherOutputStream getDataStream(OutputStream stream, int initia
      * 
      * @see &lt;a href="http://msdn.microsoft.com/en-us/library/dd943321(v=office.12).aspx"&gt;2.3.5.4 RC4 CryptoAPI Encrypted Summary Stream&lt;/a&gt;
      */
-    public OutputStream getSummaryEntries(DirectoryNode dir)
     throws IOException, GeneralSecurityException {
         CryptoAPIDocumentOutputStream bos = new CryptoAPIDocumentOutputStream(this); // NOSONAR
         byte buf[] = new byte[8];
         
         bos.write(buf, 0, 8); // skip header
-        String entryNames[] = {
-            SummaryInformation.DEFAULT_STREAM_NAME,
-            DocumentSummaryInformation.DEFAULT_STREAM_NAME
-        };
-        
         List&lt;StreamDescriptorEntry&gt; descList = new ArrayList&lt;StreamDescriptorEntry&gt;();
 
         int block = 0;
-        for (String entryName : entryNames) {
-            if (!dir.hasEntry(entryName)) {
                 continue;
             }
             StreamDescriptorEntry descEntry = new StreamDescriptorEntry();
             descEntry.block = block;
             descEntry.streamOffset = bos.size();
-            descEntry.streamName = entryName;
             descEntry.flags = StreamDescriptorEntry.flagStream.setValue(0, 1);
             descEntry.reserved2 = 0;
             
             bos.setBlock(block);
-            DocumentInputStream dis = dir.createDocumentInputStream(entryName);
             IOUtils.copy(dis, bos);
             dis.close();
             
             descEntry.streamSize = bos.size() - descEntry.streamOffset;
             descList.add(descEntry);
             
-            dir.getEntry(entryName).delete();
-            
             block++;
         }
         
@@ -197,16 +188,7 @@ public OutputStream getSummaryEntries(DirectoryNode dir)
         bos.write(buf, 0, 8);
         bos.setSize(savedSize);
         
-        dir.createDocument("EncryptedSummary", new ByteArrayInputStream(bos.getBuf(), 0, savedSize));
-        DocumentSummaryInformation dsi = PropertySetFactory.newDocumentSummaryInformation();
-        
-        try {
-            dsi.write(dir, DocumentSummaryInformation.DEFAULT_STREAM_NAME);
-        } catch (WritingNotSupportedException e) {
-            throw new IOException(e);
-        }
-        
-        return bos;
     }
 
     protected int getKeySizeInBytes() {
</code_before><code_after>@@ -32,10 +32,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import javax.crypto.SecretKey;
 
 import org.apache.poi.EncryptedDocumentException;
 import org.apache.poi.poifs.crypt.ChunkedCipherOutputStream;
 import org.apache.poi.poifs.crypt.CryptoFunctions;
 import org.apache.poi.poifs.crypt.DataSpaceMapUtils;
@@ -46,6 +42,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.poi.poifs.crypt.standard.EncryptionRecord;
 import org.apache.poi.poifs.filesystem.DirectoryNode;
 import org.apache.poi.poifs.filesystem.DocumentInputStream;
+import org.apache.poi.poifs.filesystem.Entry;
+import org.apache.poi.poifs.filesystem.NPOIFSFileSystem;
 import org.apache.poi.util.IOUtils;
 import org.apache.poi.util.LittleEndian;
 import org.apache.poi.util.LittleEndianByteArrayOutputStream;
@@ -124,41 +122,34 @@ public CryptoAPICipherOutputStream getDataStream(OutputStream stream, int initia
      * 
      * @see &lt;a href="http://msdn.microsoft.com/en-us/library/dd943321(v=office.12).aspx"&gt;2.3.5.4 RC4 CryptoAPI Encrypted Summary Stream&lt;/a&gt;
      */
+    public void setSummaryEntries(DirectoryNode dir, String encryptedStream, NPOIFSFileSystem entries)
     throws IOException, GeneralSecurityException {
         CryptoAPIDocumentOutputStream bos = new CryptoAPIDocumentOutputStream(this); // NOSONAR
         byte buf[] = new byte[8];
         
         bos.write(buf, 0, 8); // skip header
         List&lt;StreamDescriptorEntry&gt; descList = new ArrayList&lt;StreamDescriptorEntry&gt;();
 
         int block = 0;
+        for (Entry entry : entries.getRoot()) {
+            if (entry.isDirectoryEntry()) {
                 continue;
             }
             StreamDescriptorEntry descEntry = new StreamDescriptorEntry();
             descEntry.block = block;
             descEntry.streamOffset = bos.size();
+            descEntry.streamName = entry.getName();
             descEntry.flags = StreamDescriptorEntry.flagStream.setValue(0, 1);
             descEntry.reserved2 = 0;
             
             bos.setBlock(block);
+            DocumentInputStream dis = dir.createDocumentInputStream(entry);
             IOUtils.copy(dis, bos);
             dis.close();
             
             descEntry.streamSize = bos.size() - descEntry.streamOffset;
             descList.add(descEntry);
             
             block++;
         }
         
@@ -197,16 +188,7 @@ public OutputStream getSummaryEntries(DirectoryNode dir)
         bos.write(buf, 0, 8);
         bos.setSize(savedSize);
         
+        dir.createDocument(encryptedStream, new ByteArrayInputStream(bos.getBuf(), 0, savedSize));
     }
 
     protected int getKeySizeInBytes() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>206461</refactoring_id><commit_sha>cbd88179051a51e66abac4c65d4af865c203c337</commit_sha><commit_link>https://github.com/netty/netty/commit/cbd88179051a51e66abac4c65d4af865c203c337</commit_link><file_path>example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java</file_path><description>Rename Method public messageReceived(ctx ChannelHandlerContext, request SocksCmdRequest) : void renamed to public messageReceived0(ctx ChannelHandlerContext, request SocksCmdRequest) : void in class io.netty.example.socksproxy.SocksServerConnectHandler</description><code_before>@@ -39,11 +39,11 @@ public static String getName() {
     private final Bootstrap b = new Bootstrap();
 
     @Override
-    public void messageReceived(final ChannelHandlerContext ctx, final SocksCmdRequest request) throws Exception {
         CallbackNotifier cb = new CallbackNotifier() {
             @Override
             public void onSuccess(final ChannelHandlerContext outboundCtx) {
-                ctx.channel().write(new SocksCmdResponse(SocksCmdStatus.SUCCESS, request.addressType()))
                              .addListener(new ChannelFutureListener() {
                     @Override
                     public void operationComplete(ChannelFuture channelFuture) throws Exception {
</code_before><code_after>@@ -39,11 +39,11 @@ public static String getName() {
     private final Bootstrap b = new Bootstrap();
 
     @Override
+    public void messageReceived0(final ChannelHandlerContext ctx, final SocksCmdRequest request) throws Exception {
         CallbackNotifier cb = new CallbackNotifier() {
             @Override
             public void onSuccess(final ChannelHandlerContext outboundCtx) {
+                ctx.channel().write(new SocksCmdResponse(SocksCmdStatus.SUCCESS, request.addressType())).flush()
                              .addListener(new ChannelFutureListener() {
                     @Override
                     public void operationComplete(ChannelFuture channelFuture) throws Exception {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>294770</refactoring_id><commit_sha>3861add9b8ceaceb94d019dfcf97db43da2567ac</commit_sha><commit_link>https://github.com/apache/ambari/commit/3861add9b8ceaceb94d019dfcf97db43da2567ac</commit_link><file_path>ambari-server/src/main/java/org/apache/ambari/server/stack/ServiceModule.java</file_path><description>Rename Method public setErrors(error String) : void renamed to public addError(error String) : void in class org.apache.ambari.server.stack.ServiceModule</description><code_before>@@ -19,7 +19,6 @@
 package org.apache.ambari.server.stack;
 
 import com.google.common.base.Function;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
@@ -35,6 +34,8 @@
 import org.apache.ambari.server.state.ServicePropertyInfo;
 import org.apache.ambari.server.state.ThemeInfo;
 import org.apache.commons.lang.StringUtils;
 
 import javax.annotation.Nullable;
 
@@ -364,8 +365,8 @@ private void populateConfigurationModules() {
           if (isValid()){
             setValid(config.isValid() &amp;&amp; info.isValid());
             if (!isValid()){
-              setErrors(config.getErrors());
-              setErrors(info.getErrors());
             }
           }
           serviceInfo.getProperties().addAll(info.getProperties());
@@ -594,25 +595,31 @@ public void setValid(boolean valid) {
   private Set&lt;String&gt; errorSet = new HashSet&lt;String&gt;();
 
   @Override
-  public void setErrors(String error) {
     errorSet.add(error);
   }
 
   @Override
-  public Collection getErrors() {
     return errorSet;
   }
 
   @Override
-  public void setErrors(Collection error) {
-    this.errorSet.addAll(error);
   }
 
 
   private void validateServiceInfo() {
     if (!serviceInfo.isValid()) {
       setValid(false);
-      setErrors(serviceInfo.getErrors());
     }
   }
 }
</code_before><code_after>@@ -19,7 +19,6 @@
 package org.apache.ambari.server.stack;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
@@ -35,6 +34,8 @@
 import org.apache.ambari.server.state.ServicePropertyInfo;
 import org.apache.ambari.server.state.ThemeInfo;
 import org.apache.commons.lang.StringUtils;
+import org.apache.commons.lang.builder.ToStringBuilder;
+import org.apache.commons.lang.builder.ToStringStyle;
 
 import javax.annotation.Nullable;
 
@@ -364,8 +365,8 @@ private void populateConfigurationModules() {
           if (isValid()){
             setValid(config.isValid() &amp;&amp; info.isValid());
             if (!isValid()){
+              addErrors(config.getErrors());
+              addErrors(info.getErrors());
             }
           }
           serviceInfo.getProperties().addAll(info.getProperties());
@@ -594,25 +595,31 @@ public void setValid(boolean valid) {
   private Set&lt;String&gt; errorSet = new HashSet&lt;String&gt;();
 
   @Override
+  public void addError(String error) {
     errorSet.add(error);
   }
 
   @Override
+  public Collection&lt;String&gt; getErrors() {
     return errorSet;
   }
 
   @Override
+  public void addErrors(Collection&lt;String&gt; errors) {
+    this.errorSet.addAll(errors);
   }
 
 
   private void validateServiceInfo() {
     if (!serviceInfo.isValid()) {
       setValid(false);
+      addErrors(serviceInfo.getErrors());
     }
   }
+  
+
+  @Override
+  public String toString() {
+    return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);
+  }
 }
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>289854</refactoring_id><commit_sha>6d2e252bcfb1a36db86bbcc2003c07f04244d41f</commit_sha><commit_link>https://github.com/yacy/yacy_search_server/commit/6d2e252bcfb1a36db86bbcc2003c07f04244d41f</commit_link><file_path>source/net/yacy/kelondro/rwi/ReferenceIterator.java</file_path><description>Rename Method public next() : ReferenceContainer&lt;ReferenceType&gt; renamed to public next0() : ReferenceContainer&lt;ReferenceType&gt; in class net.yacy.kelondro.rwi.ReferenceIterator</description><code_before>@@ -9,7 +9,7 @@
 // $LastChangedBy$
 //
 // LICENSE
-// 
 // This program is free software; you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
 // the Free Software Foundation; either version 2 of the License, or
@@ -28,70 +28,66 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.util.Iterator;
 import java.util.Map;
 
 import net.yacy.kelondro.blob.HeapReader;
 import net.yacy.kelondro.index.RowSet;
 import net.yacy.kelondro.index.RowSpaceExceededException;
 import net.yacy.kelondro.logging.Log;
 import net.yacy.kelondro.order.CloneableIterator;
 
 /**
  * iterator of BLOBHeap files: is used to import heap dumps into a write-enabled index heap
  */
-public class ReferenceIterator &lt;ReferenceType extends Reference&gt; implements CloneableIterator&lt;ReferenceContainer&lt;ReferenceType&gt;&gt;, Iterable&lt;ReferenceContainer&lt;ReferenceType&gt;&gt; {
     HeapReader.entries blobs;
     File blobFile;
     ReferenceFactory&lt;ReferenceType&gt; factory;
-    
-    public ReferenceIterator(final File blobFile, ReferenceFactory&lt;ReferenceType&gt; factory) throws IOException {
         this.blobs = new HeapReader.entries(blobFile, factory.getRow().primaryKeyLength);
         this.blobFile = blobFile;
         this.factory = factory;
     }
-    
-    public boolean hasNext() {
-        if (blobs == null) return false;
-        if (blobs.hasNext()) return true;
-        close();
-        return false;
-    }
 
     /**
      * return an index container
      * because they may get very large, it is wise to deallocate some memory before calling next()
      */
-    public ReferenceContainer&lt;ReferenceType&gt; next() {
-        Map.Entry&lt;byte[], byte[]&gt; entry = blobs.next();
-        byte[] payload = entry.getValue();
-        try {
-            return new ReferenceContainer&lt;ReferenceType&gt;(factory, entry.getKey(), RowSet.importRowSet(payload, factory.getRow()));
-        } catch (RowSpaceExceededException e) {
-            Log.logSevere("ReferenceIterator", "lost entry '" + entry.getKey() + "' because of too low memory: " + e.toString());
-            return null;
         }
-    }
-    
-    public void remove() {
-        throw new UnsupportedOperationException("heap dumps are read-only");
     }
 
-    public Iterator&lt;ReferenceContainer&lt;ReferenceType&gt;&gt; iterator() {
-        return this;
-    }
-    
     public void close() {
-        if (blobs != null) this.blobs.close();
-        blobs = null;
     }
 
-    public CloneableIterator&lt;ReferenceContainer&lt;ReferenceType&gt;&gt; clone(Object modifier) {
-        if (blobs != null) this.blobs.close();
-        blobs = null;
         try {
-            return new ReferenceIterator&lt;ReferenceType&gt;(this.blobFile, factory);
-        } catch (IOException e) {
             Log.logException(e);
             return null;
         }
</code_before><code_after>@@ -9,7 +9,7 @@
 // $LastChangedBy$
 //
 // LICENSE
+//
 // This program is free software; you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
 // the Free Software Foundation; either version 2 of the License, or
@@ -28,70 +28,66 @@
 
 import java.io.File;
 import java.io.IOException;
 import java.util.Map;
 
 import net.yacy.kelondro.blob.HeapReader;
 import net.yacy.kelondro.index.RowSet;
 import net.yacy.kelondro.index.RowSpaceExceededException;
 import net.yacy.kelondro.logging.Log;
 import net.yacy.kelondro.order.CloneableIterator;
+import net.yacy.kelondro.util.LookAheadIterator;
 
 /**
  * iterator of BLOBHeap files: is used to import heap dumps into a write-enabled index heap
  */
+public class ReferenceIterator &lt;ReferenceType extends Reference&gt; extends LookAheadIterator&lt;ReferenceContainer&lt;ReferenceType&gt;&gt; implements CloneableIterator&lt;ReferenceContainer&lt;ReferenceType&gt;&gt;, Iterable&lt;ReferenceContainer&lt;ReferenceType&gt;&gt; {
     HeapReader.entries blobs;
     File blobFile;
     ReferenceFactory&lt;ReferenceType&gt; factory;
+
+    public ReferenceIterator(final File blobFile, final ReferenceFactory&lt;ReferenceType&gt; factory) throws IOException {
         this.blobs = new HeapReader.entries(blobFile, factory.getRow().primaryKeyLength);
         this.blobFile = blobFile;
         this.factory = factory;
     }
 
     /**
      * return an index container
      * because they may get very large, it is wise to deallocate some memory before calling next()
      */
+    public ReferenceContainer&lt;ReferenceType&gt; next0() {
+        if (this.blobs == null) return null;
+        RowSet row;
+        Map.Entry&lt;byte[], byte[]&gt; entry;
+        while (this.blobs.hasNext()) {
+            entry = this.blobs.next();
+            try {
+                row = RowSet.importRowSet(entry.getValue(), this.factory.getRow());
+                if (row == null) {
+                    Log.logSevere("ReferenceIterator", "lost entry '" + entry.getKey() + "' because importRowSet returned null");
+                    continue; // thats a fail but not as REALLY bad if the whole method would crash here
+                }
+                return new ReferenceContainer&lt;ReferenceType&gt;(this.factory, entry.getKey(), row);
+            } catch (final RowSpaceExceededException e) {
+                Log.logSevere("ReferenceIterator", "lost entry '" + entry.getKey() + "' because of too low memory: " + e.toString());
+                continue;
+            }
         }
+        close();
+        return null;
     }
 
     public void close() {
+        if (this.blobs != null) this.blobs.close();
+        this.blobs = null;
     }
 
+    public CloneableIterator&lt;ReferenceContainer&lt;ReferenceType&gt;&gt; clone(final Object modifier) {
+        if (this.blobs != null) this.blobs.close();
+        this.blobs = null;
         try {
+            return new ReferenceIterator&lt;ReferenceType&gt;(this.blobFile, this.factory);
+        } catch (final IOException e) {
             Log.logException(e);
             return null;
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>217980</refactoring_id><commit_sha>27f42ad5e1024f51ce687d1403acf680df3f5088</commit_sha><commit_link>https://github.com/teammates/teammates/commit/27f42ad5e1024f51ce687d1403acf680df3f5088</commit_link><file_path>src/test/java/teammates/test/cases/action/AdminInstructorAccountAddActionTest.java</file_path><description>Rename Method public classSetup() : void renamed to protected getActionUri() : String in class teammates.test.cases.action.AdminInstructorAccountAddActionTest</description><code_before>@@ -1,6 +1,5 @@
 package teammates.test.cases.action;
 
-import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
 import teammates.common.datatransfer.CommentAttributes;
@@ -17,14 +16,14 @@
 
 public class AdminInstructorAccountAddActionTest extends BaseActionTest {
 
-    // private final DataBundle dataBundle = getTypicalDataBundle();
-    //TODO: move all the input validation/sanitization js code to server side
     
-    @BeforeClass
-    public void classSetup() {
-        printTestClassHeader();
-        uri = Const.ActionURIs.ADMIN_INSTRUCTORACCOUNT_ADD;
-        // removeAndRestoreTypicalDataInDatastore();
     }
 
     @Test
@@ -33,6 +32,7 @@ public void testGenerateNextDemoCourseId() throws Exception {
         testGenerateNextDemoCourseIdForLengthLimit(20);
     }
     
     @Test
     public void testExecuteAndPostProcess() throws Exception {
         final String newInstructorShortName = "James";
@@ -73,7 +73,7 @@ public void testExecuteAndPostProcess() throws Exception {
                 Const.ParamsNames.INSTRUCTOR_EMAIL, emailWithSpaces,
                 Const.ParamsNames.INSTRUCTOR_INSTITUTION, instituteWithSpaces);
         
-        AjaxResult r = (AjaxResult) a.executeAndPostProcess();
         assertTrue(r.getStatusMessage().contains("Instructor " + name + " has been successfully created"));
         
         verifyNumberOfEmailsSent(a, 1);
@@ -98,7 +98,7 @@ public void testExecuteAndPostProcess() throws Exception {
                 + "it contains invalid characters. All person name must start with an "
                 + "alphanumeric character, and cannot contain any vertical bar (|) or percent sign (%).";
         
-        AjaxResult rInvalidParam = (AjaxResult) a.executeAndPostProcess();
         assertEquals(expectedError, rInvalidParam.getStatusMessage());
         
         AdminHomePageData pageData = (AdminHomePageData) rInvalidParam.data;
@@ -117,7 +117,7 @@ public void testExecuteAndPostProcess() throws Exception {
                 Const.ParamsNames.INSTRUCTOR_EMAIL, email,
                 Const.ParamsNames.INSTRUCTOR_INSTITUTION, institute);
         
-        r = (AjaxResult) a.executeAndPostProcess();
         assertTrue(r.getStatusMessage().contains("Instructor " + name + " has been successfully created"));
         
         verifyNumberOfEmailsSent(a, 1);
@@ -178,8 +178,9 @@ private String generateNextDemoCourseId(String instructorEmailOrProposedCourseId
                                      a, new Object[] { instructorEmailOrProposedCourseId, maximumIdLength });
     }
 
-    private AdminInstructorAccountAddAction getAction(String... parameters) {
-        return (AdminInstructorAccountAddAction) gaeSimulation.getActionObject(uri, parameters);
     }
 
     private String getDemoCourseIdRoot(String instructorEmail) {
</code_before><code_after>@@ -1,6 +1,5 @@
 package teammates.test.cases.action;
 
 import org.testng.annotations.Test;
 
 import teammates.common.datatransfer.CommentAttributes;
@@ -17,14 +16,14 @@
 
 public class AdminInstructorAccountAddActionTest extends BaseActionTest {
 
+    @Override
+    protected String getActionUri() {
+        return Const.ActionURIs.ADMIN_INSTRUCTORACCOUNT_ADD;
+    }
     
+    @Override
+    protected void prepareTestData() {
+        // no test data used in this test
     }
 
     @Test
@@ -33,6 +32,7 @@ public void testGenerateNextDemoCourseId() throws Exception {
         testGenerateNextDemoCourseIdForLengthLimit(20);
     }
     
+    @Override
     @Test
     public void testExecuteAndPostProcess() throws Exception {
         final String newInstructorShortName = "James";
@@ -73,7 +73,7 @@ public void testExecuteAndPostProcess() throws Exception {
                 Const.ParamsNames.INSTRUCTOR_EMAIL, emailWithSpaces,
                 Const.ParamsNames.INSTRUCTOR_INSTITUTION, instituteWithSpaces);
         
+        AjaxResult r = getAjaxResult(a);
         assertTrue(r.getStatusMessage().contains("Instructor " + name + " has been successfully created"));
         
         verifyNumberOfEmailsSent(a, 1);
@@ -98,7 +98,7 @@ public void testExecuteAndPostProcess() throws Exception {
                 + "it contains invalid characters. All person name must start with an "
                 + "alphanumeric character, and cannot contain any vertical bar (|) or percent sign (%).";
         
+        AjaxResult rInvalidParam = getAjaxResult(a);
         assertEquals(expectedError, rInvalidParam.getStatusMessage());
         
         AdminHomePageData pageData = (AdminHomePageData) rInvalidParam.data;
@@ -117,7 +117,7 @@ public void testExecuteAndPostProcess() throws Exception {
                 Const.ParamsNames.INSTRUCTOR_EMAIL, email,
                 Const.ParamsNames.INSTRUCTOR_INSTITUTION, institute);
         
+        r = getAjaxResult(a);
         assertTrue(r.getStatusMessage().contains("Instructor " + name + " has been successfully created"));
         
         verifyNumberOfEmailsSent(a, 1);
@@ -178,8 +178,9 @@ private String generateNextDemoCourseId(String instructorEmailOrProposedCourseId
                                      a, new Object[] { instructorEmailOrProposedCourseId, maximumIdLength });
     }
 
+    @Override
+    protected AdminInstructorAccountAddAction getAction(String... params) {
+        return (AdminInstructorAccountAddAction) gaeSimulation.getActionObject(getActionUri(), params);
     }
 
     private String getDemoCourseIdRoot(String instructorEmail) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>217689</refactoring_id><commit_sha>b9926b8e3e0dc67dd54231425b0fa797efa878a0</commit_sha><commit_link>https://github.com/opensolon/solon/commit/b9926b8e3e0dc67dd54231425b0fa797efa878a0</commit_link><file_path>_extend/solon.cloud.tracing/src/main/java/org/noear/solon/cloud/tracing/integration/SpanSimulate.java</file_path><description>Rename Method public log(timestampMicroseconds long, fields Map&lt;String,?&gt;) : Span renamed to public getInstance() : Span in class org.noear.solon.cloud.tracing.integration.SpanSimulate</description><code_before>@@ -13,7 +13,11 @@
  * @since 1.7
  */
 public class SpanSimulate implements Span {
-    public static final Span instance = new SpanSimulate();
 
     @Override
     public SpanContext context() {
@@ -22,47 +26,47 @@ public SpanContext context() {
 
     @Override
     public Span setTag(String key, String value) {
-        return instance;
     }
 
     @Override
     public Span setTag(String key, boolean value) {
-        return instance;
     }
 
     @Override
     public Span setTag(String key, Number value) {
-        return instance;
     }
 
     @Override
     public &lt;T&gt; Span setTag(Tag&lt;T&gt; tag, T value) {
-        return instance;
     }
 
     @Override
     public Span log(Map&lt;String, ?&gt; fields) {
-        return instance;
     }
 
     @Override
     public Span log(long timestampMicroseconds, Map&lt;String, ?&gt; fields) {
-        return instance;
     }
 
     @Override
     public Span log(String event) {
-        return instance;
     }
 
     @Override
     public Span log(long timestampMicroseconds, String event) {
-        return instance;
     }
 
     @Override
     public Span setBaggageItem(String key, String value) {
-        return instance;
     }
 
     @Override
@@ -72,7 +76,7 @@ public String getBaggageItem(String key) {
 
     @Override
     public Span setOperationName(String operationName) {
-        return instance;
     }
 
     @Override
</code_before><code_after>@@ -13,7 +13,11 @@
  * @since 1.7
  */
 public class SpanSimulate implements Span {
+    private static final Span instance = new SpanSimulate();
+
+    public static Span getInstance() {
+        return instance;
+    }
 
     @Override
     public SpanContext context() {
@@ -22,47 +26,47 @@ public SpanContext context() {
 
     @Override
     public Span setTag(String key, String value) {
+        return this;
     }
 
     @Override
     public Span setTag(String key, boolean value) {
+        return this;
     }
 
     @Override
     public Span setTag(String key, Number value) {
+        return this;
     }
 
     @Override
     public &lt;T&gt; Span setTag(Tag&lt;T&gt; tag, T value) {
+        return this;
     }
 
     @Override
     public Span log(Map&lt;String, ?&gt; fields) {
+        return this;
     }
 
     @Override
     public Span log(long timestampMicroseconds, Map&lt;String, ?&gt; fields) {
+        return this;
     }
 
     @Override
     public Span log(String event) {
+        return this;
     }
 
     @Override
     public Span log(long timestampMicroseconds, String event) {
+        return this;
     }
 
     @Override
     public Span setBaggageItem(String key, String value) {
+        return this;
     }
 
     @Override
@@ -72,7 +76,7 @@ public String getBaggageItem(String key) {
 
     @Override
     public Span setOperationName(String operationName) {
+        return this;
     }
 
     @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>314513</refactoring_id><commit_sha>847ead01f2f0aaf318b2b1ba8501bc697d245900</commit_sha><commit_link>https://github.com/apache/flink/commit/847ead01f2f0aaf318b2b1ba8501bc697d245900</commit_link><file_path>flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java</file_path><description>Rename Method public snapshotOperatorState(checkpointId long, timestamp long) : StreamTaskState renamed to public snapshotState(out FSDataOutputStream, checkpointId long, timestamp long) : void in class org.apache.flink.cep.operator.AbstractKeyedCEPPatternOperator</description><code_before>@@ -24,14 +24,15 @@
 import org.apache.flink.api.java.functions.KeySelector;
 import org.apache.flink.cep.nfa.NFA;
 import org.apache.flink.cep.nfa.compiler.NFACompiler;
 import org.apache.flink.core.memory.DataInputView;
 import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.runtime.state.AbstractStateBackend;
-import org.apache.flink.runtime.state.StateHandle;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.MultiplexingStreamRecordSerializer;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.tasks.StreamTaskState;
 
 import java.io.IOException;
 import java.io.Serializable;
@@ -183,30 +184,22 @@ public void processWatermark(Watermark mark) throws Exception {
 	}
 
 	@Override
-	public StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {
-		StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);
-
-		AbstractStateBackend.CheckpointStateOutputView ov = getStateBackend().createCheckpointStateOutputView(checkpointId, timestamp);
 
 		ov.writeInt(keys.size());
 
 		for (KEY key: keys) {
 			keySerializer.serialize(key, ov);
 		}
-
-		taskState.setOperatorState(ov.closeAndGetHandle());
-
-		return taskState;
 	}
 
 	@Override
-	public void restoreState(StreamTaskState state) throws Exception {
 		super.restoreState(state);
 
-		@SuppressWarnings("unchecked")
-		StateHandle&lt;DataInputView&gt; stateHandle = (StateHandle&lt;DataInputView&gt;) state.getOperatorState();
-
-		DataInputView inputView = stateHandle.getState(getUserCodeClassloader());
 
 		if (keys == null) {
 			keys = new HashSet&lt;&gt;();
</code_before><code_after>@@ -24,14 +24,15 @@
 import org.apache.flink.api.java.functions.KeySelector;
 import org.apache.flink.cep.nfa.NFA;
 import org.apache.flink.cep.nfa.compiler.NFACompiler;
+import org.apache.flink.core.fs.FSDataInputStream;
+import org.apache.flink.core.fs.FSDataOutputStream;
 import org.apache.flink.core.memory.DataInputView;
+import org.apache.flink.core.memory.DataInputViewStreamWrapper;
 import org.apache.flink.core.memory.DataOutputView;
+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.MultiplexingStreamRecordSerializer;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 
 import java.io.IOException;
 import java.io.Serializable;
@@ -183,30 +184,22 @@ public void processWatermark(Watermark mark) throws Exception {
 	}
 
 	@Override
+	public void snapshotState(FSDataOutputStream out, long checkpointId, long timestamp) throws Exception {
+		super.snapshotState(out, checkpointId, timestamp);
 
+		DataOutputView ov = new DataOutputViewStreamWrapper(out);
 		ov.writeInt(keys.size());
 
 		for (KEY key: keys) {
 			keySerializer.serialize(key, ov);
 		}
 	}
 
 	@Override
+	public void restoreState(FSDataInputStream state) throws Exception {
 		super.restoreState(state);
 
+		DataInputView inputView = new DataInputViewStreamWrapper(state);
 
 		if (keys == null) {
 			keys = new HashSet&lt;&gt;();
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>192983</refactoring_id><commit_sha>936ab5f9fc3646cf6cbc1f338846d40cd1e54652</commit_sha><commit_link>https://github.com/jabref/jabref/commit/936ab5f9fc3646cf6cbc1f338846d40cd1e54652</commit_link><file_path>src/test/java/org/jabref/gui/entryeditor/citationrelationtab/CitationsRelationsTabViewModelTest.java</file_path><description>Rename Method package testExistingEntryCitesOtherPaperWithCitationKeysAndExistingCiteField() : void renamed to package existingEntryCitesOtherPaperWithCitationKeysAndExistingCiteField() : void in class org.jabref.gui.entryeditor.citationrelationtab.CitationsRelationsTabViewModelTest</description><code_before>@@ -99,7 +99,7 @@ void setUp() {
     }
 
     @Test
-    void testExistingEntryCitesOtherPaperWithCitationKeys() {
         var citationItems = List.of(new CitationRelationItem(firstEntryToImport, false),
                 new CitationRelationItem(secondEntryToImport, false));
 
@@ -109,7 +109,7 @@ void testExistingEntryCitesOtherPaperWithCitationKeys() {
     }
 
     @Test
-    void testImportedEntriesWithExistingCitationKeysCiteExistingEntry() {
         var citationItems = List.of(new CitationRelationItem(firstEntryToImport, false),
                 new CitationRelationItem(secondEntryToImport, false));
 
@@ -119,7 +119,7 @@ void testImportedEntriesWithExistingCitationKeysCiteExistingEntry() {
     }
 
     @Test
-    void testExistingEntryCitesOtherPaperWithCitationKeysAndExistingCiteField() {
         existingEntry.setField(StandardField.CITES, "Asdf1222");
         var citationItems = List.of(new CitationRelationItem(firstEntryToImport, false),
                 new CitationRelationItem(secondEntryToImport, false));
</code_before><code_after>@@ -99,7 +99,7 @@ void setUp() {
     }
 
     @Test
+    void existingEntryCitesOtherPaperWithCitationKeys() {
         var citationItems = List.of(new CitationRelationItem(firstEntryToImport, false),
                 new CitationRelationItem(secondEntryToImport, false));
 
@@ -109,7 +109,7 @@ void testExistingEntryCitesOtherPaperWithCitationKeys() {
     }
 
     @Test
+    void importedEntriesWithExistingCitationKeysCiteExistingEntry() {
         var citationItems = List.of(new CitationRelationItem(firstEntryToImport, false),
                 new CitationRelationItem(secondEntryToImport, false));
 
@@ -119,7 +119,7 @@ void testImportedEntriesWithExistingCitationKeysCiteExistingEntry() {
     }
 
     @Test
+    void existingEntryCitesOtherPaperWithCitationKeysAndExistingCiteField() {
         existingEntry.setField(StandardField.CITES, "Asdf1222");
         var citationItems = List.of(new CitationRelationItem(firstEntryToImport, false),
                 new CitationRelationItem(secondEntryToImport, false));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>130512</refactoring_id><commit_sha>4b833a7126fe4ddc9208f4eba1159da0a061851d</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/4b833a7126fe4ddc9208f4eba1159da0a061851d</commit_link><file_path>src/main/java/de/metas/ui/web/view/DocumentViewCreateRequest.java</file_path><description>Rename Method private getDocumentType() : String renamed to private getDocumentTypeId() : DocumentId in class de.metas.ui.web.view.DocumentViewCreateRequest.Builder</description><code_before>@@ -7,10 +7,12 @@
 
 import org.adempiere.util.Check;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
 import de.metas.ui.web.view.json.JSONViewDataType;
 import de.metas.ui.web.window.datatypes.DocumentPath;
 import de.metas.ui.web.window.datatypes.json.filters.JSONDocumentFilter;
 import de.metas.ui.web.window.descriptor.DocumentFieldDescriptor.Characteristic;
@@ -47,18 +49,17 @@
 @lombok.Data
 public final class DocumentViewCreateRequest
 {
-	public static final Builder builder(final String documentType, final JSONViewDataType viewType)
 	{
-		return new Builder(documentType, viewType);
 	}
 
 	public static final Builder builder(final int adWindowId, final JSONViewDataType viewType)
 	{
-		final String documentType = String.valueOf(adWindowId);
-		return new Builder(documentType, viewType);
 	}
 
-	private final String documentType;
 	private final JSONViewDataType viewType;
 
 	private final Set&lt;DocumentPath&gt; referencingDocumentPaths;
@@ -75,7 +76,7 @@ public static final Builder builder(final int adWindowId, final JSONViewDataType
 
 	private DocumentViewCreateRequest(final Builder builder)
 	{
-		documentType = builder.getDocumentType();
 		viewType = builder.getViewType();
 
 		referencingDocumentPaths = builder.getReferencingDocumentPaths();
@@ -88,11 +89,7 @@ private DocumentViewCreateRequest(final Builder builder)
 
 	public int getAD_Window_ID()
 	{
-		if(_adWindowId == null)
-		{
-			_adWindowId = Integer.parseInt(documentType);
-		}
-		return _adWindowId;
 	}
 
 	public Characteristic getViewTypeRequiredFieldCharacteristic()
@@ -119,7 +116,7 @@ public DocumentPath getSingleReferencingDocumentPathOrNull()
 	//
 	public static final class Builder
 	{
-		private final String documentType;
 		private final JSONViewDataType viewType;
 
 		private Set&lt;DocumentPath&gt; referencingDocumentPaths;
@@ -129,11 +126,11 @@ public static final class Builder
 		private int queryFirstRow = -1;
 		private int queryPageLength = -1;
 
-		private Builder(final String documentType, final JSONViewDataType viewType)
 		{
 			super();
-			Check.assumeNotEmpty(documentType, "documentType is not empty");
-			this.documentType = documentType;
 
 			Check.assumeNotNull(viewType, "Parameter viewType is not null");
 			this.viewType = viewType;
@@ -144,9 +141,9 @@ public DocumentViewCreateRequest build()
 			return new DocumentViewCreateRequest(this);
 		}
 
-		private String getDocumentType()
 		{
-			return documentType;
 		}
 
 		private JSONViewDataType getViewType()
</code_before><code_after>@@ -7,10 +7,12 @@
 
 import org.adempiere.util.Check;
 
+import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
 import de.metas.ui.web.view.json.JSONViewDataType;
+import de.metas.ui.web.window.datatypes.DocumentId;
 import de.metas.ui.web.window.datatypes.DocumentPath;
 import de.metas.ui.web.window.datatypes.json.filters.JSONDocumentFilter;
 import de.metas.ui.web.window.descriptor.DocumentFieldDescriptor.Characteristic;
@@ -47,18 +49,17 @@
 @lombok.Data
 public final class DocumentViewCreateRequest
 {
+	public static final Builder builder(final DocumentId documentTypeId, final JSONViewDataType viewType)
 	{
+		return new Builder(documentTypeId, viewType);
 	}
 
 	public static final Builder builder(final int adWindowId, final JSONViewDataType viewType)
 	{
+		return new Builder(DocumentId.of(adWindowId), viewType);
 	}
 
+	private final DocumentId documentTypeId;
 	private final JSONViewDataType viewType;
 
 	private final Set&lt;DocumentPath&gt; referencingDocumentPaths;
@@ -75,7 +76,7 @@ public static final Builder builder(final int adWindowId, final JSONViewDataType
 
 	private DocumentViewCreateRequest(final Builder builder)
 	{
+		documentTypeId = builder.getDocumentTypeId();
 		viewType = builder.getViewType();
 
 		referencingDocumentPaths = builder.getReferencingDocumentPaths();
@@ -88,11 +89,7 @@ private DocumentViewCreateRequest(final Builder builder)
 
 	public int getAD_Window_ID()
 	{
+		return documentTypeId.toInt();
 	}
 
 	public Characteristic getViewTypeRequiredFieldCharacteristic()
@@ -119,7 +116,7 @@ public DocumentPath getSingleReferencingDocumentPathOrNull()
 	//
 	public static final class Builder
 	{
+		private final DocumentId documentTypeId;
 		private final JSONViewDataType viewType;
 
 		private Set&lt;DocumentPath&gt; referencingDocumentPaths;
@@ -129,11 +126,11 @@ public static final class Builder
 		private int queryFirstRow = -1;
 		private int queryPageLength = -1;
 
+		private Builder(final DocumentId documentTypeId, final JSONViewDataType viewType)
 		{
 			super();
+			Preconditions.checkNotNull(documentTypeId, "documentTypeId is null");
+			this.documentTypeId = documentTypeId;
 
 			Check.assumeNotNull(viewType, "Parameter viewType is not null");
 			this.viewType = viewType;
@@ -144,9 +141,9 @@ public DocumentViewCreateRequest build()
 			return new DocumentViewCreateRequest(this);
 		}
 
+		private DocumentId getDocumentTypeId()
 		{
+			return documentTypeId;
 		}
 
 		private JSONViewDataType getViewType()
</code_after><evaluations><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>222304</refactoring_id><commit_sha>cefb52471fcfdb7ab027ea30a6562de3c5b40e7c</commit_sha><commit_link>https://github.com/polymorphicshade/Tubular/commit/cefb52471fcfdb7ab027ea30a6562de3c5b40e7c</commit_link><file_path>app/src/main/java/org/schabi/newpipe/player/Player.java</file_path><description>Rename Method public afterOnClick(v View) : void renamed to public manageControlsAfterOnClick(v View) : void in class org.schabi.newpipe.player.Player</description><code_before>@@ -3759,14 +3759,14 @@ public void onClick(final View v) {
             context.sendBroadcast(new Intent(VideoDetailFragment.ACTION_HIDE_MAIN_PLAYER));
         }
 
-        afterOnClick(v);
     }
 
     /**
-     * Function that should be executed after a click occured on the player UI.
      * @param v &#x2013; The view that was clicked
      */
-    public void afterOnClick(@NonNull final View v) {
         if (currentState == STATE_COMPLETED) {
             return;
         }
</code_before><code_after>@@ -3759,14 +3759,14 @@ public void onClick(final View v) {
             context.sendBroadcast(new Intent(VideoDetailFragment.ACTION_HIDE_MAIN_PLAYER));
         }
 
+        manageControlsAfterOnClick(v);
     }
 
     /**
+     * Manages the controls after a click occurred on the player UI.
      * @param v &#x2013; The view that was clicked
      */
+    public void manageControlsAfterOnClick(@NonNull final View v) {
         if (currentState == STATE_COMPLETED) {
             return;
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>329188</refactoring_id><commit_sha>af31d3dd6243c1690792a2593bb844552af5a669</commit_sha><commit_link>https://github.com/oracle/graal/commit/af31d3dd6243c1690792a2593bb844552af5a669</commit_link><file_path>projects/com.oracle.truffle.llvm.nodes/src/com/oracle/truffle/llvm/nodes/asm/LLVMAMD64CmpXchgNode.java</file_path><description>Rename Method protected execute(frame VirtualFrame, a byte, src byte, dst byte) : Object renamed to protected doOp(frame VirtualFrame, a byte, src byte, dst byte) : Object in class com.oracle.truffle.llvm.nodes.asm.LLVMAMD64CmpXchgNode.LLVMAMD64CmpXchgbNode</description><code_before>@@ -61,7 +61,7 @@ public LLVMAMD64CmpXchgbNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
-        protected Object execute(VirtualFrame frame, byte a, byte src, byte dst) {
             int result = a - dst;
             boolean carry = Byte.toUnsignedInt(a) &lt; Byte.toUnsignedInt(dst);
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -81,7 +81,7 @@ public LLVMAMD64CmpXchgwNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
-        protected Object execute(VirtualFrame frame, short a, short src, short dst) {
             int result = a - dst;
             boolean carry = Short.toUnsignedInt(a) &lt; Short.toUnsignedInt(dst);
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -101,7 +101,7 @@ public LLVMAMD64CmpXchglNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
-        protected Object execute(VirtualFrame frame, int a, int src, int dst) {
             int result = a - dst;
             boolean carry = Integer.compareUnsigned(a, dst) &lt; 0;
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -121,7 +121,7 @@ public LLVMAMD64CmpXchgqNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
-        protected Object execute(VirtualFrame frame, long a, long src, long dst) {
             long result = a - dst;
             boolean carry = Long.compareUnsigned(a, dst) &lt; 0;
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -135,7 +135,7 @@ protected Object execute(VirtualFrame frame, long a, long src, long dst) {
         }
 
         @Specialization
-        protected Object execute(VirtualFrame frame, LLVMAddress a, LLVMAddress src, LLVMAddress dst) {
             long result = a.getVal() - dst.getVal();
             boolean carry = Long.compareUnsigned(a.getVal(), dst.getVal()) &lt; 0;
             boolean adjust = (((a.getVal() ^ dst.getVal()) ^ result) &amp; 0x10) != 0;
</code_before><code_after>@@ -61,7 +61,7 @@ public LLVMAMD64CmpXchgbNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
+        protected Object doOp(VirtualFrame frame, byte a, byte src, byte dst) {
             int result = a - dst;
             boolean carry = Byte.toUnsignedInt(a) &lt; Byte.toUnsignedInt(dst);
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -81,7 +81,7 @@ public LLVMAMD64CmpXchgwNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
+        protected Object doOp(VirtualFrame frame, short a, short src, short dst) {
             int result = a - dst;
             boolean carry = Short.toUnsignedInt(a) &lt; Short.toUnsignedInt(dst);
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -101,7 +101,7 @@ public LLVMAMD64CmpXchglNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
+        protected Object doOp(VirtualFrame frame, int a, int src, int dst) {
             int result = a - dst;
             boolean carry = Integer.compareUnsigned(a, dst) &lt; 0;
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -121,7 +121,7 @@ public LLVMAMD64CmpXchgqNode(LLVMAMD64UpdateCPAZSOFlagsNode flags, LLVMAMD64Writ
         }
 
         @Specialization
+        protected Object doOp(VirtualFrame frame, long a, long src, long dst) {
             long result = a - dst;
             boolean carry = Long.compareUnsigned(a, dst) &lt; 0;
             boolean adjust = (((a ^ dst) ^ result) &amp; 0x10) != 0;
@@ -135,7 +135,7 @@ protected Object execute(VirtualFrame frame, long a, long src, long dst) {
         }
 
         @Specialization
+        protected Object doOp(VirtualFrame frame, LLVMAddress a, LLVMAddress src, LLVMAddress dst) {
             long result = a.getVal() - dst.getVal();
             boolean carry = Long.compareUnsigned(a.getVal(), dst.getVal()) &lt; 0;
             boolean adjust = (((a.getVal() ^ dst.getVal()) ^ result) &amp; 0x10) != 0;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>206387</refactoring_id><commit_sha>6fd0a0c55f1cf721c88bb0df957b2fa50215724c</commit_sha><commit_link>https://github.com/netty/netty/commit/6fd0a0c55f1cf721c88bb0df957b2fa50215724c</commit_link><file_path>codec-http2/src/main/java/io/netty/handler/codec/http2/HttpUtil.java</file_path><description>Rename Method public visit(entry Entry&lt;ByteString,ByteString&gt;) : boolean renamed to public translate(entry Entry&lt;ByteString,ByteString&gt;) : void in class io.netty.handler.codec.http2.HttpUtil.Http2ToHttpHeaderTranslator</description><code_before>@@ -18,8 +18,6 @@
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 import static io.netty.handler.codec.http2.Http2Exception.streamError;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
-import io.netty.handler.codec.BinaryHeaders;
-import io.netty.handler.codec.TextHeaders.EntryVisitor;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpMessage;
@@ -41,6 +39,7 @@
 import java.net.URI;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -246,9 +245,11 @@ public static void addHttp2ToHttpHeaders(int streamId, Http2Headers sourceHeader
                     FullHttpMessage destinationMessage, boolean addToTrailer) throws Http2Exception {
         HttpHeaders headers = addToTrailer ? destinationMessage.trailingHeaders() : destinationMessage.headers();
         boolean request = destinationMessage instanceof HttpRequest;
-        Http2ToHttpHeaderTranslator visitor = new Http2ToHttpHeaderTranslator(streamId, headers, request);
         try {
-            sourceHeaders.forEachEntry(visitor);
         } catch (Http2Exception ex) {
             throw ex;
         } catch (Throwable t) {
@@ -315,29 +316,27 @@ public static Http2Headers toHttp2Headers(HttpHeaders inHeaders) throws Exceptio
 
         final Http2Headers out = new DefaultHttp2Headers();
 
-        inHeaders.forEachEntry(new EntryVisitor() {
-            @Override
-            public boolean visit(Entry&lt;CharSequence, CharSequence&gt; entry) throws Exception {
-                final AsciiString aName = AsciiString.of(entry.getKey()).toLowerCase();
-                if (!HTTP_TO_HTTP2_HEADER_BLACKLIST.contains(aName)) {
-                    AsciiString aValue = AsciiString.of(entry.getValue());
-                    // https://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-8.1.2.2
-                    // makes a special exception for TE
-                    if (!aName.equalsIgnoreCase(HttpHeaderNames.TE) ||
-                        aValue.equalsIgnoreCase(HttpHeaderValues.TRAILERS)) {
-                        out.add(aName, aValue);
-                    }
                 }
-                return true;
             }
-        });
         return out;
     }
 
     /**
      * A visitor which translates HTTP/2 headers to HTTP/1 headers
      */
-    private static final class Http2ToHttpHeaderTranslator implements BinaryHeaders.EntryVisitor {
         /**
          * Translations from HTTP/2 header name to the HTTP/1.x equivalent.
          */
@@ -372,8 +371,7 @@ private static final class Http2ToHttpHeaderTranslator implements BinaryHeaders.
             translations = request ? REQUEST_HEADER_TRANSLATIONS : RESPONSE_HEADER_TRANSLATIONS;
         }
 
-        @Override
-        public boolean visit(Entry&lt;ByteString, ByteString&gt; entry) throws Http2Exception {
             final ByteString name = entry.getKey();
             final ByteString value = entry.getValue();
             ByteString translatedName = translations.get(name);
@@ -391,7 +389,6 @@ public boolean visit(Entry&lt;ByteString, ByteString&gt; entry) throws Http2Exception
                     output.add(new AsciiString(translatedName, false), new AsciiString(value, false));
                 }
             }
-            return true;
         }
     }
 }
</code_before><code_after>@@ -18,8 +18,6 @@
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 import static io.netty.handler.codec.http2.Http2Exception.streamError;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpMessage;
@@ -41,6 +39,7 @@
 import java.net.URI;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -246,9 +245,11 @@ public static void addHttp2ToHttpHeaders(int streamId, Http2Headers sourceHeader
                     FullHttpMessage destinationMessage, boolean addToTrailer) throws Http2Exception {
         HttpHeaders headers = addToTrailer ? destinationMessage.trailingHeaders() : destinationMessage.headers();
         boolean request = destinationMessage instanceof HttpRequest;
+        Http2ToHttpHeaderTranslator translator = new Http2ToHttpHeaderTranslator(streamId, headers, request);
         try {
+            for (Entry&lt;ByteString, ByteString&gt; entry : sourceHeaders) {
+                translator.translate(entry);
+            }
         } catch (Http2Exception ex) {
             throw ex;
         } catch (Throwable t) {
@@ -315,29 +316,27 @@ public static Http2Headers toHttp2Headers(HttpHeaders inHeaders) throws Exceptio
 
         final Http2Headers out = new DefaultHttp2Headers();
 
+        Iterator&lt;Entry&lt;CharSequence, CharSequence&gt;&gt; iter = inHeaders.iteratorCharSequence();
+        while (iter.hasNext()) {
+            Entry&lt;CharSequence, CharSequence&gt; entry = iter.next();
+            final AsciiString aName = AsciiString.of(entry.getKey()).toLowerCase();
+            if (!HTTP_TO_HTTP2_HEADER_BLACKLIST.contains(aName)) {
+                AsciiString aValue = AsciiString.of(entry.getValue());
+                // https://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-8.1.2.2
+                // makes a special exception for TE
+                if (!aName.equalsIgnoreCase(HttpHeaderNames.TE) ||
+                    aValue.equalsIgnoreCase(HttpHeaderValues.TRAILERS)) {
+                    out.add(aName, aValue);
                 }
             }
+        }
         return out;
     }
 
     /**
      * A visitor which translates HTTP/2 headers to HTTP/1 headers
      */
+    private static final class Http2ToHttpHeaderTranslator {
         /**
          * Translations from HTTP/2 header name to the HTTP/1.x equivalent.
          */
@@ -372,8 +371,7 @@ private static final class Http2ToHttpHeaderTranslator implements BinaryHeaders.
             translations = request ? REQUEST_HEADER_TRANSLATIONS : RESPONSE_HEADER_TRANSLATIONS;
         }
 
+        public void translate(Entry&lt;ByteString, ByteString&gt; entry) throws Http2Exception {
             final ByteString name = entry.getKey();
             final ByteString value = entry.getValue();
             ByteString translatedName = translations.get(name);
@@ -391,7 +389,6 @@ public boolean visit(Entry&lt;ByteString, ByteString&gt; entry) throws Http2Exception
                     output.add(new AsciiString(translatedName, false), new AsciiString(value, false));
                 }
             }
         }
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>136978</refactoring_id><commit_sha>f8846bbb1fc437e631ceab8977edbbbd0a702835</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/f8846bbb1fc437e631ceab8977edbbbd0a702835</commit_link><file_path>plugins/org.jkiss.dbeaver.ext.oracle/src/org/jkiss/dbeaver/ext/oracle/model/OracleTableColumn.java</file_path><description>Rename Method public getType() : OracleDataType renamed to public getDataType() : OracleDataType in class org.jkiss.dbeaver.ext.oracle.model.OracleTableColumn</description><code_before>@@ -30,6 +30,7 @@
 import org.jkiss.dbeaver.model.meta.Property;
 import org.jkiss.dbeaver.model.runtime.DBRProgressMonitor;
 import org.jkiss.dbeaver.model.struct.DBSDataType;
 import org.jkiss.dbeaver.model.struct.rdb.DBSTableColumn;
 import org.jkiss.dbeaver.model.meta.IPropertyValueListProvider;
 
@@ -41,7 +42,7 @@
 /**
  * OracleTableColumn
  */
-public class OracleTableColumn extends JDBCTableColumn&lt;OracleTableBase&gt; implements DBSTableColumn, DBPHiddenObject, DBPNamedObject2
 {
     static final Log log = Log.getLog(OracleTableColumn.class);
 
@@ -96,8 +97,9 @@ public OracleDataSource getDataSource()
         return getTable().getDataSource();
     }
 
     @Property(viewable = true, editable = true, updatable = true, order = 20, listProvider = ColumnDataTypeListProvider.class)
-    public OracleDataType getType()
     {
         return type;
     }
@@ -216,8 +218,8 @@ public boolean allowCustomValue()
         public Object[] getPossibleValues(OracleTableColumn column)
         {
             List&lt;DBSDataType&gt; dataTypes = new ArrayList&lt;&gt;(column.getTable().getDataSource().getLocalDataTypes());
-            if (!dataTypes.contains(column.getType())) {
-                dataTypes.add(column.getType());
             }
             return dataTypes.toArray(new DBSDataType[dataTypes.size()]);
         }
</code_before><code_after>@@ -30,6 +30,7 @@
 import org.jkiss.dbeaver.model.meta.Property;
 import org.jkiss.dbeaver.model.runtime.DBRProgressMonitor;
 import org.jkiss.dbeaver.model.struct.DBSDataType;
+import org.jkiss.dbeaver.model.struct.DBSTypedObjectEx;
 import org.jkiss.dbeaver.model.struct.rdb.DBSTableColumn;
 import org.jkiss.dbeaver.model.meta.IPropertyValueListProvider;
 
@@ -41,7 +42,7 @@
 /**
  * OracleTableColumn
  */
+public class OracleTableColumn extends JDBCTableColumn&lt;OracleTableBase&gt; implements DBSTableColumn, DBSTypedObjectEx, DBPHiddenObject, DBPNamedObject2
 {
     static final Log log = Log.getLog(OracleTableColumn.class);
 
@@ -96,8 +97,9 @@ public OracleDataSource getDataSource()
         return getTable().getDataSource();
     }
 
+    @Override
     @Property(viewable = true, editable = true, updatable = true, order = 20, listProvider = ColumnDataTypeListProvider.class)
+    public OracleDataType getDataType()
     {
         return type;
     }
@@ -216,8 +218,8 @@ public boolean allowCustomValue()
         public Object[] getPossibleValues(OracleTableColumn column)
         {
             List&lt;DBSDataType&gt; dataTypes = new ArrayList&lt;&gt;(column.getTable().getDataSource().getLocalDataTypes());
+            if (!dataTypes.contains(column.getDataType())) {
+                dataTypes.add(column.getDataType());
             }
             return dataTypes.toArray(new DBSDataType[dataTypes.size()]);
         }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>179371</refactoring_id><commit_sha>0cac43d53fe7befb2859322552f57609ab28ff4d</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/0cac43d53fe7befb2859322552f57609ab28ff4d</commit_link><file_path>jetty-io/src/main/java/org/eclipse/jetty/io/ManagedSelector.java</file_path><description>Rename Method public onClose(endPoint EndPoint) : void renamed to public destroyEndPoint(endPoint EndPoint) : void in class org.eclipse.jetty.io.ManagedSelector</description><code_before>@@ -413,6 +413,7 @@ private void closeNoExceptions(Closeable closeable)
     private EndPoint createEndPoint(SelectableChannel channel, SelectionKey selectionKey) throws IOException
     {
         EndPoint endPoint = _selectorManager.newEndPoint(channel, this, selectionKey);
         _selectorManager.endPointOpened(endPoint);
         Connection connection = _selectorManager.newConnection(channel, endPoint, selectionKey.attachment());
         endPoint.setConnection(connection);
@@ -423,21 +424,17 @@ private EndPoint createEndPoint(SelectableChannel channel, SelectionKey selectio
         return endPoint;
     }
 
-    public void onClose(final EndPoint endPoint)
     {
         final Connection connection = endPoint.getConnection();
-            submit(new Product()
-            {
-                @Override
-                public void run()
-                {
-                    if (LOG.isDebugEnabled())
-                        LOG.debug("Destroyed {}", endPoint);
-                    if (connection != null)
-                        _selectorManager.connectionClosed(connection);
-                    endPoint.close();
-                }
-            });
     }
 
     @Override
</code_before><code_after>@@ -413,6 +413,7 @@ private void closeNoExceptions(Closeable closeable)
     private EndPoint createEndPoint(SelectableChannel channel, SelectionKey selectionKey) throws IOException
     {
         EndPoint endPoint = _selectorManager.newEndPoint(channel, this, selectionKey);
+        endPoint.onOpen();
         _selectorManager.endPointOpened(endPoint);
         Connection connection = _selectorManager.newConnection(channel, endPoint, selectionKey.attachment());
         endPoint.setConnection(connection);
@@ -423,21 +424,17 @@ private EndPoint createEndPoint(SelectableChannel channel, SelectionKey selectio
         return endPoint;
     }
 
+    public void destroyEndPoint(final EndPoint endPoint)
     {
         final Connection connection = endPoint.getConnection();
+        submit((Product)() -&gt;
+        {
+            if (LOG.isDebugEnabled())
+                LOG.debug("Destroyed {}", endPoint);
+            if (connection != null)
+                _selectorManager.connectionClosed(connection);
+            _selectorManager.endPointClosed(endPoint);
+        });
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>197127</refactoring_id><commit_sha>0206899cb335ad2f59599edf99fc11949da695bb</commit_sha><commit_link>https://github.com/camunda/camunda/commit/0206899cb335ad2f59599edf99fc11949da695bb</commit_link><file_path>broker-core/src/main/java/io/zeebe/broker/event/processor/TopicSubscriberEvent.java</file_path><description>Rename Method public setEventType(event TopicSubscriberEventType) : TopicSubscriberEvent renamed to public setState(event TopicSubscriberState) : TopicSubscriberEvent in class io.zeebe.broker.event.processor.TopicSubscriberEvent</description><code_before>@@ -35,12 +35,12 @@ public class TopicSubscriberEvent extends UnpackedObject
 
     // true if startPosition should override any previously acknowledged position
     protected BooleanProperty forceStartProp = new BooleanProperty("forceStart", false);
-    protected EnumProperty&lt;TopicSubscriberEventType&gt; eventProp = new EnumProperty&lt;&gt;("eventType", TopicSubscriberEventType.class);
 
     public TopicSubscriberEvent()
     {
         this
-            .declareProperty(eventProp)
             .declareProperty(startPositionProp)
             .declareProperty(nameProp)
             .declareProperty(prefetchCapacityProp)
@@ -91,14 +91,14 @@ public boolean getForceStart()
         return forceStartProp.getValue();
     }
 
-    public TopicSubscriberEventType getEventType()
     {
-        return eventProp.getValue();
     }
 
-    public TopicSubscriberEvent setEventType(TopicSubscriberEventType event)
     {
-        this.eventProp.setValue(event);
         return this;
     }
 
</code_before><code_after>@@ -35,12 +35,12 @@ public class TopicSubscriberEvent extends UnpackedObject
 
     // true if startPosition should override any previously acknowledged position
     protected BooleanProperty forceStartProp = new BooleanProperty("forceStart", false);
+    protected EnumProperty&lt;TopicSubscriberState&gt; stateProp = new EnumProperty&lt;&gt;("state", TopicSubscriberState.class);
 
     public TopicSubscriberEvent()
     {
         this
+            .declareProperty(stateProp)
             .declareProperty(startPositionProp)
             .declareProperty(nameProp)
             .declareProperty(prefetchCapacityProp)
@@ -91,14 +91,14 @@ public boolean getForceStart()
         return forceStartProp.getValue();
     }
 
+    public TopicSubscriberState getState()
     {
+        return stateProp.getValue();
     }
 
+    public TopicSubscriberEvent setState(TopicSubscriberState event)
     {
+        this.stateProp.setValue(event);
         return this;
     }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>236044</refactoring_id><commit_sha>9b889024596dc47dea4917551a2d5813796a6b19</commit_sha><commit_link>https://github.com/apache/activemq/commit/9b889024596dc47dea4917551a2d5813796a6b19</commit_link><file_path>activemq-broker/src/main/java/org/apache/activemq/broker/jmx/NetworkDestinationView.java</file_path><description>Rename Method public resetStatistics() : void renamed to public resetStats() : void in class org.apache.activemq.broker.jmx.NetworkDestinationView</description><code_before>@@ -25,10 +25,12 @@ public class NetworkDestinationView implements NetworkDestinationViewMBean {
     private TimeStatisticImpl timeStatistic = new TimeStatisticImpl("networkEnqueue","network messages enqueued");
 
     private final String name;
     private long lastTime = -1;
 
-    public NetworkDestinationView(String name){
-       this.name = name;
     }
     /**
      * Returns the name of this destination
@@ -42,7 +44,7 @@ public String getName() {
      * Resets the managment counters.
      */
     @Override
-    public void resetStatistics() {
         timeStatistic.reset();
         lastTime = -1;
     }
@@ -70,4 +72,8 @@ public void messageSent(){
         timeStatistic.addTime(time);
         lastTime=currentTime;
     }
 }
</code_before><code_after>@@ -25,10 +25,12 @@ public class NetworkDestinationView implements NetworkDestinationViewMBean {
     private TimeStatisticImpl timeStatistic = new TimeStatisticImpl("networkEnqueue","network messages enqueued");
 
     private final String name;
+    private final NetworkBridgeView networkBridgeView;
     private long lastTime = -1;
 
+    public NetworkDestinationView(NetworkBridgeView networkBridgeView, String name){
+       this.networkBridgeView = networkBridgeView;
+       this.name=name;
     }
     /**
      * Returns the name of this destination
@@ -42,7 +44,7 @@ public String getName() {
      * Resets the managment counters.
      */
     @Override
+    public void resetStats() {
         timeStatistic.reset();
         lastTime = -1;
     }
@@ -70,4 +72,8 @@ public void messageSent(){
         timeStatistic.addTime(time);
         lastTime=currentTime;
     }
+
+    public void close(){
+        networkBridgeView.removeNetworkDestinationView(this);
+    }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>218258</refactoring_id><commit_sha>ad1dae1b444445d293be437e43d89a736e1c88a2</commit_sha><commit_link>https://github.com/teammates/teammates/commit/ad1dae1b444445d293be437e43d89a736e1c88a2</commit_link><file_path>src/e2e/java/teammates/e2e/cases/BaseE2ETestCase.java</file_path><description>Rename Method protected createUrl(relativeUrl String) : AppUrl renamed to protected createBackendUrl(relativeUrl String) : AppUrl in class teammates.e2e.cases.BaseE2ETestCase</description><code_before>@@ -93,11 +93,20 @@ public void baseClassTearDown(ITestContext context) {
 
     /**
      * Creates an {@link AppUrl} for the supplied {@code relativeUrl} parameter.
-     * The base URL will be the value of test.app.url in test.properties.
      * {@code relativeUrl} must start with a "/".
      */
-    protected static AppUrl createUrl(String relativeUrl) {
-        return new AppUrl(TestProperties.TEAMMATES_URL + relativeUrl);
     }
 
     /**
@@ -109,7 +118,7 @@ protected &lt;T extends AppPage&gt; T loginToPage(AppUrl url, Class&lt;T&gt; typeOfPage, Str
         if (!TestProperties.isDevServer()) {
             // In order for the cookie injection to work, we need to be in the domain.
             // Use the home page to minimize the page load time.
-            browser.goToUrl(TestProperties.TEAMMATES_URL);
 
             String cookieValue = BACKDOOR.getUserCookie(userId);
             browser.addCookie(Const.SecurityConfig.AUTH_COOKIE_NAME, cookieValue, true, true);
@@ -137,7 +146,7 @@ protected &lt;T extends AppPage&gt; T loginAdminToPage(AppUrl url, Class&lt;T&gt; typeOfPage
      * Equivalent to clicking the 'logout' link in the top menu of the page.
      */
     protected void logout() {
-        browser.goToUrl(createUrl(Const.WebPageURIs.LOGOUT).toAbsoluteString());
         AppPage.getNewPageInstance(browser, HomePage.class).waitForPageToLoad();
     }
 
</code_before><code_after>@@ -93,11 +93,20 @@ public void baseClassTearDown(ITestContext context) {
 
     /**
      * Creates an {@link AppUrl} for the supplied {@code relativeUrl} parameter.
+     * The base URL will be the value of test.app.frontend.url in test.properties.
      * {@code relativeUrl} must start with a "/".
      */
+    protected static AppUrl createFrontendUrl(String relativeUrl) {
+        return new AppUrl(TestProperties.TEAMMATES_FRONTEND_URL + relativeUrl);
+    }
+
+    /**
+     * Creates an {@link AppUrl} for the supplied {@code relativeUrl} parameter.
+     * The base URL will be the value of test.app.backend.url in test.properties.
+     * {@code relativeUrl} must start with a "/".
+     */
+    protected static AppUrl createBackendUrl(String relativeUrl) {
+        return new AppUrl(TestProperties.TEAMMATES_BACKEND_URL + relativeUrl);
     }
 
     /**
@@ -109,7 +118,7 @@ protected &lt;T extends AppPage&gt; T loginToPage(AppUrl url, Class&lt;T&gt; typeOfPage, Str
         if (!TestProperties.isDevServer()) {
             // In order for the cookie injection to work, we need to be in the domain.
             // Use the home page to minimize the page load time.
+            browser.goToUrl(TestProperties.TEAMMATES_FRONTEND_URL);
 
             String cookieValue = BACKDOOR.getUserCookie(userId);
             browser.addCookie(Const.SecurityConfig.AUTH_COOKIE_NAME, cookieValue, true, true);
@@ -137,7 +146,7 @@ protected &lt;T extends AppPage&gt; T loginAdminToPage(AppUrl url, Class&lt;T&gt; typeOfPage
      * Equivalent to clicking the 'logout' link in the top menu of the page.
      */
     protected void logout() {
+        browser.goToUrl(createBackendUrl(Const.WebPageURIs.LOGOUT).toAbsoluteString());
         AppPage.getNewPageInstance(browser, HomePage.class).waitForPageToLoad();
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>136196</refactoring_id><commit_sha>e0381c21c67aa7dfa01cc9669ccf7be4ede29af2</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/e0381c21c67aa7dfa01cc9669ccf7be4ede29af2</commit_link><file_path>activiti-engine/src/main/java/org/activiti/engine/impl/GroupQueryImpl.java</file_path><description>Rename Method public name(name String) : GroupQuery renamed to public groupName(name String) : GroupQuery in class org.activiti.engine.impl.GroupQueryImpl</description><code_before>@@ -18,10 +18,8 @@
 import org.activiti.engine.ActivitiException;
 import org.activiti.engine.identity.Group;
 import org.activiti.engine.identity.GroupQuery;
-import org.activiti.engine.identity.GroupQueryProperty;
 import org.activiti.engine.impl.interceptor.CommandContext;
 import org.activiti.engine.impl.interceptor.CommandExecutor;
-import org.activiti.engine.query.QueryProperty;
 
 
 /**
@@ -34,7 +32,6 @@ public class GroupQueryImpl extends AbstractQuery&lt;GroupQuery, Group&gt; implements
   protected String nameLike;
   protected String type;
   protected String userId;
-  protected GroupQueryProperty orderProperty;
   
   public GroupQueryImpl() {
     
@@ -52,31 +49,31 @@ public GroupQuery groupId(String id) {
     return this;
   }
   
-  public GroupQuery name(String name) {
     if (name == null) {
       throw new ActivitiException("Provided name is null");
     }
     this.name = name;
     return this;
   }
   
-  public GroupQuery nameLike(String nameLike) {
     if (nameLike == null) {
       throw new ActivitiException("Provided nameLike is null");
     }
     this.nameLike = nameLike;
     return this;
   }
   
-  public GroupQuery type(String type) {
     if (type == null) {
       throw new ActivitiException("Provided type is null");
     }
     this.type = type;
     return this;
   }
   
-  public GroupQuery member(String userId) {
     if (userId == null) {
       throw new ActivitiException("Provided userId is null");
     }
@@ -90,39 +87,14 @@ public GroupQuery orderByGroupId() {
     return orderBy(GroupQueryProperty.GROUP_ID);
   }
   
-  public GroupQuery orderByName() {
     return orderBy(GroupQueryProperty.NAME);
   }
   
-  public GroupQuery orderByType() {
     return orderBy(GroupQueryProperty.TYPE);
   }
   
-  public GroupQuery orderBy(QueryProperty property) {
-    if(!(property instanceof GroupQueryProperty)) {
-      throw new ActivitiException("Only GroupQueryProperty can be used with orderBy");
-    }
-    this.orderProperty = (GroupQueryProperty) property;
-    return this;
-  }
-  
-  public GroupQuery asc() {
-    return direction(Direction.ASCENDING);
-  }
-  
-  public GroupQuery desc() {
-    return direction(Direction.DESCENDING);
-  }
-  
-  public GroupQuery direction(Direction direction) {
-    if (orderProperty==null) {
-      throw new ActivitiException("You should call any of the orderBy methods first before specifying a direction");
-    }
-    addOrder(orderProperty.getName(), direction.getName());
-    orderProperty = null;
-    return this;
-  }
-
   //results ////////////////////////////////////////////////////////
   
   public long executeCount(CommandContext commandContext) {
@@ -139,12 +111,6 @@ public List&lt;Group&gt; executeList(CommandContext commandContext, Page page) {
       .findGroupByQueryCriteria(this, page);
   }
   
-  protected void checkQueryOk() {
-    if (orderProperty != null) {
-      throw new ActivitiException("Invalid query: call asc() or desc() after using orderByXX()");
-    }
-  }
-  
   //getters ////////////////////////////////////////////////////////
   
   public String getId() {
</code_before><code_after>@@ -18,10 +18,8 @@
 import org.activiti.engine.ActivitiException;
 import org.activiti.engine.identity.Group;
 import org.activiti.engine.identity.GroupQuery;
 import org.activiti.engine.impl.interceptor.CommandContext;
 import org.activiti.engine.impl.interceptor.CommandExecutor;
 
 
 /**
@@ -34,7 +32,6 @@ public class GroupQueryImpl extends AbstractQuery&lt;GroupQuery, Group&gt; implements
   protected String nameLike;
   protected String type;
   protected String userId;
   
   public GroupQueryImpl() {
     
@@ -52,31 +49,31 @@ public GroupQuery groupId(String id) {
     return this;
   }
   
+  public GroupQuery groupName(String name) {
     if (name == null) {
       throw new ActivitiException("Provided name is null");
     }
     this.name = name;
     return this;
   }
   
+  public GroupQuery groupNameLike(String nameLike) {
     if (nameLike == null) {
       throw new ActivitiException("Provided nameLike is null");
     }
     this.nameLike = nameLike;
     return this;
   }
   
+  public GroupQuery groupType(String type) {
     if (type == null) {
       throw new ActivitiException("Provided type is null");
     }
     this.type = type;
     return this;
   }
   
+  public GroupQuery groupMember(String userId) {
     if (userId == null) {
       throw new ActivitiException("Provided userId is null");
     }
@@ -90,39 +87,14 @@ public GroupQuery orderByGroupId() {
     return orderBy(GroupQueryProperty.GROUP_ID);
   }
   
+  public GroupQuery orderByGroupName() {
     return orderBy(GroupQueryProperty.NAME);
   }
   
+  public GroupQuery orderByGroupType() {
     return orderBy(GroupQueryProperty.TYPE);
   }
   
   //results ////////////////////////////////////////////////////////
   
   public long executeCount(CommandContext commandContext) {
@@ -139,12 +111,6 @@ public List&lt;Group&gt; executeList(CommandContext commandContext, Page page) {
       .findGroupByQueryCriteria(this, page);
   }
   
   //getters ////////////////////////////////////////////////////////
   
   public String getId() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>225060</refactoring_id><commit_sha>7c3844099547b063c0788656aeb5dcc91f146ad5</commit_sha><commit_link>https://github.com/apache/iotdb/commit/7c3844099547b063c0788656aeb5dcc91f146ad5</commit_link><file_path>metrics/micrometer-metrics/src/main/java/org/apache/iotdb/metrics/micrometer/type/MicrometerHistogramSnapshot.java</file_path><description>Rename Method public getMedian() : double renamed to public getSum() : double in class org.apache.iotdb.metrics.micrometer.type.MicrometerHistogramSnapshot</description><code_before>@@ -21,17 +21,15 @@
 
 import org.apache.iotdb.metrics.type.HistogramSnapshot;
 
-import io.micrometer.core.instrument.distribution.ValueAtPercentile;
-
-import java.util.Arrays;
-
 public class MicrometerHistogramSnapshot implements HistogramSnapshot {
 
   io.micrometer.core.instrument.distribution.HistogramSnapshot histogramSnapshot;
 
   public MicrometerHistogramSnapshot(
-      io.micrometer.core.instrument.distribution.HistogramSnapshot histogramSnapshot) {
-    this.histogramSnapshot = histogramSnapshot;
   }
 
   @Override
@@ -51,22 +49,15 @@ public double getValue(double quantile) {
   }
 
   @Override
-  public double[] getValues() {
-    return Arrays.stream(this.histogramSnapshot.percentileValues())
-        .mapToDouble(ValueAtPercentile::value)
-        .toArray();
   }
 
   @Override
   public int size() {
     return this.histogramSnapshot.percentileValues().length;
   }
 
-  @Override
-  public double getMedian() {
-    return getValue(0.5);
-  }
-
   @Override
   public double getMax() {
     return this.histogramSnapshot.max();
@@ -76,10 +67,4 @@ public double getMax() {
   public double getMean() {
     return this.histogramSnapshot.mean();
   }
-
-  @Override
-  public double getMin() {
-    // need distributionSummary to push 0 percentiles
-    return getValue(0.0);
-  }
 }
</code_before><code_after>@@ -21,17 +21,15 @@
 
 import org.apache.iotdb.metrics.type.HistogramSnapshot;
 
 public class MicrometerHistogramSnapshot implements HistogramSnapshot {
 
+  io.micrometer.core.instrument.DistributionSummary distributionSummary;
   io.micrometer.core.instrument.distribution.HistogramSnapshot histogramSnapshot;
 
   public MicrometerHistogramSnapshot(
+      io.micrometer.core.instrument.DistributionSummary distributionSummary) {
+    this.distributionSummary = distributionSummary;
+    this.histogramSnapshot = distributionSummary.takeSnapshot();
   }
 
   @Override
@@ -51,22 +49,15 @@ public double getValue(double quantile) {
   }
 
   @Override
+  public double getSum() {
+    return this.distributionSummary.totalAmount();
   }
 
   @Override
   public int size() {
     return this.histogramSnapshot.percentileValues().length;
   }
 
   @Override
   public double getMax() {
     return this.histogramSnapshot.max();
@@ -76,10 +67,4 @@ public double getMax() {
   public double getMean() {
     return this.histogramSnapshot.mean();
   }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>253774</refactoring_id><commit_sha>8729e9d97d718d42bd43fa9ed791e977cf7978a9</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/8729e9d97d718d42bd43fa9ed791e977cf7978a9</commit_link><file_path>src/edu/stanford/nlp/pipeline/CustomAnnotationSerializer.java</file_path><description>Rename Method public write(corpus Annotation, os OutputStream) : OutputStream renamed to public append(corpus Annotation, os OutputStream) : OutputStream in class edu.stanford.nlp.pipeline.CustomAnnotationSerializer</description><code_before>@@ -401,7 +401,7 @@ private static Map&lt;Integer, CorefChain&gt; loadCorefChains(BufferedReader reader) t
   }
 
   @Override
-  public OutputStream write(Annotation corpus, OutputStream os) throws IOException {
     if (!(os instanceof GZIPOutputStream)) {
       if(compress) os = new GZIPOutputStream(os);
     }
@@ -628,9 +628,7 @@ public static void main(String[] args) throws Exception {
     if (loadFile != null &amp;&amp; ! loadFile.equals("")) {
       CustomAnnotationSerializer ser = new CustomAnnotationSerializer(false, false);
       InputStream is = new FileInputStream(loadFile);
-      Pair&lt;Annotation, InputStream&gt; pair = ser.read(is);
-      pair.second.close();
-      Annotation anno = pair.first;
       System.out.println(anno.toShorterString(new String[0]));
       is.close();
     } else if (file != null &amp;&amp; ! file.equals("")) {
@@ -640,7 +638,8 @@ public static void main(String[] args) throws Exception {
 
       CustomAnnotationSerializer ser = new CustomAnnotationSerializer(false, false);
       PrintStream os = new PrintStream(new FileOutputStream(file + ".ser"));
-      ser.write(doc, os).close();
       System.err.println("Serialized annotation saved in " + file + ".ser");
     } else {
       System.err.println("usage: CustomAnnotationSerializer [-file file] [-loadFile file]");
</code_before><code_after>@@ -401,7 +401,7 @@ private static Map&lt;Integer, CorefChain&gt; loadCorefChains(BufferedReader reader) t
   }
 
   @Override
+  public OutputStream append(Annotation corpus, OutputStream os) throws IOException {
     if (!(os instanceof GZIPOutputStream)) {
       if(compress) os = new GZIPOutputStream(os);
     }
@@ -628,9 +628,7 @@ public static void main(String[] args) throws Exception {
     if (loadFile != null &amp;&amp; ! loadFile.equals("")) {
       CustomAnnotationSerializer ser = new CustomAnnotationSerializer(false, false);
       InputStream is = new FileInputStream(loadFile);
+      Annotation anno = ser.load(is);
       System.out.println(anno.toShorterString(new String[0]));
       is.close();
     } else if (file != null &amp;&amp; ! file.equals("")) {
@@ -640,7 +638,8 @@ public static void main(String[] args) throws Exception {
 
       CustomAnnotationSerializer ser = new CustomAnnotationSerializer(false, false);
       PrintStream os = new PrintStream(new FileOutputStream(file + ".ser"));
+      ser.save(doc, os);
+      os.close();
       System.err.println("Serialized annotation saved in " + file + ".ser");
     } else {
       System.err.println("usage: CustomAnnotationSerializer [-file file] [-loadFile file]");
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>255724</refactoring_id><commit_sha>efee6f0ee2c722459989975767eb2314e1bd0596</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/efee6f0ee2c722459989975767eb2314e1bd0596</commit_link><file_path>src/edu/stanford/nlp/trees/BobChrisTreeNormalizer.java</file_path><description>Rename Method public accept(t Tree) : boolean renamed to public test(t Tree) : boolean in class edu.stanford.nlp.trees.BobChrisTreeNormalizer.AOverAFilter</description><code_before>@@ -1,7 +1,7 @@
 package edu.stanford.nlp.trees;
 
 import edu.stanford.nlp.ling.Label;
-import edu.stanford.nlp.util.Filter;
 
 
 /**
@@ -109,19 +109,19 @@ public Tree transformTree(Tree tree) {
   }
 
 
-  protected Filter&lt;Tree&gt; emptyFilter = new EmptyFilter();
 
-  protected Filter&lt;Tree&gt; aOverAFilter = new AOverAFilter();
 
   private static final long serialVersionUID = -1005188028979810143L;
 
 
-  public static class EmptyFilter implements Filter&lt;Tree&gt; {
 
     private static final long serialVersionUID = 8914098359495987617L;
 
     /** Doesn't accept nodes that only cover an empty. */
-    public boolean accept(Tree t) {
       Tree[] kids = t.children();
       Label l = t.label();
       // Delete (return false for) empty/trace nodes (ones marked '-NONE-')
@@ -133,12 +133,12 @@ public boolean accept(Tree t) {
   } // end class EmptyFilter
 
 
-  public static class AOverAFilter implements Filter&lt;Tree&gt; {
 
     /** Doesn't accept nodes that are A over A nodes (perhaps due to
      *  empty removal or are EDITED nodes).
      */
-    public boolean accept(Tree t) {
       if (t.isLeaf() || t.isPreTerminal()) {
         return true;
       }
</code_before><code_after>@@ -1,7 +1,7 @@
 package edu.stanford.nlp.trees;
 
 import edu.stanford.nlp.ling.Label;
+import java.util.function.Predicate;
 
 
 /**
@@ -109,19 +109,19 @@ public Tree transformTree(Tree tree) {
   }
 
 
+  protected Predicate&lt;Tree&gt; emptyFilter = new EmptyFilter();
 
+  protected Predicate&lt;Tree&gt; aOverAFilter = new AOverAFilter();
 
   private static final long serialVersionUID = -1005188028979810143L;
 
 
+  public static class EmptyFilter implements Predicate&lt;Tree&gt; {
 
     private static final long serialVersionUID = 8914098359495987617L;
 
     /** Doesn't accept nodes that only cover an empty. */
+    public boolean test(Tree t) {
       Tree[] kids = t.children();
       Label l = t.label();
       // Delete (return false for) empty/trace nodes (ones marked '-NONE-')
@@ -133,12 +133,12 @@ public boolean accept(Tree t) {
   } // end class EmptyFilter
 
 
+  public static class AOverAFilter implements Predicate&lt;Tree&gt; {
 
     /** Doesn't accept nodes that are A over A nodes (perhaps due to
      *  empty removal or are EDITED nodes).
      */
+    public boolean test(Tree t) {
       if (t.isLeaf() || t.isPreTerminal()) {
         return true;
       }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>315036</refactoring_id><commit_sha>c5e9a512242e050b71635cacaaca7890fadc6b67</commit_sha><commit_link>https://github.com/apache/flink/commit/c5e9a512242e050b71635cacaaca7890fadc6b67</commit_link><file_path>flink-addons/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/invokable/operator/CounterInvokable.java</file_path><description>Rename Method protected callUserFunction() : void renamed to public invoke() : void in class org.apache.flink.streaming.api.invokable.operator.CounterInvokable</description><code_before>@@ -21,30 +21,17 @@
 
 public class CounterInvokable&lt;IN&gt; extends StreamInvokable&lt;IN, Long&gt; {
 	private static final long serialVersionUID = 1L;
-	
 	Long count = 0L;
-	
 	public CounterInvokable() {
 		super(null);
 	}
-	
-	@Override
-	protected void immutableInvoke() throws Exception {
-		while ((reuse = recordIterator.next(reuse)) != null) {
-			callUserFunctionAndLogException();
-			resetReuse();
-		}
-	}
 
 	@Override
-	protected void mutableInvoke() throws Exception {
-		while ((reuse = recordIterator.next(reuse)) != null) {
-			callUserFunctionAndLogException();
 		}
 	}
-
-	@Override
-	protected void callUserFunction() throws Exception {
-		collector.collect(++count);
-	}
 }
</code_before><code_after>@@ -21,30 +21,17 @@
 
 public class CounterInvokable&lt;IN&gt; extends StreamInvokable&lt;IN, Long&gt; {
 	private static final long serialVersionUID = 1L;
+
 	Long count = 0L;
+
 	public CounterInvokable() {
 		super(null);
 	}
 
 	@Override
+	public void invoke() throws Exception {
+		while (readNext() != null) {
+			collector.collect(++count);
 		}
 	}
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>247102</refactoring_id><commit_sha>69e48828cc58692a29d957a89890f2f14e6fbdf0</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/69e48828cc58692a29d957a89890f2f14e6fbdf0</commit_link><file_path>org.springframework.expression/src/main/java/org/springframework/expression/spel/SpelParseException.java</file_path><description>Rename Method public getMessageUnformatted() : SpelMessages renamed to public getMessageCode() : SpelMessage in class org.springframework.expression.spel.SpelParseException</description><code_before>@@ -20,15 +20,15 @@
 
 /**
  * Root exception for Spring EL related exceptions. Rather than holding a hard coded string indicating the problem, it
- * records a message key and the inserts for the message. See {@link SpelMessages} for the list of all possible messages
  * that can occur.
  * 
  * @author Andy Clement
  * @since 3.0
  */
 public class SpelParseException extends ParseException {
 
-	private SpelMessages message;
 	private Object[] inserts;
 
 //	public SpelParseException(String expressionString, int position, Throwable cause, SpelMessages message, Object... inserts) {
@@ -37,21 +37,21 @@ public class SpelParseException extends ParseException {
 //		this.inserts = inserts;
 //	}
 
-	public SpelParseException(String expressionString, int position, SpelMessages message, Object... inserts) {
 		super(expressionString, position, message.formatMessage(position,inserts));
 		this.position = position;
 		this.message = message;
 		this.inserts = inserts; 
 	}
 
-	public SpelParseException(int position, SpelMessages message, Object... inserts) {
 		super(position, message.formatMessage(position,inserts));
 		this.position = position;
 		this.message = message;
 		this.inserts = inserts;
 	}
 
-	public SpelParseException(int position, Throwable cause, SpelMessages message, Object... inserts) {
 		super(position, message.formatMessage(position,inserts), cause);
 		this.position = position;
 		this.message = message;
@@ -91,9 +91,9 @@ public String getMessage() {
 	}
 
 	/**
-	 * @return the unformatted message
 	 */
-	public SpelMessages getMessageUnformatted() {
 		return this.message;
 	}
 
</code_before><code_after>@@ -20,15 +20,15 @@
 
 /**
  * Root exception for Spring EL related exceptions. Rather than holding a hard coded string indicating the problem, it
+ * records a message key and the inserts for the message. See {@link SpelMessage} for the list of all possible messages
  * that can occur.
  * 
  * @author Andy Clement
  * @since 3.0
  */
 public class SpelParseException extends ParseException {
 
+	private SpelMessage message;
 	private Object[] inserts;
 
 //	public SpelParseException(String expressionString, int position, Throwable cause, SpelMessages message, Object... inserts) {
@@ -37,21 +37,21 @@ public class SpelParseException extends ParseException {
 //		this.inserts = inserts;
 //	}
 
+	public SpelParseException(String expressionString, int position, SpelMessage message, Object... inserts) {
 		super(expressionString, position, message.formatMessage(position,inserts));
 		this.position = position;
 		this.message = message;
 		this.inserts = inserts; 
 	}
 
+	public SpelParseException(int position, SpelMessage message, Object... inserts) {
 		super(position, message.formatMessage(position,inserts));
 		this.position = position;
 		this.message = message;
 		this.inserts = inserts;
 	}
 
+	public SpelParseException(int position, Throwable cause, SpelMessage message, Object... inserts) {
 		super(position, message.formatMessage(position,inserts), cause);
 		this.position = position;
 		this.message = message;
@@ -91,9 +91,9 @@ public String getMessage() {
 	}
 
 	/**
+	 * @return the message code
 	 */
+	public SpelMessage getMessageCode() {
 		return this.message;
 	}
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>146272</refactoring_id><commit_sha>312e396d9affdcf413a0b3b1c5f7be5a2614283e</commit_sha><commit_link>https://github.com/nationalsecurityagency/ghidra/commit/312e396d9affdcf413a0b3b1c5f7be5a2614283e</commit_link><file_path>Ghidra/Debug/Debugger-swig-lldb/src/main/java/SWIG/SBProcess.java</file_path><description>Rename Method public __str__() : String renamed to public __repr__() : String in class SWIG.SBProcess</description><code_before>@@ -323,8 +323,12 @@ public boolean IsInstrumentationRuntimePresent(InstrumentationRuntimeType type)
     return lldbJNI.SBProcess_IsInstrumentationRuntimePresent(swigCPtr, this, type.swigValue());
   }
 
   public SBError SaveCore(String file_name) {
-    return new SBError(lldbJNI.SBProcess_SaveCore(swigCPtr, this, file_name), true);
   }
 
   public SBError GetMemoryRegionInfo(java.math.BigInteger load_addr, SBMemoryRegionInfo region_info) {
@@ -347,8 +351,8 @@ public SBError DeallocateMemory(java.math.BigInteger ptr) {
     return new SBError(lldbJNI.SBProcess_DeallocateMemory(swigCPtr, this, ptr), true);
   }
 
-  public String __str__() {
-    return lldbJNI.SBProcess___str__(swigCPtr, this);
   }
 
   public final static int eBroadcastBitStateChanged = lldbJNI.SBProcess_eBroadcastBitStateChanged_get();
</code_before><code_after>@@ -323,8 +323,12 @@ public boolean IsInstrumentationRuntimePresent(InstrumentationRuntimeType type)
     return lldbJNI.SBProcess_IsInstrumentationRuntimePresent(swigCPtr, this, type.swigValue());
   }
 
+  public SBError SaveCore(String file_name, String flavor, SaveCoreStyle core_style) {
+    return new SBError(lldbJNI.SBProcess_SaveCore__SWIG_0(swigCPtr, this, file_name, flavor, core_style.swigValue()), true);
+  }
+
   public SBError SaveCore(String file_name) {
+    return new SBError(lldbJNI.SBProcess_SaveCore__SWIG_1(swigCPtr, this, file_name), true);
   }
 
   public SBError GetMemoryRegionInfo(java.math.BigInteger load_addr, SBMemoryRegionInfo region_info) {
@@ -347,8 +351,8 @@ public SBError DeallocateMemory(java.math.BigInteger ptr) {
     return new SBError(lldbJNI.SBProcess_DeallocateMemory(swigCPtr, this, ptr), true);
   }
 
+  public String __repr__() {
+    return lldbJNI.SBProcess___repr__(swigCPtr, this);
   }
 
   public final static int eBroadcastBitStateChanged = lldbJNI.SBProcess_eBroadcastBitStateChanged_get();
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>210264</refactoring_id><commit_sha>16beedd68ed982745385b9944d6ca3ac1fe17dc4</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/16beedd68ed982745385b9944d6ca3ac1fe17dc4</commit_link><file_path>core/client/src/main/java/alluxio/client/file/policy/MostAvailableFirstPolicy.java</file_path><description>Rename Method public getWorkerForBlock(options BlockLocationPolicyGetWorkerOptions) : WorkerNetAddress renamed to public getWorker(options BlockLocationPolicyGetWorkerOptions) : WorkerNetAddress in class alluxio.client.file.policy.MostAvailableFirstPolicy</description><code_before>@@ -47,7 +47,7 @@ public WorkerNetAddress getWorkerForNextBlock(Iterable&lt;BlockWorkerInfo&gt; workerIn
   }
 
   @Override
-  public WorkerNetAddress getWorkerForBlock(BlockLocationPolicyGetWorkerOptions options) {
     return getWorkerForNextBlock(options.getBlockWorkerInfos(), options.getBlockSize());
   }
 
</code_before><code_after>@@ -47,7 +47,7 @@ public WorkerNetAddress getWorkerForNextBlock(Iterable&lt;BlockWorkerInfo&gt; workerIn
   }
 
   @Override
+  public WorkerNetAddress getWorker(BlockLocationPolicyGetWorkerOptions options) {
     return getWorkerForNextBlock(options.getBlockWorkerInfos(), options.getBlockSize());
   }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>130043</refactoring_id><commit_sha>3860940049b5e83677fa86589a5b5cbef3bd2362</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/3860940049b5e83677fa86589a5b5cbef3bd2362</commit_link><file_path>de.metas.business/src/main/java/de/metas/quantity/Capacity.java</file_path><description>Rename Method public getCapacity() : BigDecimal renamed to public getCapacityQty() : BigDecimal in class de.metas.quantity.Capacity</description><code_before>@@ -125,8 +125,13 @@ public boolean isAllowNegativeCapacity()
 		return allowNegativeCapacity;
 	}
 
 	@Override
-	public BigDecimal getCapacity()
 	{
 		Check.assume(!isInfiniteCapacity(), "Cannot retrieve capacity Qty if it's infinite for {}", this);
 		return capacity;
</code_before><code_after>@@ -125,8 +125,13 @@ public boolean isAllowNegativeCapacity()
 		return allowNegativeCapacity;
 	}
 
+	/**
+	 * Will throw "Assumption Failure" if capacity is unlimited (should never be called without first checking with {@link #isInfiniteCapacity()} first)
+	 *
+	 * @return capacity
+	 */
 	@Override
+	public BigDecimal getCapacityQty()
 	{
 		Check.assume(!isInfiniteCapacity(), "Cannot retrieve capacity Qty if it's infinite for {}", this);
 		return capacity;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>139234</refactoring_id><commit_sha>919d3f94a93821d8b0a5e61a5252630ff83f1e56</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/919d3f94a93821d8b0a5e61a5252630ff83f1e56</commit_link><file_path>src/main/java/vazkii/botania/common/block/tile/TileFakeAir.java</file_path><description>Rename Method public func_230337_a_(state BlockState, tag CompoundNBT) : void renamed to public read(state BlockState, tag CompoundNBT) : void in class vazkii.botania.common.block.tile.TileFakeAir</description><code_before>@@ -48,8 +48,8 @@ public CompoundNBT write(CompoundNBT tag) {
 	}
 
 	@Override
-	public void func_230337_a_(BlockState state, CompoundNBT tag) {
-		super.func_230337_a_(state, tag);
 		flowerPos = new BlockPos(
 				tag.getInt(TAG_FLOWER_X),
 				tag.getInt(TAG_FLOWER_Y),
</code_before><code_after>@@ -48,8 +48,8 @@ public CompoundNBT write(CompoundNBT tag) {
 	}
 
 	@Override
+	public void read(BlockState state, CompoundNBT tag) {
+		super.read(state, tag);
 		flowerPos = new BlockPos(
 				tag.getInt(TAG_FLOWER_X),
 				tag.getInt(TAG_FLOWER_Y),
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>166032</refactoring_id><commit_sha>02b3bed98b870da030e242bd1525f766d6cd8b53</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/02b3bed98b870da030e242bd1525f766d6cd8b53</commit_link><file_path>backend/src/main/java/org/camunda/optimize/service/es/reader/DecisionDefinitionReader.java</file_path><description>Rename Method public getDecisionDefinitions(fullyImported boolean, withXml boolean, includeDeleted boolean) : List&lt;DecisionDefinitionOptimizeDto&gt; renamed to public getAllDecisionDefinitions() : List&lt;DecisionDefinitionOptimizeDto&gt; in class org.camunda.optimize.service.es.reader.DecisionDefinitionReader</description><code_before>@@ -23,22 +23,20 @@ public class DecisionDefinitionReader {
   public Optional&lt;DecisionDefinitionOptimizeDto&gt; getDecisionDefinition(final String decisionDefinitionKey,
                                                                        final List&lt;String&gt; decisionDefinitionVersions,
                                                                        final List&lt;String&gt; tenantIds) {
-    return definitionReader.getFirstDefinitionFromTenantsIfAvailable(
       DefinitionType.DECISION,
       decisionDefinitionKey,
       decisionDefinitionVersions,
       tenantIds
     );
   }
 
-  public List&lt;DecisionDefinitionOptimizeDto&gt; getDecisionDefinitions(final boolean fullyImported,
-                                                                    final boolean withXml,
-                                                                    final boolean includeDeleted) {
     return definitionReader.getDefinitions(
       DefinitionType.DECISION,
-      fullyImported,
-      withXml,
-      includeDeleted
     );
   }
 
</code_before><code_after>@@ -23,22 +23,20 @@ public class DecisionDefinitionReader {
   public Optional&lt;DecisionDefinitionOptimizeDto&gt; getDecisionDefinition(final String decisionDefinitionKey,
                                                                        final List&lt;String&gt; decisionDefinitionVersions,
                                                                        final List&lt;String&gt; tenantIds) {
+    return definitionReader.getFirstFullyImportedDefinitionFromTenantsIfAvailable(
       DefinitionType.DECISION,
       decisionDefinitionKey,
       decisionDefinitionVersions,
       tenantIds
     );
   }
 
+  public List&lt;DecisionDefinitionOptimizeDto&gt; getAllDecisionDefinitions() {
     return definitionReader.getDefinitions(
       DefinitionType.DECISION,
+      false,
+      false,
+      true
     );
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>227077</refactoring_id><commit_sha>cb4b81fcbf3d6ebe805d7c8a947a575a1bdfd6b0</commit_sha><commit_link>https://github.com/languagetool-org/languagetool/commit/cb4b81fcbf3d6ebe805d7c8a947a575a1bdfd6b0</commit_link><file_path>languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java</file_path><description>Rename Method protected getRuleMatch(word String, startPos int) : List&lt;RuleMatch&gt; renamed to protected getRuleMatches(word String, startPos int) : List&lt;RuleMatch&gt; in class org.languagetool.rules.en.AbstractEnglishSpellerRule</description><code_before>@@ -40,8 +40,8 @@ public AbstractEnglishSpellerRule(ResourceBundle messages, Language language) th
   }
 
   @Override
-  protected List&lt;RuleMatch&gt; getRuleMatch(String word, int startPos) throws IOException {
-    List&lt;RuleMatch&gt; ruleMatches = super.getRuleMatch(word, startPos);
     if (ruleMatches.size() &gt; 0) {
       // so 'word' is misspelled: 
       IrregularForms irregularForms = getIrregularFormsOrNull(word);
</code_before><code_after>@@ -40,8 +40,8 @@ public AbstractEnglishSpellerRule(ResourceBundle messages, Language language) th
   }
 
   @Override
+  protected List&lt;RuleMatch&gt; getRuleMatches(String word, int startPos) throws IOException {
+    List&lt;RuleMatch&gt; ruleMatches = super.getRuleMatches(word, startPos);
     if (ruleMatches.size() &gt; 0) {
       // so 'word' is misspelled: 
       IrregularForms irregularForms = getIrregularFormsOrNull(word);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>270347</refactoring_id><commit_sha>8e58a3f5f58db1f92ebf52de76c31c8139f3d036</commit_sha><commit_link>https://github.com/androidx/media/commit/8e58a3f5f58db1f92ebf52de76c31c8139f3d036</commit_link><file_path>library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java</file_path><description>Rename Method protected getCurrentPositionUs() : long renamed to public getPositionUs() : long in class com.google.android.exoplayer.MediaCodecAudioTrackRenderer</description><code_before>@@ -31,7 +31,7 @@
  * Decodes and renders audio using {@link MediaCodec} and {@link android.media.AudioTrack}.
  */
 @TargetApi(16)
-public class MediaCodecAudioTrackRenderer extends MediaCodecTrackRenderer {
 
   /**
    * Interface definition for a callback to be notified of {@link MediaCodecAudioTrackRenderer}
@@ -72,6 +72,7 @@ public interface EventListener extends MediaCodecTrackRenderer.EventListener {
 
   private int audioSessionId;
   private long currentPositionUs;
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
@@ -151,8 +152,8 @@ protected void configureCodec(MediaCodec codec, String codecName,
   }
 
   @Override
-  protected boolean isTimeSource() {
-    return true;
   }
 
   @Override
@@ -163,7 +164,7 @@ protected boolean handlesMimeType(String mimeType) {
   @Override
   protected void onEnabled(long positionUs, boolean joining) {
     super.onEnabled(positionUs, joining);
-    currentPositionUs = Long.MIN_VALUE;
   }
 
   @Override
@@ -219,14 +220,12 @@ protected boolean isReady() {
   }
 
   @Override
-  protected long getCurrentPositionUs() {
-    long audioTrackCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
-    if (audioTrackCurrentPositionUs == AudioTrack.CURRENT_POSITION_NOT_SET) {
-      // Use the super class position before audio playback starts.
-      currentPositionUs = Math.max(currentPositionUs, super.getCurrentPositionUs());
-    } else {
-      // Make sure we don't ever report time moving backwards.
-      currentPositionUs = Math.max(currentPositionUs, audioTrackCurrentPositionUs);
     }
     return currentPositionUs;
   }
@@ -244,9 +243,14 @@ protected void onDisabled() {
   @Override
   protected void seekTo(long positionUs) throws ExoPlaybackException {
     super.seekTo(positionUs);
     // TODO: Try and re-use the same AudioTrack instance once [Internal: b/7941810] is fixed.
     audioTrack.reset();
-    currentPositionUs = Long.MIN_VALUE;
   }
 
   @Override
@@ -290,7 +294,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
 
     // If we are out of sync, allow currentPositionUs to jump backwards.
     if ((handleBufferResult &amp; AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      currentPositionUs = Long.MIN_VALUE;
     }
 
     // Release the buffer if it was consumed.
</code_before><code_after>@@ -31,7 +31,7 @@
  * Decodes and renders audio using {@link MediaCodec} and {@link android.media.AudioTrack}.
  */
 @TargetApi(16)
+public class MediaCodecAudioTrackRenderer extends MediaCodecTrackRenderer implements MediaClock {
 
   /**
    * Interface definition for a callback to be notified of {@link MediaCodecAudioTrackRenderer}
@@ -72,6 +72,7 @@ public interface EventListener extends MediaCodecTrackRenderer.EventListener {
 
   private int audioSessionId;
   private long currentPositionUs;
+  private boolean allowPositionDiscontinuity;
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
@@ -151,8 +152,8 @@ protected void configureCodec(MediaCodec codec, String codecName,
   }
 
   @Override
+  protected MediaClock getMediaClock() {
+    return this;
   }
 
   @Override
@@ -163,7 +164,7 @@ protected boolean handlesMimeType(String mimeType) {
   @Override
   protected void onEnabled(long positionUs, boolean joining) {
     super.onEnabled(positionUs, joining);
+    seekToInternal(positionUs);
   }
 
   @Override
@@ -219,14 +220,12 @@ protected boolean isReady() {
   }
 
   @Override
+  public long getPositionUs() {
+    long newCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioTrack.CURRENT_POSITION_NOT_SET) {
+      currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
+          : Math.max(currentPositionUs, newCurrentPositionUs);
+      allowPositionDiscontinuity = false;
     }
     return currentPositionUs;
   }
@@ -244,9 +243,14 @@ protected void onDisabled() {
   @Override
   protected void seekTo(long positionUs) throws ExoPlaybackException {
     super.seekTo(positionUs);
+    seekToInternal(positionUs);
+  }
+
+  private void seekToInternal(long positionUs) {
     // TODO: Try and re-use the same AudioTrack instance once [Internal: b/7941810] is fixed.
     audioTrack.reset();
+    currentPositionUs = positionUs;
+    allowPositionDiscontinuity = true;
   }
 
   @Override
@@ -290,7 +294,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
 
     // If we are out of sync, allow currentPositionUs to jump backwards.
     if ((handleBufferResult &amp; AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
+      allowPositionDiscontinuity = true;
     }
 
     // Release the buffer if it was consumed.
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>227994</refactoring_id><commit_sha>c3e47c2e0a4aac25b8c726b5e0c50ca4169759fc</commit_sha><commit_link>https://github.com/zstackio/zstack/commit/c3e47c2e0a4aac25b8c726b5e0c50ca4169759fc</commit_link><file_path>header/src/main/java/org/zstack/header/storage/backup/APIGetTrashOnBackupStorageReply.java</file_path><description>Rename Method public getStorageTrashes() : List&lt;StorageTrash&gt; renamed to public getStorageTrashSpecs() : List&lt;StorageTrashSpec&gt; in class org.zstack.header.storage.backup.APIGetTrashOnBackupStorageReply</description><code_before>@@ -11,22 +11,22 @@
 /**
  * Created by mingjian.deng on 2018/12/10.
  */
-@RestResponse(allTo = "storageTrashes")
 public class APIGetTrashOnBackupStorageReply extends APIReply {
-    private List&lt;StorageTrash&gt; storageTrashes = new ArrayList&lt;&gt;();
 
-    public List&lt;StorageTrash&gt; getStorageTrashes() {
-        return storageTrashes;
     }
 
-    public void setStorageTrashes(List&lt;StorageTrash&gt; storageTrashes) {
-        this.storageTrashes = storageTrashes;
     }
 
     public static APIGetTrashOnBackupStorageReply __example__() {
         APIGetTrashOnBackupStorageReply reply = new APIGetTrashOnBackupStorageReply();
 
-        reply.setStorageTrashes(asList(new StorageTrash(uuid(), "ImageVO", uuid(), "BackupStorageVO", "/zstack_bs/installpath", 1024000L)));
 
         return reply;
     }
</code_before><code_after>@@ -11,22 +11,22 @@
 /**
  * Created by mingjian.deng on 2018/12/10.
  */
+@RestResponse(allTo = "storageTrashSpecs")
 public class APIGetTrashOnBackupStorageReply extends APIReply {
+    private List&lt;StorageTrashSpec&gt; storageTrashSpecs = new ArrayList&lt;&gt;();
 
+    public List&lt;StorageTrashSpec&gt; getStorageTrashSpecs() {
+        return storageTrashSpecs;
     }
 
+    public void setStorageTrashSpecs(List&lt;StorageTrashSpec&gt; storageTrashSpecs) {
+        this.storageTrashSpecs = storageTrashSpecs;
     }
 
     public static APIGetTrashOnBackupStorageReply __example__() {
         APIGetTrashOnBackupStorageReply reply = new APIGetTrashOnBackupStorageReply();
 
+        reply.setStorageTrashSpecs(asList(new StorageTrashSpec(uuid(), "ImageVO", uuid(), "BackupStorageVO", "/zstack_bs/installpath", 1024000L)));
 
         return reply;
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>189741</refactoring_id><commit_sha>b6d92031e6acef1e18053d3944614c0a93fa5049</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/b6d92031e6acef1e18053d3944614c0a93fa5049</commit_link><file_path>OsmAnd/src/net/osmand/core/jni/MapStyleRule.java</file_path><description>Rename Method public dump() : void renamed to public getRootNode() : SWIGTYPE_p_std__shared_ptrT_OsmAnd__ResolvedMapStyle__RuleNode_t in class net.osmand.core.jni.ResolvedMapStyle.BaseRule</description><code_before>@@ -1,51 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.3
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package net.osmand.core.jni;
-
-public class MapStyleRule {
-  private long swigCPtr;
-  private boolean swigCMemOwn;
-
-  protected MapStyleRule(long cPtr, boolean cMemoryOwn) {
-    swigCMemOwn = cMemoryOwn;
-    swigCPtr = cPtr;
-  }
-
-  protected static long getCPtr(MapStyleRule obj) {
-    return (obj == null) ? 0 : obj.swigCPtr;
-  }
-
-  protected void finalize() {
-    delete();
-  }
-
-  public synchronized void delete() {
-    if (swigCPtr != 0) {
-      if (swigCMemOwn) {
-        swigCMemOwn = false;
-        OsmAndCoreJNI.delete_MapStyleRule(swigCPtr);
-      }
-      swigCPtr = 0;
-    }
-  }
-
-  public MapStyle getOwner() {
-    long cPtr = OsmAndCoreJNI.MapStyleRule_owner_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new MapStyle(cPtr, true);
-  }
-
-  public void dump(String prefix) {
-    OsmAndCoreJNI.MapStyleRule_dump__SWIG_0(swigCPtr, this, prefix);
-  }
-
-  public void dump() {
-    OsmAndCoreJNI.MapStyleRule_dump__SWIG_1(swigCPtr, this);
-  }
-
-}
</code_before><code_after>@@ -1,51 +0,0 @@
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring></Rename_Method><Rename_Variable><refactoring><refactoring_id>335595</refactoring_id><commit_sha>95e6553d90e52c28bb9ee2a5e478d42b3df63b39</commit_sha><commit_link>https://github.com/apache/doris/commit/95e6553d90e52c28bb9ee2a5e478d42b3df63b39</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/nereids/rules/analysis/BindSlotReference.java</file_path><description>Rename Variable agg : LogicalAggregate&lt;GroupPlan&gt; to sort : LogicalSort&lt;LogicalHaving&lt;Aggregate&lt;GroupPlan&gt;&gt;&gt; in method public buildRules() : List&lt;Rule&gt; from class org.apache.doris.nereids.rules.analysis.BindSlotReference</description><code_before>@@ -66,6 +66,7 @@
 import org.apache.doris.nereids.trees.plans.logical.LogicalRepeat;
 import org.apache.doris.nereids.trees.plans.logical.LogicalSetOperation;
 import org.apache.doris.nereids.trees.plans.logical.LogicalSort;
 import org.apache.doris.planner.PlannerContext;
 
 import com.google.common.base.Preconditions;
@@ -76,6 +77,7 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -127,41 +129,63 @@ public List&lt;Rule&gt; buildRules() {
                     return new LogicalFilter&lt;&gt;(boundConjuncts, filter.child());
                 })
             ),
-            RuleType.BINDING_JOIN_SLOT.build(
-                    logicalJoin().when(Plan::canBind)
-                            .whenNot(j -&gt; j.getJoinType().equals(JoinType.USING_JOIN)).thenApply(ctx -&gt; {
-                                LogicalJoin&lt;GroupPlan, GroupPlan&gt; join = ctx.root;
-                                List&lt;Expression&gt; cond = join.getOtherJoinConjuncts().stream()
-                                        .map(expr -&gt; bind(expr, join.children(), join, ctx.cascadesContext))
-                                        .collect(Collectors.toList());
-                                List&lt;Expression&gt; hashJoinConjuncts = join.getHashJoinConjuncts().stream()
-                                        .map(expr -&gt; bind(expr, join.children(), join, ctx.cascadesContext))
-                                        .collect(Collectors.toList());
-                                return new LogicalJoin&lt;&gt;(join.getJoinType(),
-                                        hashJoinConjuncts, cond, join.getHint(), join.left(), join.right());
-                            })
-            ),
             RuleType.BINDING_USING_JOIN_SLOT.build(
-                    logicalJoin().when(j -&gt; j.getJoinType().equals(JoinType.USING_JOIN)).thenApply(ctx -&gt; {
-                        LogicalJoin&lt;GroupPlan, GroupPlan&gt; join = ctx.root;
-                        List&lt;Expression&gt; unboundSlots = join.getHashJoinConjuncts();
-                        List&lt;Expression&gt; leftSlots = unboundSlots.stream()
-                                .map(expr -&gt; bind(expr, Collections.singletonList(join.left()),
-                                        join, ctx.cascadesContext))
-                                .collect(Collectors.toList());
-                        List&lt;Expression&gt; rightSlots = unboundSlots.stream()
-                                .map(expr -&gt; bind(expr, Collections.singletonList(join.right()),
-                                        join, ctx.cascadesContext))
-                                .collect(Collectors.toList());
                         int size = leftSlots.size();
                         List&lt;Expression&gt; hashEqExpr = new ArrayList&lt;&gt;();
                         for (int i = 0; i &lt; size; i++) {
                             hashEqExpr.add(new EqualTo(leftSlots.get(i), rightSlots.get(i)));
                         }
-                        return new LogicalJoin(JoinType.INNER_JOIN, hashEqExpr,
-                                join.getOtherJoinConjuncts(), join.getHint(), join.left(), join.right());
                     })
                 ),
             RuleType.BINDING_AGGREGATE_SLOT.build(
                 logicalAggregate().when(Plan::canBind).thenApply(ctx -&gt; {
                     LogicalAggregate&lt;GroupPlan&gt; agg = ctx.root;
</code_before><code_after>@@ -66,6 +66,7 @@
 import org.apache.doris.nereids.trees.plans.logical.LogicalRepeat;
 import org.apache.doris.nereids.trees.plans.logical.LogicalSetOperation;
 import org.apache.doris.nereids.trees.plans.logical.LogicalSort;
+import org.apache.doris.nereids.trees.plans.logical.UsingJoin;
 import org.apache.doris.planner.PlannerContext;
 
 import com.google.common.base.Preconditions;
@@ -76,6 +77,7 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -127,41 +129,63 @@ public List&lt;Rule&gt; buildRules() {
                     return new LogicalFilter&lt;&gt;(boundConjuncts, filter.child());
                 })
             ),
+
             RuleType.BINDING_USING_JOIN_SLOT.build(
+                    usingJoin().thenApply(ctx -&gt; {
+                        UsingJoin&lt;GroupPlan, GroupPlan&gt; using = ctx.root;
+                        LogicalJoin lj = new LogicalJoin(using.getJoinType() == JoinType.CROSS_JOIN
+                                ? JoinType.INNER_JOIN : using.getJoinType(),
+                                using.getHashJoinConjuncts(),
+                                using.getOtherJoinConjuncts(), using.getHint(), using.left(),
+                                using.right());
+                        List&lt;Expression&gt; unboundSlots = lj.getHashJoinConjuncts();
+                        Set&lt;String&gt; slotNames = new HashSet&lt;&gt;();
+                        List&lt;Slot&gt; leftOutput = new ArrayList&lt;&gt;(lj.left().getOutput());
+                        // Suppose A JOIN B USING(name) JOIN C USING(name), [A JOIN B] is the left node, in this case,
+                        // C should combine with table B on C.name=B.name. so we reverse the output to make sure that
+                        // the most right slot is matched with priority.
+                        Collections.reverse(leftOutput);
+                        List&lt;Expression&gt; leftSlots = new ArrayList&lt;&gt;();
+                        Scope scope = toScope(leftOutput.stream()
+                                .filter(s -&gt; !slotNames.contains(s.getName()))
+                                .peek(s -&gt; slotNames.add(s.getName())).collect(
+                                        Collectors.toList()));
+                        for (Expression unboundSlot : unboundSlots) {
+                            Expression expression = new SlotBinder(scope, lj, ctx.cascadesContext).bind(unboundSlot);
+                            leftSlots.add(expression);
+                        }
+                        slotNames.clear();
+                        scope = toScope(lj.right().getOutput().stream()
+                                .filter(s -&gt; !slotNames.contains(s.getName()))
+                                .peek(s -&gt; slotNames.add(s.getName())).collect(
+                                        Collectors.toList()));
+                        List&lt;Expression&gt; rightSlots = new ArrayList&lt;&gt;();
+                        for (Expression unboundSlot : unboundSlots) {
+                            Expression expression = new SlotBinder(scope, lj, ctx.cascadesContext).bind(unboundSlot);
+                            rightSlots.add(expression);
+                        }
                         int size = leftSlots.size();
                         List&lt;Expression&gt; hashEqExpr = new ArrayList&lt;&gt;();
                         for (int i = 0; i &lt; size; i++) {
                             hashEqExpr.add(new EqualTo(leftSlots.get(i), rightSlots.get(i)));
                         }
+                        return lj.withHashJoinConjuncts(hashEqExpr);
                     })
                 ),
+                RuleType.BINDING_JOIN_SLOT.build(
+                        logicalJoin().when(Plan::canBind)
+                                .whenNot(j -&gt; j.getJoinType().equals(JoinType.USING_JOIN)).thenApply(ctx -&gt; {
+                                    LogicalJoin&lt;GroupPlan, GroupPlan&gt; join = ctx.root;
+                                    List&lt;Expression&gt; cond = join.getOtherJoinConjuncts().stream()
+                                            .map(expr -&gt; bind(expr, join.children(), join, ctx.cascadesContext))
+                                            .collect(Collectors.toList());
+                                    List&lt;Expression&gt; hashJoinConjuncts = join.getHashJoinConjuncts().stream()
+                                            .map(expr -&gt; bind(expr, join.children(), join, ctx.cascadesContext))
+                                            .collect(Collectors.toList());
+                                    return new LogicalJoin&lt;&gt;(join.getJoinType(),
+                                            hashJoinConjuncts, cond, join.getHint(), join.left(), join.right());
+                                })
+                ),
             RuleType.BINDING_AGGREGATE_SLOT.build(
                 logicalAggregate().when(Plan::canBind).thenApply(ctx -&gt; {
                     LogicalAggregate&lt;GroupPlan&gt; agg = ctx.root;
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>454532</refactoring_id><commit_sha>7576c77203a9a66da1edcc9f408d1490232c8349</commit_sha><commit_link>https://github.com/apache/flink/commit/7576c77203a9a66da1edcc9f408d1490232c8349</commit_link><file_path>pact/pact-tests/src/test/java/eu/stratosphere/pact/test/iterative/IterativeKMeansITCase.java</file_path><description>Rename Variable config : Configuration to config1 : Configuration in method public getConfigurations() : Collection&lt;Object[]&gt; from class eu.stratosphere.pact.test.iterative.IterativeKMeansITCase</description><code_before>@@ -47,13 +47,16 @@ protected JobGraph getJobGraph() throws Exception {
 
 		IterativeKMeans kmi = new IterativeKMeans();
 
-		Plan plan = kmi.getPlan("1", // config.getString("IterativeKMeansITCase#NoSubtasks", "1"), 
 				getFilesystemProvider().getURIPrefix()	+ dataPath, 
 				getFilesystemProvider().getURIPrefix() + clusterPath,  
 				getFilesystemProvider().getURIPrefix()	+ resultPath,
-				"10");
 		
-		setParameterToCross(plan, "INPUT_LEFT_SHIP_STRATEGY", "SHIP_FORWARD");
 
 		PactCompiler pc = new PactCompiler();
 		OptimizedPlan op = pc.compile(plan);
@@ -67,9 +70,29 @@ protected JobGraph getJobGraph() throws Exception {
 	public static Collection&lt;Object[]&gt; getConfigurations() {
 		ArrayList&lt;Configuration&gt; tConfigs = new ArrayList&lt;Configuration&gt;();
 
-		Configuration config = new Configuration();
-		config.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
-		tConfigs.add(config);
 
 		return toParameterList(tConfigs);
 	}
</code_before><code_after>@@ -47,13 +47,16 @@ protected JobGraph getJobGraph() throws Exception {
 
 		IterativeKMeans kmi = new IterativeKMeans();
 
+		Plan plan = kmi.getPlan(config.getString("IterativeKMeansITCase#NoSubtasks", "1"), 
 				getFilesystemProvider().getURIPrefix()	+ dataPath, 
 				getFilesystemProvider().getURIPrefix() + clusterPath,  
 				getFilesystemProvider().getURIPrefix()	+ resultPath,
+				config.getString("IterativeKMeansITCase#NumIterations", "1"));
 		
+		final String presetShipStrat = config.getString("IterativeKMeansITCase#ShipStrategyDataPoints", null);
+		if (presetShipStrat != null) {
+			setParameterToCross(plan, "INPUT_LEFT_SHIP_STRATEGY", presetShipStrat);
+		}
 
 		PactCompiler pc = new PactCompiler();
 		OptimizedPlan op = pc.compile(plan);
@@ -67,9 +70,29 @@ protected JobGraph getJobGraph() throws Exception {
 	public static Collection&lt;Object[]&gt; getConfigurations() {
 		ArrayList&lt;Configuration&gt; tConfigs = new ArrayList&lt;Configuration&gt;();
 
+		Configuration config1 = new Configuration();
+		config1.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
+		config1.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_FORWARD");
+		config1.setString("IterativeKMeansITCase#NumIterations", "1");
+		tConfigs.add(config1);
+		
+		Configuration config2 = new Configuration();
+		config2.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
+		config2.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_BROADCAST");
+		config2.setString("IterativeKMeansITCase#NumIterations", "1");
+		tConfigs.add(config2);
+		
+		Configuration config3 = new Configuration();
+		config3.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
+		config3.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_FORWARD");
+		config3.setString("IterativeKMeansITCase#NumIterations", "10");
+		tConfigs.add(config3);
+		
+		Configuration config4 = new Configuration();
+		config4.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
+		config4.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_BROADCAST");
+		config4.setString("IterativeKMeansITCase#NumIterations", "10");
+		tConfigs.add(config4);
 
 		return toParameterList(tConfigs);
 	}
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>341083</refactoring_id><commit_sha>4db738689faf2707c46a8880acf231794aa486b7</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/4db738689faf2707c46a8880acf231794aa486b7</commit_link><file_path>services/src/main/java/org/keycloak/services/models/nosql/impl/types/NoSQLObjectConverter.java</file_path><description>Rename Variable expectedType : Class&lt;?&gt; to expectedReturnType : Class&lt;?&gt; in method private setPropertyValue(object NoSQLObject, valueFromDB Object, property Property) : void from class org.keycloak.services.models.nosql.impl.types.BasicDBObjectConverter</description><code_before>@@ -1,5 +1,6 @@
 package org.keycloak.services.models.nosql.impl.types;
 
 import java.util.List;
 import java.util.Map;
 
@@ -29,84 +30,18 @@ public NoSQLObjectConverter(MongoDBImpl mongoDBImpl, TypeConverter typeConverter
     }
 
     @Override
-    public T convertDBObjectToApplicationObject(BasicDBObject dbObject) {
-        if (dbObject == null) {
-            return null;
-        }
-
-        ObjectInfo objectInfo = mongoDBImpl.getObjectInfo(expectedNoSQLObjectType);
-
-        T object;
-        try {
-            object = expectedNoSQLObjectType.newInstance();
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-
-        for (String key : dbObject.keySet()) {
-            Object value = dbObject.get(key);
-            Property&lt;Object&gt; property;
-
-            if ("_id".equals(key)) {
-                // Current property is "id"
-                Property&lt;String&gt; idProperty = objectInfo.getOidProperty();
-                if (idProperty != null) {
-                    idProperty.setValue(object, value.toString());
-                }
-
-            } else if ((property = objectInfo.getPropertyByName(key)) != null) {
-                // It's declared property with @DBField annotation
-                setPropertyValue(object, value, property);
-
-            } else if (object instanceof AttributedNoSQLObject) {
-                // It's attributed object and property is not declared, so we will call setAttribute
-                ((AttributedNoSQLObject)object).setAttribute(key, value.toString());
-
-            } else {
-                // Show warning if it's unknown
-                // TODO: logging
-                // logger.warn("Property with key " + key + " not known for type " + type);
-                System.err.println("Property with key " + key + " not known for type " + expectedNoSQLObjectType);
-            }
-        }
-
-        return object;
-    }
-
-    private void setPropertyValue(NoSQLObject object, Object valueFromDB, Property property) {
-        Class&lt;?&gt; expectedType = property.getJavaClass();
-        Class actualType = valueFromDB != null ? valueFromDB.getClass() : expectedType;
-
-        // handle primitives
-        expectedType = Types.boxedClass(expectedType);
-        actualType = Types.boxedClass(actualType);
-
-        if (actualType.isAssignableFrom(expectedType)) {
-            property.setValue(object, valueFromDB);
-        } else {
-            // we need to convert
-            Object convertedValue = typeConverter.convertDBObjectToApplicationObject(valueFromDB, expectedType);
-            property.setValue(object, convertedValue);
-        }
-    }
-
-    @Override
-    public BasicDBObject convertApplicationObjectToDBObject(T applicationObject) {
         ObjectInfo objectInfo = mongoDBImpl.getObjectInfo(applicationObject.getClass());
 
         // Create instance of BasicDBObject and add all declared properties to it (properties with null value probably should be skipped)
         BasicDBObject dbObject = new BasicDBObject();
-        List&lt;Property&lt;Object&gt;&gt; props = objectInfo.getProperties();
         for (Property&lt;Object&gt; property : props) {
             String propName = property.getName();
             Object propValue = property.getValue(applicationObject);
 
-            // Check if we have noSQLObject, which is indication that we need to convert recursively
-            if (propValue instanceof NoSQLObject) {
-                propValue = typeConverter.convertApplicationObjectToDBObject(propValue, BasicDBObject.class);
-            }
-
-            dbObject.append(propName, propValue);
         }
 
         // Adding attributes
@@ -122,12 +57,12 @@ public BasicDBObject convertApplicationObjectToDBObject(T applicationObject) {
     }
 
     @Override
-    public Class&lt;T&gt; getApplicationObjectType() {
         return expectedNoSQLObjectType;
     }
 
     @Override
-    public Class&lt;BasicDBObject&gt; getDBObjectType() {
         return BasicDBObject.class;
     }
 }
</code_before><code_after>@@ -1,5 +1,6 @@
 package org.keycloak.services.models.nosql.impl.types;
 
+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
@@ -29,84 +30,18 @@ public NoSQLObjectConverter(MongoDBImpl mongoDBImpl, TypeConverter typeConverter
     }
 
     @Override
+    public BasicDBObject convertObject(T applicationObject) {
         ObjectInfo objectInfo = mongoDBImpl.getObjectInfo(applicationObject.getClass());
 
         // Create instance of BasicDBObject and add all declared properties to it (properties with null value probably should be skipped)
         BasicDBObject dbObject = new BasicDBObject();
+        Collection&lt;Property&lt;Object&gt;&gt; props = objectInfo.getProperties();
         for (Property&lt;Object&gt; property : props) {
             String propName = property.getName();
             Object propValue = property.getValue(applicationObject);
 
+            Object dbValue = propValue == null ? null : typeConverter.convertApplicationObjectToDBObject(propValue, Types.boxedClass(property.getJavaClass()));
+            dbObject.put(propName, dbValue);
         }
 
         // Adding attributes
@@ -122,12 +57,12 @@ public BasicDBObject convertApplicationObjectToDBObject(T applicationObject) {
     }
 
     @Override
+    public Class&lt;? extends T&gt; getConverterObjectType() {
         return expectedNoSQLObjectType;
     }
 
     @Override
+    public Class&lt;BasicDBObject&gt; getExpectedReturnType() {
         return BasicDBObject.class;
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>436327</refactoring_id><commit_sha>ee477cc4ddd1ab8ba4c7c2338d31060119735e7a</commit_sha><commit_link>https://github.com/apache/cassandra/commit/ee477cc4ddd1ab8ba4c7c2338d31060119735e7a</commit_link><file_path>src/java/org/apache/cassandra/io/sstable/IndexSummaryBuilder.java</file_path><description>Rename Variable expectedEntries : long to maxExpectedEntries : long in method public IndexSummaryBuilder(expectedKeys long, minIndexInterval int, samplingLevel int) from class org.apache.cassandra.io.sstable.IndexSummaryBuilder</description><code_before>@@ -28,51 +28,51 @@
 import org.slf4j.LoggerFactory;
 
 import static org.apache.cassandra.io.sstable.Downsampling.BASE_SAMPLING_LEVEL;
-import static org.apache.cassandra.io.sstable.Downsampling.MIN_SAMPLING_LEVEL;
 
 public class IndexSummaryBuilder
 {
     private static final Logger logger = LoggerFactory.getLogger(IndexSummaryBuilder.class);
 
     private final ArrayList&lt;Long&gt; positions;
     private final ArrayList&lt;byte[]&gt; keys;
-    private final int indexInterval;
     private final int samplingLevel;
     private final int[] startPoints;
     private long keysWritten = 0;
     private long indexIntervalMatches = 0;
     private long offheapSize = 0;
 
-    public IndexSummaryBuilder(long expectedKeys, int indexInterval, int samplingLevel)
     {
-        this.indexInterval = indexInterval;
         this.samplingLevel = samplingLevel;
         this.startPoints = Downsampling.getStartPoints(BASE_SAMPLING_LEVEL, samplingLevel);
 
-        long expectedEntries = expectedKeys / indexInterval;
-        if (expectedEntries &gt; Integer.MAX_VALUE)
         {
-            // that's a _lot_ of keys, and a very low interval
-            int effectiveInterval = (int) Math.ceil((double) Integer.MAX_VALUE / expectedKeys);
-            expectedEntries = expectedKeys / effectiveInterval;
-            assert expectedEntries &lt;= Integer.MAX_VALUE : expectedEntries;
-            logger.warn("Index interval of {} is too low for {} expected keys; using interval of {} instead",
-                        indexInterval, expectedKeys, effectiveInterval);
         }
 
-        // adjust our estimates based on the sampling level
-        expectedEntries = (expectedEntries * samplingLevel) / BASE_SAMPLING_LEVEL;
-
-        positions = new ArrayList&lt;&gt;((int)expectedEntries);
-        keys = new ArrayList&lt;&gt;((int)expectedEntries);
     }
 
     public IndexSummaryBuilder maybeAddEntry(DecoratedKey decoratedKey, long indexPosition)
     {
-        if (keysWritten % indexInterval == 0)
         {
-            indexIntervalMatches++;
-
             // see if we should skip this key based on our sampling level
             boolean shouldSkip = false;
             for (int start : startPoints)
@@ -92,6 +92,8 @@ public IndexSummaryBuilder maybeAddEntry(DecoratedKey decoratedKey, long indexPo
                 positions.add(indexPosition);
                 offheapSize += TypeSizes.NATIVE.sizeof(indexPosition);
             }
         }
         keysWritten++;
 
@@ -124,25 +126,30 @@ public IndexSummary build(IPartitioner partitioner)
             memory.setLong(keyPosition, actualIndexPosition);
             keyPosition += TypeSizes.NATIVE.sizeof(actualIndexPosition);
         }
-        int sizeAtFullSampling = (int) Math.ceil(keysWritten / (double) indexInterval);
-        return new IndexSummary(partitioner, memory, keys.size(), sizeAtFullSampling, indexInterval, samplingLevel);
     }
 
     public static int entriesAtSamplingLevel(int samplingLevel, int maxSummarySize)
     {
-        return (samplingLevel * maxSummarySize) / BASE_SAMPLING_LEVEL;
     }
 
-    public static int calculateSamplingLevel(int currentSamplingLevel, int currentNumEntries, long targetNumEntries)
     {
         // Algebraic explanation for calculating the new sampling level (solve for newSamplingLevel):
         // originalNumEntries = (baseSamplingLevel / currentSamplingLevel) * currentNumEntries
         // newSpaceUsed = (newSamplingLevel / baseSamplingLevel) * originalNumEntries
         // newSpaceUsed = (newSamplingLevel / baseSamplingLevel) * (baseSamplingLevel / currentSamplingLevel) * currentNumEntries
         // newSpaceUsed = (newSamplingLevel / currentSamplingLevel) * currentNumEntries
         // (newSpaceUsed * currentSamplingLevel) / currentNumEntries = newSamplingLevel
         int newSamplingLevel = (int) (targetNumEntries * currentSamplingLevel) / currentNumEntries;
-        return Math.min(BASE_SAMPLING_LEVEL, Math.max(MIN_SAMPLING_LEVEL, newSamplingLevel));
     }
 
     /**
@@ -153,7 +160,7 @@ public static int calculateSamplingLevel(int currentSamplingLevel, int currentNu
      * @param partitioner the partitioner used for the index summary
      * @return a new IndexSummary
      */
-    public static IndexSummary downsample(IndexSummary existing, int newSamplingLevel, IPartitioner partitioner)
     {
         // To downsample the old index summary, we'll go through (potentially) several rounds of downsampling.
         // Conceptually, each round starts at position X and then removes every Nth item.  The value of X follows
@@ -162,6 +169,7 @@ public static IndexSummary downsample(IndexSummary existing, int newSamplingLeve
 
         int currentSamplingLevel = existing.getSamplingLevel();
         assert currentSamplingLevel &gt; newSamplingLevel;
 
         // calculate starting indexes for downsampling rounds
         int[] startPoints = Downsampling.getStartPoints(currentSamplingLevel, newSamplingLevel);
@@ -207,6 +215,7 @@ public static IndexSummary downsample(IndexSummary existing, int newSamplingLeve
             memory.setBytes(keyPosition, entry, 0, entry.length);
             keyPosition += entry.length;
         }
-        return new IndexSummary(partitioner, memory, newKeyCount, existing.getMaxNumberOfEntries(), existing.getIndexInterval(), newSamplingLevel);
     }
 }
</code_before><code_after>@@ -28,51 +28,51 @@
 import org.slf4j.LoggerFactory;
 
 import static org.apache.cassandra.io.sstable.Downsampling.BASE_SAMPLING_LEVEL;
 
 public class IndexSummaryBuilder
 {
     private static final Logger logger = LoggerFactory.getLogger(IndexSummaryBuilder.class);
 
     private final ArrayList&lt;Long&gt; positions;
     private final ArrayList&lt;byte[]&gt; keys;
+    private final int minIndexInterval;
     private final int samplingLevel;
     private final int[] startPoints;
     private long keysWritten = 0;
     private long indexIntervalMatches = 0;
     private long offheapSize = 0;
 
+    public IndexSummaryBuilder(long expectedKeys, int minIndexInterval, int samplingLevel)
     {
         this.samplingLevel = samplingLevel;
         this.startPoints = Downsampling.getStartPoints(BASE_SAMPLING_LEVEL, samplingLevel);
 
+        long maxExpectedEntries = expectedKeys / minIndexInterval;
+        if (maxExpectedEntries &gt; Integer.MAX_VALUE)
         {
+            // that's a _lot_ of keys, and a very low min index interval
+            int effectiveMinInterval = (int) Math.ceil((double) Integer.MAX_VALUE / expectedKeys);
+            maxExpectedEntries = expectedKeys / effectiveMinInterval;
+            assert maxExpectedEntries &lt;= Integer.MAX_VALUE : maxExpectedEntries;
+            logger.warn("min_index_interval of {} is too low for {} expected keys; using interval of {} instead",
+                        minIndexInterval, expectedKeys, effectiveMinInterval);
+            this.minIndexInterval = effectiveMinInterval;
+        }
+        else
+        {
+            this.minIndexInterval = minIndexInterval;
         }
 
+        // for initializing data structures, adjust our estimates based on the sampling level
+        maxExpectedEntries = (maxExpectedEntries * samplingLevel) / BASE_SAMPLING_LEVEL;
+        positions = new ArrayList&lt;&gt;((int)maxExpectedEntries);
+        keys = new ArrayList&lt;&gt;((int)maxExpectedEntries);
     }
 
     public IndexSummaryBuilder maybeAddEntry(DecoratedKey decoratedKey, long indexPosition)
     {
+        if (keysWritten % minIndexInterval == 0)
         {
             // see if we should skip this key based on our sampling level
             boolean shouldSkip = false;
             for (int start : startPoints)
@@ -92,6 +92,8 @@ public IndexSummaryBuilder maybeAddEntry(DecoratedKey decoratedKey, long indexPo
                 positions.add(indexPosition);
                 offheapSize += TypeSizes.NATIVE.sizeof(indexPosition);
             }
+
+            indexIntervalMatches++;
         }
         keysWritten++;
 
@@ -124,25 +126,30 @@ public IndexSummary build(IPartitioner partitioner)
             memory.setLong(keyPosition, actualIndexPosition);
             keyPosition += TypeSizes.NATIVE.sizeof(actualIndexPosition);
         }
+        int sizeAtFullSampling = (int) Math.ceil(keysWritten / (double) minIndexInterval);
+        return new IndexSummary(partitioner, memory, keys.size(), sizeAtFullSampling, minIndexInterval, samplingLevel);
     }
 
     public static int entriesAtSamplingLevel(int samplingLevel, int maxSummarySize)
     {
+        return (int) Math.ceil((samplingLevel * maxSummarySize) / (double) BASE_SAMPLING_LEVEL);
     }
 
+    public static int calculateSamplingLevel(int currentSamplingLevel, int currentNumEntries, long targetNumEntries, int minIndexInterval, int maxIndexInterval)
     {
+        // effective index interval == (BASE_SAMPLING_LEVEL / samplingLevel) * minIndexInterval
+        // so we can just solve for minSamplingLevel here:
+        // maxIndexInterval == (BASE_SAMPLING_LEVEL / minSamplingLevel) * minIndexInterval
+        int effectiveMinSamplingLevel = Math.max(1, (int) Math.ceil((BASE_SAMPLING_LEVEL * minIndexInterval) / (double) maxIndexInterval));
+
         // Algebraic explanation for calculating the new sampling level (solve for newSamplingLevel):
         // originalNumEntries = (baseSamplingLevel / currentSamplingLevel) * currentNumEntries
         // newSpaceUsed = (newSamplingLevel / baseSamplingLevel) * originalNumEntries
         // newSpaceUsed = (newSamplingLevel / baseSamplingLevel) * (baseSamplingLevel / currentSamplingLevel) * currentNumEntries
         // newSpaceUsed = (newSamplingLevel / currentSamplingLevel) * currentNumEntries
         // (newSpaceUsed * currentSamplingLevel) / currentNumEntries = newSamplingLevel
         int newSamplingLevel = (int) (targetNumEntries * currentSamplingLevel) / currentNumEntries;
+        return Math.min(BASE_SAMPLING_LEVEL, Math.max(effectiveMinSamplingLevel, newSamplingLevel));
     }
 
     /**
@@ -153,7 +160,7 @@ public static int calculateSamplingLevel(int currentSamplingLevel, int currentNu
      * @param partitioner the partitioner used for the index summary
      * @return a new IndexSummary
      */
+    public static IndexSummary downsample(IndexSummary existing, int newSamplingLevel, int minIndexInterval, IPartitioner partitioner)
     {
         // To downsample the old index summary, we'll go through (potentially) several rounds of downsampling.
         // Conceptually, each round starts at position X and then removes every Nth item.  The value of X follows
@@ -162,6 +169,7 @@ public static IndexSummary downsample(IndexSummary existing, int newSamplingLeve
 
         int currentSamplingLevel = existing.getSamplingLevel();
         assert currentSamplingLevel &gt; newSamplingLevel;
+        assert minIndexInterval == existing.getMinIndexInterval();
 
         // calculate starting indexes for downsampling rounds
         int[] startPoints = Downsampling.getStartPoints(currentSamplingLevel, newSamplingLevel);
@@ -207,6 +215,7 @@ public static IndexSummary downsample(IndexSummary existing, int newSamplingLeve
             memory.setBytes(keyPosition, entry, 0, entry.length);
             keyPosition += entry.length;
         }
+        return new IndexSummary(partitioner, memory, newKeyCount, existing.getMaxNumberOfEntries(),
+                                minIndexInterval, newSamplingLevel);
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>429382</refactoring_id><commit_sha>61caaa699faa21c382f4e3a8fb8871f23031ed88</commit_sha><commit_link>https://github.com/aws/aws-sdk-java-v2/commit/61caaa699faa21c382f4e3a8fb8871f23031ed88</commit_link><file_path>http-clients/netty-nio-client/src/main/java/software/amazon/awssdk/http/nio/netty/internal/ChannelPipelineInitializer.java</file_path><description>Rename Variable p : ChannelPipeline to pipeline : ChannelPipeline in method public channelCreated(ch Channel) : void from class software.amazon.awssdk.http.nio.netty.internal.ChannelPipelineInitializer</description><code_before>@@ -15,67 +15,92 @@
 
 package software.amazon.awssdk.http.nio.netty.internal;
 
-import com.typesafe.netty.http.HttpStreamsClientHandler;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.pool.AbstractChannelPoolHandler;
 import io.netty.handler.codec.http.HttpClientCodec;
 import io.netty.handler.ssl.SslContext;
-import io.netty.handler.ssl.SslHandler;
-import io.netty.handler.timeout.ReadTimeoutHandler;
-import io.netty.handler.timeout.WriteTimeoutHandler;
-import java.util.ArrayList;
-import java.util.List;
-import software.amazon.awssdk.http.nio.netty.internal.utils.ChannelUtils;
-import software.amazon.awssdk.http.nio.netty.internal.utils.LoggingHandler;
-import software.amazon.awssdk.utils.Logger;
-
-public class ChannelPipelineInitializer extends AbstractChannelPoolHandler {
-    private static final Logger log = Logger.loggerFor(ChannelPipelineInitializer.class);
 
-    private final SslContext sslContext;
-    private final ChannelHandler[] handlers;
-
-    public ChannelPipelineInitializer(SslContext sslContext) {
-        this.sslContext = sslContext;
 
-        List&lt;ChannelHandler&gt; tmpHandlers = new ArrayList&lt;&gt;();
-        if (log.isLoggingLevelEnabled("debug")) {
-            tmpHandlers.add(new LoggingHandler(log::debug));
-        }
 
-        handlers = tmpHandlers.toArray(new ChannelHandler[0]);
     }
 
     @Override
     public void channelCreated(Channel ch) throws Exception {
-        ChannelPipeline p = ch.pipeline();
 
-        if (sslContext != null) {
-            SslHandler handler = sslContext.newHandler(ch.alloc());
-            p.addLast(handler);
-            handler.handshakeFuture().addListener(future -&gt; {
-                if (!future.isSuccess()) {
-                    log.error(() -&gt; "SSL handshake failed.", future.cause());
-                }
-            });
         }
 
-        p.addLast(new HttpClientCodec());
-        p.addLast(handlers);
-        // Disabling auto-read is needed for backpressure to work
-        ch.config().setOption(ChannelOption.AUTO_READ, false);
     }
 
-    @Override
-    public void channelReleased(Channel ch) throws Exception {
-        // Remove any existing handlers from the pipeline from the previous request.
-        ChannelUtils.removeIfExists(ch.pipeline(),
-                                    HttpStreamsClientHandler.class,
-                                    ResponseHandler.class,
-                                    ReadTimeoutHandler.class,
-                                    WriteTimeoutHandler.class);
     }
 }
</code_before><code_after>@@ -15,67 +15,92 @@
 
 package software.amazon.awssdk.http.nio.netty.internal;
 
+import static software.amazon.awssdk.http.nio.netty.internal.ChannelAttributeKeys.MAX_CONCURRENT_STREAMS;
+import static software.amazon.awssdk.http.nio.netty.internal.ChannelAttributeKeys.PROTOCOL_FUTURE;
+
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.pool.AbstractChannelPoolHandler;
 import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http2.Http2MultiplexCodecBuilder;
+import io.netty.handler.codec.http2.Http2SettingsFrame;
+import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.handler.ssl.SslContext;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import software.amazon.awssdk.http.Protocol;
 
+/**
+ * Configures the client pipeline to support HTTP/2 frames with multiplexed streams.
+ */
+class ChannelPipelineInitializer extends AbstractChannelPoolHandler {
 
+    private final Protocol protocol;
+    private final SslContext sslCtx;
+    private final long clientMaxStreams;
 
+    ChannelPipelineInitializer(Protocol protocol,
+                               SslContext sslCtx,
+                               long clientMaxStreams) {
+        this.protocol = protocol;
+        this.sslCtx = sslCtx;
+        this.clientMaxStreams = clientMaxStreams;
     }
 
     @Override
     public void channelCreated(Channel ch) throws Exception {
+        ch.attr(PROTOCOL_FUTURE).set(new CompletableFuture&lt;&gt;());
+        ChannelPipeline pipeline = ch.pipeline();
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
+        }
 
+        if (protocol == Protocol.HTTP2) {
+            configureHttp2(ch, pipeline);
+        } else {
+            configureHttp11(ch, pipeline);
         }
+    }
+
+    private void configureHttp2(Channel ch, ChannelPipeline pipeline) {
+        pipeline.addLast(Http2MultiplexCodecBuilder
+                             .forClient(new NoOpChannelInitializer())
+                             // TODO disable frame logging for performance
+                             //.frameLogger(new SdkHttp2FrameLogger(LogLevel.DEBUG))
+                             .headerSensitivityDetector((name, value) -&gt; {
+                                 String lowerName = name.toString().toLowerCase();
+                                 return lowerName.equals("authorization");
+                             })
+                             .build());
+        pipeline.addLast(new SimpleChannelInboundHandler&lt;Http2SettingsFrame&gt;() {
+            @Override
+            protected void channelRead0(ChannelHandlerContext ctx, Http2SettingsFrame msg) throws Exception {
+                Long serverMaxStreams = Optional.ofNullable(msg.settings().maxConcurrentStreams()).orElse(Long.MAX_VALUE);
+                ch.attr(MAX_CONCURRENT_STREAMS).set(Math.min(clientMaxStreams, serverMaxStreams));
+                ch.attr(PROTOCOL_FUTURE).get().complete(ApplicationProtocolNames.HTTP_2);
+            }
 
+            @Override
+            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+                ch.attr(PROTOCOL_FUTURE).get().completeExceptionally(cause);
+            }
+        });
     }
 
+    private void configureHttp11(Channel ch, ChannelPipeline pipeline) {
+        pipeline.addLast(new HttpClientCodec());
+        ch.attr(PROTOCOL_FUTURE).get().complete(ApplicationProtocolNames.HTTP_1_1);
+    }
+
+    private static class NoOpChannelInitializer extends ChannelInitializer&lt;Channel&gt; {
+        @Override
+        protected void initChannel(Channel ch) throws Exception {
+        }
     }
+
 }
+
+
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>428377</refactoring_id><commit_sha>602d880841c5cc5491f8f56b45bfa9feb497a953</commit_sha><commit_link>https://github.com/google/exoplayer/commit/602d880841c5cc5491f8f56b45bfa9feb497a953</commit_link><file_path>library/ui/src/main/java/com/google/android/exoplayer2/ui/StyledPlayerControlViewLayoutManager.java</file_path><description>Rename Variable id : int to v : View in method private updateLayoutForSizeChange() : void from class com.google.android.exoplayer2.ui.StyledPlayerControlViewLayoutManager</description><code_before>@@ -28,6 +28,7 @@
 import android.view.animation.LinearInterpolator;
 import androidx.annotation.Nullable;
 import java.util.ArrayList;
 
 /* package */ final class StyledPlayerControlViewLayoutManager {
   private static final long ANIMATION_INTERVAL_MS = 2_000;
@@ -53,6 +54,8 @@
   private final Runnable hideControllerRunnable;
   private final OnLayoutChangeListener onLayoutChangeListener;
 
   private int uxState;
   private boolean initiallyHidden;
   private boolean isMinimalMode;
@@ -88,6 +91,7 @@ public StyledPlayerControlViewLayoutManager() {
     onLayoutChangeListener = this::onLayoutChange;
     animationEnabled = true;
     uxState = UX_STATE_ALL_VISIBLE;
   }
 
   public void show() {
@@ -157,6 +161,7 @@ public void removeHideCallbacks() {
     styledPlayerControlView.removeCallbacks(hideProgressBarRunnable);
   }
 
   public void onViewAttached(StyledPlayerControlView v) {
     styledPlayerControlView = v;
 
@@ -426,6 +431,27 @@ public boolean isFullyVisible() {
     return uxState == UX_STATE_ALL_VISIBLE &amp;&amp; styledPlayerControlView.isVisible();
   }
 
   private void setUxState(int uxState) {
     int prevUxState = this.uxState;
     this.uxState = uxState;
@@ -573,9 +599,7 @@ private boolean shouldBeMinimalMode() {
         Math.max(
             getWidth(embeddedTransportControls), getWidth(timeView) + getWidth(overflowShowButton));
     int defaultModeHeight =
-        getHeight(embeddedTransportControls)
-            + getHeight(timeBar)
-            + getHeight(bottomBar);
 
     return (width &lt;= defaultModeWidth || height &lt;= defaultModeHeight);
   }
@@ -584,7 +608,7 @@ private void updateLayoutForSizeChange() {
     if (this.styledPlayerControlView == null) {
       return;
     }
-    ViewGroup playerControlView = this.styledPlayerControlView;
 
     if (minimalControls != null) {
       minimalControls.setVisibility(isMinimalMode ? View.VISIBLE : View.INVISIBLE);
@@ -624,23 +648,22 @@ private void updateLayoutForSizeChange() {
       }
     }
 
-    int[] idsToHideInMinimalMode = {
-      R.id.exo_bottom_bar,
-      R.id.exo_prev,
-      R.id.exo_next,
-      R.id.exo_rew,
-      R.id.exo_rew_with_amount,
-      R.id.exo_ffwd,
-      R.id.exo_ffwd_with_amount
-    };
-    for (int id : idsToHideInMinimalMode) {
-      View v = playerControlView.findViewById(id);
-      if (v != null) {
-        v.setVisibility(isMinimalMode ? View.INVISIBLE : View.VISIBLE);
-      }
     }
   }
 
   private void onLayoutWidthChanged() {
     if (basicControls == null || extraControls == null) {
       return;
</code_before><code_after>@@ -28,6 +28,7 @@
 import android.view.animation.LinearInterpolator;
 import androidx.annotation.Nullable;
 import java.util.ArrayList;
+import java.util.List;
 
 /* package */ final class StyledPlayerControlViewLayoutManager {
   private static final long ANIMATION_INTERVAL_MS = 2_000;
@@ -53,6 +54,8 @@
   private final Runnable hideControllerRunnable;
   private final OnLayoutChangeListener onLayoutChangeListener;
 
+  private final List&lt;View&gt; shownButtons;
+
   private int uxState;
   private boolean initiallyHidden;
   private boolean isMinimalMode;
@@ -88,6 +91,7 @@ public StyledPlayerControlViewLayoutManager() {
     onLayoutChangeListener = this::onLayoutChange;
     animationEnabled = true;
     uxState = UX_STATE_ALL_VISIBLE;
+    shownButtons = new ArrayList&lt;&gt;();
   }
 
   public void show() {
@@ -157,6 +161,7 @@ public void removeHideCallbacks() {
     styledPlayerControlView.removeCallbacks(hideProgressBarRunnable);
   }
 
+  // TODO(insun): Pass StyledPlayerControlView to constructor and reduce multiple nullchecks.
   public void onViewAttached(StyledPlayerControlView v) {
     styledPlayerControlView = v;
 
@@ -426,6 +431,27 @@ public boolean isFullyVisible() {
     return uxState == UX_STATE_ALL_VISIBLE &amp;&amp; styledPlayerControlView.isVisible();
   }
 
+  public void setShowButton(@Nullable View button, boolean showButton) {
+    if (button == null) {
+      return;
+    }
+    if (!showButton) {
+      button.setVisibility(View.GONE);
+      shownButtons.remove(button);
+      return;
+    }
+    if (isMinimalMode &amp;&amp; shouldHideInMinimalMode(button)) {
+      button.setVisibility(View.INVISIBLE);
+    } else {
+      button.setVisibility(View.VISIBLE);
+    }
+    shownButtons.add(button);
+  }
+
+  public boolean getShowButton(@Nullable View button) {
+    return button != null &amp;&amp; shownButtons.contains(button);
+  }
+
   private void setUxState(int uxState) {
     int prevUxState = this.uxState;
     this.uxState = uxState;
@@ -573,9 +599,7 @@ private boolean shouldBeMinimalMode() {
         Math.max(
             getWidth(embeddedTransportControls), getWidth(timeView) + getWidth(overflowShowButton));
     int defaultModeHeight =
+        getHeight(embeddedTransportControls) + getHeight(timeBar) + getHeight(bottomBar);
 
     return (width &lt;= defaultModeWidth || height &lt;= defaultModeHeight);
   }
@@ -584,7 +608,7 @@ private void updateLayoutForSizeChange() {
     if (this.styledPlayerControlView == null) {
       return;
     }
+    StyledPlayerControlView playerControlView = this.styledPlayerControlView;
 
     if (minimalControls != null) {
       minimalControls.setVisibility(isMinimalMode ? View.VISIBLE : View.INVISIBLE);
@@ -624,23 +648,22 @@ private void updateLayoutForSizeChange() {
       }
     }
 
+    for (View v : shownButtons) {
+      v.setVisibility(isMinimalMode &amp;&amp; shouldHideInMinimalMode(v) ? View.INVISIBLE : View.VISIBLE);
     }
   }
 
+  private boolean shouldHideInMinimalMode(View button) {
+    int id = button.getId();
+    return (id == R.id.exo_bottom_bar
+        || id == R.id.exo_prev
+        || id == R.id.exo_next
+        || id == R.id.exo_rew
+        || id == R.id.exo_rew_with_amount
+        || id == R.id.exo_ffwd
+        || id == R.id.exo_ffwd_with_amount);
+  }
+
   private void onLayoutWidthChanged() {
     if (basicControls == null || extraControls == null) {
       return;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>430875</refactoring_id><commit_sha>52621613fd386203773ba93903abd50b46fa093a</commit_sha><commit_link>https://github.com/apache/kafka/commit/52621613fd386203773ba93903abd50b46fa093a</commit_link><file_path>metadata/src/test/java/org/apache/kafka/controller/QuorumControllerTest.java</file_path><description>Rename Variable alterIsrs : List&lt;AlterIsrRequestData.PartitionData&gt; to alterPartitions : List&lt;AlterPartitionRequestData.PartitionData&gt; in method public testMissingInMemorySnapshot() : void from class org.apache.kafka.controller.QuorumControllerTest</description><code_before>@@ -41,7 +41,7 @@
 import org.apache.kafka.common.config.ConfigResource;
 import org.apache.kafka.common.errors.TimeoutException;
 import org.apache.kafka.common.message.AllocateProducerIdsRequestData;
-import org.apache.kafka.common.message.AlterIsrRequestData;
 import org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData.ReassignableTopic;
 import org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData;
 import org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData;
@@ -756,38 +756,38 @@ public void testMissingInMemorySnapshot() throws Exception {
             ).get().topics().find(topicName).topicId();
 
             // Create a lot of alter isr
-            List&lt;AlterIsrRequestData.PartitionData&gt; alterIsrs = IntStream
                 .range(0, numPartitions)
                 .mapToObj(partitionIndex -&gt; {
                     PartitionRegistration partitionRegistration = controller.replicationControl().getPartition(
                         topicId,
                         partitionIndex
                     );
 
-                    return new AlterIsrRequestData.PartitionData()
                         .setPartitionIndex(partitionIndex)
                         .setLeaderEpoch(partitionRegistration.leaderEpoch)
-                        .setCurrentIsrVersion(partitionRegistration.partitionEpoch)
                         .setNewIsr(Arrays.asList(0, 1));
                 })
                 .collect(Collectors.toList());
 
-            AlterIsrRequestData.TopicData topicData = new AlterIsrRequestData.TopicData()
                 .setName(topicName);
-            topicData.partitions().addAll(alterIsrs);
 
             int leaderId = 0;
-            AlterIsrRequestData alterIsrRequest = new AlterIsrRequestData()
                 .setBrokerId(leaderId)
                 .setBrokerEpoch(brokerEpochs.get(leaderId));
-            alterIsrRequest.topics().add(topicData);
 
             logEnv.logManagers().get(0).resignAfterNonAtomicCommit();
 
             int oldClaimEpoch = controller.curClaimEpoch();
             assertThrows(
                 ExecutionException.class,
-                () -&gt; controller.alterIsr(alterIsrRequest).get()
             );
 
             // Wait for the controller to become active again
@@ -797,7 +797,7 @@ public void testMissingInMemorySnapshot() throws Exception {
                 String.format("oldClaimEpoch = %s, newClaimEpoch = %s", oldClaimEpoch, controller.curClaimEpoch())
             );
 
-            // Since the alterIsr partially failed we expect to see
             // some partitions to still have 2 in the ISR.
             int partitionsWithReplica2 = Utils.toList(
                 controller
</code_before><code_after>@@ -41,7 +41,7 @@
 import org.apache.kafka.common.config.ConfigResource;
 import org.apache.kafka.common.errors.TimeoutException;
 import org.apache.kafka.common.message.AllocateProducerIdsRequestData;
+import org.apache.kafka.common.message.AlterPartitionRequestData;
 import org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData.ReassignableTopic;
 import org.apache.kafka.common.message.AlterPartitionReassignmentsRequestData;
 import org.apache.kafka.common.message.AlterPartitionReassignmentsResponseData;
@@ -756,38 +756,38 @@ public void testMissingInMemorySnapshot() throws Exception {
             ).get().topics().find(topicName).topicId();
 
             // Create a lot of alter isr
+            List&lt;AlterPartitionRequestData.PartitionData&gt; alterPartitions = IntStream
                 .range(0, numPartitions)
                 .mapToObj(partitionIndex -&gt; {
                     PartitionRegistration partitionRegistration = controller.replicationControl().getPartition(
                         topicId,
                         partitionIndex
                     );
 
+                    return new AlterPartitionRequestData.PartitionData()
                         .setPartitionIndex(partitionIndex)
                         .setLeaderEpoch(partitionRegistration.leaderEpoch)
+                        .setPartitionEpoch(partitionRegistration.partitionEpoch)
                         .setNewIsr(Arrays.asList(0, 1));
                 })
                 .collect(Collectors.toList());
 
+            AlterPartitionRequestData.TopicData topicData = new AlterPartitionRequestData.TopicData()
                 .setName(topicName);
+            topicData.partitions().addAll(alterPartitions);
 
             int leaderId = 0;
+            AlterPartitionRequestData alterPartitionRequest = new AlterPartitionRequestData()
                 .setBrokerId(leaderId)
                 .setBrokerEpoch(brokerEpochs.get(leaderId));
+            alterPartitionRequest.topics().add(topicData);
 
             logEnv.logManagers().get(0).resignAfterNonAtomicCommit();
 
             int oldClaimEpoch = controller.curClaimEpoch();
             assertThrows(
                 ExecutionException.class,
+                () -&gt; controller.alterPartition(alterPartitionRequest).get()
             );
 
             // Wait for the controller to become active again
@@ -797,7 +797,7 @@ public void testMissingInMemorySnapshot() throws Exception {
                 String.format("oldClaimEpoch = %s, newClaimEpoch = %s", oldClaimEpoch, controller.curClaimEpoch())
             );
 
+            // Since the alterPartition partially failed we expect to see
             // some partitions to still have 2 in the ISR.
             int partitionsWithReplica2 = Utils.toList(
                 controller
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>447362</refactoring_id><commit_sha>86581e45804cb8e7c941d23f98e0173a2b6be0f9</commit_sha><commit_link>https://github.com/metersphere/metersphere/commit/86581e45804cb8e7c941d23f98e0173a2b6be0f9</commit_link><file_path>backend/services/system-setting/src/test/java/io/metersphere/system/base/BaseCustomFieldTestService.java</file_path><description>Rename Variable customFieldDao : CustomFieldDao to customFieldDTO : CustomFieldDTO in method private invokeValidate(valueMap Map&lt;CustomFieldType,Object&gt;, customFieldType CustomFieldType) : void from class io.metersphere.system.base.BaseCustomFieldTestService</description><code_before>@@ -6,7 +6,7 @@
 import io.metersphere.sdk.exception.MSException;
 import io.metersphere.sdk.util.BeanUtils;
 import io.metersphere.system.domain.CustomField;
-import io.metersphere.system.dto.CustomFieldDao;
 import io.metersphere.system.dto.sdk.request.CustomFieldOptionRequest;
 import io.metersphere.system.resolver.field.AbstractCustomFieldResolver;
 import io.metersphere.system.resolver.field.CustomFieldResolverFactory;
@@ -129,8 +129,8 @@ public void testResolverParse() {
 
             AbstractCustomFieldResolver customFieldResolver = CustomFieldResolverFactory.getResolver(customFieldType.name());
             CustomField customField = getCustomFields().get(customFieldType);
-            CustomFieldDao customFieldDao = BeanUtils.copyBean(new CustomFieldDao(), customField);
-            customFieldDao.setRequired(true);
             String valueStr = customFieldResolver.parse2String(objectValueMap.get(customFieldType));
             Object objectValue = customFieldResolver.parse2Value(valueStr);
             // &#x6821;&#x9A8C; parse2String &#x548C; parse2Value &#x662F;&#x5426;&#x6B63;&#x786E;
@@ -157,8 +157,8 @@ private void assertValidateError(Map&lt;CustomFieldType, Object&gt; errorValueMap) {
     private void invokeValidate(Map&lt;CustomFieldType, Object&gt; valueMap, CustomFieldType customFieldType) {
         AbstractCustomFieldResolver customFieldResolver = CustomFieldResolverFactory.getResolver(customFieldType.name());
         CustomField customField = getCustomFields().get(customFieldType);
-        CustomFieldDao customFieldDao = BeanUtils.copyBean(new CustomFieldDao(), customField);
-        customFieldDao.setRequired(true);
-        customFieldResolver.validate(customFieldDao, valueMap.get(customFieldType));
     }
 }
</code_before><code_after>@@ -6,7 +6,7 @@
 import io.metersphere.sdk.exception.MSException;
 import io.metersphere.sdk.util.BeanUtils;
 import io.metersphere.system.domain.CustomField;
+import io.metersphere.system.dto.CustomFieldDTO;
 import io.metersphere.system.dto.sdk.request.CustomFieldOptionRequest;
 import io.metersphere.system.resolver.field.AbstractCustomFieldResolver;
 import io.metersphere.system.resolver.field.CustomFieldResolverFactory;
@@ -129,8 +129,8 @@ public void testResolverParse() {
 
             AbstractCustomFieldResolver customFieldResolver = CustomFieldResolverFactory.getResolver(customFieldType.name());
             CustomField customField = getCustomFields().get(customFieldType);
+            CustomFieldDTO customFieldDTO = BeanUtils.copyBean(new CustomFieldDTO(), customField);
+            customFieldDTO.setRequired(true);
             String valueStr = customFieldResolver.parse2String(objectValueMap.get(customFieldType));
             Object objectValue = customFieldResolver.parse2Value(valueStr);
             // &#x6821;&#x9A8C; parse2String &#x548C; parse2Value &#x662F;&#x5426;&#x6B63;&#x786E;
@@ -157,8 +157,8 @@ private void assertValidateError(Map&lt;CustomFieldType, Object&gt; errorValueMap) {
     private void invokeValidate(Map&lt;CustomFieldType, Object&gt; valueMap, CustomFieldType customFieldType) {
         AbstractCustomFieldResolver customFieldResolver = CustomFieldResolverFactory.getResolver(customFieldType.name());
         CustomField customField = getCustomFields().get(customFieldType);
+        CustomFieldDTO customFieldDTO = BeanUtils.copyBean(new CustomFieldDTO(), customField);
+        customFieldDTO.setRequired(true);
+        customFieldResolver.validate(customFieldDTO, valueMap.get(customFieldType));
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>411862</refactoring_id><commit_sha>1be56acc67ad88c2b8bd34dcd6329fc1e83e099f</commit_sha><commit_link>https://github.com/real-logic/aeron/commit/1be56acc67ad88c2b8bd34dcd6329fc1e83e099f</commit_link><file_path>aeron-mediadriver/src/main/java/uk/co/real_logic/aeron/mediadriver/Receiver.java</file_path><description>Rename Variable rcvDestination : UdpDestination to udpDestination : UdpDestination in method private onAddSubscription(destination String, channelIds long[]) : void from class uk.co.real_logic.aeron.mediadriver.Receiver</description><code_before>@@ -97,7 +97,7 @@ else if (cmd instanceof RemoveSubscriptionCmd)
             }
             catch (final Exception ex)
             {
-
                 LOGGER.logException(ex);
             }
         }
@@ -124,29 +124,29 @@ public NioSelector nioSelector()
         return nioSelector;
     }
 
-    public DataFrameHandler frameHandler(final UdpDestination destination)
     {
         return frameHandlerByDestinationMap.get(destination);
     }
 
     private void onAddSubscription(final String destination, final long[] channelIds) throws Exception
     {
-        final UdpDestination rcvDestination = UdpDestination.parse(destination);
-        DataFrameHandler frameHandler = frameHandler(rcvDestination);
 
         if (null == frameHandler)
         {
-            frameHandler = new DataFrameHandler(rcvDestination, nioSelector, conductorProxy, connectedSubscriptions);
-            frameHandlerByDestinationMap.put(rcvDestination, frameHandler);
         }
 
         frameHandler.addSubscriptions(channelIds);
     }
 
     private void onRemoveSubscription(final String destination, final long[] channelIds)
     {
-        final UdpDestination rcvDestination = UdpDestination.parse(destination);
-        final DataFrameHandler frameHandler = frameHandler(rcvDestination);
 
         if (null == frameHandler)
         {
@@ -157,14 +157,14 @@ private void onRemoveSubscription(final String destination, final long[] channel
 
         if (0 == frameHandler.subscribedChannelCount())
         {
-            frameHandlerByDestinationMap.remove(rcvDestination);
             frameHandler.close();
         }
     }
 
     private void onNewConnectedSubscription(final NewConnectedSubscriptionCmd cmd)
     {
-        final DataFrameHandler frameHandler = frameHandler(cmd.destination());
         FeedbackDelayGenerator delayGenerator;
 
         if (null == frameHandler)
@@ -174,9 +174,11 @@ private void onNewConnectedSubscription(final NewConnectedSubscriptionCmd cmd)
             return;
         }
 
-        final GapScanner[] scanners = cmd.bufferRotator().buffers()
-            .map((rawLog) -&gt; new GapScanner(rawLog.logBuffer(), rawLog.stateBuffer()))
-            .toArray(GapScanner[]::new);
 
         if (cmd.destination().isMulticast())
         {
</code_before><code_after>@@ -97,7 +97,7 @@ else if (cmd instanceof RemoveSubscriptionCmd)
             }
             catch (final Exception ex)
             {
+                // TODO: Send error to client - however best if validated by conductor so receiver not delayed
                 LOGGER.logException(ex);
             }
         }
@@ -124,29 +124,29 @@ public NioSelector nioSelector()
         return nioSelector;
     }
 
+    public DataFrameHandler getFrameHandler(final UdpDestination destination)
     {
         return frameHandlerByDestinationMap.get(destination);
     }
 
     private void onAddSubscription(final String destination, final long[] channelIds) throws Exception
     {
+        final UdpDestination udpDestination = UdpDestination.parse(destination);
+        DataFrameHandler frameHandler = getFrameHandler(udpDestination);
 
         if (null == frameHandler)
         {
+            frameHandler = new DataFrameHandler(udpDestination, nioSelector, conductorProxy, connectedSubscriptions);
+            frameHandlerByDestinationMap.put(udpDestination, frameHandler);
         }
 
         frameHandler.addSubscriptions(channelIds);
     }
 
     private void onRemoveSubscription(final String destination, final long[] channelIds)
     {
+        final UdpDestination udpDestination = UdpDestination.parse(destination);
+        final DataFrameHandler frameHandler = getFrameHandler(udpDestination);
 
         if (null == frameHandler)
         {
@@ -157,14 +157,14 @@ private void onRemoveSubscription(final String destination, final long[] channel
 
         if (0 == frameHandler.subscribedChannelCount())
         {
+            frameHandlerByDestinationMap.remove(udpDestination);
             frameHandler.close();
         }
     }
 
     private void onNewConnectedSubscription(final NewConnectedSubscriptionCmd cmd)
     {
+        final DataFrameHandler frameHandler = getFrameHandler(cmd.destination());
         FeedbackDelayGenerator delayGenerator;
 
         if (null == frameHandler)
@@ -174,9 +174,11 @@ private void onNewConnectedSubscription(final NewConnectedSubscriptionCmd cmd)
             return;
         }
 
+        final GapScanner[] scanners =
+            cmd.bufferRotator()
+               .buffers()
+               .map((rawLog) -&gt; new GapScanner(rawLog.logBuffer(), rawLog.stateBuffer()))
+               .toArray(GapScanner[]::new);
 
         if (cmd.destination().isMulticast())
         {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>370378</refactoring_id><commit_sha>d74b0ecd0f619cfcb03c50e0260f0aec8cd6dd85</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/d74b0ecd0f619cfcb03c50e0260f0aec8cd6dd85</commit_link><file_path>src/test/java/com/google/devtools/build/lib/analysis/util/AnalysisTestCase.java</file_path><description>Rename Variable packageCacheOptions : PackageCacheOptions to packageOptions : PackageOptions in method private reinitializeSkyframeExecutor() : void from class com.google.devtools.build.lib.analysis.util.AnalysisTestCase</description><code_before>@@ -58,8 +58,8 @@
 import com.google.devtools.build.lib.packages.Target;
 import com.google.devtools.build.lib.packages.util.MockToolsConfig;
 import com.google.devtools.build.lib.pkgcache.LoadingOptions;
-import com.google.devtools.build.lib.pkgcache.PackageCacheOptions;
 import com.google.devtools.build.lib.pkgcache.PackageManager;
 import com.google.devtools.build.lib.pkgcache.PathPackageLocator;
 import com.google.devtools.build.lib.rules.repository.RepositoryDelegatorFunction;
 import com.google.devtools.build.lib.runtime.KeepGoingOption;
@@ -216,12 +216,12 @@ protected void useRuleClassProvider(ConfiguredRuleClassProvider ruleClassProvide
 
   private void reinitializeSkyframeExecutor() {
     SkyframeExecutorTestHelper.process(skyframeExecutor);
-    PackageCacheOptions packageCacheOptions = Options.getDefaults(PackageCacheOptions.class);
-    packageCacheOptions.showLoadingProgress = true;
-    packageCacheOptions.globbingThreads = 3;
     skyframeExecutor.preparePackageLoading(
         pkgLocator,
-        packageCacheOptions,
         Options.getDefaults(StarlarkSemanticsOptions.class),
         UUID.randomUUID(),
         ImmutableMap.&lt;String, String&gt;of(),
@@ -268,7 +268,7 @@ public final void useConfiguration(String... args) throws Exception {
                 Iterables.concat(
                     Arrays.asList(
                         ExecutionOptions.class,
-                        PackageCacheOptions.class,
                         StarlarkSemanticsOptions.class,
                         BuildRequestOptions.class,
                         AnalysisOptions.class,
@@ -352,24 +352,24 @@ protected AnalysisResult update(
     boolean discardAnalysisCache = viewOptions.discardAnalysisCache;
     viewOptions.skyframePrepareAnalysis = flags.contains(Flag.SKYFRAME_PREPARE_ANALYSIS);
 
-    PackageCacheOptions packageCacheOptions = optionsParser.getOptions(PackageCacheOptions.class);
     PathPackageLocator pathPackageLocator =
         PathPackageLocator.create(
             outputBase,
-            packageCacheOptions.packagePath,
             reporter,
             rootDirectory,
             rootDirectory,
             BazelSkyframeExecutorConstants.BUILD_FILES_BY_PRIORITY);
-    packageCacheOptions.showLoadingProgress = true;
-    packageCacheOptions.globbingThreads = 7;
 
     StarlarkSemanticsOptions starlarkSemanticsOptions =
         optionsParser.getOptions(StarlarkSemanticsOptions.class);
 
     skyframeExecutor.preparePackageLoading(
         pathPackageLocator,
-        packageCacheOptions,
         starlarkSemanticsOptions,
         UUID.randomUUID(),
         ImmutableMap.&lt;String, String&gt;of(),
</code_before><code_after>@@ -58,8 +58,8 @@
 import com.google.devtools.build.lib.packages.Target;
 import com.google.devtools.build.lib.packages.util.MockToolsConfig;
 import com.google.devtools.build.lib.pkgcache.LoadingOptions;
 import com.google.devtools.build.lib.pkgcache.PackageManager;
+import com.google.devtools.build.lib.pkgcache.PackageOptions;
 import com.google.devtools.build.lib.pkgcache.PathPackageLocator;
 import com.google.devtools.build.lib.rules.repository.RepositoryDelegatorFunction;
 import com.google.devtools.build.lib.runtime.KeepGoingOption;
@@ -216,12 +216,12 @@ protected void useRuleClassProvider(ConfiguredRuleClassProvider ruleClassProvide
 
   private void reinitializeSkyframeExecutor() {
     SkyframeExecutorTestHelper.process(skyframeExecutor);
+    PackageOptions packageOptions = Options.getDefaults(PackageOptions.class);
+    packageOptions.showLoadingProgress = true;
+    packageOptions.globbingThreads = 3;
     skyframeExecutor.preparePackageLoading(
         pkgLocator,
+        packageOptions,
         Options.getDefaults(StarlarkSemanticsOptions.class),
         UUID.randomUUID(),
         ImmutableMap.&lt;String, String&gt;of(),
@@ -268,7 +268,7 @@ public final void useConfiguration(String... args) throws Exception {
                 Iterables.concat(
                     Arrays.asList(
                         ExecutionOptions.class,
+                        PackageOptions.class,
                         StarlarkSemanticsOptions.class,
                         BuildRequestOptions.class,
                         AnalysisOptions.class,
@@ -352,24 +352,24 @@ protected AnalysisResult update(
     boolean discardAnalysisCache = viewOptions.discardAnalysisCache;
     viewOptions.skyframePrepareAnalysis = flags.contains(Flag.SKYFRAME_PREPARE_ANALYSIS);
 
+    PackageOptions packageOptions = optionsParser.getOptions(PackageOptions.class);
     PathPackageLocator pathPackageLocator =
         PathPackageLocator.create(
             outputBase,
+            packageOptions.packagePath,
             reporter,
             rootDirectory,
             rootDirectory,
             BazelSkyframeExecutorConstants.BUILD_FILES_BY_PRIORITY);
+    packageOptions.showLoadingProgress = true;
+    packageOptions.globbingThreads = 7;
 
     StarlarkSemanticsOptions starlarkSemanticsOptions =
         optionsParser.getOptions(StarlarkSemanticsOptions.class);
 
     skyframeExecutor.preparePackageLoading(
         pathPackageLocator,
+        packageOptions,
         starlarkSemanticsOptions,
         UUID.randomUUID(),
         ImmutableMap.&lt;String, String&gt;of(),
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>384797</refactoring_id><commit_sha>431f598357047a7bfdc51d1999524e9a8ccc4d98</commit_sha><commit_link>https://github.com/apache/ignite/commit/431f598357047a7bfdc51d1999524e9a8ccc4d98</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsReader.java</file_path><description>Rename Variable handler : PerformanceStatisticsHandler to hnd : PerformanceStatisticsHandler in method private deserialize(buf ByteBuffer, nodeId UUID) : boolean from class org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatisticsReader</description><code_before>@@ -219,8 +219,8 @@ private boolean deserialize(ByteBuffer buf, UUID nodeId) throws IOException {
             long startTime = buf.getLong();
             long duration = buf.getLong();
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.cacheOperation(nodeId, opType, cacheId, startTime, duration);
 
             return true;
         }
@@ -241,8 +241,8 @@ else if (transactionOperation(opType)) {
             long startTime = buf.getLong();
             long duration = buf.getLong();
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.transaction(nodeId, cacheIds, startTime, duration, opType == TX_COMMIT);
 
             return true;
         }
@@ -287,8 +287,8 @@ else if (opType == QUERY) {
             if (text == null)
                 forwardRead(hash);
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.query(nodeId, queryType, text, id, startTime, duration, success);
 
             return true;
         }
@@ -302,8 +302,8 @@ else if (opType == QUERY_READS) {
             long logicalReads = buf.getLong();
             long physicalReads = buf.getLong();
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.queryReads(nodeId, queryType, uuid, id, logicalReads, physicalReads);
 
             return true;
         }
@@ -318,8 +318,8 @@ else if (opType == QUERY_ROWS) {
             long id = buf.getLong();
             long rows = buf.getLong();
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.queryRows(nodeId, qryType, uuid, id, action, rows);
 
             return true;
         }
@@ -341,8 +341,8 @@ else if (opType == QUERY_PROPERTY) {
             UUID uuid = readUuid(buf);
             long id = buf.getLong();
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.queryProperty(nodeId, qryType, uuid, id, name, val);
 
             return true;
         }
@@ -386,8 +386,8 @@ else if (opType == TASK) {
             if (taskName == null)
                 forwardRead(hash);
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.task(nodeId, sesId, taskName, startTime, duration, affPartId);
 
             return true;
         }
@@ -401,8 +401,8 @@ else if (opType == JOB) {
             long duration = buf.getLong();
             boolean timedOut = buf.get() != 0;
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.job(nodeId, sesId, queuedTime, startTime, duration, timedOut);
 
             return true;
         }
@@ -440,8 +440,8 @@ else if (opType == CACHE_START) {
 
             int cacheId = buf.getInt();
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.cacheStart(nodeId, cacheId, cacheName);
 
             return true;
         }
@@ -465,8 +465,8 @@ else if (opType == CHECKPOINT) {
             int dataPagesWritten = buf.getInt();
             int cowPagesWritten = buf.getInt();
 
-            for (PerformanceStatisticsHandler handler : curHnd) {
-                handler.checkpoint(nodeId,
                     beforeLockDuration,
                     lockWaitDuration,
                     listenersExecDuration,
@@ -493,8 +493,8 @@ else if (opType == PAGES_WRITE_THROTTLE) {
             long endTime = buf.getLong();
             long duration = buf.getLong();
 
-            for (PerformanceStatisticsHandler handler : curHnd)
-                handler.pagesWriteThrottle(nodeId, endTime, duration);
 
             return true;
         }
</code_before><code_after>@@ -219,8 +219,8 @@ private boolean deserialize(ByteBuffer buf, UUID nodeId) throws IOException {
             long startTime = buf.getLong();
             long duration = buf.getLong();
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.cacheOperation(nodeId, opType, cacheId, startTime, duration);
 
             return true;
         }
@@ -241,8 +241,8 @@ else if (transactionOperation(opType)) {
             long startTime = buf.getLong();
             long duration = buf.getLong();
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.transaction(nodeId, cacheIds, startTime, duration, opType == TX_COMMIT);
 
             return true;
         }
@@ -287,8 +287,8 @@ else if (opType == QUERY) {
             if (text == null)
                 forwardRead(hash);
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.query(nodeId, queryType, text, id, startTime, duration, success);
 
             return true;
         }
@@ -302,8 +302,8 @@ else if (opType == QUERY_READS) {
             long logicalReads = buf.getLong();
             long physicalReads = buf.getLong();
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.queryReads(nodeId, queryType, uuid, id, logicalReads, physicalReads);
 
             return true;
         }
@@ -318,8 +318,8 @@ else if (opType == QUERY_ROWS) {
             long id = buf.getLong();
             long rows = buf.getLong();
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.queryRows(nodeId, qryType, uuid, id, action, rows);
 
             return true;
         }
@@ -341,8 +341,8 @@ else if (opType == QUERY_PROPERTY) {
             UUID uuid = readUuid(buf);
             long id = buf.getLong();
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.queryProperty(nodeId, qryType, uuid, id, name, val);
 
             return true;
         }
@@ -386,8 +386,8 @@ else if (opType == TASK) {
             if (taskName == null)
                 forwardRead(hash);
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.task(nodeId, sesId, taskName, startTime, duration, affPartId);
 
             return true;
         }
@@ -401,8 +401,8 @@ else if (opType == JOB) {
             long duration = buf.getLong();
             boolean timedOut = buf.get() != 0;
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.job(nodeId, sesId, queuedTime, startTime, duration, timedOut);
 
             return true;
         }
@@ -440,8 +440,8 @@ else if (opType == CACHE_START) {
 
             int cacheId = buf.getInt();
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.cacheStart(nodeId, cacheId, cacheName);
 
             return true;
         }
@@ -465,8 +465,8 @@ else if (opType == CHECKPOINT) {
             int dataPagesWritten = buf.getInt();
             int cowPagesWritten = buf.getInt();
 
+            for (PerformanceStatisticsHandler hnd : curHnd) {
+                hnd.checkpoint(nodeId,
                     beforeLockDuration,
                     lockWaitDuration,
                     listenersExecDuration,
@@ -493,8 +493,8 @@ else if (opType == PAGES_WRITE_THROTTLE) {
             long endTime = buf.getLong();
             long duration = buf.getLong();
 
+            for (PerformanceStatisticsHandler hnd : curHnd)
+                hnd.pagesWriteThrottle(nodeId, endTime, duration);
 
             return true;
         }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>362283</refactoring_id><commit_sha>b15d77c985f28c9d9a7d6f4dd72401eefbb9dda1</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/b15d77c985f28c9d9a7d6f4dd72401eefbb9dda1</commit_link><file_path>broker/src/test/java/io/zeebe/broker/system/configuration/BrokerCfgTest.java</file_path><description>Rename Variable cfgCluster : ClusterCfg to experimentalCfg : ExperimentalCfg in method public shouldOverrideMaxAppendBatchSizeViaEnvironment() : void from class io.zeebe.broker.system.configuration.BrokerCfgTest</description><code_before>@@ -57,9 +57,9 @@ public final class BrokerCfgTest {
   private static final String ZEEBE_BROKER_CLUSTER_CLUSTER_NAME =
       "zeebe.broker.cluster.clusterName";
   private static final String ZEEBE_BROKER_CLUSTER_MAX_APPENDS_PER_FOLLOWER =
-      "zeebe.broker.cluster.maxAppendsPerFollower";
   private static final String ZEEBE_BROKER_CLUSTER_MAX_APPEND_BATCH_SIZE =
-      "zeebe.broker.cluster.maxAppendBatchSize";
 
   private static final String ZEEBE_BROKER_DATA_DIRECTORIES = "zeebe.broker.data.directories";
 
@@ -441,23 +441,23 @@ public void shouldOverrideMaxAppendsViaEnvironment() {
 
     // when
     final BrokerCfg cfg = TestConfigReader.readConfig("cluster-cfg", environment);
-    final ClusterCfg cfgCluster = cfg.getCluster();
 
     // then
-    assertThat(cfgCluster.getMaxAppendsPerFollower()).isEqualTo(8);
   }
 
   @Test
   public void shouldOverrideMaxAppendBatchSizeViaEnvironment() {
     // given
-    environment.put(ZEEBE_BROKER_CLUSTER_MAX_APPEND_BATCH_SIZE, "32KB");
 
     // when
     final BrokerCfg cfg = TestConfigReader.readConfig("cluster-cfg", environment);
-    final ClusterCfg cfgCluster = cfg.getCluster();
 
     // then
-    assertThat(cfgCluster.getMaxAppendBatchSize()).isEqualTo(16 * 1024);
   }
 
   @Test
</code_before><code_after>@@ -57,9 +57,9 @@ public final class BrokerCfgTest {
   private static final String ZEEBE_BROKER_CLUSTER_CLUSTER_NAME =
       "zeebe.broker.cluster.clusterName";
   private static final String ZEEBE_BROKER_CLUSTER_MAX_APPENDS_PER_FOLLOWER =
+      "zeebe.broker.experimental.maxAppendsPerFollower";
   private static final String ZEEBE_BROKER_CLUSTER_MAX_APPEND_BATCH_SIZE =
+      "zeebe.broker.experimental.maxAppendBatchSize";
 
   private static final String ZEEBE_BROKER_DATA_DIRECTORIES = "zeebe.broker.data.directories";
 
@@ -441,23 +441,23 @@ public void shouldOverrideMaxAppendsViaEnvironment() {
 
     // when
     final BrokerCfg cfg = TestConfigReader.readConfig("cluster-cfg", environment);
+    final ExperimentalCfg experimentalCfg = cfg.getExperimental();
 
     // then
+    assertThat(experimentalCfg.getMaxAppendsPerFollower()).isEqualTo(8);
   }
 
   @Test
   public void shouldOverrideMaxAppendBatchSizeViaEnvironment() {
     // given
+    environment.put(ZEEBE_BROKER_CLUSTER_MAX_APPEND_BATCH_SIZE, "256KB");
 
     // when
     final BrokerCfg cfg = TestConfigReader.readConfig("cluster-cfg", environment);
+    final ExperimentalCfg experimentalCfg = cfg.getExperimental();
 
     // then
+    assertThat(experimentalCfg.getMaxAppendBatchSizeInBytes()).isEqualTo(256 * 1024);
   }
 
   @Test
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>406232</refactoring_id><commit_sha>5d2da329f791758c8642a634bb7492a6197b1022</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/5d2da329f791758c8642a634bb7492a6197b1022</commit_link><file_path>profiler/src/main/java/com/navercorp/pinpoint/profiler/monitor/codahale/gc/SerialDetailedMetricsCollector.java</file_path><description>Rename Variable gc : TJvmGc to jvmGc : TJvmGc in method public collect() : TJvmGc from class com.navercorp.pinpoint.profiler.monitor.collector.jvmgc.JvmGcDetailedMetricCollector</description><code_before>@@ -1,91 +0,0 @@
-package com.navercorp.pinpoint.profiler.monitor.codahale.gc;
-
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.EXCLUDED_DOUBLE;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_GC_SERIAL_NEWGEN_COUNT;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_GC_SERIAL_NEWGEN_TIME;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_MEMORY_POOLS_SERIAL_CODE_CACHE_USAGE;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_MEMORY_POOLS_SERIAL_METASPACE_USAGE;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_MEMORY_POOLS_SERIAL_NEWGEN_USAGE;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_MEMORY_POOLS_SERIAL_OLDGEN_USAGE;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_MEMORY_POOLS_SERIAL_PERMGEN_USAGE;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.JVM_MEMORY_POOLS_SERIAL_SURVIVOR_USAGE;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.getDoubleGauge;
-import static com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorValues.getLongGauge;
-
-import java.util.SortedMap;
-
-import com.codahale.metrics.Gauge;
-import com.codahale.metrics.MetricRegistry;
-import com.navercorp.pinpoint.profiler.monitor.codahale.MetricMonitorRegistry;
-import com.navercorp.pinpoint.thrift.dto.TJvmGc;
-import com.navercorp.pinpoint.thrift.dto.TJvmGcDetailed;
-
-/**
- * HotSpot's Serial collector with detailed metrics
- *
- * @author dawidmalina
- */
-public class SerialDetailedMetricsCollector extends SerialCollector{
-
-    private final Gauge&lt;Double&gt; codeCacheUsage;
-    private final Gauge&lt;Double&gt; newGenUsage;
-    private final Gauge&lt;Double&gt; oldGenUsage;
-    private final Gauge&lt;Double&gt; survivorUsage;
-    private final Gauge&lt;Double&gt; permGenUsage;
-    private final Gauge&lt;Double&gt; metaspaceUsage;
-    private final Gauge&lt;Long&gt; newGcCount;
-    private final Gauge&lt;Long&gt; newGcTime;
-
-    public SerialDetailedMetricsCollector(MetricMonitorRegistry registry) {
-
-        super(registry);
-
-        final MetricRegistry metricRegistry = registry.getRegistry();
-        @SuppressWarnings("rawtypes")
-        final SortedMap&lt;String, Gauge&gt; gauges = metricRegistry.getGauges();
-
-        this.codeCacheUsage = getDoubleGauge(gauges, JVM_MEMORY_POOLS_SERIAL_CODE_CACHE_USAGE);
-        this.newGenUsage = getDoubleGauge(gauges, JVM_MEMORY_POOLS_SERIAL_NEWGEN_USAGE);
-        this.oldGenUsage = getDoubleGauge(gauges, JVM_MEMORY_POOLS_SERIAL_OLDGEN_USAGE);
-        this.survivorUsage = getDoubleGauge(gauges, JVM_MEMORY_POOLS_SERIAL_SURVIVOR_USAGE);
-
-        if (gauges.containsKey(JVM_MEMORY_POOLS_SERIAL_PERMGEN_USAGE)) {
-            this.permGenUsage = getDoubleGauge(gauges, JVM_MEMORY_POOLS_SERIAL_PERMGEN_USAGE);
-            this.metaspaceUsage = EXCLUDED_DOUBLE;
-        } else {
-            this.metaspaceUsage = getDoubleGauge(gauges, JVM_MEMORY_POOLS_SERIAL_METASPACE_USAGE);
-            this.permGenUsage = EXCLUDED_DOUBLE;
-        }
-
-        this.newGcCount = getLongGauge(gauges, JVM_GC_SERIAL_NEWGEN_COUNT);
-        this.newGcTime = getLongGauge(gauges, JVM_GC_SERIAL_NEWGEN_TIME);
-
-    }
-
-    @Override
-    public TJvmGc collect() {
-        final TJvmGc gc = super.collect();
-        final TJvmGcDetailed details = new TJvmGcDetailed();
-        details.setJvmPoolCodeCacheUsed(codeCacheUsage.getValue());
-        details.setJvmPoolNewGenUsed(newGenUsage.getValue());
-        details.setJvmPoolOldGenUsed(oldGenUsage.getValue());
-        details.setJvmPoolSurvivorSpaceUsed(survivorUsage.getValue());
-        if (EXCLUDED_DOUBLE.getValue() == permGenUsage.getValue()) {
-            // metric for jvm &gt;= 1.8
-            details.setJvmPoolMetaspaceUsed(metaspaceUsage.getValue());
-        } else {
-            // metric for jvm &lt; 1.8
-            details.setJvmPoolPermGenUsed(permGenUsage.getValue());
-        }
-        details.setJvmGcNewCount(newGcCount.getValue());
-        details.setJvmGcNewTime(newGcTime.getValue());
-        gc.setJvmGcDetailed(details);
-        return gc;
-    }
-
-    @Override
-    public String toString() {
-        return "HotSpot's Serial collector with detailed metrics";
-    }
-
-}
</code_before><code_after>@@ -1,91 +0,0 @@
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>407983</refactoring_id><commit_sha>fa4ba2a82bc5bad00010dbd96b43dd4019243859</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/fa4ba2a82bc5bad00010dbd96b43dd4019243859</commit_link><file_path>spring-webmvc/src/test/java/org/springframework/web/servlet/resource/ResourceTransformerSupportTests.java</file_path><description>Rename Variable mainCss : Resource to css : Resource in method public resolveUrlPath() : void from class org.springframework.web.servlet.resource.ResourceTransformerSupportTests</description><code_before>@@ -17,7 +17,7 @@
 
 import static org.junit.Assert.assertEquals;
 
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
@@ -48,93 +48,61 @@ public class ResourceTransformerSupportTests {
 
 	@Before
 	public void setUp() {
-		VersionResourceResolver versionResolver = new VersionResourceResolver();
-		versionResolver.setStrategyMap(Collections.singletonMap("/**", new ContentVersionStrategy()));
-
-		List&lt;ResourceResolver&gt; resolvers = new ArrayList&lt;&gt;();
-		resolvers.add(versionResolver);
-		resolvers.add(new PathResourceResolver());
 		this.transformerChain = new DefaultResourceTransformerChain(new DefaultResourceResolverChain(resolvers), null);
 
-		List&lt;Resource&gt; locations = new ArrayList&lt;&gt;();
-		locations.add(new ClassPathResource("test/", getClass()));
 
 		ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();
-		handler.setLocations(locations);
 		handler.setResourceResolvers(resolvers);
-
 		ResourceUrlProvider urlProvider = new ResourceUrlProvider();
 		urlProvider.setHandlerMap(Collections.singletonMap("/resources/**", handler));
-
-		this.transformer = new TestResourceTransformerSupport();
-		this.transformer.setResourceUrlProvider(urlProvider);
-
-		this.request = new MockHttpServletRequest();
 	}
 
-	@Test
-	public void rewriteAbsolutePathWithContext() throws Exception {
-		this.request.setRequestURI("/servlet/context/resources/main.css");
-		this.request.setMethod("GET");
-		this.request.setServletPath("/servlet");
-		this.request.setContextPath("/context");
-		this.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, "/resources/main.css");
-
-		String resourcePath = "/servlet/context/resources/bar.css";
-		Resource mainCss = new ClassPathResource("test/main.css", getClass());
-		String actual = this.transformer.resolveUrlPath(resourcePath, this.request, mainCss, this.transformerChain);
-		assertEquals("/servlet/context/resources/bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
-	}
 
 	@Test
-	public void rewriteAbsolutePath() throws Exception {
-		this.request.setRequestURI("/resources/main.css");
-		this.request.setMethod("GET");
 		this.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, "/resources/main.css");
 
-		String resourcePath = "/resources/bar.css";
-		Resource mainCss = new ClassPathResource("test/main.css", getClass());
-		String actual = this.transformer.resolveUrlPath(resourcePath, this.request, mainCss, this.transformerChain);
-		assertEquals("/resources/bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
-
-		actual = this.transformer.resolveUrlPath("bar.css", this.request, mainCss, this.transformerChain);
-		assertEquals("bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
 	}
 
 	@Test
-	public void rewriteRelativePath() throws Exception {
-		this.request.setRequestURI("/servlet/context/resources/main.css");
-		this.request.setMethod("GET");
-		this.request.setServletPath("/servlet");
 		this.request.setContextPath("/context");
-		this.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, "/resources/main.css");
-
-		Resource mainCss = new ClassPathResource("test/main.css", getClass());
-		String actual = this.transformer.resolveUrlPath("bar.css", this.request, mainCss, this.transformerChain);
-		assertEquals("bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
-	}
-
-	@Test(expected = IllegalStateException.class)
-	public void rewriteAbsolutePathWrongPath() throws Exception {
-		this.request.setRequestURI("/servlet/context/resources/main.css");
-		this.request.setMethod("GET");
 		this.request.setServletPath("/servlet");
-		this.request.setContextPath("/context");
-		this.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, "/wrong/main.css");
 
-		String resourcePath = "/servlet/context/resources/bar.css";
-		Resource mainCss = new ClassPathResource("test/main.css", getClass());
-		this.transformer.resolveUrlPath(resourcePath, this.request, mainCss, this.transformerChain);
 	}
 
 	@Test
-	public void rewriteRelativePathUpperLevel() throws Exception {
-		this.request.setRequestURI("/servlet/context/resources/images/image.png");
-		this.request.setMethod("GET");
-		this.request.setServletPath("/servlet");
-		this.request.setContextPath("/context");
-		this.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, "/resources/images/image.png");
 
 		Resource imagePng = new ClassPathResource("test/images/image.png", getClass());
 		String actual = this.transformer.resolveUrlPath("../bar.css", this.request, imagePng, this.transformerChain);
 		assertEquals("../bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
</code_before><code_after>@@ -17,7 +17,7 @@
 
 import static org.junit.Assert.assertEquals;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -48,93 +48,61 @@ public class ResourceTransformerSupportTests {
 
 	@Before
 	public void setUp() {
+		VersionResourceResolver resolver = new VersionResourceResolver();
+		resolver.setStrategyMap(Collections.singletonMap("/**", new ContentVersionStrategy()));
+		List&lt;ResourceResolver&gt; resolvers = Arrays.asList(resolver, new PathResourceResolver());
 		this.transformerChain = new DefaultResourceTransformerChain(new DefaultResourceResolverChain(resolvers), null);
 
+		this.transformer = new TestResourceTransformerSupport();
+		this.transformer.setResourceUrlProvider(createResourceUrlProvider(resolvers));
+
+		this.request = new MockHttpServletRequest("GET", "");
+	}
 
+	protected ResourceUrlProvider createResourceUrlProvider(List&lt;ResourceResolver&gt; resolvers) {
 		ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();
+		handler.setLocations(Arrays.asList(new ClassPathResource("test/", getClass())));
 		handler.setResourceResolvers(resolvers);
 		ResourceUrlProvider urlProvider = new ResourceUrlProvider();
 		urlProvider.setHandlerMap(Collections.singletonMap("/resources/**", handler));
+		return urlProvider;
 	}
 
 
 	@Test
+	public void resolveUrlPath() throws Exception {
+		this.request.setRequestURI("/context/servlet/resources/main.css");
 		this.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, "/resources/main.css");
 
+		String resourcePath = "/context/servlet/resources/bar.css";
+		Resource css = new ClassPathResource("test/main.css", getClass());
+		String actual = this.transformer.resolveUrlPath(resourcePath, this.request, css, this.transformerChain);
+		assertEquals("/context/servlet/resources/bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
 	}
 
 	@Test
+	public void resolveUrlPathWithoutHandlerMappingAttribute() throws Exception {
+		this.request.setRequestURI("/context/servlet/resources/main.css");
 		this.request.setContextPath("/context");
 		this.request.setServletPath("/servlet");
 
+		String resourcePath = "/context/servlet/resources/bar.css";
+		Resource css = new ClassPathResource("test/main.css", getClass());
+		String actual = this.transformer.resolveUrlPath(resourcePath, this.request, css, this.transformerChain);
+		assertEquals("/context/servlet/resources/bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
 	}
 
 	@Test
+	public void resolveUrlPathWithRelativePath() throws Exception {
+		this.request.setRequestURI("/context/servlet/resources/main.css");
+		Resource css = new ClassPathResource("test/main.css", getClass());
+		String actual = this.transformer.resolveUrlPath("bar.css", this.request, css, this.transformerChain);
+		assertEquals("bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
+	}
 
+	@Test
+	public void resolveUrlPathWithRelativePathInParentDirectory() throws Exception {
+		this.request.setRequestURI("/context/servlet/resources/images/image.png");
 		Resource imagePng = new ClassPathResource("test/images/image.png", getClass());
 		String actual = this.transformer.resolveUrlPath("../bar.css", this.request, imagePng, this.transformerChain);
 		assertEquals("../bar-11e16cf79faee7ac698c805cf28248d2.css", actual);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>427047</refactoring_id><commit_sha>12513e9898d99324e45c0a96b0e58df1ece47c7f</commit_sha><commit_link>https://github.com/google/exoplayer/commit/12513e9898d99324e45c0a96b0e58df1ece47c7f</commit_link><file_path>library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java</file_path><description>Rename Variable schemeDatas : List&lt;SchemeData&gt; to matchingSchemeDatas : List&lt;SchemeData&gt; in method private getSchemeData(drmInitData DrmInitData, uuid UUID) : SchemeData from class com.google.android.exoplayer2.drm.DefaultDrmSessionManager</description><code_before>@@ -349,15 +349,14 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
       // If there is no scheme information, assume patternless AES-CTR.
       return true;
     } else if (C.CENC_TYPE_cbc1.equals(schemeType) || C.CENC_TYPE_cbcs.equals(schemeType)
-            || C.CENC_TYPE_cens.equals(schemeType)) {
       // AES-CBC and pattern encryption are supported on API 24 onwards.
       return Util.SDK_INT &gt;= 24;
     }
     // Unknown schemes, assume one of them is supported.
     return true;
   }
 
-
   @Override
   public DrmSession&lt;T&gt; acquireSession(Looper playbackLooper, DrmInitData drmInitData) {
     Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
@@ -462,34 +461,35 @@ public void onProvisionError(Exception error) {
    * @return The extracted {@link SchemeData}, or null if no suitable data is present.
    */
   private static SchemeData getSchemeData(DrmInitData drmInitData, UUID uuid) {
-    List&lt;SchemeData&gt; schemeDatas = new ArrayList&lt;&gt;();
-    // Look for matching PSSH boxes, or the common box in the case of ClearKey
-    for (int i = 0; i &lt; drmInitData.schemeDataCount; ++i) {
       SchemeData schemeData = drmInitData.get(i);
       if (schemeData.matches(uuid)
-              || (C.CLEARKEY_UUID.equals(uuid) &amp;&amp; schemeData.matches(C.COMMON_PSSH_UUID))) {
-        schemeDatas.add(schemeData);
       }
     }
 
-    if (schemeDatas.isEmpty()) {
       return null;
     }
 
-    // For Widevine, we prefer v1 init data on M and higher, v0 for lower
     if (C.WIDEVINE_UUID.equals(uuid)) {
-      for (SchemeData schemeData : schemeDatas ) {
-        int version = PsshAtomUtil.parseVersion(schemeData.data);
         if (Util.SDK_INT &lt; 23 &amp;&amp; version == 0) {
-          return schemeData;
         } else if (Util.SDK_INT &gt;= 23 &amp;&amp; version == 1) {
-          return schemeData;
         }
       }
     }
 
-    // If we don't have any special handling for this system, we take the first scheme data found
-    return schemeDatas.get(0);
   }
 
   private static byte[] getSchemeInitData(SchemeData data, UUID uuid) {
</code_before><code_after>@@ -349,15 +349,14 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
       // If there is no scheme information, assume patternless AES-CTR.
       return true;
     } else if (C.CENC_TYPE_cbc1.equals(schemeType) || C.CENC_TYPE_cbcs.equals(schemeType)
+        || C.CENC_TYPE_cens.equals(schemeType)) {
       // AES-CBC and pattern encryption are supported on API 24 onwards.
       return Util.SDK_INT &gt;= 24;
     }
     // Unknown schemes, assume one of them is supported.
     return true;
   }
 
   @Override
   public DrmSession&lt;T&gt; acquireSession(Looper playbackLooper, DrmInitData drmInitData) {
     Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
@@ -462,34 +461,35 @@ public void onProvisionError(Exception error) {
    * @return The extracted {@link SchemeData}, or null if no suitable data is present.
    */
   private static SchemeData getSchemeData(DrmInitData drmInitData, UUID uuid) {
+    // Look for matching scheme data (matching the Common PSSH box for ClearKey).
+    List&lt;SchemeData&gt; matchingSchemeDatas = new ArrayList&lt;&gt;(drmInitData.schemeDataCount);
+    for (int i = 0; i &lt; drmInitData.schemeDataCount; i++) {
       SchemeData schemeData = drmInitData.get(i);
       if (schemeData.matches(uuid)
+          || (C.CLEARKEY_UUID.equals(uuid) &amp;&amp; schemeData.matches(C.COMMON_PSSH_UUID))) {
+        matchingSchemeDatas.add(schemeData);
       }
     }
 
+    if (matchingSchemeDatas.isEmpty()) {
       return null;
     }
 
+    // For Widevine PSSH boxes, prefer V1 boxes from API 23 and V0 before.
     if (C.WIDEVINE_UUID.equals(uuid)) {
+      for (int i = 0; i &lt; matchingSchemeDatas.size(); i++) {
+        SchemeData matchingSchemeData = matchingSchemeDatas.get(i);
+        int version = PsshAtomUtil.parseVersion(matchingSchemeData.data);
         if (Util.SDK_INT &lt; 23 &amp;&amp; version == 0) {
+          return matchingSchemeData;
         } else if (Util.SDK_INT &gt;= 23 &amp;&amp; version == 1) {
+          return matchingSchemeData;
         }
       }
     }
 
+    // If we don't have any special handling, prefer the first matching scheme data.
+    return matchingSchemeDatas.get(0);
   }
 
   private static byte[] getSchemeInitData(SchemeData data, UUID uuid) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>417476</refactoring_id><commit_sha>3cbbedda7f3acd729d4e769adea3142da4e865b7</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/3cbbedda7f3acd729d4e769adea3142da4e865b7</commit_link><file_path>src/edu/stanford/nlp/dcoref/Rules.java</file_path><description>Rename Variable mSpeakerID : int to speakerMentionId : int in method public getSpeakerClusterId(document Document, speakerString String) : int from class edu.stanford.nlp.dcoref.Rules</description><code_before>@@ -583,13 +583,11 @@ public static boolean entityPersonDisagree(Document document, Mention m, Mention
       int mUtter = m.headWord.get(CoreAnnotations.UtteranceAnnotation.class);
       if (document.speakers.containsKey(mUtter - 1)) {
         String previousSpeaker = document.speakers.get(mUtter - 1);
-        int previousSpeakerID;
-        try {
-          previousSpeakerID = Integer.parseInt(previousSpeaker);
-        } catch (Exception e) {
           return true;
         }
-        if (ant.corefClusterID != document.allPredictedMentions.get(previousSpeakerID).corefClusterID &amp;&amp; ant.person != Person.I) {
           return true;
         }
       } else {
@@ -599,13 +597,11 @@ public static boolean entityPersonDisagree(Document document, Mention m, Mention
       int aUtter = ant.headWord.get(CoreAnnotations.UtteranceAnnotation.class);
       if (document.speakers.containsKey(aUtter - 1)) {
         String previousSpeaker = document.speakers.get(aUtter - 1);
-        int previousSpeakerID;
-        try {
-          previousSpeakerID = Integer.parseInt(previousSpeaker);
-        } catch (Exception e) {
           return true;
         }
-        if (m.corefClusterID != document.allPredictedMentions.get(previousSpeakerID).corefClusterID &amp;&amp; m.person != Person.I) {
           return true;
         }
       } else {
@@ -625,21 +621,40 @@ public static boolean entitySameSpeaker(Document document, Mention m, Mention an
       return false;
     }
 
-    int mSpeakerID;
-    int antSpeakerID;
-    if (NumberMatchingRegex.isDecimalInteger(mSpeakerStr) &amp;&amp; NumberMatchingRegex.isDecimalInteger(antSpeakerStr)) {
       try {
-        mSpeakerID = Integer.parseInt(mSpeakerStr);
-        antSpeakerID = Integer.parseInt(ant.headWord.get(CoreAnnotations.SpeakerAnnotation.class));
       } catch (Exception e) {
-        return (m.headWord.get(CoreAnnotations.SpeakerAnnotation.class).equals(ant.headWord.get(CoreAnnotations.SpeakerAnnotation.class)));
       }
-    } else {
-      return (m.headWord.get(CoreAnnotations.SpeakerAnnotation.class).equals(ant.headWord.get(CoreAnnotations.SpeakerAnnotation.class)));
     }
-    int mSpeakerClusterID = document.allPredictedMentions.get(mSpeakerID).corefClusterID;
-    int antSpeakerClusterID = document.allPredictedMentions.get(antSpeakerID).corefClusterID;
-    return (mSpeakerClusterID == antSpeakerClusterID);
   }
 
   public static boolean entitySubjectObject(Mention m1, Mention m2) {
</code_before><code_after>@@ -583,13 +583,11 @@ public static boolean entityPersonDisagree(Document document, Mention m, Mention
       int mUtter = m.headWord.get(CoreAnnotations.UtteranceAnnotation.class);
       if (document.speakers.containsKey(mUtter - 1)) {
         String previousSpeaker = document.speakers.get(mUtter - 1);
+        int previousSpeakerCorefClusterID = getSpeakerClusterId(document, previousSpeaker);
+        if (previousSpeakerCorefClusterID &lt; 0) {
           return true;
         }
+        if (ant.corefClusterID != previousSpeakerCorefClusterID &amp;&amp; ant.person != Person.I) {
           return true;
         }
       } else {
@@ -599,13 +597,11 @@ public static boolean entityPersonDisagree(Document document, Mention m, Mention
       int aUtter = ant.headWord.get(CoreAnnotations.UtteranceAnnotation.class);
       if (document.speakers.containsKey(aUtter - 1)) {
         String previousSpeaker = document.speakers.get(aUtter - 1);
+        int previousSpeakerCorefClusterID = getSpeakerClusterId(document, previousSpeaker);
+        if (previousSpeakerCorefClusterID &lt; 0) {
           return true;
         }
+        if (m.corefClusterID != previousSpeakerCorefClusterID &amp;&amp; m.person != Person.I) {
           return true;
         }
       } else {
@@ -625,21 +621,40 @@ public static boolean entitySameSpeaker(Document document, Mention m, Mention an
       return false;
     }
 
+    // Speakers are the same if the speaker strings are the same (most common case?)
+    if (mSpeakerStr.equals(antSpeakerStr)) {
+      return true;
+    } else {
+      // Speakers are also the same if they map to the same cluster id...
+      int mSpeakerClusterID = getSpeakerClusterId(document, mSpeakerStr);
+      int antSpeakerClusterID = getSpeakerClusterId(document, antSpeakerStr);
+      if (mSpeakerClusterID &gt;= 0 &amp;&amp; antSpeakerClusterID &gt;= 0) {
+        return (mSpeakerClusterID == antSpeakerClusterID);
+      } else {
+        return false;
+      }
+    }
+  }
+
+  /**
+   * Given the name of a speaker, returns the coref cluster id it belows to (-1 if no cluster)
+   * @param document
+   * @param speakerString
+   * @return
+   */
+  public static int getSpeakerClusterId(Document document, String speakerString) {
+    int speakerClusterId = -1;
+    if (speakerString != null &amp;&amp; NumberMatchingRegex.isDecimalInteger(speakerString)) {
       try {
+        int speakerMentionId = Integer.parseInt(speakerString);
+        Mention mention = document.allPredictedMentions.get(speakerMentionId);
+        if (mention != null) {
+          speakerClusterId = mention.corefClusterID;
+        }
       } catch (Exception e) {
       }
     }
+    return speakerClusterId;
   }
 
   public static boolean entitySubjectObject(Mention m1, Mention m2) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>441964</refactoring_id><commit_sha>78ba492e3e70fd9db61bc82469371d04a8d6b762</commit_sha><commit_link>https://github.com/AutoMQ/automq/commit/78ba492e3e70fd9db61bc82469371d04a8d6b762</commit_link><file_path>clients/src/main/java/org/apache/kafka/common/network/NetworkReceive.java</file_path><description>Rename Variable requestSize : int to receiveSize : int in method public readFromReadableChannel(channel ReadableByteChannel) : long from class org.apache.kafka.common.network.NetworkReceive</description><code_before>@@ -15,31 +15,50 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.ScatteringByteChannel;
 
 /**
  * A size delimited Receive that consists of a 4 byte network-ordered size N followed by N bytes of content
  */
 public class NetworkReceive implements Receive {
 
-    private final int source;
     private final ByteBuffer size;
     private ByteBuffer buffer;
 
-    public NetworkReceive(int source, ByteBuffer buffer) {
         this.source = source;
         this.buffer = buffer;
         this.size = null;
     }
 
-    public NetworkReceive(int source) {
         this.source = source;
         this.size = ByteBuffer.allocate(4);
         this.buffer = null;
     }
 
     @Override
-    public int source() {
         return source;
     }
 
@@ -48,13 +67,15 @@ public boolean complete() {
         return !size.hasRemaining() &amp;&amp; !buffer.hasRemaining();
     }
 
-    @Override
-    public ByteBuffer[] reify() {
-        return new ByteBuffer[] {this.buffer};
     }
 
-    @Override
-    public long readFrom(ScatteringByteChannel channel) throws IOException {
         int read = 0;
         if (size.hasRemaining()) {
             int bytesRead = channel.read(size);
@@ -63,10 +84,12 @@ public long readFrom(ScatteringByteChannel channel) throws IOException {
             read += bytesRead;
             if (!size.hasRemaining()) {
                 size.rewind();
-                int requestSize = size.getInt();
-                if (requestSize &lt; 0)
-                    throw new IllegalStateException("Invalid request (size = " + requestSize + ")");
-                this.buffer = ByteBuffer.allocate(requestSize);
             }
         }
         if (buffer != null) {
@@ -83,4 +106,14 @@ public ByteBuffer payload() {
         return this.buffer;
     }
 
 }
</code_before><code_after>@@ -15,31 +15,50 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 
 /**
  * A size delimited Receive that consists of a 4 byte network-ordered size N followed by N bytes of content
  */
 public class NetworkReceive implements Receive {
 
+    public final static String UNKNOWN_SOURCE = "";
+    public final static int UNLIMITED = -1;
+
+    private final String source;
     private final ByteBuffer size;
+    private final int maxSize;
     private ByteBuffer buffer;
 
+
+    public NetworkReceive(String source, ByteBuffer buffer) {
         this.source = source;
         this.buffer = buffer;
         this.size = null;
+        this.maxSize = UNLIMITED;
+    }
+
+    public NetworkReceive(String source) {
+        this.source = source;
+        this.size = ByteBuffer.allocate(4);
+        this.buffer = null;
+        this.maxSize = UNLIMITED;
     }
 
+    public NetworkReceive(int maxSize, String source) {
         this.source = source;
         this.size = ByteBuffer.allocate(4);
         this.buffer = null;
+        this.maxSize = maxSize;
+    }
+
+    public NetworkReceive() {
+        this(UNKNOWN_SOURCE);
     }
 
     @Override
+    public String source() {
         return source;
     }
 
@@ -48,13 +67,15 @@ public boolean complete() {
         return !size.hasRemaining() &amp;&amp; !buffer.hasRemaining();
     }
 
+    public long readFrom(ScatteringByteChannel channel) throws IOException {
+        return readFromReadableChannel(channel);
     }
 
+    // Need a method to read from ReadableByteChannel because BlockingChannel requires read with timeout
+    // See: http://stackoverflow.com/questions/2866557/timeout-for-socketchannel-doesnt-work
+    // This can go away after we get rid of BlockingChannel
+    @Deprecated
+    public long readFromReadableChannel(ReadableByteChannel channel) throws IOException {
         int read = 0;
         if (size.hasRemaining()) {
             int bytesRead = channel.read(size);
@@ -63,10 +84,12 @@ public long readFrom(ScatteringByteChannel channel) throws IOException {
             read += bytesRead;
             if (!size.hasRemaining()) {
                 size.rewind();
+                int receiveSize = size.getInt();
+                if (receiveSize &lt; 0)
+                    throw new InvalidReceiveException("Invalid receive (size = " + receiveSize + ")");
+                if (maxSize != UNLIMITED &amp;&amp; receiveSize &gt; maxSize)
+                    throw new InvalidReceiveException("Invalid receive (size = " + receiveSize + " larger than " + maxSize + ")");
+                this.buffer = ByteBuffer.allocate(receiveSize);
             }
         }
         if (buffer != null) {
@@ -83,4 +106,14 @@ public ByteBuffer payload() {
         return this.buffer;
     }
 
+    // Used only by BlockingChannel, so we may be able to get rid of this when/if we get rid of BlockingChannel
+    @Deprecated
+    public long readCompletely(ReadableByteChannel channel) throws IOException {
+        int totalRead = 0;
+        while (!complete()) {
+            totalRead += readFromReadableChannel(channel);
+        }
+        return totalRead;
+    }
+
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>398835</refactoring_id><commit_sha>c667f5f115a68dffd4d42e258ad5f5940835a70f</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/c667f5f115a68dffd4d42e258ad5f5940835a70f</commit_link><file_path>flex/tools/flex-ui-designer/idea-plugin/src/com/intellij/flex/uiDesigner/libraries/FlexDefinitionProcessor.java</file_path><description>Rename Variable mname : String to mName : String in method public methodTraitName(name int, traitKind int, in DataBuffer, encoder Encoder) : boolean from class com.intellij.flex.uiDesigner.libraries.FlexDefinitionProcessor.MethodAccessModifier</description><code_before>@@ -151,14 +151,14 @@ private static boolean equals(CharSequence s1, int s1Offset, CharSequence s2) {
   }
 
   private static void flipDefinition(Definition definition, Map&lt;CharSequence, Definition&gt; definitionMap, String name) {
-    // don't remove old entry from map, it may be requred before we inject
     int i = name.indexOf(':');
     String newName = name.substring(0, i + 1) + OVERLOADED_AND_BACKED_CLASS_MARK + name.substring(i + 2);
     definitionMap.put(newName, definition);
     //definition.name = newName;
   }
 
-  private static void changeAbcName(final String name, ByteBuffer buffer) throws IOException {
     final int oldPosition = buffer.position();
     buffer.position(buffer.position() + 4 + name.length() + 1 /* null-terminated string */);
     parseCPoolAndRename(name.substring(name.indexOf(':') + 1), buffer);
@@ -169,7 +169,7 @@ private static void changeAbcName(final String name, ByteBuffer buffer) throws I
     buffer.position(oldPosition);
   }
 
-  private static void parseCPoolAndRename(String from, ByteBuffer buffer) throws IOException {
     buffer.position(buffer.position() + 4);
 
     int n = AbcUtil.readU32(buffer);
@@ -292,8 +292,8 @@ public boolean slotTraitName(int name, int traitKind, DataBuffer in, Encoder enc
     public boolean methodTraitName(int name, int traitKind, DataBuffer in, Encoder encoder) {
       if (changeAccessModifier != null &amp;&amp; !changeAccessModifier.isEmpty() &amp;&amp; isNotOverridenMethod(traitKind)) {
         for (int i = 0, size = changeAccessModifier.size(); i &lt; size; i++) {
-          String mname = changeAccessModifier.get(i);
-          if (encoder.changeAccessModifier(mname, name, in)) {
             if (changeAccessModifier.size() == 1) {
               changeAccessModifier = null;
             }
@@ -349,7 +349,7 @@ public void assertOnInstanceEnd() {
   }
 
   private static class VarAccessModifier extends AbcModifierBase {
-    private String[] fieldNames;
 
     private VarAccessModifier(String ...fieldNames) {
       this.fieldNames = fieldNames;
</code_before><code_after>@@ -151,14 +151,14 @@ private static boolean equals(CharSequence s1, int s1Offset, CharSequence s2) {
   }
 
   private static void flipDefinition(Definition definition, Map&lt;CharSequence, Definition&gt; definitionMap, String name) {
+    // don't remove old entry from map, it may be required before we inject
     int i = name.indexOf(':');
     String newName = name.substring(0, i + 1) + OVERLOADED_AND_BACKED_CLASS_MARK + name.substring(i + 2);
     definitionMap.put(newName, definition);
     //definition.name = newName;
   }
 
+  private static void changeAbcName(final String name, ByteBuffer buffer) {
     final int oldPosition = buffer.position();
     buffer.position(buffer.position() + 4 + name.length() + 1 /* null-terminated string */);
     parseCPoolAndRename(name.substring(name.indexOf(':') + 1), buffer);
@@ -169,7 +169,7 @@ private static void changeAbcName(final String name, ByteBuffer buffer) throws I
     buffer.position(oldPosition);
   }
 
+  private static void parseCPoolAndRename(String from, ByteBuffer buffer) {
     buffer.position(buffer.position() + 4);
 
     int n = AbcUtil.readU32(buffer);
@@ -292,8 +292,8 @@ public boolean slotTraitName(int name, int traitKind, DataBuffer in, Encoder enc
     public boolean methodTraitName(int name, int traitKind, DataBuffer in, Encoder encoder) {
       if (changeAccessModifier != null &amp;&amp; !changeAccessModifier.isEmpty() &amp;&amp; isNotOverridenMethod(traitKind)) {
         for (int i = 0, size = changeAccessModifier.size(); i &lt; size; i++) {
+          String mName = changeAccessModifier.get(i);
+          if (encoder.changeAccessModifier(mName, name, in)) {
             if (changeAccessModifier.size() == 1) {
               changeAccessModifier = null;
             }
@@ -349,7 +349,7 @@ public void assertOnInstanceEnd() {
   }
 
   private static class VarAccessModifier extends AbcModifierBase {
+    private final String[] fieldNames;
 
     private VarAccessModifier(String ...fieldNames) {
       this.fieldNames = fieldNames;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>351429</refactoring_id><commit_sha>378a1292e73ed05b96e4a1cd9fd21f0a44793022</commit_sha><commit_link>https://github.com/apache/pinot/commit/378a1292e73ed05b96e4a1cd9fd21f0a44793022</commit_link><file_path>pinot-core/src/main/java/com/linkedin/pinot/core/query/aggregation/function/MinAggregationFunction.java</file_path><description>Rename Variable tmp : double to value : double in method public aggregate(mergedResult Double, docId int, block Block[]) : Double from class com.linkedin.pinot.core.query.aggregation.function.MinAggregationFunction</description><code_before>@@ -26,12 +26,10 @@
 import com.linkedin.pinot.core.common.Block;
 import com.linkedin.pinot.core.common.BlockDocIdIterator;
 import com.linkedin.pinot.core.common.BlockSingleValIterator;
-import com.linkedin.pinot.core.common.BlockValIterator;
 import com.linkedin.pinot.core.common.Constants;
 import com.linkedin.pinot.core.query.aggregation.AggregationFunction;
 import com.linkedin.pinot.core.query.aggregation.CombineLevel;
 import com.linkedin.pinot.core.segment.index.readers.Dictionary;
-import com.linkedin.pinot.core.segment.index.readers.ImmutableDictionaryReader;
 
 
 public class MinAggregationFunction implements AggregationFunction&lt;Double, Double&gt; {
@@ -69,14 +67,18 @@ public Double aggregate(Block docIdSetBlock, Block[] block) {
   public Double aggregate(Double mergedResult, int docId, Block[] block) {
     BlockSingleValIterator blockValIterator = (BlockSingleValIterator) block[0].getBlockValueSet().iterator();
     blockValIterator.skipTo(docId);
-    if (mergedResult == null) {
-      return block[0].getMetadata().getDictionary().getDoubleValue(blockValIterator.nextIntVal());
-    }
-    double tmp = block[0].getMetadata().getDictionary().getDoubleValue(blockValIterator.nextIntVal());
-    if (tmp &lt; mergedResult) {
-      return tmp;
     }
-    return mergedResult;
   }
 
   @Override
</code_before><code_after>@@ -26,12 +26,10 @@
 import com.linkedin.pinot.core.common.Block;
 import com.linkedin.pinot.core.common.BlockDocIdIterator;
 import com.linkedin.pinot.core.common.BlockSingleValIterator;
 import com.linkedin.pinot.core.common.Constants;
 import com.linkedin.pinot.core.query.aggregation.AggregationFunction;
 import com.linkedin.pinot.core.query.aggregation.CombineLevel;
 import com.linkedin.pinot.core.segment.index.readers.Dictionary;
 
 
 public class MinAggregationFunction implements AggregationFunction&lt;Double, Double&gt; {
@@ -69,14 +67,18 @@ public Double aggregate(Block docIdSetBlock, Block[] block) {
   public Double aggregate(Double mergedResult, int docId, Block[] block) {
     BlockSingleValIterator blockValIterator = (BlockSingleValIterator) block[0].getBlockValueSet().iterator();
     blockValIterator.skipTo(docId);
+    int dictionaryIndex = blockValIterator.nextIntVal();
+
+    if (dictionaryIndex != Dictionary.NULL_VALUE_INDEX) {
+      double value = block[0].getMetadata().getDictionary().getDoubleValue(dictionaryIndex);
+      if(mergedResult != null) {
+        return Math.min(value, mergedResult);
+      } else {
+        return value;
+      }
+    } else {
+      return mergedResult;
     }
   }
 
   @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>378875</refactoring_id><commit_sha>5695c68d7b9ff18246d0964dbaf8c8aa717e53bf</commit_sha><commit_link>https://github.com/camunda/camunda/commit/5695c68d7b9ff18246d0964dbaf8c8aa717e53bf</commit_link><file_path>broker-core/src/test/java/io/zeebe/broker/event/TopicSubscriptionThrottlingTest.java</file_path><description>Rename Variable nrOfTasks : int to nrOfJobs : int in method public shouldPushMoreAfterAck() : void from class io.zeebe.broker.event.TopicSubscriptionThrottlingTest</description><code_before>@@ -30,7 +30,7 @@
 import io.zeebe.protocol.clientapi.ValueType;
 import io.zeebe.protocol.intent.SubscriberIntent;
 import io.zeebe.protocol.intent.SubscriptionIntent;
-import io.zeebe.protocol.intent.TaskIntent;
 import io.zeebe.test.broker.protocol.clientapi.ClientApiRule;
 import io.zeebe.test.util.TestUtil;
 
@@ -60,10 +60,10 @@ public void openSubscription(int prefetchCapacity)
     public void shouldNotPushMoreThanPrefetchCapacity() throws InterruptedException
     {
         // given
-        final int nrOfTasks = 5;
         final int prefetchCapacity = 3;
 
-        createTasks(nrOfTasks);
 
         // when
         openSubscription(prefetchCapacity);
@@ -79,10 +79,10 @@ public void shouldNotPushMoreThanPrefetchCapacity() throws InterruptedException
     public void shouldPushMoreAfterAck() throws InterruptedException
     {
         // given
-        final int nrOfTasks = 5;
         final int prefetchCapacity = 3;
 
-        createTasks(nrOfTasks);
         openSubscription(prefetchCapacity);
         TestUtil.waitUntil(() -&gt; apiRule.numSubscribedEventsAvailable() == 3);
 
@@ -119,28 +119,28 @@ public void shouldPushMoreAfterAck() throws InterruptedException
     public void shouldPushAllEventsWithoutPrefetchCapacity() throws InterruptedException
     {
         // given
-        final int nrOfTasks = 5;
         final int prefetchCapacity = -1;
 
-        createTasks(nrOfTasks);
 
         // when
         openSubscription(prefetchCapacity);
 
         // then
-        final int expectedNumberOfEvents = nrOfTasks * 2; // CREATE and CREATED
 
         TestUtil.waitUntil(() -&gt; apiRule.numSubscribedEventsAvailable() == expectedNumberOfEvents);
     }
 
-    protected void createTasks(int nrOfTasks)
     {
-        for (int i = 0; i &lt; nrOfTasks; i++)
         {
             apiRule.createCmdRequest()
-                .type(ValueType.TASK, TaskIntent.CREATE)
                 .command()
-                    .put("type", "theTaskType")
                     .done()
                 .sendAndAwait();
         }
</code_before><code_after>@@ -30,7 +30,7 @@
 import io.zeebe.protocol.clientapi.ValueType;
 import io.zeebe.protocol.intent.SubscriberIntent;
 import io.zeebe.protocol.intent.SubscriptionIntent;
+import io.zeebe.protocol.intent.JobIntent;
 import io.zeebe.test.broker.protocol.clientapi.ClientApiRule;
 import io.zeebe.test.util.TestUtil;
 
@@ -60,10 +60,10 @@ public void openSubscription(int prefetchCapacity)
     public void shouldNotPushMoreThanPrefetchCapacity() throws InterruptedException
     {
         // given
+        final int nrOfJobs = 5;
         final int prefetchCapacity = 3;
 
+        createJobs(nrOfJobs);
 
         // when
         openSubscription(prefetchCapacity);
@@ -79,10 +79,10 @@ public void shouldNotPushMoreThanPrefetchCapacity() throws InterruptedException
     public void shouldPushMoreAfterAck() throws InterruptedException
     {
         // given
+        final int nrOfJobs = 5;
         final int prefetchCapacity = 3;
 
+        createJobs(nrOfJobs);
         openSubscription(prefetchCapacity);
         TestUtil.waitUntil(() -&gt; apiRule.numSubscribedEventsAvailable() == 3);
 
@@ -119,28 +119,28 @@ public void shouldPushMoreAfterAck() throws InterruptedException
     public void shouldPushAllEventsWithoutPrefetchCapacity() throws InterruptedException
     {
         // given
+        final int nrOfJobs = 5;
         final int prefetchCapacity = -1;
 
+        createJobs(nrOfJobs);
 
         // when
         openSubscription(prefetchCapacity);
 
         // then
+        final int expectedNumberOfEvents = nrOfJobs * 2; // CREATE and CREATED
 
         TestUtil.waitUntil(() -&gt; apiRule.numSubscribedEventsAvailable() == expectedNumberOfEvents);
     }
 
+    protected void createJobs(int nrOfJobs)
     {
+        for (int i = 0; i &lt; nrOfJobs; i++)
         {
             apiRule.createCmdRequest()
+                .type(ValueType.JOB, JobIntent.CREATE)
                 .command()
+                    .put("type", "theJobType")
                     .done()
                 .sendAndAwait();
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>400169</refactoring_id><commit_sha>6c7443c93abb66386a508a6e6e3ddae8bd742e02</commit_sha><commit_link>https://github.com/apache/druid/commit/6c7443c93abb66386a508a6e6e3ddae8bd742e02</commit_link><file_path>extensions-core/azure-extensions/src/test/java/org/apache/druid/storage/azure/output/AzureOutputConfigTest.java</file_path><description>Rename Variable tempDir : File to temporaryFolder : File in method public testTempDirectoryNotPresentButWritable(tempDir File) : void from class org.apache.druid.storage.azure.output.AzureOutputConfigTest</description><code_before>@@ -24,62 +24,60 @@
 import org.apache.druid.java.util.common.FileUtils;
 import org.apache.druid.java.util.common.HumanReadableBytes;
 import org.apache.druid.java.util.common.ISE;
-import org.junit.Assert;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
 
 import java.io.File;
 import java.io.IOException;
 
 public class AzureOutputConfigTest
 {
-
-  @Rule
-  public final TemporaryFolder temporaryFolder = new TemporaryFolder();
-
   private static final String CONTAINER = "container";
   private static final String PREFIX = "prefix";
   private static final int MAX_RETRY_COUNT = 0;
 
   @Test
-  public void testTooLargeChunkSize()
   {
     HumanReadableBytes chunkSize = new HumanReadableBytes("4001MiB");
-    Assert.assertThrows(
         DruidException.class,
-        () -&gt; new AzureOutputConfig(CONTAINER, PREFIX, temporaryFolder.newFolder(), chunkSize, MAX_RETRY_COUNT)
     );
   }
 
   @Test
-  public void testTempDirectoryNotWritable() throws IOException
   {
-    File tempDir = temporaryFolder.newFolder();
     if (!tempDir.setWritable(false)) {
       throw new ISE("Unable to change the permission of temp folder for %s", this.getClass().getName());
     }
     //noinspection ResultOfObjectAllocationIgnored
-    Assert.assertThrows(
         DruidException.class,
         () -&gt; new AzureOutputConfig(CONTAINER, PREFIX, tempDir, null, MAX_RETRY_COUNT)
     );
   }
 
   @Test
-  public void testTempDirectoryNotPresentButWritable() throws IOException
   {
-    File tempDir = new File(temporaryFolder.newFolder() + "/notPresent1/notPresent2/notPresent3");
     //noinspection ResultOfObjectAllocationIgnored
-    new AzureOutputConfig(CONTAINER, PREFIX, tempDir, null, MAX_RETRY_COUNT);
   }
 
   @Test
-  public void testTempDirectoryPresent() throws IOException
   {
-    File tempDir = new File(temporaryFolder.newFolder() + "/notPresent1/notPresent2/notPresent3");
-    FileUtils.mkdirp(tempDir);
     //noinspection ResultOfObjectAllocationIgnored
-    new AzureOutputConfig(CONTAINER, PREFIX, tempDir, null, MAX_RETRY_COUNT);
   }
 }
</code_before><code_after>@@ -24,62 +24,60 @@
 import org.apache.druid.java.util.common.FileUtils;
 import org.apache.druid.java.util.common.HumanReadableBytes;
 import org.apache.druid.java.util.common.ISE;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
 
 import java.io.File;
 import java.io.IOException;
 
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
 public class AzureOutputConfigTest
 {
   private static final String CONTAINER = "container";
   private static final String PREFIX = "prefix";
   private static final int MAX_RETRY_COUNT = 0;
 
   @Test
+  public void testTooLargeChunkSize(@TempDir File tempDir)
   {
     HumanReadableBytes chunkSize = new HumanReadableBytes("4001MiB");
+
+    //noinspection ResultOfObjectAllocationIgnored
+    assertThrows(
         DruidException.class,
+        () -&gt; new AzureOutputConfig(CONTAINER, PREFIX, tempDir, chunkSize, MAX_RETRY_COUNT)
     );
   }
 
   @Test
+  public void testTempDirectoryNotWritable(@TempDir File tempDir)
   {
     if (!tempDir.setWritable(false)) {
       throw new ISE("Unable to change the permission of temp folder for %s", this.getClass().getName());
     }
+
     //noinspection ResultOfObjectAllocationIgnored
+    assertThrows(
         DruidException.class,
         () -&gt; new AzureOutputConfig(CONTAINER, PREFIX, tempDir, null, MAX_RETRY_COUNT)
     );
   }
 
   @Test
+  public void testTempDirectoryNotPresentButWritable(@TempDir File tempDir)
   {
+    File temporaryFolder = new File(tempDir + "/notPresent1/notPresent2/notPresent3");
     //noinspection ResultOfObjectAllocationIgnored
+    new AzureOutputConfig(CONTAINER, PREFIX, temporaryFolder, null, MAX_RETRY_COUNT);
   }
 
   @Test
+  public void testTempDirectoryPresent(@TempDir File tempDir) throws IOException
   {
+    File temporaryFolder = new File(tempDir + "/notPresent1/notPresent2/notPresent3");
+    FileUtils.mkdirp(temporaryFolder);
     //noinspection ResultOfObjectAllocationIgnored
+    new AzureOutputConfig(CONTAINER, PREFIX, temporaryFolder, null, MAX_RETRY_COUNT);
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>371647</refactoring_id><commit_sha>ef60c61f4e72aa246665a6ed34365fd4b60250dd</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/ef60c61f4e72aa246665a6ed34365fd4b60250dd</commit_link><file_path>query/src/test/java/org/infinispan/query/test/CustomKey.java</file_path><description>Rename Variable customKey : CustomKey to other : CustomKey in method public equals(o Object) : boolean from class org.infinispan.query.test.CustomKey</description><code_before>@@ -44,21 +44,12 @@ public void setK(int k) {
    public boolean equals(Object o) {
       if (this == o) return true;
       if (o == null || getClass() != o.getClass()) return false;
-
-      CustomKey customKey = (CustomKey) o;
-
-      if (i != customKey.i) return false;
-      if (j != customKey.j) return false;
-      if (k != customKey.k) return false;
-
-      return true;
    }
 
    @Override
    public int hashCode() {
-      int result = i;
-      result = 31 * result + j;
-      result = 31 * result + k;
-      return result;
    }
 }
</code_before><code_after>@@ -44,21 +44,12 @@ public void setK(int k) {
    public boolean equals(Object o) {
       if (this == o) return true;
       if (o == null || getClass() != o.getClass()) return false;
+      CustomKey other = (CustomKey) o;
+      return i == other.i &amp;&amp; j == other.j &amp;&amp; k == other.k;
    }
 
    @Override
    public int hashCode() {
+      return 31 * (31 * i + j) + k;
    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>446499</refactoring_id><commit_sha>8fb9bf36accdac550a789372fc1791f50a37c1bb</commit_sha><commit_link>https://github.com/flowable/flowable-engine/commit/8fb9bf36accdac550a789372fc1791f50a37c1bb</commit_link><file_path>modules/activiti-engine/src/main/java/org/activiti/engine/impl/bpmn/behavior/ErrorEndEventActivityBehavior.java</file_path><description>Rename Variable parentActivity : ActivityImpl to currentActivity : ActivityImpl in method protected executeCatchInSameProcess(execution ActivityExecution) : void from class org.activiti.engine.impl.bpmn.behavior.ErrorEndEventActivityBehavior</description><code_before>@@ -36,7 +36,7 @@ public ErrorEndEventActivityBehavior(String errorCode) {
   
   public void execute(ActivityExecution execution) throws Exception {
     
-    // TODO: merge two approaches (super process / regular process approach), not 100% happy with it now
     
     // The borderEventActivityId is set during parsing (for performance reasons)
     // However, this only works on one process level (and not for call activities)
@@ -88,7 +88,7 @@ protected void executeCatchInSuperProcess(ActivityExecution superExecution) {
     
     if (found) {
       outgoingExecution.executeActivity(catchingActivity);
-    } else {
       ActivityExecution superSuperExecution = getSuperExecution(superExecution);
       if (superSuperExecution != null) {
         executeCatchInSuperProcess(superSuperExecution);
@@ -118,44 +118,42 @@ protected void executeCatchInSameProcess(ActivityExecution execution) {
     }
     
     boolean matchingParentFound = false;
-    ActivityExecution parentExecution = execution;
-    ActivityImpl parentActivity = (ActivityImpl) execution.getActivity().getParent();
     
     // Traverse parents until one is found that is a scope 
     // and matches the activity the boundary event is defined on
-    while(!matchingParentFound &amp;&amp; parentExecution != null &amp;&amp; parentActivity != null) {
-      if (parentExecution.isScope() 
-              &amp;&amp; !parentExecution.isConcurrent() 
-              &amp;&amp; parentActivity.getId().equals(catchingScope.getId())) {
         matchingParentFound = true;
-      } else if (parentExecution.isConcurrent()) {
-        parentExecution = parentExecution.getParent();
-      } else if (parentExecution.isScope()) {
-        parentActivity = parentActivity.getParentActivity();
-        parentExecution = parentExecution.getParent();
       } 
-      
     }
     
-    if (matchingParentFound &amp;&amp; parentExecution != null) {
-      parentExecution.executeActivity(borderEventActivity);
     } else {
       throw new ActivitiException("No matching parent execution for activity " + borderEventActivityId + " found");
     }
   }
-
   public String getBorderEventActivityId() {
     return borderEventActivityId;
   }
-
   public void setBorderEventActivityId(String borderEventActivityId) {
     this.borderEventActivityId = borderEventActivityId;
   }
-
   public String getErrorCode() {
     return errorCode;
   }
-
   public void setErrorCode(String errorCode) {
     this.errorCode = errorCode;
   }
</code_before><code_after>@@ -36,7 +36,7 @@ public ErrorEndEventActivityBehavior(String errorCode) {
   
   public void execute(ActivityExecution execution) throws Exception {
     
+    // TODO: merge two approaches (super process / regular process approach)
     
     // The borderEventActivityId is set during parsing (for performance reasons)
     // However, this only works on one process level (and not for call activities)
@@ -88,7 +88,7 @@ protected void executeCatchInSuperProcess(ActivityExecution superExecution) {
     
     if (found) {
       outgoingExecution.executeActivity(catchingActivity);
+    } else { // no matching catch found, going one level up in process hierarchy
       ActivityExecution superSuperExecution = getSuperExecution(superExecution);
       if (superSuperExecution != null) {
         executeCatchInSuperProcess(superSuperExecution);
@@ -118,44 +118,42 @@ protected void executeCatchInSameProcess(ActivityExecution execution) {
     }
     
     boolean matchingParentFound = false;
+    ActivityExecution leavingExecution = execution;
+    String multiInstance = (String) catchingScope.getProperty("multiInstance");
+    ActivityImpl currentActivity = (multiInstance == null || "sequential".equals(multiInstance))  ?
+          (ActivityImpl) execution.getActivity().getParent()  : (ActivityImpl) execution.getActivity();
     
     // Traverse parents until one is found that is a scope 
     // and matches the activity the boundary event is defined on
+    while(!matchingParentFound &amp;&amp; leavingExecution != null &amp;&amp; currentActivity != null) {
+      if (leavingExecution.isScope() 
+            &amp;&amp; !leavingExecution.isConcurrent() 
+            &amp;&amp; currentActivity.getId().equals(catchingScope.getId())) {
         matchingParentFound = true;
+      } else if (leavingExecution.isConcurrent()) {
+        leavingExecution = leavingExecution.getParent();
+      } else {
+        currentActivity = currentActivity.getParentActivity();
+        leavingExecution = leavingExecution.getParent();
       } 
     }
     
+    if (matchingParentFound &amp;&amp; leavingExecution != null) {
+      leavingExecution.executeActivity(borderEventActivity);
     } else {
       throw new ActivitiException("No matching parent execution for activity " + borderEventActivityId + " found");
     }
   }
+  
   public String getBorderEventActivityId() {
     return borderEventActivityId;
   }
   public void setBorderEventActivityId(String borderEventActivityId) {
     this.borderEventActivityId = borderEventActivityId;
   }
   public String getErrorCode() {
     return errorCode;
   }
   public void setErrorCode(String errorCode) {
     this.errorCode = errorCode;
   }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>402971</refactoring_id><commit_sha>9d806c86f1efbe2445ef7283351d8490805ce674</commit_sha><commit_link>https://github.com/apache/accumulo/commit/9d806c86f1efbe2445ef7283351d8490805ce674</commit_link><file_path>server/monitor/src/main/java/org/apache/accumulo/monitor/view/WebViews.java</file_path><description>Rename Variable imports : String to resourcesProperty : String in method private addExternalResources(model Map&lt;String,Object&gt;) : void from class org.apache.accumulo.monitor.view.WebViews</description><code_before>@@ -16,6 +16,8 @@
  */
 package org.apache.accumulo.monitor.view;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -38,7 +40,6 @@
 import org.apache.accumulo.core.conf.Property;
 import org.apache.accumulo.core.util.AddressUtil;
 import org.apache.accumulo.monitor.Monitor;
-import org.apache.commons.lang.StringUtils;
 import org.glassfish.jersey.server.mvc.Template;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -59,19 +60,20 @@ public class WebViews {
   private static final Logger log = LoggerFactory.getLogger(WebViews.class);
 
   /**
-   * Get HTML for CSS and JS imports from configuration. See ACCUMULO-4739
    *
-   * @param model map of the MVC model
    */
   private void addExternalResources(Map&lt;String,Object&gt; model) {
     AccumuloConfiguration conf = Monitor.getContext().getConfiguration();
-    String imports = conf.get(Property.MONITOR_RESOURCES_EXTERNAL);
-    if (StringUtils.isEmpty(imports))
       return;
     List&lt;String&gt; monitorResources = new ArrayList&lt;&gt;();
     ObjectMapper objectMapper = new ObjectMapper();
     try {
-      for (String monitorResource : objectMapper.readValue(imports, String[].class)) {
         monitorResources.add(monitorResource);
       }
     } catch (IOException e) {
</code_before><code_after>@@ -16,6 +16,8 @@
  */
 package org.apache.accumulo.monitor.view;
 
+import static org.apache.commons.lang.StringUtils.isEmpty;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -38,7 +40,6 @@
 import org.apache.accumulo.core.conf.Property;
 import org.apache.accumulo.core.util.AddressUtil;
 import org.apache.accumulo.monitor.Monitor;
 import org.glassfish.jersey.server.mvc.Template;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -59,19 +60,20 @@ public class WebViews {
   private static final Logger log = LoggerFactory.getLogger(WebViews.class);
 
   /**
+   * Get HTML for external CSS and JS resources from configuration. See ACCUMULO-4739
    *
+   * @param model
+   *          map of the MVC model
    */
   private void addExternalResources(Map&lt;String,Object&gt; model) {
     AccumuloConfiguration conf = Monitor.getContext().getConfiguration();
+    String resourcesProperty = conf.get(Property.MONITOR_RESOURCES_EXTERNAL);
+    if (isEmpty(resourcesProperty))
       return;
     List&lt;String&gt; monitorResources = new ArrayList&lt;&gt;();
     ObjectMapper objectMapper = new ObjectMapper();
     try {
+      for (String monitorResource : objectMapper.readValue(resourcesProperty, String[].class)) {
         monitorResources.add(monitorResource);
       }
     } catch (IOException e) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>377240</refactoring_id><commit_sha>9dddc7cc6833925a7dcfd64717707d7dde8af17f</commit_sha><commit_link>https://github.com/jabref/jabref/commit/9dddc7cc6833925a7dcfd64717707d7dde8af17f</commit_link><file_path>src/java/net/sf/jabref/JTextAreaWithHighlighting.java</file_path><description>Rename Variable e : CannotRedoException to ignored : CannotRedoException in method public actionPerformed(evt ActionEvent) : void from class net.sf.jabref.JTextAreaWithHighlighting.setupUndoRedo.put.new AbstractAction</description><code_before>@@ -90,7 +90,7 @@ public void actionPerformed(ActionEvent evt) {
                             if (undo.canUndo()) {
                                 undo.undo();
                             }
-                        } catch (CannotUndoException e) {
                         }
                     }
                 });
@@ -106,7 +106,7 @@ public void actionPerformed(ActionEvent evt) {
                             if (undo.canRedo()) {
                                 undo.redo();
                             }
-                        } catch (CannotRedoException e) {
                         }
                     }
                 });
</code_before><code_after>@@ -90,7 +90,7 @@ public void actionPerformed(ActionEvent evt) {
                             if (undo.canUndo()) {
                                 undo.undo();
                             }
+                        } catch (CannotUndoException ignored) {
                         }
                     }
                 });
@@ -106,7 +106,7 @@ public void actionPerformed(ActionEvent evt) {
                             if (undo.canRedo()) {
                                 undo.redo();
                             }
+                        } catch (CannotRedoException ignored) {
                         }
                     }
                 });
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>420666</refactoring_id><commit_sha>0f60f5eba5bfff80c34df7db0a42d9a457dbbc35</commit_sha><commit_link>https://github.com/apache/poi/commit/0f60f5eba5bfff80c34df7db0a42d9a457dbbc35</commit_link><file_path>src/java/org/apache/poi/hssf/record/aggregates/RowRecordsAggregate.java</file_path><description>Rename Variable lastRow : int to nextRowIx : int in method public collapseRow(rowNumber int) : void from class org.apache.poi.hssf.record.aggregates.RowRecordsAggregate</description><code_before>@@ -321,39 +321,38 @@ public int findEndOfRowOutlineGroup( int row )
         return currentRow-1;
     }
 
-    public int writeHidden( RowRecord rowRecord, int row, boolean hidden )
-    {
         int level = rowRecord.getOutlineLevel();
-        while (rowRecord != null &amp;&amp; this.getRow(row).getOutlineLevel() &gt;= level)
-        {
-            rowRecord.setZeroHeight( hidden );
-            row++;
-            rowRecord = this.getRow( row );
         }
-        return row - 1;
     }
 
-    public void collapseRow( int rowNumber )
-    {
 
         // Find the start of the group.
-        int startRow = findStartOfRowOutlineGroup( rowNumber );
-        RowRecord rowRecord = getRow( startRow );
 
         // Hide all the columns until the end of the group
-        int lastRow = writeHidden( rowRecord, startRow, true );
 
-        // Write collapse field
-        if (getRow(lastRow + 1) != null)
-        {
-            getRow(lastRow + 1).setColapsed( true );
-        }
-        else
-        {
-            RowRecord row = createRow( lastRow + 1);
-            row.setColapsed( true );
-            insertRow( row );
         }
     }
 
     /**
@@ -500,6 +499,9 @@ public void insertCell(CellValueRecordInterface cvRec) {
         _valuesAgg.insertCell(cvRec);
     }
     public void removeCell(CellValueRecordInterface cvRec) {
         _valuesAgg.removeCell(cvRec);
     }
     public FormulaRecordAggregate createFormula(int row, int col) {
</code_before><code_after>@@ -321,39 +321,38 @@ public int findEndOfRowOutlineGroup( int row )
         return currentRow-1;
     }
 
+    /**
+     * Hide all rows at or below the current outline level
+     * @return index of the &lt;em&gt;next&lt;em&gt; row after the last row that gets hidden
+     */
+    private int writeHidden(RowRecord pRowRecord, int row) {
+        int rowIx = row;
+        RowRecord rowRecord = pRowRecord;
         int level = rowRecord.getOutlineLevel();
+        while (rowRecord != null &amp;&amp; getRow(rowIx).getOutlineLevel() &gt;= level) {
+            rowRecord.setZeroHeight(true);
+            rowIx++;
+            rowRecord = getRow(rowIx);
         }
+        return rowIx;
     }
 
+    public void collapseRow(int rowNumber) {
 
         // Find the start of the group.
+        int startRow = findStartOfRowOutlineGroup(rowNumber);
+        RowRecord rowRecord = getRow(startRow);
 
         // Hide all the columns until the end of the group
+        int nextRowIx = writeHidden(rowRecord, startRow);
 
+        RowRecord row = getRow(nextRowIx);
+        if (row == null) {
+            row = createRow(nextRowIx);
+            insertRow(row);
         }
+        // Write collapse field
+        row.setColapsed(true);
     }
 
     /**
@@ -500,6 +499,9 @@ public void insertCell(CellValueRecordInterface cvRec) {
         _valuesAgg.insertCell(cvRec);
     }
     public void removeCell(CellValueRecordInterface cvRec) {
+        if (cvRec instanceof FormulaRecordAggregate) {
+            ((FormulaRecordAggregate)cvRec).notifyFormulaChanging();
+        }
         _valuesAgg.removeCell(cvRec);
     }
     public FormulaRecordAggregate createFormula(int row, int col) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>373073</refactoring_id><commit_sha>3a6e02f7e633d4fe2660eafb3ab9ca4aeb55c4d9</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/3a6e02f7e633d4fe2660eafb3ab9ca4aeb55c4d9</commit_link><file_path>object-filter/src/main/java/org/infinispan/objectfilter/impl/ProtobufMatcher.java</file_path><description>Rename Variable propPath : List&lt;Integer&gt; to translatedPath : List&lt;Integer&gt; in method public mapPropertyNamePathToFieldIdPath(messageDescriptor Descriptor, propertyPath String[]) : List&lt;?&gt; from class org.infinispan.objectfilter.impl.hql.ProtobufPropertyHelper</description><code_before>@@ -1,15 +1,14 @@
 package org.infinispan.objectfilter.impl;
 
 import org.infinispan.objectfilter.impl.hql.ProtobufEntityNamesResolver;
 import org.infinispan.objectfilter.impl.hql.ProtobufPropertyHelper;
 import org.infinispan.objectfilter.impl.predicateindex.ProtobufMatcherEvalContext;
 import org.infinispan.protostream.SerializationContext;
 import org.infinispan.protostream.WrappedMessage;
 import org.infinispan.protostream.descriptors.Descriptor;
 import org.infinispan.protostream.descriptors.FieldDescriptor;
-import org.infinispan.protostream.descriptors.JavaType;
 
-import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -54,15 +53,17 @@ protected FilterRegistry&lt;Descriptor, FieldDescriptor, Integer&gt; getFilterRegistry
 
    @Override
    protected MetadataAdapter&lt;Descriptor, FieldDescriptor, Integer&gt; createMetadataAdapter(Descriptor messageDescriptor) {
-      return new MetadataAdapterImpl(messageDescriptor);
    }
 
    private static class MetadataAdapterImpl implements MetadataAdapter&lt;Descriptor, FieldDescriptor, Integer&gt; {
 
       private final Descriptor messageDescriptor;
 
-      MetadataAdapterImpl(Descriptor messageDescriptor) {
          this.messageDescriptor = messageDescriptor;
       }
 
       @Override
@@ -76,19 +77,8 @@ public Descriptor getTypeMetadata() {
       }
 
       @Override
-      public List&lt;Integer&gt; translatePropertyPath(String[] path) {
-         List&lt;Integer&gt; propPath = new ArrayList&lt;&gt;(path.length);
-         Descriptor md = messageDescriptor;
-         for (String prop : path) {
-            FieldDescriptor fd = md.findFieldByName(prop);
-            propPath.add(fd.getNumber());
-            if (fd.getJavaType() == JavaType.MESSAGE) {
-               md = fd.getMessageType();
-            } else {
-               md = null; // iteration is expected to stop here
-            }
-         }
-         return propPath;
       }
 
       @Override
</code_before><code_after>@@ -1,15 +1,14 @@
 package org.infinispan.objectfilter.impl;
 
+import org.infinispan.objectfilter.impl.hql.ObjectPropertyHelper;
 import org.infinispan.objectfilter.impl.hql.ProtobufEntityNamesResolver;
 import org.infinispan.objectfilter.impl.hql.ProtobufPropertyHelper;
 import org.infinispan.objectfilter.impl.predicateindex.ProtobufMatcherEvalContext;
 import org.infinispan.protostream.SerializationContext;
 import org.infinispan.protostream.WrappedMessage;
 import org.infinispan.protostream.descriptors.Descriptor;
 import org.infinispan.protostream.descriptors.FieldDescriptor;
 
 import java.util.List;
 
 /**
@@ -54,15 +53,17 @@ protected FilterRegistry&lt;Descriptor, FieldDescriptor, Integer&gt; getFilterRegistry
 
    @Override
    protected MetadataAdapter&lt;Descriptor, FieldDescriptor, Integer&gt; createMetadataAdapter(Descriptor messageDescriptor) {
+      return new MetadataAdapterImpl(messageDescriptor, propertyHelper);
    }
 
    private static class MetadataAdapterImpl implements MetadataAdapter&lt;Descriptor, FieldDescriptor, Integer&gt; {
 
       private final Descriptor messageDescriptor;
+      private final ObjectPropertyHelper&lt;Descriptor&gt; propertyHelper;
 
+      MetadataAdapterImpl(Descriptor messageDescriptor, ObjectPropertyHelper&lt;Descriptor&gt; propertyHelper) {
          this.messageDescriptor = messageDescriptor;
+         this.propertyHelper = propertyHelper;
       }
 
       @Override
@@ -76,19 +77,8 @@ public Descriptor getTypeMetadata() {
       }
 
       @Override
+      public List&lt;Integer&gt; mapPropertyNamePathToFieldIdPath(String[] path) {
+         return (List&lt;Integer&gt;) propertyHelper.mapPropertyNamePathToFieldIdPath(messageDescriptor, path);
       }
 
       @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>433623</refactoring_id><commit_sha>1f60acd68d1f3b9db79545381ac3ac07c2ce8500</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/1f60acd68d1f3b9db79545381ac3ac07c2ce8500</commit_link><file_path>quickstep/src/com/android/quickstep/AbsSwipeUpHandler.java</file_path><description>Rename Variable willGoToNewTask : boolean to willGoToNewTaskOnSwipeUp : boolean in method private calculateEndTarget(velocity PointF, endVelocity float, isFlingY boolean, isCancel boolean) : GestureEndTarget from class com.android.quickstep.AbsSwipeUpHandler</description><code_before>@@ -1013,19 +1013,19 @@ private GestureEndTarget calculateEndTarget(PointF velocity, float endVelocity,
             return RECENTS;
         }
         final GestureEndTarget endTarget;
-        final boolean canGoToNewTask;
         if (mRecentsView != null) {
             if (!hasTargets()) {
                 // If there are no running tasks, then we can assume that this is a continuation of
                 // the last gesture, but after the recents animation has finished
-                canGoToNewTask = true;
             } else {
                 final int runningTaskIndex = mRecentsView.getRunningTaskIndex();
                 final int taskToLaunch = mRecentsView.getNextPage();
-                canGoToNewTask = runningTaskIndex &gt;= 0 &amp;&amp; taskToLaunch != runningTaskIndex;
             }
         } else {
-            canGoToNewTask = false;
         }
         final boolean reachedOverviewThreshold = mCurrentShift.value &gt;= MIN_PROGRESS_FOR_OVERVIEW;
         final boolean isFlingX = Math.abs(velocity.x) &gt; mContext.getResources()
@@ -1034,36 +1034,40 @@ private GestureEndTarget calculateEndTarget(PointF velocity, float endVelocity,
             if (isCancel) {
                 endTarget = LAST_TASK;
             } else if (mDeviceState.isFullyGesturalNavMode()) {
-                if (canGoToNewTask &amp;&amp; isFlingX) {
                     // Flinging towards new task takes precedence over mIsMotionPaused (which only
                     // checks y-velocity).
                     endTarget = NEW_TASK;
                 } else if (mIsMotionPaused) {
                     endTarget = RECENTS;
-                } else if (canGoToNewTask) {
                     endTarget = NEW_TASK;
                 } else {
                     endTarget = !reachedOverviewThreshold ? LAST_TASK : HOME;
                 }
             } else {
                 endTarget = reachedOverviewThreshold &amp;&amp; mGestureStarted
                         ? RECENTS
-                        : canGoToNewTask
                                 ? NEW_TASK
                                 : LAST_TASK;
             }
         } else {
             // If swiping at a diagonal, base end target on the faster velocity.
             boolean isSwipeUp = endVelocity &lt; 0;
-            boolean willGoToNewTask =
-                    canGoToNewTask &amp;&amp; Math.abs(velocity.x) &gt; Math.abs(endVelocity);
-
-            if (mDeviceState.isFullyGesturalNavMode() &amp;&amp; isSwipeUp) {
-                endTarget = willGoToNewTask ? NEW_TASK : HOME;
             } else if (isSwipeUp) {
-                endTarget = (!reachedOverviewThreshold &amp;&amp; willGoToNewTask) ? NEW_TASK : RECENTS;
             } else {
-                endTarget = willGoToNewTask ? NEW_TASK : LAST_TASK; // Swipe is downward.
             }
         }
 
@@ -1141,8 +1145,6 @@ private void handleNormalGestureEnd(float endVelocity, boolean isFling, PointF v
                     duration = Math.max(duration, mRecentsView.getScroller().getDuration());
                 }
             }
-        } else if (endTarget == LAST_TASK &amp;&amp; mRecentsView != null) {
-            mRecentsView.snapToPage(mRecentsView.getCurrentPage(), Math.toIntExact(duration));
         }
 
         // Let RecentsView handle the scrolling to the task, which we launch in startNewTask()
</code_before><code_after>@@ -1013,19 +1013,19 @@ private GestureEndTarget calculateEndTarget(PointF velocity, float endVelocity,
             return RECENTS;
         }
         final GestureEndTarget endTarget;
+        final boolean goingToNewTask;
         if (mRecentsView != null) {
             if (!hasTargets()) {
                 // If there are no running tasks, then we can assume that this is a continuation of
                 // the last gesture, but after the recents animation has finished
+                goingToNewTask = true;
             } else {
                 final int runningTaskIndex = mRecentsView.getRunningTaskIndex();
                 final int taskToLaunch = mRecentsView.getNextPage();
+                goingToNewTask = runningTaskIndex &gt;= 0 &amp;&amp; taskToLaunch != runningTaskIndex;
             }
         } else {
+            goingToNewTask = false;
         }
         final boolean reachedOverviewThreshold = mCurrentShift.value &gt;= MIN_PROGRESS_FOR_OVERVIEW;
         final boolean isFlingX = Math.abs(velocity.x) &gt; mContext.getResources()
@@ -1034,36 +1034,40 @@ private GestureEndTarget calculateEndTarget(PointF velocity, float endVelocity,
             if (isCancel) {
                 endTarget = LAST_TASK;
             } else if (mDeviceState.isFullyGesturalNavMode()) {
+                if (goingToNewTask &amp;&amp; isFlingX) {
                     // Flinging towards new task takes precedence over mIsMotionPaused (which only
                     // checks y-velocity).
                     endTarget = NEW_TASK;
                 } else if (mIsMotionPaused) {
                     endTarget = RECENTS;
+                } else if (goingToNewTask) {
                     endTarget = NEW_TASK;
                 } else {
                     endTarget = !reachedOverviewThreshold ? LAST_TASK : HOME;
                 }
             } else {
                 endTarget = reachedOverviewThreshold &amp;&amp; mGestureStarted
                         ? RECENTS
+                        : goingToNewTask
                                 ? NEW_TASK
                                 : LAST_TASK;
             }
         } else {
             // If swiping at a diagonal, base end target on the faster velocity.
             boolean isSwipeUp = endVelocity &lt; 0;
+            boolean willGoToNewTaskOnSwipeUp =
+                    goingToNewTask &amp;&amp; Math.abs(velocity.x) &gt; Math.abs(endVelocity);
+
+            if (mDeviceState.isFullyGesturalNavMode() &amp;&amp; isSwipeUp &amp;&amp; !willGoToNewTaskOnSwipeUp) {
+                endTarget = HOME;
+            } else if (mDeviceState.isFullyGesturalNavMode() &amp;&amp; isSwipeUp) {
+                // If swiping at a diagonal, base end target on the faster velocity.
+                endTarget = NEW_TASK;
             } else if (isSwipeUp) {
+                endTarget = !reachedOverviewThreshold &amp;&amp; willGoToNewTaskOnSwipeUp
+                        ? NEW_TASK : RECENTS;
             } else {
+                endTarget = goingToNewTask ? NEW_TASK : LAST_TASK;
             }
         }
 
@@ -1141,8 +1145,6 @@ private void handleNormalGestureEnd(float endVelocity, boolean isFling, PointF v
                     duration = Math.max(duration, mRecentsView.getScroller().getDuration());
                 }
             }
         }
 
         // Let RecentsView handle the scrolling to the task, which we launch in startNewTask()
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>372152</refactoring_id><commit_sha>5eac2873718797f3c6618d2a55310f2de15a7592</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/5eac2873718797f3c6618d2a55310f2de15a7592</commit_link><file_path>scripting/src/test/java/org/infinispan/scripting/DistributedCacheScriptingTest.java</file_path><description>Rename Variable cache : Cache to cache1 : Cache in method public call() : void from class org.infinispan.scripting.ClusteredScriptingTest.testDistributedMapReduceStream.withCacheManagers.new MultiCacheManagerCallable</description><code_before>@@ -1,67 +0,0 @@
-package org.infinispan.scripting;
-
-import org.infinispan.Cache;
-import org.infinispan.configuration.cache.CacheMode;
-import org.infinispan.configuration.cache.ConfigurationBuilder;
-import org.infinispan.stream.CacheCollectors;
-import org.infinispan.tasks.TaskContext;
-import org.infinispan.test.MultipleCacheManagersTest;
-import org.infinispan.test.data.Address;
-import org.testng.annotations.Test;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-import static org.infinispan.scripting.utils.ScriptingUtils.*;
-import static org.testng.AssertJUnit.assertEquals;
-import static org.testng.AssertJUnit.assertTrue;
-
-/**
- * Testing the Scripting on distributed cluster.
- */
-@Test(groups = "functional", testName = "scripting.DistributedCacheScriptingTest")
-public class DistributedCacheScriptingTest extends MultipleCacheManagersTest {
-
-    @Override
-    protected void createCacheManagers() throws Throwable {
-        final ConfigurationBuilder conf = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);
-        createCluster(conf, 4);
-        waitForClusterToForm();
-    }
-
-    public void testDistributedScriptExecution() throws IOException, ExecutionException, InterruptedException {
-        ScriptingManager scriptingManager = getScriptingManager(manager(0));
-        loadScript(scriptingManager, "/distExec.js");
-
-        List&lt;Address&gt; addressList = (List&lt;Address&gt;) scriptingManager.runScript("distExec.js", new TaskContext().cache(cache(0))).get();
-        assertTrue(addressList.contains(manager(0).getAddress()));
-        assertTrue(addressList.contains(manager(1).getAddress()));
-        assertTrue(addressList.contains(manager(2).getAddress()));
-        assertTrue(addressList.contains(manager(3).getAddress()));
-    }
-
-    @Test(enabled = false, description = "Disabled until the bug ISPN-6173 is fixed.")
-    public void testDistributedMapReduceStream() throws IOException, ExecutionException, InterruptedException {
-        ScriptingManager scriptingManager = getScriptingManager(manager(0));
-        Cache cache = cache(0);
-
-        loadData(cache, "/macbeth.txt");
-        loadScript(scriptingManager, "/wordCountStream_dist.js");
-
-        ArrayList&lt;Map&lt;String, Long&gt;&gt; resultsFuture =  (ArrayList&lt;Map&lt;String, Long&gt;&gt;) scriptingManager.runScript("wordCountStream_dist.js", new TaskContext().cache(cache(0))).get();
-        assertEquals(2, resultsFuture.size());
-        assertEquals(3209, resultsFuture.get(0).size());
-        assertEquals(3209, resultsFuture.get(1).size());
-        assertEquals(resultsFuture.get(0).get("macbeth"), Long.valueOf(287));
-        assertEquals(resultsFuture.get(1).get("macbeth"), Long.valueOf(287));
-    }
-}
</code_before><code_after>@@ -1,67 +0,0 @@
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>366409</refactoring_id><commit_sha>089e51f0bc02b63490e1038e0ec23d1d43adf9a8</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/089e51f0bc02b63490e1038e0ec23d1d43adf9a8</commit_link><file_path>jetty-util/src/main/java/org/eclipse/jetty/util/ssl/SslContextFactory.java</file_path><description>Rename Variable ignored : AutoLock to l : AutoLock in method protected doStart() : void from class org.eclipse.jetty.util.ssl.SslContextFactory</description><code_before>@@ -214,7 +214,7 @@ public SslContextFactory(boolean trustAll)
     protected void doStart() throws Exception
     {
         super.doStart();
-        try (AutoLock ignored = _lock.lock())
         {
             load();
         }
@@ -438,7 +438,7 @@ List&lt;SslSelectionDump&gt; selectionDump() throws NoSuchAlgorithmException
     @Override
     protected void doStop() throws Exception
     {
-        try (AutoLock ignored = _lock.lock())
         {
             unload();
         }
@@ -1041,7 +1041,7 @@ public SSLContext getSslContext()
         if (!isStarted())
             return _setContext;
 
-        try (AutoLock ignored = _lock.lock())
         {
             if (_factory == null)
                 throw new IllegalStateException("SslContextFactory reload failed");
@@ -1422,7 +1422,7 @@ public KeyStore getKeyStore()
         if (!isStarted())
             return _setKeyStore;
 
-        try (AutoLock ignored = _lock.lock())
         {
             if (_factory == null)
                 throw new IllegalStateException("SslContextFactory reload failed");
@@ -1445,7 +1445,7 @@ public KeyStore getTrustStore()
         if (!isStarted())
             return _setTrustStore;
 
-        try (AutoLock ignored = _lock.lock())
         {
             if (_factory == null)
                 throw new IllegalStateException("SslContextFactory reload failed");
@@ -1882,7 +1882,7 @@ public SSLParameters customize(SSLParameters sslParams)
 
     public void reload(Consumer&lt;SslContextFactory&gt; consumer) throws Exception
     {
-        try (AutoLock ignored = _lock.lock())
         {
             consumer.accept(this);
             unload();
</code_before><code_after>@@ -214,7 +214,7 @@ public SslContextFactory(boolean trustAll)
     protected void doStart() throws Exception
     {
         super.doStart();
+        try (AutoLock l = _lock.lock())
         {
             load();
         }
@@ -438,7 +438,7 @@ List&lt;SslSelectionDump&gt; selectionDump() throws NoSuchAlgorithmException
     @Override
     protected void doStop() throws Exception
     {
+        try (AutoLock l = _lock.lock())
         {
             unload();
         }
@@ -1041,7 +1041,7 @@ public SSLContext getSslContext()
         if (!isStarted())
             return _setContext;
 
+        try (AutoLock l = _lock.lock())
         {
             if (_factory == null)
                 throw new IllegalStateException("SslContextFactory reload failed");
@@ -1422,7 +1422,7 @@ public KeyStore getKeyStore()
         if (!isStarted())
             return _setKeyStore;
 
+        try (AutoLock l = _lock.lock())
         {
             if (_factory == null)
                 throw new IllegalStateException("SslContextFactory reload failed");
@@ -1445,7 +1445,7 @@ public KeyStore getTrustStore()
         if (!isStarted())
             return _setTrustStore;
 
+        try (AutoLock l = _lock.lock())
         {
             if (_factory == null)
                 throw new IllegalStateException("SslContextFactory reload failed");
@@ -1882,7 +1882,7 @@ public SSLParameters customize(SSLParameters sslParams)
 
     public void reload(Consumer&lt;SslContextFactory&gt; consumer) throws Exception
     {
+        try (AutoLock l = _lock.lock())
         {
             consumer.accept(this);
             unload();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>375262</refactoring_id><commit_sha>a5e2b667dcd1eeeb681f693c3b0f7e3e57d33311</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/a5e2b667dcd1eeeb681f693c3b0f7e3e57d33311</commit_link><file_path>OsmAnd/src/net/osmand/plus/track/helpers/GpsFilterHelper.java</file_path><description>Rename Variable pointsCount : int to analysedPointsCount : int in method protected doInBackground(voids Void...) : Boolean from class net.osmand.plus.track.helpers.GpsFilterHelper.GpsFilterTask</description><code_before>@@ -95,7 +95,7 @@ protected Boolean doInBackground(Void... voids) {
 			filteredGpxFile = copyGpxFile(app, sourceGpx);
 			filteredGpxFile.tracks.clear();
 
-			int pointsCount = 0;
 			for (Track track : sourceGpx.tracks) {
 
 				Track filteredTrack = new Track();
@@ -128,13 +128,16 @@ protected Boolean doInBackground(Void... voids) {
 									point.lat, point.lon);
 						}
 						boolean firstOrLast = i == 0 || i + 1 == points.size();
 
-						if (acceptPoint(point, pointsCount, cumulativeDistance, firstOrLast)) {
 							filteredSegment.points.add(new WptPt(point));
 							cumulativeDistance = 0;
 						}
 
-						pointsCount++;
 						previousPoint = point;
 					}
 
@@ -158,16 +161,17 @@ protected Boolean doInBackground(Void... voids) {
 			return true;
 		}
 
-		private boolean acceptPoint(@NonNull WptPt point, int pointIndex, double cumulativeDistance, boolean firstOrLast) {
 			SpeedFilter speedFilter = filteredSelectedGpxFile.getSpeedFilter();
 			AltitudeFilter altitudeFilter = filteredSelectedGpxFile.getAltitudeFilter();
 			HdopFilter hdopFilter = filteredSelectedGpxFile.getHdopFilter();
 			SmoothingFilter smoothingFilter = filteredSelectedGpxFile.getSmoothingFilter();
 
-			return speedFilter.acceptPoint(point, pointIndex, cumulativeDistance)
-					&amp;&amp; altitudeFilter.acceptPoint(point, pointIndex, cumulativeDistance)
-					&amp;&amp; hdopFilter.acceptPoint(point, pointIndex, cumulativeDistance)
-					&amp;&amp; (firstOrLast || smoothingFilter.acceptPoint(point, pointIndex, cumulativeDistance));
 		}
 
 		@Nullable
@@ -299,7 +303,8 @@ protected void checkSelectedValues() {
 
 		public abstract boolean isRangeSupported();
 
-		public abstract boolean acceptPoint(@NonNull WptPt point, int pointIndex, double distanceToLastSurvivedPoint);
 
 		public abstract double getMinValue();
 
@@ -418,7 +423,8 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
-		public boolean acceptPoint(@NonNull WptPt point, int pointIndex, double distanceToLastSurvivedPoint) {
 			return !isNeeded() || getSelectedMaxValue() == 0 || distanceToLastSurvivedPoint &gt; getSelectedMaxValue();
 		}
 
@@ -497,8 +503,9 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
-		public boolean acceptPoint(@NonNull WptPt point, int pointIndex, double distanceToLastSurvivedPoint) {
-			float speed = analysis.speedData.get(pointIndex).speed;
 			return !isNeeded() || getSelectedMinValue() &lt;= speed &amp;&amp; speed &lt;= getSelectedMaxValue();
 		}
 
@@ -587,8 +594,9 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
-		public boolean acceptPoint(@NonNull WptPt point, int pointIndex, double distanceToLastSurvivedPoint) {
-			float altitude = analysis.elevationData.get(pointIndex).elevation;
 			return !isNeeded() || getSelectedMinValue() &lt;= altitude &amp;&amp; altitude &lt;= getSelectedMaxValue();
 		}
 
@@ -675,7 +683,8 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
-		public boolean acceptPoint(@NonNull WptPt point, int pointIndex, double distanceToLastSurvivedPoint) {
 			return !isNeeded() || point.hdop &lt;= getSelectedMaxValue();
 		}
 
</code_before><code_after>@@ -95,7 +95,7 @@ protected Boolean doInBackground(Void... voids) {
 			filteredGpxFile = copyGpxFile(app, sourceGpx);
 			filteredGpxFile.tracks.clear();
 
+			int analysedPointsCount = 0;
 			for (Track track : sourceGpx.tracks) {
 
 				Track filteredTrack = new Track();
@@ -128,13 +128,16 @@ protected Boolean doInBackground(Void... voids) {
 									point.lat, point.lon);
 						}
 						boolean firstOrLast = i == 0 || i + 1 == points.size();
+						boolean singlePoint = points.size() == 1;
 
+						if (acceptPoint(point, analysedPointsCount, cumulativeDistance, firstOrLast, singlePoint)) {
 							filteredSegment.points.add(new WptPt(point));
 							cumulativeDistance = 0;
 						}
 
+						if (!singlePoint) {
+							analysedPointsCount++;
+						}
 						previousPoint = point;
 					}
 
@@ -158,16 +161,17 @@ protected Boolean doInBackground(Void... voids) {
 			return true;
 		}
 
+		private boolean acceptPoint(@NonNull WptPt point, int pointIndex, double cumulativeDistance,
+		                            boolean firstOrLast, boolean singlePoint) {
 			SpeedFilter speedFilter = filteredSelectedGpxFile.getSpeedFilter();
 			AltitudeFilter altitudeFilter = filteredSelectedGpxFile.getAltitudeFilter();
 			HdopFilter hdopFilter = filteredSelectedGpxFile.getHdopFilter();
 			SmoothingFilter smoothingFilter = filteredSelectedGpxFile.getSmoothingFilter();
 
+			return speedFilter.acceptPoint(point, pointIndex, cumulativeDistance, singlePoint)
+					&amp;&amp; altitudeFilter.acceptPoint(point, pointIndex, cumulativeDistance, singlePoint)
+					&amp;&amp; hdopFilter.acceptPoint(point, pointIndex, cumulativeDistance, singlePoint)
+					&amp;&amp; (firstOrLast || smoothingFilter.acceptPoint(point, pointIndex, cumulativeDistance, singlePoint));
 		}
 
 		@Nullable
@@ -299,7 +303,8 @@ protected void checkSelectedValues() {
 
 		public abstract boolean isRangeSupported();
 
+		public abstract boolean acceptPoint(@NonNull WptPt point, int pointIndex,
+		                                    double distanceToLastSurvivedPoint, boolean singlePoint);
 
 		public abstract double getMinValue();
 
@@ -418,7 +423,8 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
+		public boolean acceptPoint(@NonNull WptPt point, int pointIndex,
+		                           double distanceToLastSurvivedPoint, boolean singlePoint) {
 			return !isNeeded() || getSelectedMaxValue() == 0 || distanceToLastSurvivedPoint &gt; getSelectedMaxValue();
 		}
 
@@ -497,8 +503,9 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
+		public boolean acceptPoint(@NonNull WptPt point, int pointIndex,
+		                           double distanceToLastSurvivedPoint, boolean singlePoint) {
+			float speed = singlePoint ? (float) point.speed : analysis.speedData.get(pointIndex).speed;
 			return !isNeeded() || getSelectedMinValue() &lt;= speed &amp;&amp; speed &lt;= getSelectedMaxValue();
 		}
 
@@ -587,8 +594,9 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
+		public boolean acceptPoint(@NonNull WptPt point, int pointIndex,
+		                           double distanceToLastSurvivedPoint, boolean singlePoint) {
+			float altitude = singlePoint ? (float) point.ele : analysis.elevationData.get(pointIndex).elevation;
 			return !isNeeded() || getSelectedMinValue() &lt;= altitude &amp;&amp; altitude &lt;= getSelectedMaxValue();
 		}
 
@@ -675,7 +683,8 @@ public boolean isRangeSupported() {
 		}
 
 		@Override
+		public boolean acceptPoint(@NonNull WptPt point, int pointIndex,
+		                           double distanceToLastSurvivedPoint, boolean singlePoint) {
 			return !isNeeded() || point.hdop &lt;= getSelectedMaxValue();
 		}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>434674</refactoring_id><commit_sha>bd61a1b90ff9328ea9d44f391ab5cd1f046aa138</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/bd61a1b90ff9328ea9d44f391ab5cd1f046aa138</commit_link><file_path>onedrive/src/main/java/ch/cyberduck/core/onedrive/features/OneDriveTouchFeature.java</file_path><description>Rename Variable foundItem : OneDriveItem to folder : OneDriveFolder in method public touch(file Path, status TransferStatus) : Path from class ch.cyberduck.core.onedrive.features.OneDriveTouchFeature</description><code_before>@@ -47,14 +47,8 @@ public OneDriveTouchFeature(final OneDriveSession session) {
     @Override
     public Path touch(final Path file, final TransferStatus status) throws BackgroundException {
         try {
-            final OneDriveItem foundItem = session.toItem(file.getParent());
-            if(null == foundItem) {
-                throw new NotfoundException(String.format("Did not find parent for %s", file));
-            }
-            if(!(foundItem instanceof OneDriveFolder)) {
-                throw new NotfoundException(String.format("Did not find directory %s for file %s", file.getParent(), file));
-            }
-            final OneDriveFile oneDriveFile = new OneDriveFile(session.getClient(), (OneDriveFolder) foundItem,
                 URIEncoder.encode(file.getName()), OneDriveItem.ItemIdentifierType.Path);
             oneDriveFile.create(StringUtils.isNotBlank(status.getMime()) ? status.getMime() : MimeTypeService.DEFAULT_CONTENT_TYPE);
         }
</code_before><code_after>@@ -47,14 +47,8 @@ public OneDriveTouchFeature(final OneDriveSession session) {
     @Override
     public Path touch(final Path file, final TransferStatus status) throws BackgroundException {
         try {
+            final OneDriveFolder folder = session.toFolder(file.getParent());
+            final OneDriveFile oneDriveFile = new OneDriveFile(session.getClient(), folder,
                 URIEncoder.encode(file.getName()), OneDriveItem.ItemIdentifierType.Path);
             oneDriveFile.create(StringUtils.isNotBlank(status.getMime()) ? status.getMime() : MimeTypeService.DEFAULT_CONTENT_TYPE);
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>382163</refactoring_id><commit_sha>3c757939731979e72546ec836540a0671105457f</commit_sha><commit_link>https://github.com/apache/ignite/commit/3c757939731979e72546ec836540a0671105457f</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpClientDiscoverySpi.java</file_path><description>Rename Variable discoData : Map&lt;Integer,Object&gt; to entry : Map.Entry&lt;UUID,Map&lt;Integer,Object&gt;&gt; in method private processNodeAddedMessage(msg TcpDiscoveryNodeAddedMessage) : void from class org.apache.ignite.spi.discovery.tcp.TcpClientDiscoverySpi.MessageWorker</description><code_before>@@ -27,6 +27,7 @@
 import org.apache.ignite.spi.*;
 import org.apache.ignite.spi.discovery.*;
 import org.apache.ignite.spi.discovery.tcp.internal.*;
 import org.apache.ignite.spi.discovery.tcp.ipfinder.multicast.*;
 import org.apache.ignite.spi.discovery.tcp.messages.*;
 import org.jdk8.backport.*;
@@ -46,7 +47,7 @@
  * &lt;p&gt;
  * This discovery SPI requires at least on server node configured with
  * {@link TcpDiscoverySpi}. It will try to connect to random IP taken from
- * {@link org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder} which should point to one of these server
  * nodes and will maintain connection only with this node (will not enter the ring).
  * If this connection is broken, it will try to reconnect using addresses from
  * the same IP finder.
@@ -381,7 +382,7 @@ public void setDisconnectCheckInterval(long disconnectCheckInt) {
     /**
      * @param recon Reconnect flag.
      * @return Whether joined successfully.
-     * @throws org.apache.ignite.spi.IgniteSpiException In case of error.
      */
     private boolean joinTopology(boolean recon) throws IgniteSpiException {
         if (!recon)
@@ -735,9 +736,9 @@ protected SocketReader(UUID nodeId, MessageWorker msgWrk) {
 
                         stats.onMessageReceived(msg);
 
-                        IgniteSpiException err = null;
-
                         if (joinLatch.getCount() &gt; 0) {
                             if (msg instanceof TcpDiscoveryDuplicateIdMessage)
                                 err = duplicateIdError((TcpDiscoveryDuplicateIdMessage)msg);
                             else if (msg instanceof TcpDiscoveryAuthFailedMessage)
@@ -893,11 +894,11 @@ private void processNodeAddedMessage(TcpDiscoveryNodeAddedMessage msg) {
                         if (msg.topologyHistory() != null)
                             topHist.putAll(msg.topologyHistory());
 
-                        Collection&lt;Map&lt;Integer, Object&gt;&gt; dataList = msg.oldNodesDiscoveryData();
 
-                        if (dataList != null) {
-                            for (Map&lt;Integer, Object&gt; discoData : dataList)
-                                exchange.onExchange(newNodeId, discoData);
                         }
 
                         locNode.setAttributes(node.attributes());
@@ -920,7 +921,7 @@ else if (log.isDebugEnabled())
                     Map&lt;Integer, Object&gt; data = msg.newNodeDiscoveryData();
 
                     if (data != null)
-                        exchange.onExchange(newNodeId, data);
                 }
             }
         }
</code_before><code_after>@@ -27,6 +27,7 @@
 import org.apache.ignite.spi.*;
 import org.apache.ignite.spi.discovery.*;
 import org.apache.ignite.spi.discovery.tcp.internal.*;
+import org.apache.ignite.spi.discovery.tcp.ipfinder.TcpDiscoveryIpFinder;
 import org.apache.ignite.spi.discovery.tcp.ipfinder.multicast.*;
 import org.apache.ignite.spi.discovery.tcp.messages.*;
 import org.jdk8.backport.*;
@@ -46,7 +47,7 @@
  * &lt;p&gt;
  * This discovery SPI requires at least on server node configured with
  * {@link TcpDiscoverySpi}. It will try to connect to random IP taken from
+ * {@link TcpDiscoveryIpFinder} which should point to one of these server
  * nodes and will maintain connection only with this node (will not enter the ring).
  * If this connection is broken, it will try to reconnect using addresses from
  * the same IP finder.
@@ -381,7 +382,7 @@ public void setDisconnectCheckInterval(long disconnectCheckInt) {
     /**
      * @param recon Reconnect flag.
      * @return Whether joined successfully.
+     * @throws IgniteSpiException In case of error.
      */
     private boolean joinTopology(boolean recon) throws IgniteSpiException {
         if (!recon)
@@ -735,9 +736,9 @@ protected SocketReader(UUID nodeId, MessageWorker msgWrk) {
 
                         stats.onMessageReceived(msg);
 
                         if (joinLatch.getCount() &gt; 0) {
+                            IgniteSpiException err = null;
+
                             if (msg instanceof TcpDiscoveryDuplicateIdMessage)
                                 err = duplicateIdError((TcpDiscoveryDuplicateIdMessage)msg);
                             else if (msg instanceof TcpDiscoveryAuthFailedMessage)
@@ -893,11 +894,11 @@ private void processNodeAddedMessage(TcpDiscoveryNodeAddedMessage msg) {
                         if (msg.topologyHistory() != null)
                             topHist.putAll(msg.topologyHistory());
 
+                        Map&lt;UUID, Map&lt;Integer, Object&gt;&gt; dataMap = msg.oldNodesDiscoveryData();
 
+                        if (dataMap != null) {
+                            for (Map.Entry&lt;UUID, Map&lt;Integer, Object&gt;&gt; entry : dataMap.entrySet())
+                                exchange.onExchange(newNodeId, entry.getKey(), entry.getValue());
                         }
 
                         locNode.setAttributes(node.attributes());
@@ -920,7 +921,7 @@ else if (log.isDebugEnabled())
                     Map&lt;Integer, Object&gt; data = msg.newNodeDiscoveryData();
 
                     if (data != null)
+                        exchange.onExchange(newNodeId, newNodeId, data);
                 }
             }
         }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>361182</refactoring_id><commit_sha>9c09effdef16a292d1f1ffac649669cabd0b7849</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/9c09effdef16a292d1f1ffac649669cabd0b7849</commit_link><file_path>backend/src/it/java/org/camunda/optimize/rest/ReportRestServiceIT.java</file_path><description>Rename Variable report : SingleProcessReportDefinitionDto to singleProcessReportDefinitionDto : SingleProcessReportDefinitionDto in method private addSingleProcessReportWithDefinition(processReportDataDto ProcessReportDataDto, collectionId String) : String from class org.camunda.optimize.rest.ReportRestServiceIT</description><code_before>@@ -137,7 +137,7 @@ public void createNewCombinedReportFromDefinition() {
     combinedReportDefinitionDto.setData(ProcessReportDataBuilderHelper.createCombinedReport());
     IdDto idDto = embeddedOptimizeRule
       .getRequestExecutor()
-      .buildCreateCombinedReportRequestWithDefinition(combinedReportDefinitionDto)
       .execute(IdDto.class, 200);
     // then
     assertThat(idDto, is(notNullValue()));
@@ -188,8 +188,7 @@ public void updateReportWithXml(final ReportType reportType) {
     String id = addEmptyReportToOptimize(reportType);
 
     // when
-    final Response response;
-    response = updateReportWithValidXml(id, reportType);
 
     // then the status code is okay
     assertThat(response.getStatus(), is(204));
@@ -852,15 +851,12 @@ private String createSingleReport(final ReportType reportType, final String coll
   }
 
   private IdDto createAndUpdateCombinedReport(final CombinedReportDataDto combined, final String collectionId) {
-    IdDto id = embeddedOptimizeRule
       .getRequestExecutor()
-      .buildCreateCombinedReportRequest(collectionId)
       .execute(IdDto.class, 200);
-
-    embeddedOptimizeRule.getRequestExecutor()
-      .buildUpdateCombinedProcessReportRequest(id.getId(), new CombinedReportDefinitionDto(combined), true)
-      .execute(204);
-    return id;
   }
 
   private String addReportToOptimizeWithDefinition(final ReportType reportType) {
@@ -895,19 +891,19 @@ private String addSingleDecisionReportWithDefinition(final DecisionReportDataDto
 
   private String addSingleDecisionReportWithDefinition(final DecisionReportDataDto decisionReportDataDto,
                                                        final String collectionId) {
-    SingleDecisionReportDefinitionDto report = new SingleDecisionReportDefinitionDto();
-    report.setData(decisionReportDataDto);
-    report.setId(RANDOM_STRING);
-    report.setLastModifier(RANDOM_STRING);
-    report.setName(RANDOM_STRING);
     OffsetDateTime someDate = OffsetDateTime.now().plusHours(1);
-    report.setCreated(someDate);
-    report.setLastModified(someDate);
-    report.setOwner(RANDOM_STRING);
-    report.setCollectionId(collectionId);
     return embeddedOptimizeRule
       .getRequestExecutor()
-      .buildCreateSingleDecisionReportRequestWithDefinition(report)
       .execute(IdDto.class, 200)
       .getId();
   }
@@ -917,44 +913,42 @@ private String addEmptyProcessReport() {
   }
 
   private String addEmptyProcessReport(final String collectionId) {
     return embeddedOptimizeRule
       .getRequestExecutor()
-      .buildCreateSingleProcessReportRequest(collectionId)
       .execute(IdDto.class, 200)
       .getId();
   }
 
-  private String addSingleProcessReportWithDefinition(final ProcessReportDataDto processReportDataDtoto) {
-    return addSingleProcessReportWithDefinition(processReportDataDtoto, null);
   }
 
   private String addSingleProcessReportWithDefinition(final ProcessReportDataDto processReportDataDto,
                                                       final String collectionId) {
-    SingleProcessReportDefinitionDto report = new SingleProcessReportDefinitionDto();
-    report.setData(processReportDataDto);
-    report.setId(RANDOM_STRING);
-    report.setLastModifier(RANDOM_STRING);
-    report.setName(RANDOM_STRING);
     OffsetDateTime someDate = OffsetDateTime.now().plusHours(1);
-    report.setCreated(someDate);
-    report.setLastModified(someDate);
-    report.setOwner(RANDOM_STRING);
-    report.setCollectionId(collectionId);
     return embeddedOptimizeRule
       .getRequestExecutor()
-      .buildCreateSingleProcessReportRequestWithDefinition(report)
       .execute(IdDto.class, 200)
       .getId();
   }
 
   private String addEmptyDecisionReport() {
-    return addEmptyDecisionReport(null);
-  }
-
-  private String addEmptyDecisionReport(final String collectionId) {
     return embeddedOptimizeRule
       .getRequestExecutor()
-      .buildCreateSingleDecisionReportRequest(collectionId)
       .execute(IdDto.class, 200)
       .getId();
   }
</code_before><code_after>@@ -137,7 +137,7 @@ public void createNewCombinedReportFromDefinition() {
     combinedReportDefinitionDto.setData(ProcessReportDataBuilderHelper.createCombinedReport());
     IdDto idDto = embeddedOptimizeRule
       .getRequestExecutor()
+      .buildCreateCombinedReportRequest(combinedReportDefinitionDto)
       .execute(IdDto.class, 200);
     // then
     assertThat(idDto, is(notNullValue()));
@@ -188,8 +188,7 @@ public void updateReportWithXml(final ReportType reportType) {
     String id = addEmptyReportToOptimize(reportType);
 
     // when
+    final Response response = updateReportWithValidXml(id, reportType);
 
     // then the status code is okay
     assertThat(response.getStatus(), is(204));
@@ -852,15 +851,12 @@ private String createSingleReport(final ReportType reportType, final String coll
   }
 
   private IdDto createAndUpdateCombinedReport(final CombinedReportDataDto combined, final String collectionId) {
+    CombinedReportDefinitionDto combinedReportDefinitionDto = new CombinedReportDefinitionDto(combined);
+    combinedReportDefinitionDto.setCollectionId(collectionId);
+    return embeddedOptimizeRule
       .getRequestExecutor()
+      .buildCreateCombinedReportRequest(combinedReportDefinitionDto)
       .execute(IdDto.class, 200);
   }
 
   private String addReportToOptimizeWithDefinition(final ReportType reportType) {
@@ -895,19 +891,19 @@ private String addSingleDecisionReportWithDefinition(final DecisionReportDataDto
 
   private String addSingleDecisionReportWithDefinition(final DecisionReportDataDto decisionReportDataDto,
                                                        final String collectionId) {
+    SingleDecisionReportDefinitionDto singleDecisionReportDefinitionDto = new SingleDecisionReportDefinitionDto();
+    singleDecisionReportDefinitionDto.setData(decisionReportDataDto);
+    singleDecisionReportDefinitionDto.setId(RANDOM_STRING);
+    singleDecisionReportDefinitionDto.setLastModifier(RANDOM_STRING);
+    singleDecisionReportDefinitionDto.setName(RANDOM_STRING);
     OffsetDateTime someDate = OffsetDateTime.now().plusHours(1);
+    singleDecisionReportDefinitionDto.setCreated(someDate);
+    singleDecisionReportDefinitionDto.setLastModified(someDate);
+    singleDecisionReportDefinitionDto.setOwner(RANDOM_STRING);
+    singleDecisionReportDefinitionDto.setCollectionId(collectionId);
     return embeddedOptimizeRule
       .getRequestExecutor()
+      .buildCreateSingleDecisionReportRequest(singleDecisionReportDefinitionDto)
       .execute(IdDto.class, 200)
       .getId();
   }
@@ -917,44 +913,42 @@ private String addEmptyProcessReport() {
   }
 
   private String addEmptyProcessReport(final String collectionId) {
+    SingleProcessReportDefinitionDto singleProcessReportDefinitionDto = new SingleProcessReportDefinitionDto();
+    singleProcessReportDefinitionDto.setCollectionId(collectionId);
     return embeddedOptimizeRule
       .getRequestExecutor()
+      .buildCreateSingleProcessReportRequest(singleProcessReportDefinitionDto)
       .execute(IdDto.class, 200)
       .getId();
   }
 
+  private String addSingleProcessReportWithDefinition(final ProcessReportDataDto processReportDataDto) {
+    return addSingleProcessReportWithDefinition(processReportDataDto, null);
   }
 
   private String addSingleProcessReportWithDefinition(final ProcessReportDataDto processReportDataDto,
                                                       final String collectionId) {
+    SingleProcessReportDefinitionDto singleProcessReportDefinitionDto = new SingleProcessReportDefinitionDto();
+    singleProcessReportDefinitionDto.setData(processReportDataDto);
+    singleProcessReportDefinitionDto.setId(RANDOM_STRING);
+    singleProcessReportDefinitionDto.setLastModifier(RANDOM_STRING);
+    singleProcessReportDefinitionDto.setName(RANDOM_STRING);
     OffsetDateTime someDate = OffsetDateTime.now().plusHours(1);
+    singleProcessReportDefinitionDto.setCreated(someDate);
+    singleProcessReportDefinitionDto.setLastModified(someDate);
+    singleProcessReportDefinitionDto.setOwner(RANDOM_STRING);
+    singleProcessReportDefinitionDto.setCollectionId(collectionId);
     return embeddedOptimizeRule
       .getRequestExecutor()
+      .buildCreateSingleProcessReportRequest(singleProcessReportDefinitionDto)
       .execute(IdDto.class, 200)
       .getId();
   }
 
   private String addEmptyDecisionReport() {
     return embeddedOptimizeRule
       .getRequestExecutor()
+      .buildCreateSingleDecisionReportRequest()
       .execute(IdDto.class, 200)
       .getId();
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>440340</refactoring_id><commit_sha>8cb942393ce15efb5f6fbc9f594287c30971c296</commit_sha><commit_link>https://github.com/apache/ambari/commit/8cb942393ce15efb5f6fbc9f594287c30971c296</commit_link><file_path>ambari-server/src/main/java/org/apache/ambari/server/controller/internal/AbstractProviderModule.java</file_path><description>Rename Variable hostComponents : Set&lt;Resource&gt; to serviceComponentHosts : List&lt;ServiceComponentHost&gt; in method private initProviderMaps() : void from class org.apache.ambari.server.controller.internal.AbstractProviderModule</description><code_before>@@ -67,6 +67,9 @@
 import org.apache.ambari.server.state.DesiredConfig;
 import org.apache.ambari.server.state.Host;
 import org.apache.ambari.server.state.Service;
 import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -244,6 +247,8 @@ public abstract class AbstractProviderModule implements ProviderModule,
   @Inject
   protected AmbariEventPublisher eventPublisher;
 
 
   /**
    * The map of host components.
@@ -258,8 +263,7 @@ public abstract class AbstractProviderModule implements ProviderModule,
   /**
    * JMX ports read from the configs
    */
-  private final Map&lt;String, ConcurrentMap&lt;String, ConcurrentMap&lt;String, String&gt;&gt; &gt;jmxPortMap =
-      Collections.synchronizedMap(new HashMap&lt;String, ConcurrentMap&lt;String, ConcurrentMap&lt;String, String&gt;&gt;&gt;());
 
   private volatile boolean initialized = false;
 
@@ -517,16 +521,19 @@ public String getPort(String clusterName, String componentName, String hostName)
   @Override
   public String getPort(String clusterName, String componentName, String hostName, boolean httpsEnabled) throws SystemException {
     // Parent map need not be synchronized
-    ConcurrentMap&lt;String, ConcurrentMap&lt;String, String&gt;&gt; clusterJmxPorts = jmxPortMap.get(clusterName);
-    if (clusterJmxPorts == null) {
       synchronized (jmxPortMap) {
-        clusterJmxPorts = jmxPortMap.get(clusterName);
-        if (clusterJmxPorts == null) {
           clusterJmxPorts = new ConcurrentHashMap&lt;&gt;();
           jmxPortMap.put(clusterName, clusterJmxPorts);
         }
       }
     }
     Service.Type service = componentServiceMap.get(componentName);
 
     if (service != null) {
@@ -858,49 +865,34 @@ private void resetInit() {
     }
   }
 
   private void initProviderMaps() throws SystemException {
-    ResourceProvider provider = getResourceProvider(Resource.Type.Cluster);
-
-    Set&lt;String&gt; propertyIds = new HashSet&lt;&gt;();
-    propertyIds.add(ClusterResourceProvider.CLUSTER_NAME_PROPERTY_ID);
-
-    Map&lt;String, String&gt; requestInfoProperties = new HashMap&lt;&gt;();
-    requestInfoProperties.put(ClusterResourceProvider.GET_IGNORE_PERMISSIONS_PROPERTY_ID, "true");
-
-    Request request = PropertyHelper.getReadRequest(propertyIds,
-        requestInfoProperties, null, null, null);
-
-    try {
-      jmxPortMap.clear();
-      Set&lt;Resource&gt; clusters = provider.getResources(request, null);
-
-      clusterHostComponentMap = new HashMap&lt;&gt;();
-      clusterGangliaCollectorMap = new HashMap&lt;&gt;();
 
-      for (Resource cluster : clusters) {
 
-        String clusterName = (String) cluster.getPropertyValue(CLUSTER_NAME_PROPERTY_ID);
-
-        // initialize the host component map and Ganglia server from the known hosts components...
-        provider = getResourceProvider(Resource.Type.HostComponent);
-
-        request = PropertyHelper.getReadRequest(HOST_COMPONENT_HOST_NAME_PROPERTY_ID,
-            HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID);
 
-        Predicate predicate = new PredicateBuilder().property(HOST_COMPONENT_CLUSTER_NAME_PROPERTY_ID).
-            equals(clusterName).toPredicate();
 
-        Set&lt;Resource&gt; hostComponents = provider.getResources(request, predicate);
-        Map&lt;String, String&gt; hostComponentMap = clusterHostComponentMap.get(clusterName);
 
-        if (hostComponentMap == null) {
-          hostComponentMap = new HashMap&lt;&gt;();
-          clusterHostComponentMap.put(clusterName, hostComponentMap);
-        }
 
-        for (Resource hostComponent : hostComponents) {
-          String componentName = (String) hostComponent.getPropertyValue(HOST_COMPONENT_COMPONENT_NAME_PROPERTY_ID);
-          String hostName = (String) hostComponent.getPropertyValue(HOST_COMPONENT_HOST_NAME_PROPERTY_ID);
 
           hostComponentMap.put(componentName, hostName);
 
@@ -910,26 +902,11 @@ private void initProviderMaps() throws SystemException {
           }
           if (componentName.equals(METRIC_SERVER)) {
             //  If current collector host is null or if the host or the host component not live
-            //    Update clusterMetricCollectorMap.
             metricsCollectorHAManager.addCollectorHost(clusterName, hostName);
           }
         }
       }
-    } catch (UnsupportedPropertyException e) {
-      if (LOG.isErrorEnabled()) {
-        LOG.error("Caught UnsupportedPropertyException while trying to get the host mappings.", e);
-      }
-      throw new SystemException("An exception occurred while initializing the host mappings: " + e, e);
-    } catch (NoSuchResourceException e) {
-      if (LOG.isErrorEnabled()) {
-        LOG.error("Caught NoSuchResourceException exception while trying to get the host mappings.", e);
-      }
-      throw new SystemException("An exception occurred while initializing the host mappings: " + e, e);
-    } catch (NoSuchParentResourceException e) {
-      if (LOG.isErrorEnabled()) {
-        LOG.error("Caught NoSuchParentResourceException exception while trying to get the host mappings.", e);
-      }
-      throw new SystemException("An exception occurred while initializing the host mappings: " + e, e);
     }
   }
 
</code_before><code_after>@@ -67,6 +67,9 @@
 import org.apache.ambari.server.state.DesiredConfig;
 import org.apache.ambari.server.state.Host;
 import org.apache.ambari.server.state.Service;
+import org.apache.ambari.server.state.ServiceComponentHost;
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.MapUtils;
 import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -244,6 +247,8 @@ public abstract class AbstractProviderModule implements ProviderModule,
   @Inject
   protected AmbariEventPublisher eventPublisher;
 
+  @Inject
+  private Clusters clusters;
 
   /**
    * The map of host components.
@@ -258,8 +263,7 @@ public abstract class AbstractProviderModule implements ProviderModule,
   /**
    * JMX ports read from the configs
    */
+  private final Map&lt;String, ConcurrentMap&lt;String, ConcurrentMap&lt;String, String&gt;&gt;&gt; jmxPortMap = new ConcurrentHashMap&lt;&gt;(1);
 
   private volatile boolean initialized = false;
 
@@ -517,16 +521,19 @@ public String getPort(String clusterName, String componentName, String hostName)
   @Override
   public String getPort(String clusterName, String componentName, String hostName, boolean httpsEnabled) throws SystemException {
     // Parent map need not be synchronized
+    ConcurrentMap&lt;String, ConcurrentMap&lt;String, String&gt;&gt; clusterJmxPorts;
+    // Still need double check to ensure single init
+    if (!jmxPortMap.containsKey(clusterName)) {
       synchronized (jmxPortMap) {
+        if (!jmxPortMap.containsKey(clusterName)) {
           clusterJmxPorts = new ConcurrentHashMap&lt;&gt;();
           jmxPortMap.put(clusterName, clusterJmxPorts);
         }
       }
     }
+
+    clusterJmxPorts = jmxPortMap.get(clusterName);
+
     Service.Type service = componentServiceMap.get(componentName);
 
     if (service != null) {
@@ -858,49 +865,34 @@ private void resetInit() {
     }
   }
 
+  // TODO: Fix for multi-service feature support (trunk)
+  // Called from a synchornized block !
   private void initProviderMaps() throws SystemException {
 
+    jmxPortMap.clear();
+    clusterHostComponentMap = new HashMap&lt;&gt;();
+    clusterGangliaCollectorMap = new HashMap&lt;&gt;();
 
+    Map&lt;String, Cluster&gt; clusterMap = clusters.getClusters();
+    if (MapUtils.isEmpty(clusterMap)) {
+      return;
+    }
 
+    for (Cluster cluster : clusterMap.values()) {
+      String clusterName = cluster.getClusterName();
 
+      Map&lt;String, String&gt; hostComponentMap = clusterHostComponentMap.get(clusterName);
+      if (hostComponentMap == null) {
+        hostComponentMap = new HashMap&lt;&gt;();
+        clusterHostComponentMap.put(clusterName, hostComponentMap);
+      }
 
+      List&lt;ServiceComponentHost&gt; serviceComponentHosts = cluster.getServiceComponentHosts();
 
+      if (!CollectionUtils.isEmpty(serviceComponentHosts)) {
+        for (ServiceComponentHost sch : serviceComponentHosts) {
+          String componentName = sch.getServiceComponentName();
+          String hostName = sch.getHostName();
 
           hostComponentMap.put(componentName, hostName);
 
@@ -910,26 +902,11 @@ private void initProviderMaps() throws SystemException {
           }
           if (componentName.equals(METRIC_SERVER)) {
             //  If current collector host is null or if the host or the host component not live
+            //  Update clusterMetricCollectorMap.
             metricsCollectorHAManager.addCollectorHost(clusterName, hostName);
           }
         }
       }
     }
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>388658</refactoring_id><commit_sha>c6252ab81762f561a2b62b0a22932ad60397085e</commit_sha><commit_link>https://github.com/apache/beam/commit/c6252ab81762f561a2b62b0a22932ad60397085e</commit_link><file_path>sdks/java/core/src/test/java/org/apache/beam/sdk/AggregatorPipelineExtractorTest.java</file_path><description>Rename Variable otherBound : ParDo.BoundMulti to otherParDo : ParDo.BoundMulti in method public testGetAggregatorStepsWithDifferentStepsAddsSteps() : void from class org.apache.beam.sdk.AggregatorPipelineExtractorTest</description><code_before>@@ -64,17 +64,17 @@ public void setup() {
 
   @SuppressWarnings("unchecked")
   @Test
-  public void testGetAggregatorStepsWithParDoBoundExtractsSteps() {
     @SuppressWarnings("rawtypes")
-    ParDo.Bound bound = mock(ParDo.Bound.class, "Bound");
     AggregatorProvidingDoFn&lt;ThreadGroup, StrictMath&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
-    when(bound.getFn()).thenReturn(fn);
 
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Sum.ofLongs());
     Aggregator&lt;Integer, Integer&gt; aggregatorTwo = fn.addAggregator(Min.ofIntegers());
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
-    when(transformNode.getTransform()).thenReturn(bound);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode)))
         .when(p)
@@ -85,24 +85,24 @@ public void testGetAggregatorStepsWithParDoBoundExtractsSteps() {
     Map&lt;Aggregator&lt;?, ?&gt;, Collection&lt;PTransform&lt;?, ?&gt;&gt;&gt; aggregatorSteps =
         extractor.getAggregatorSteps();
 
-    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(bound), aggregatorSteps.get(aggregatorOne));
-    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(bound), aggregatorSteps.get(aggregatorTwo));
     assertEquals(aggregatorSteps.size(), 2);
   }
 
   @SuppressWarnings("unchecked")
   @Test
   public void testGetAggregatorStepsWithParDoBoundMultiExtractsSteps() {
     @SuppressWarnings("rawtypes")
-    ParDo.BoundMulti bound = mock(ParDo.BoundMulti.class, "BoundMulti");
     AggregatorProvidingDoFn&lt;Object, Void&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
-    when(bound.getFn()).thenReturn(fn);
 
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Max.ofLongs());
     Aggregator&lt;Double, Double&gt; aggregatorTwo = fn.addAggregator(Min.ofDoubles());
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
-    when(transformNode.getTransform()).thenReturn(bound);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode)))
         .when(p)
@@ -113,29 +113,29 @@ public void testGetAggregatorStepsWithParDoBoundMultiExtractsSteps() {
     Map&lt;Aggregator&lt;?, ?&gt;, Collection&lt;PTransform&lt;?, ?&gt;&gt;&gt; aggregatorSteps =
         extractor.getAggregatorSteps();
 
-    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(bound), aggregatorSteps.get(aggregatorOne));
-    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(bound), aggregatorSteps.get(aggregatorTwo));
     assertEquals(2, aggregatorSteps.size());
   }
 
   @SuppressWarnings("unchecked")
   @Test
   public void testGetAggregatorStepsWithOneAggregatorInMultipleStepsAddsSteps() {
     @SuppressWarnings("rawtypes")
-    ParDo.Bound bound = mock(ParDo.Bound.class, "Bound");
     @SuppressWarnings("rawtypes")
-    ParDo.BoundMulti otherBound = mock(ParDo.BoundMulti.class, "otherBound");
     AggregatorProvidingDoFn&lt;String, Math&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
-    when(bound.getFn()).thenReturn(fn);
-    when(otherBound.getFn()).thenReturn(fn);
 
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Sum.ofLongs());
     Aggregator&lt;Double, Double&gt; aggregatorTwo = fn.addAggregator(Min.ofDoubles());
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
-    when(transformNode.getTransform()).thenReturn(bound);
     TransformHierarchy.Node otherTransformNode = mock(TransformHierarchy.Node.class);
-    when(otherTransformNode.getTransform()).thenReturn(otherBound);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode, otherTransformNode)))
         .when(p)
@@ -147,35 +147,35 @@ public void testGetAggregatorStepsWithOneAggregatorInMultipleStepsAddsSteps() {
         extractor.getAggregatorSteps();
 
     assertEquals(
-        ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(bound, otherBound), aggregatorSteps.get(aggregatorOne));
     assertEquals(
-        ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(bound, otherBound), aggregatorSteps.get(aggregatorTwo));
     assertEquals(2, aggregatorSteps.size());
   }
 
   @SuppressWarnings("unchecked")
   @Test
   public void testGetAggregatorStepsWithDifferentStepsAddsSteps() {
     @SuppressWarnings("rawtypes")
-    ParDo.Bound bound = mock(ParDo.Bound.class, "Bound");
 
     AggregatorProvidingDoFn&lt;ThreadGroup, Void&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Sum.ofLongs());
 
-    when(bound.getFn()).thenReturn(fn);
 
     @SuppressWarnings("rawtypes")
-    ParDo.BoundMulti otherBound = mock(ParDo.BoundMulti.class, "otherBound");
 
     AggregatorProvidingDoFn&lt;Long, Long&gt; otherFn = new AggregatorProvidingDoFn&lt;&gt;();
     Aggregator&lt;Double, Double&gt; aggregatorTwo = otherFn.addAggregator(Sum.ofDoubles());
 
-    when(otherBound.getFn()).thenReturn(otherFn);
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
-    when(transformNode.getTransform()).thenReturn(bound);
     TransformHierarchy.Node otherTransformNode = mock(TransformHierarchy.Node.class);
-    when(otherTransformNode.getTransform()).thenReturn(otherBound);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode, otherTransformNode)))
         .when(p)
@@ -186,8 +186,8 @@ public void testGetAggregatorStepsWithDifferentStepsAddsSteps() {
     Map&lt;Aggregator&lt;?, ?&gt;, Collection&lt;PTransform&lt;?, ?&gt;&gt;&gt; aggregatorSteps =
         extractor.getAggregatorSteps();
 
-    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(bound), aggregatorSteps.get(aggregatorOne));
-    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(otherBound), aggregatorSteps.get(aggregatorTwo));
     assertEquals(2, aggregatorSteps.size());
   }
 
</code_before><code_after>@@ -64,17 +64,17 @@ public void setup() {
 
   @SuppressWarnings("unchecked")
   @Test
+  public void testGetAggregatorStepsWithParDoSingleOutputExtractsSteps() {
     @SuppressWarnings("rawtypes")
+    ParDo.SingleOutput parDo = mock(ParDo.SingleOutput.class, "parDo");
     AggregatorProvidingDoFn&lt;ThreadGroup, StrictMath&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
+    when(parDo.getFn()).thenReturn(fn);
 
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Sum.ofLongs());
     Aggregator&lt;Integer, Integer&gt; aggregatorTwo = fn.addAggregator(Min.ofIntegers());
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
+    when(transformNode.getTransform()).thenReturn(parDo);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode)))
         .when(p)
@@ -85,24 +85,24 @@ public void testGetAggregatorStepsWithParDoBoundExtractsSteps() {
     Map&lt;Aggregator&lt;?, ?&gt;, Collection&lt;PTransform&lt;?, ?&gt;&gt;&gt; aggregatorSteps =
         extractor.getAggregatorSteps();
 
+    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(parDo), aggregatorSteps.get(aggregatorOne));
+    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(parDo), aggregatorSteps.get(aggregatorTwo));
     assertEquals(aggregatorSteps.size(), 2);
   }
 
   @SuppressWarnings("unchecked")
   @Test
   public void testGetAggregatorStepsWithParDoBoundMultiExtractsSteps() {
     @SuppressWarnings("rawtypes")
+    ParDo.BoundMulti parDo = mock(ParDo.BoundMulti.class, "parDo");
     AggregatorProvidingDoFn&lt;Object, Void&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
+    when(parDo.getFn()).thenReturn(fn);
 
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Max.ofLongs());
     Aggregator&lt;Double, Double&gt; aggregatorTwo = fn.addAggregator(Min.ofDoubles());
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
+    when(transformNode.getTransform()).thenReturn(parDo);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode)))
         .when(p)
@@ -113,29 +113,29 @@ public void testGetAggregatorStepsWithParDoBoundMultiExtractsSteps() {
     Map&lt;Aggregator&lt;?, ?&gt;, Collection&lt;PTransform&lt;?, ?&gt;&gt;&gt; aggregatorSteps =
         extractor.getAggregatorSteps();
 
+    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(parDo), aggregatorSteps.get(aggregatorOne));
+    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(parDo), aggregatorSteps.get(aggregatorTwo));
     assertEquals(2, aggregatorSteps.size());
   }
 
   @SuppressWarnings("unchecked")
   @Test
   public void testGetAggregatorStepsWithOneAggregatorInMultipleStepsAddsSteps() {
     @SuppressWarnings("rawtypes")
+    ParDo.SingleOutput parDo = mock(ParDo.SingleOutput.class, "parDo");
     @SuppressWarnings("rawtypes")
+    ParDo.BoundMulti otherParDo = mock(ParDo.BoundMulti.class, "otherParDo");
     AggregatorProvidingDoFn&lt;String, Math&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
+    when(parDo.getFn()).thenReturn(fn);
+    when(otherParDo.getFn()).thenReturn(fn);
 
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Sum.ofLongs());
     Aggregator&lt;Double, Double&gt; aggregatorTwo = fn.addAggregator(Min.ofDoubles());
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
+    when(transformNode.getTransform()).thenReturn(parDo);
     TransformHierarchy.Node otherTransformNode = mock(TransformHierarchy.Node.class);
+    when(otherTransformNode.getTransform()).thenReturn(otherParDo);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode, otherTransformNode)))
         .when(p)
@@ -147,35 +147,35 @@ public void testGetAggregatorStepsWithOneAggregatorInMultipleStepsAddsSteps() {
         extractor.getAggregatorSteps();
 
     assertEquals(
+        ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(parDo, otherParDo), aggregatorSteps.get(aggregatorOne));
     assertEquals(
+        ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(parDo, otherParDo), aggregatorSteps.get(aggregatorTwo));
     assertEquals(2, aggregatorSteps.size());
   }
 
   @SuppressWarnings("unchecked")
   @Test
   public void testGetAggregatorStepsWithDifferentStepsAddsSteps() {
     @SuppressWarnings("rawtypes")
+    ParDo.SingleOutput parDo = mock(ParDo.SingleOutput.class, "parDo");
 
     AggregatorProvidingDoFn&lt;ThreadGroup, Void&gt; fn = new AggregatorProvidingDoFn&lt;&gt;();
     Aggregator&lt;Long, Long&gt; aggregatorOne = fn.addAggregator(Sum.ofLongs());
 
+    when(parDo.getFn()).thenReturn(fn);
 
     @SuppressWarnings("rawtypes")
+    ParDo.BoundMulti otherParDo = mock(ParDo.BoundMulti.class, "otherParDo");
 
     AggregatorProvidingDoFn&lt;Long, Long&gt; otherFn = new AggregatorProvidingDoFn&lt;&gt;();
     Aggregator&lt;Double, Double&gt; aggregatorTwo = otherFn.addAggregator(Sum.ofDoubles());
 
+    when(otherParDo.getFn()).thenReturn(otherFn);
 
     TransformHierarchy.Node transformNode = mock(TransformHierarchy.Node.class);
+    when(transformNode.getTransform()).thenReturn(parDo);
     TransformHierarchy.Node otherTransformNode = mock(TransformHierarchy.Node.class);
+    when(otherTransformNode.getTransform()).thenReturn(otherParDo);
 
     doAnswer(new VisitNodesAnswer(ImmutableList.of(transformNode, otherTransformNode)))
         .when(p)
@@ -186,8 +186,8 @@ public void testGetAggregatorStepsWithDifferentStepsAddsSteps() {
     Map&lt;Aggregator&lt;?, ?&gt;, Collection&lt;PTransform&lt;?, ?&gt;&gt;&gt; aggregatorSteps =
         extractor.getAggregatorSteps();
 
+    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(parDo), aggregatorSteps.get(aggregatorOne));
+    assertEquals(ImmutableSet.&lt;PTransform&lt;?, ?&gt;&gt;of(otherParDo), aggregatorSteps.get(aggregatorTwo));
     assertEquals(2, aggregatorSteps.size());
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>399945</refactoring_id><commit_sha>37e150c0755c0efba609601b1122cd6bc8a271fb</commit_sha><commit_link>https://github.com/apache/druid/commit/37e150c0755c0efba609601b1122cd6bc8a271fb</commit_link><file_path>processing/src/test/java/org/apache/druid/segment/join/HashJoinSegmentTest.java</file_path><description>Rename Variable joinFilterPreAnalysis : JoinFilterPreAnalysis to joinFilterPreAnalysisGroup : JoinFilterPreAnalysisGroup in method public test_constructor_noClauses() : void from class org.apache.druid.segment.join.HashJoinSegmentTest</description><code_before>@@ -28,10 +28,8 @@
 import org.apache.druid.segment.ReferenceCountingSegment;
 import org.apache.druid.segment.SegmentReference;
 import org.apache.druid.segment.StorageAdapter;
-import org.apache.druid.segment.VirtualColumns;
-import org.apache.druid.segment.join.filter.JoinFilterAnalyzer;
-import org.apache.druid.segment.join.filter.JoinFilterPreAnalysis;
-import org.apache.druid.segment.join.filter.JoinableClauses;
 import org.apache.druid.segment.join.table.IndexedTableJoinable;
 import org.apache.druid.testing.InitializedNullHandlingTest;
 import org.apache.druid.timeline.SegmentId;
@@ -52,6 +50,13 @@
 
 public class HashJoinSegmentTest extends InitializedNullHandlingTest
 {
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
 
@@ -129,14 +134,9 @@ public Optional&lt;Closeable&gt; acquireReferences()
         )
     );
 
-    JoinFilterPreAnalysis joinFilterPreAnalysis = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(
-        JoinableClauses.fromList(joinableClauses),
-        VirtualColumns.EMPTY,
-        null,
-        true,
-        true,
-        true,
-        QueryContexts.DEFAULT_ENABLE_JOIN_FILTER_REWRITE_MAX_SIZE
     );
 
     referencedSegment = ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment);
@@ -188,7 +188,7 @@ public void close()
     hashJoinSegment = new HashJoinSegment(
         testWrapper,
         joinableClauses,
-        joinFilterPreAnalysis
     )
     {
       @Override
@@ -213,20 +213,15 @@ public void test_constructor_noClauses()
 
     List&lt;JoinableClause&gt; joinableClauses = ImmutableList.of();
 
-    JoinFilterPreAnalysis joinFilterPreAnalysis = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(
-        JoinableClauses.fromList(joinableClauses),
-        VirtualColumns.EMPTY,
-        null,
-        true,
-        true,
-        true,
-        QueryContexts.DEFAULT_ENABLE_JOIN_FILTER_REWRITE_MAX_SIZE
     );
 
     final HashJoinSegment ignored = new HashJoinSegment(
         ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),
         joinableClauses,
-        joinFilterPreAnalysis
     );
   }
 
</code_before><code_after>@@ -28,10 +28,8 @@
 import org.apache.druid.segment.ReferenceCountingSegment;
 import org.apache.druid.segment.SegmentReference;
 import org.apache.druid.segment.StorageAdapter;
+import org.apache.druid.segment.join.filter.rewrite.JoinFilterPreAnalysisGroup;
+import org.apache.druid.segment.join.filter.rewrite.JoinFilterRewriteConfig;
 import org.apache.druid.segment.join.table.IndexedTableJoinable;
 import org.apache.druid.testing.InitializedNullHandlingTest;
 import org.apache.druid.timeline.SegmentId;
@@ -52,6 +50,13 @@
 
 public class HashJoinSegmentTest extends InitializedNullHandlingTest
 {
+  private JoinFilterRewriteConfig DEFAULT_JOIN_FILTER_REWRITE_CONFIG = new JoinFilterRewriteConfig(
+      true,
+      true,
+      true,
+      QueryContexts.DEFAULT_ENABLE_JOIN_FILTER_REWRITE_MAX_SIZE
+  );
+
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
 
@@ -129,14 +134,9 @@ public Optional&lt;Closeable&gt; acquireReferences()
         )
     );
 
+    JoinFilterPreAnalysisGroup joinFilterPreAnalysisGroup = new JoinFilterPreAnalysisGroup(
+        DEFAULT_JOIN_FILTER_REWRITE_CONFIG,
+        true
     );
 
     referencedSegment = ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment);
@@ -188,7 +188,7 @@ public void close()
     hashJoinSegment = new HashJoinSegment(
         testWrapper,
         joinableClauses,
+        joinFilterPreAnalysisGroup
     )
     {
       @Override
@@ -213,20 +213,15 @@ public void test_constructor_noClauses()
 
     List&lt;JoinableClause&gt; joinableClauses = ImmutableList.of();
 
+    JoinFilterPreAnalysisGroup joinFilterPreAnalysisGroup = new JoinFilterPreAnalysisGroup(
+        DEFAULT_JOIN_FILTER_REWRITE_CONFIG,
+        true
     );
 
     final HashJoinSegment ignored = new HashJoinSegment(
         ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),
         joinableClauses,
+        joinFilterPreAnalysisGroup
     );
   }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>419937</refactoring_id><commit_sha>8d80166aaf0c4cf0ee43ef3e9e226c585aa52d49</commit_sha><commit_link>https://github.com/spring-projects/spring-security/commit/8d80166aaf0c4cf0ee43ef3e9e226c585aa52d49</commit_link><file_path>ldap/src/integration-test/java/org/springframework/security/ldap/DefaultSpringSecurityContextSourceTests.java</file_path><description>Rename Variable e : Exception to ex : Exception in method public cantBindWithWrongPasswordImmediatelyAfterSuccessfulBind() : void from class org.springframework.security.ldap.DefaultSpringSecurityContextSourceTests</description><code_before>@@ -85,7 +85,7 @@ public void cantBindWithWrongPasswordImmediatelyAfterSuccessfulBind() throws Exc
 		try {
 			ctx = this.contextSource.getContext("uid=Bob,ou=people,dc=springframework,dc=org", "bobspassword");
 		}
-		catch (Exception e) {
 		}
 		assertThat(ctx).isNotNull();
 		// com.sun.jndi.ldap.LdapPoolManager.showStats(System.out);
</code_before><code_after>@@ -85,7 +85,7 @@ public void cantBindWithWrongPasswordImmediatelyAfterSuccessfulBind() throws Exc
 		try {
 			ctx = this.contextSource.getContext("uid=Bob,ou=people,dc=springframework,dc=org", "bobspassword");
 		}
+		catch (Exception ex) {
 		}
 		assertThat(ctx).isNotNull();
 		// com.sun.jndi.ldap.LdapPoolManager.showStats(System.out);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>364879</refactoring_id><commit_sha>b6a7e4b3c300d703c1c69807c10b8e9d18a599f4</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/b6a7e4b3c300d703c1c69807c10b8e9d18a599f4</commit_link><file_path>src/main/java/mekanism/client/render/tileentity/RenderNutritionalLiquifier.java</file_path><description>Rename Variable f5 : float to minV : float in method public render(matrix Matrix4f, buffer VertexConsumer, partialTicks float, light int) : void from class mekanism.client.render.tileentity.RenderNutritionalLiquifier.PseudoParticle</description><code_before>@@ -242,30 +242,26 @@ public void render(Matrix4f matrix, VertexConsumer buffer, float partialTicks, i
                 vector3f.add(f, f1, f2);
             }
 
-            float f7 = this.getU0();
-            float f8 = this.getU1();
-            float f5 = this.getV0();
-            float f6 = this.getV1();
-            buffer.vertex(matrix, vectors[0].x(), vectors[0].y(), vectors[0].z())
-                  .uv(f8, f6)
-                  .color(0xFF, 0xFF, 0xFF, 0xFF)
-                  .uv2(light)
-                  .endVertex();
-            buffer.vertex(matrix, vectors[1].x(), vectors[1].y(), vectors[1].z())
-                  .uv(f8, f5)
-                  .color(0xFF, 0xFF, 0xFF, 0xFF)
-                  .uv2(light)
-                  .endVertex();
-            buffer.vertex(matrix, vectors[2].x(), vectors[2].y(), vectors[2].z())
-                  .uv(f7, f5)
-                  .color(0xFF, 0xFF, 0xFF, 0xFF)
-                  .uv2(light)
-                  .endVertex();
-            buffer.vertex(matrix, vectors[3].x(), vectors[3].y(), vectors[3].z())
-                  .uv(f7, f6)
-                  .color(0xFF, 0xFF, 0xFF, 0xFF)
-                  .uv2(light)
-                  .endVertex();
         }
 
         protected float getU0() {
</code_before><code_after>@@ -242,30 +242,26 @@ public void render(Matrix4f matrix, VertexConsumer buffer, float partialTicks, i
                 vector3f.add(f, f1, f2);
             }
 
+            float minU = this.getU0();
+            float maxU = this.getU1();
+            float minV = this.getV0();
+            float maxV = this.getV1();
+            buffer.addVertex(matrix, vectors[0].x(), vectors[0].y(), vectors[0].z())
+                  .setUv(maxU, maxV)
+                  .setColor(0xFF, 0xFF, 0xFF, 0xFF)
+                  .setLight(light);
+            buffer.addVertex(matrix, vectors[1].x(), vectors[1].y(), vectors[1].z())
+                  .setUv(maxU, minV)
+                  .setColor(0xFF, 0xFF, 0xFF, 0xFF)
+                  .setLight(light);
+            buffer.addVertex(matrix, vectors[2].x(), vectors[2].y(), vectors[2].z())
+                  .setUv(minU, minV)
+                  .setColor(0xFF, 0xFF, 0xFF, 0xFF)
+                  .setLight(light);
+            buffer.addVertex(matrix, vectors[3].x(), vectors[3].y(), vectors[3].z())
+                  .setUv(minU, maxV)
+                  .setColor(0xFF, 0xFF, 0xFF, 0xFF)
+                  .setLight(light);
         }
 
         protected float getU0() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>342043</refactoring_id><commit_sha>aa1f15bddbf56b1ed9c79851c7d664beb5994565</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/aa1f15bddbf56b1ed9c79851c7d664beb5994565</commit_link><file_path>spring-boot-starter/starter/src/test/java/org/camunda/bpm/spring/boot/starter/TelemetryNonPaIT.java</file_path><description>Rename Variable telemetryRegistry : TelemetryRegistry to diagnosticsRegistry : DiagnosticsRegistry in method public shouldSubmitApplicationServerData() : void from class org.camunda.bpm.spring.boot.starter.TelemetryNonPaIT</description><code_before>@@ -21,8 +21,8 @@
 import java.util.Set;
 
 import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;
-import org.camunda.bpm.engine.impl.telemetry.CamundaIntegration;
-import org.camunda.bpm.engine.impl.telemetry.TelemetryRegistry;
 import org.camunda.bpm.engine.impl.telemetry.dto.ApplicationServerImpl;
 import org.camunda.bpm.engine.impl.telemetry.dto.TelemetryDataImpl;
 import org.camunda.bpm.spring.boot.starter.test.nonpa.TestApplication;
@@ -41,10 +41,10 @@ public class TelemetryNonPaIT extends AbstractCamundaAutoConfigurationIT {
 
   @Test
   public void shouldSubmitApplicationServerData() {
-    TelemetryRegistry telemetryRegistry = processEngine.getProcessEngineConfiguration().getTelemetryRegistry();
 
     // then
-    ApplicationServerImpl applicationServer = telemetryRegistry.getApplicationServer();
     assertThat(applicationServer).isNotNull();
     assertThat(applicationServer.getVendor()).isEqualTo("Apache Tomcat");
     assertThat(applicationServer.getVersion()).isNotNull();
</code_before><code_after>@@ -21,8 +21,8 @@
 import java.util.Set;
 
 import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;
+import org.camunda.bpm.engine.impl.diagnostics.CamundaIntegration;
+import org.camunda.bpm.engine.impl.diagnostics.DiagnosticsRegistry;
 import org.camunda.bpm.engine.impl.telemetry.dto.ApplicationServerImpl;
 import org.camunda.bpm.engine.impl.telemetry.dto.TelemetryDataImpl;
 import org.camunda.bpm.spring.boot.starter.test.nonpa.TestApplication;
@@ -41,10 +41,10 @@ public class TelemetryNonPaIT extends AbstractCamundaAutoConfigurationIT {
 
   @Test
   public void shouldSubmitApplicationServerData() {
+    DiagnosticsRegistry diagnosticsRegistry = ((ProcessEngineConfigurationImpl) processEngine.getProcessEngineConfiguration()).getDiagnosticsRegistry();
 
     // then
+    ApplicationServerImpl applicationServer = diagnosticsRegistry.getApplicationServer();
     assertThat(applicationServer).isNotNull();
     assertThat(applicationServer.getVendor()).isEqualTo("Apache Tomcat");
     assertThat(applicationServer.getVersion()).isNotNull();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>439517</refactoring_id><commit_sha>a7b6996b85f28295f92266486096af33b10eebe6</commit_sha><commit_link>https://github.com/h2database/h2database/commit/a7b6996b85f28295f92266486096af33b10eebe6</commit_link><file_path>h2/src/test/org/h2/test/unit/TestMathUtils.java</file_path><description>Rename Variable LARGEST_POW2 : int to largestPower2 : int in method private testNextPowerOf2Int() : void from class org.h2.test.unit.TestMathUtils</description><code_before>@@ -51,11 +51,11 @@ private void testRandom() {
 
     private void testNextPowerOf2Int() {
         // the largest power of two that fits into an integer
-        final int LARGEST_POW2 = 0x40000000;
         int[] testValues = { 0, 1, 2, 3, 4, 12, 17, 500, 1023,
-                LARGEST_POW2-500, LARGEST_POW2 };
         int[] resultValues = { 1, 1, 2, 4, 4, 16, 32, 512, 1024,
-                LARGEST_POW2, LARGEST_POW2 };
 
         for (int i = 0; i &lt; testValues.length; i++) {
             assertEquals(resultValues[i], MathUtils.nextPowerOf2(testValues[i]));
</code_before><code_after>@@ -51,11 +51,11 @@ private void testRandom() {
 
     private void testNextPowerOf2Int() {
         // the largest power of two that fits into an integer
+        final int largestPower2 = 0x40000000;
         int[] testValues = { 0, 1, 2, 3, 4, 12, 17, 500, 1023,
+                largestPower2 - 500, largestPower2 };
         int[] resultValues = { 1, 1, 2, 4, 4, 16, 32, 512, 1024,
+                largestPower2, largestPower2 };
 
         for (int i = 0; i &lt; testValues.length; i++) {
             assertEquals(resultValues[i], MathUtils.nextPowerOf2(testValues[i]));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>351520</refactoring_id><commit_sha>d4e5d737bed8fbadc94615010a7c2e3bd7a6a8fc</commit_sha><commit_link>https://github.com/pentaho/pentaho-kettle/commit/d4e5d737bed8fbadc94615010a7c2e3bd7a6a8fc</commit_link><file_path>src-ui/org/pentaho/di/ui/spoon/delegates/SpoonTransformationDelegate.java</file_path><description>Rename Variable transLog : TransLog to activeTransGraph : TransGraph in method public executeTransformation(transMeta TransMeta, local boolean, remote boolean, cluster boolean, preview boolean, debug boolean, replayDate Date, safe boolean) : void from class org.pentaho.di.ui.spoon.delegates.SpoonTransformationDelegate</description><code_before>@@ -204,15 +204,17 @@ public void addTransGraph(TransMeta transMeta)
 				tabItem.setImage(GUIResource.getInstance().getImageTransGraph());
 				tabItem.setControl(transGraph);
 
 				spoon.delegates.tabs.addTab(new TabMapEntry(tabItem, tabName, transGraph, TabMapEntry.OBJECT_TYPE_TRANSFORMATION_GRAPH));
 			}
 			int idx = spoon.tabfolder.indexOf(tabItem);
 
-			// OK, also see if we need to open a new history window.
-			if (transMeta.getLogConnection() != null &amp;&amp; !Const.isEmpty(transMeta.getLogTable()) &amp;&amp; !transMeta.isSlaveTransformation())
-			{
-				addTransHistory(transMeta, false);
-			}
 			// keep the focus on the graph
 			spoon.tabfolder.setSelected(idx);
 
@@ -272,23 +274,20 @@ public void addTransLog(TransMeta transMeta, boolean setActive)
 		{
 			TransLog transLog = new TransLog(spoon.tabfolder.getSwtTabset(), spoon, transMeta);
 			tabItem = new TabItem(spoon.tabfolder, tabName, tabName);
-			tabItem.setToolTipText(Messages.getString("Spoon.Title.ExecLogTransView.Tooltip",
-					spoon.delegates.tabs.makeTransGraphTabName(transMeta)));
 			tabItem.setControl(transLog);
 
 			// If there is an associated history window, we want to keep that
 			// one up-to-date as well.
 			//
-			TransHistory transHistory = findTransHistoryOfTransformation(transMeta);
-			TabItem historyItem = spoon.delegates.tabs.findTabItem(spoon.delegates.tabs
-					.makeHistoryTabName(transMeta), TabMapEntry.OBJECT_TYPE_TRANSFORMATION_HISTORY);
 
-			if (transHistory != null &amp;&amp; historyItem != null)
 			{
-				TransHistoryRefresher transHistoryRefresher = new TransHistoryRefresher(historyItem,
-						transHistory);
 				spoon.tabfolder.addListener(transHistoryRefresher);
-				transLog.setTransHistoryRefresher(transHistoryRefresher);
 			}
 
 			spoon.delegates.tabs.addTab(new TabMapEntry(tabItem, tabName, transLog,
@@ -301,6 +300,7 @@ public void addTransLog(TransMeta transMeta, boolean setActive)
 		}
 	}
 
 	public void addTransHistory(TransMeta transMeta, boolean select)
 	{
 		// See if there already is a tab for this history view
@@ -320,14 +320,14 @@ public void addTransHistory(TransMeta transMeta, boolean select)
 
 			// If there is an associated log window that's open, find it and add
 			// a refresher
-			TransLog transLog = findTransLogOfTransformation(transMeta);
-			if (transLog != null)
 			{
 				TransHistoryRefresher transHistoryRefresher = new TransHistoryRefresher(tabItem, transHistory);
 				spoon.tabfolder.addListener(transHistoryRefresher);
-				transLog.setTransHistoryRefresher(transHistoryRefresher);
 			}
-			transHistory.markRefreshNeeded(); // will refresh when first
 			// selected
 
 			spoon.delegates.tabs.addTab(new TabMapEntry(tabItem, tabName, transHistory,
@@ -339,7 +339,8 @@ public void addTransHistory(TransMeta transMeta, boolean select)
 			spoon.tabfolder.setSelected(idx);
 		}
 	}
-
 	public void tabSelected(TabItem item)
 	{
 		List&lt;TabMapEntry&gt; collection = spoon.delegates.tabs.getTabs();
@@ -1015,16 +1016,17 @@ else if (preview) {
 			
 
 			
-			addTransLog(transMeta, executionConfiguration.isExecutingLocally());
-			TransLog transLog = spoon.getActiveTransLog();
 
 			// Is this a local execution?
 			//
 			if (executionConfiguration.isExecutingLocally()) {
 				if (debug || preview) {
-					transLog.debug(executionConfiguration, transDebugMeta);
 				} else {
-					transLog.start(executionConfiguration);
 				}
 				
 			// Are we executing remotely?
</code_before><code_after>@@ -204,15 +204,17 @@ public void addTransGraph(TransMeta transMeta)
 				tabItem.setImage(GUIResource.getInstance().getImageTransGraph());
 				tabItem.setControl(transGraph);
 
+				// OK, also see if we need to open a new history window.
+				if (transMeta.getLogConnection() != null &amp;&amp; !Const.isEmpty(transMeta.getLogTable()) &amp;&amp; !transMeta.isSlaveTransformation())
+				{
+					// addTransHistory(transMeta, false);
+					transGraph.transHistoryDelegate.addTransHistory();
+				}
+
 				spoon.delegates.tabs.addTab(new TabMapEntry(tabItem, tabName, transGraph, TabMapEntry.OBJECT_TYPE_TRANSFORMATION_GRAPH));
 			}
 			int idx = spoon.tabfolder.indexOf(tabItem);
 
 			// keep the focus on the graph
 			spoon.tabfolder.setSelected(idx);
 
@@ -272,23 +274,20 @@ public void addTransLog(TransMeta transMeta, boolean setActive)
 		{
 			TransLog transLog = new TransLog(spoon.tabfolder.getSwtTabset(), spoon, transMeta);
 			tabItem = new TabItem(spoon.tabfolder, tabName, tabName);
+			tabItem.setToolTipText(Messages.getString("Spoon.Title.ExecLogTransView.Tooltip", spoon.delegates.tabs.makeTransGraphTabName(transMeta)));
 			tabItem.setControl(transLog);
 
 			// If there is an associated history window, we want to keep that
 			// one up-to-date as well.
 			//
+			TransGraph transGraph = findTransGraphOfTransformation(transMeta);
+			TabItem historyItem = spoon.delegates.tabs.findTabItem(spoon.delegates.tabs.makeHistoryTabName(transMeta), TabMapEntry.OBJECT_TYPE_TRANSFORMATION_HISTORY);
 
+			if (transGraph != null &amp;&amp; historyItem != null)
 			{
+				TransHistoryRefresher transHistoryRefresher = new TransHistoryRefresher(historyItem, transGraph);
 				spoon.tabfolder.addListener(transHistoryRefresher);
+				// transLog.setTransHistoryRefresher(transHistoryRefresher);
 			}
 
 			spoon.delegates.tabs.addTab(new TabMapEntry(tabItem, tabName, transLog,
@@ -301,6 +300,7 @@ public void addTransLog(TransMeta transMeta, boolean setActive)
 		}
 	}
 
+	/*
 	public void addTransHistory(TransMeta transMeta, boolean select)
 	{
 		// See if there already is a tab for this history view
@@ -320,14 +320,14 @@ public void addTransHistory(TransMeta transMeta, boolean select)
 
 			// If there is an associated log window that's open, find it and add
 			// a refresher
+			TransGraph transGraph = findTransGraphOfTransformation(transMeta);
+			if (transGraph != null)
 			{
 				TransHistoryRefresher transHistoryRefresher = new TransHistoryRefresher(tabItem, transHistory);
 				spoon.tabfolder.addListener(transHistoryRefresher);
+				transGraph.setTransHistoryRefresher(transHistoryRefresher);
 			}
+			transGraph.transHistoryDelegate.markRefreshNeeded(); // will refresh when first
 			// selected
 
 			spoon.delegates.tabs.addTab(new TabMapEntry(tabItem, tabName, transHistory,
@@ -339,7 +339,8 @@ public void addTransHistory(TransMeta transMeta, boolean select)
 			spoon.tabfolder.setSelected(idx);
 		}
 	}
+	*/
+	
 	public void tabSelected(TabItem item)
 	{
 		List&lt;TabMapEntry&gt; collection = spoon.delegates.tabs.getTabs();
@@ -1015,16 +1016,17 @@ else if (preview) {
 			
 
 			
+			// addTransLog(transMeta, executionConfiguration.isExecutingLocally());
+			// TransLog transLog = spoon.getActiveTransLog();
+			TransGraph activeTransGraph = spoon.getActiveTransGraph();
 
 			// Is this a local execution?
 			//
 			if (executionConfiguration.isExecutingLocally()) {
 				if (debug || preview) {
+					activeTransGraph.debug(executionConfiguration, transDebugMeta);
 				} else {
+					activeTransGraph.start(executionConfiguration);
 				}
 				
 			// Are we executing remotely?
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>403397</refactoring_id><commit_sha>13c829eb8fe1a9385fa0192a5dfddefc3172e020</commit_sha><commit_link>https://github.com/apache/tomcat/commit/13c829eb8fe1a9385fa0192a5dfddefc3172e020</commit_link><file_path>java/jakarta/servlet/jsp/el/ImplicitObjectELResolver.java</file_path><description>Rename Variable v : Vector&lt;String&gt; to list : List&lt;String&gt; in method protected getAttributeNames() : Enumeration&lt;String&gt; from class jakarta.servlet.jsp.el.ImplicitObjectELResolver.ScopeManager.getCookie.new ScopeMap&lt;&gt;</description><code_before>@@ -20,14 +20,14 @@
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import java.util.Vector;
 
 import jakarta.el.ELContext;
 import jakarta.el.ELResolver;
@@ -259,11 +259,11 @@ public Map&lt;String,Cookie&gt; getCookie() {
                     protected Enumeration&lt;String&gt; getAttributeNames() {
                         Cookie[] cookies = ((HttpServletRequest) page.getRequest()).getCookies();
                         if (cookies != null) {
-                            Vector&lt;String&gt; v = new Vector&lt;&gt;();
                             for (Cookie cookie : cookies) {
-                                v.add(cookie.getName());
                             }
-                            return v.elements();
                         }
                         return null;
                     }
</code_before><code_after>@@ -20,14 +20,14 @@
 import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 
 import jakarta.el.ELContext;
 import jakarta.el.ELResolver;
@@ -259,11 +259,11 @@ public Map&lt;String,Cookie&gt; getCookie() {
                     protected Enumeration&lt;String&gt; getAttributeNames() {
                         Cookie[] cookies = ((HttpServletRequest) page.getRequest()).getCookies();
                         if (cookies != null) {
+                            List&lt;String&gt; list = new ArrayList&lt;&gt;(cookies.length);
                             for (Cookie cookie : cookies) {
+                                list.add(cookie.getName());
                             }
+                            return Collections.enumeration(list);
                         }
                         return null;
                     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>381623</refactoring_id><commit_sha>6e1ebaebe10514e0b231695814c465af4b6e3a28</commit_sha><commit_link>https://github.com/apache/ignite/commit/6e1ebaebe10514e0b231695814c465af4b6e3a28</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/processors/platform/client/cache/ClientCacheConfigurationSerializer.java</file_path><description>Rename Variable index : QueryIndex to idx : QueryIndex in method private writeQueryEntity(writer BinaryRawWriterEx, qryEntity QueryEntity, protocolCtx ClientProtocolContext) : void from class org.apache.ignite.internal.processors.platform.client.cache.ClientCacheConfigurationSerializer</description><code_before>@@ -280,8 +280,8 @@ private static void writeQueryEntity(BinaryRawWriterEx writer, QueryEntity qryEn
         if (indexes != null) {
             writer.writeInt(indexes.size());
 
-            for (QueryIndex index : indexes)
-                PlatformConfigurationUtils.writeQueryIndex(writer, index);
         }
         else
             writer.writeInt(0);
</code_before><code_after>@@ -280,8 +280,8 @@ private static void writeQueryEntity(BinaryRawWriterEx writer, QueryEntity qryEn
         if (indexes != null) {
             writer.writeInt(indexes.size());
 
+            for (QueryIndex idx : indexes)
+                PlatformConfigurationUtils.writeQueryIndex(writer, idx);
         }
         else
             writer.writeInt(0);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>461215</refactoring_id><commit_sha>eb34311d00407ff3719ba56194e0afbc403637bb</commit_sha><commit_link>https://github.com/oracle/graal/commit/eb34311d00407ff3719ba56194e0afbc403637bb</commit_link><file_path>compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java</file_path><description>Rename Variable a : PrimitiveConstant to value : PrimitiveConstant in method public foldConstant(c Constant) : Constant from class org.graalvm.compiler.core.common.type.FloatStamp.OPS.new ArithmeticOpTable.new UnaryOp.Neg</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,12 +35,13 @@
 import java.util.function.DoubleBinaryOperator;
 
 import org.graalvm.compiler.core.common.LIRKind;
 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;
 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.FloatConvertOp;
 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.UnaryOp;
 import org.graalvm.compiler.debug.GraalError;
-
 import jdk.vm.ci.meta.Constant;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.JavaKind;
@@ -981,6 +982,25 @@ public Stamp foldStamp(Stamp s1, Stamp s2) {
                         }
                     },
 
                     new FloatConvertOp(F2I) {
 
                         @Override
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,12 +35,13 @@
 import java.util.function.DoubleBinaryOperator;
 
 import org.graalvm.compiler.core.common.LIRKind;
+import org.graalvm.compiler.core.common.calc.ReinterpretUtils;
 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;
 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.FloatConvertOp;
+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.ReinterpretOp;
 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.UnaryOp;
 import org.graalvm.compiler.debug.GraalError;
 import jdk.vm.ci.meta.Constant;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.JavaKind;
@@ -981,6 +982,25 @@ public Stamp foldStamp(Stamp s1, Stamp s2) {
                         }
                     },
 
+                    new ReinterpretOp() {
+
+                        @Override
+                        public Constant foldConstant(Stamp resultStamp, Constant constant) {
+                            return ReinterpretUtils.foldConstant(resultStamp, constant);
+                        }
+
+                        @Override
+                        public Stamp foldStamp(Stamp resultStamp, Stamp input) {
+                            if (input.isEmpty()) {
+                                return resultStamp.empty();
+                            } else if (resultStamp instanceof IntegerStamp &amp;&amp; input instanceof FloatStamp) {
+                                return ReinterpretUtils.floatToInt((FloatStamp) input);
+                            } else {
+                                return resultStamp;
+                            }
+                        }
+                    },
+
                     new FloatConvertOp(F2I) {
 
                         @Override
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>355060</refactoring_id><commit_sha>db06ad61bdb8eac1d35800eea6b5cae56e392e1d</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/db06ad61bdb8eac1d35800eea6b5cae56e392e1d</commit_link><file_path>container-core/src/test/java/com/yahoo/processing/request/CompoundNameTestCase.java</file_path><description>Rename Variable abc : CompoundName to abcc : CompoundName in method package testPrefix() : void from class com.yahoo.processing.request.CompoundNameTestCase</description><code_before>@@ -13,7 +13,7 @@
 /**
  * Module local test of the basic property name building block.
  *
- * @author &lt;a href="mailto:steinar@yahoo-inc.com"&gt;Steinar Knutsen&lt;/a&gt;
  */
 public class CompoundNameTestCase {
 
@@ -30,31 +30,32 @@ void verifyStrict(String expected, CompoundName actual) {
     }
 
     @Test
-    final void testLast() {
         assertEquals(NAME.substring(NAME.lastIndexOf('.') + 1), C_NAME.last());
     }
 
     @Test
-    final void testFirst() {
         assertEquals(NAME.substring(0, NAME.indexOf('.')), C_NAME.first());
     }
 
     @Test
-    final void testRest() {
         verifyStrict(NAME.substring(NAME.indexOf('.') + 1), C_NAME.rest());
     }
 
     @Test
-    final void testRestN() {
         verifyStrict("a.b.c.d.e", C_abcde.rest(0));
         verifyStrict("b.c.d.e", C_abcde.rest(1));
         verifyStrict("c.d.e", C_abcde.rest(2));
         verifyStrict("d.e", C_abcde.rest(3));
         verifyStrict("e", C_abcde.rest(4));
         verifyStrict(CompoundName.empty, C_abcde.rest(5));
     }
     @Test
-    final void testFirstN() {
         verifyStrict("a.b.c.d.e", C_abcde.first(5));
         verifyStrict("a.b.c.d", C_abcde.first(4));
         verifyStrict("a.b.c", C_abcde.first(3));
@@ -64,15 +65,16 @@ final void testFirstN() {
     }
 
     @Test
-    final void testPrefix() {
-        CompoundName abc = CompoundName.from("a.b.c");
-        assertTrue(abc.hasPrefix(CompoundName.empty));
-        assertTrue(abc.hasPrefix(CompoundName.from("a")));
-        assertTrue(abc.hasPrefix(CompoundName.from("a.b")));
-        assertTrue(abc.hasPrefix(CompoundName.from("a.b.c")));
 
-        assertFalse(abc.hasPrefix(CompoundName.from("a.b.c.d")));
-        assertFalse(abc.hasPrefix(CompoundName.from("a.b.d")));
     }
 
     @Test
@@ -82,7 +84,7 @@ void testFromComponents() {
     }
 
     @Test
-    final void testSize() {
         Splitter s = Splitter.on('.');
         Iterable&lt;String&gt; i = s.split(NAME);
         int n = 0;
@@ -93,23 +95,23 @@ final void testSize() {
     }
 
     @Test
-    final void testGet() {
         String s = C_NAME.get(0);
         assertEquals(NAME.substring(0, NAME.indexOf('.')), s);
     }
 
     @Test
-    final void testIsCompound() {
         assertTrue(C_NAME.isCompound());
     }
 
     @Test
-    final void testIsEmpty() {
         assertFalse(C_NAME.isEmpty());
     }
 
     @Test
-    final void testAsList() {
         List&lt;String&gt; l = C_NAME.asList();
         Splitter peoplesFront = Splitter.on('.');
         Iterable&lt;String&gt; answer = peoplesFront.split(NAME);
@@ -121,15 +123,15 @@ final void testAsList() {
     }
 
     @Test
-    final void testEqualsObject() {
         assertNotEquals(C_NAME, NAME);
         assertNotEquals(C_NAME, null);
         verifyStrict(C_NAME, C_NAME);
         verifyStrict(C_NAME, CompoundName.from(NAME));
     }
 
     @Test
-    final void testEmptyNonEmpty() {
         assertTrue(CompoundName.empty.isEmpty());
         assertEquals(0, CompoundName.empty.size());
         assertFalse(CompoundName.from("a").isEmpty());
@@ -140,7 +142,7 @@ final void testEmptyNonEmpty() {
     }
 
     @Test
-    final void testGetLowerCasedName() {
         assertEquals(Lowercase.toLowerCase(NAME), C_NAME.getLowerCasedName());
     }
 
@@ -223,4 +225,5 @@ void testAsList2() {
         assertEquals("[one]", CompoundName.from("one").asList().toString());
         assertEquals("[one, two, three]", CompoundName.from("one.two.three").asList().toString());
     }
 }
</code_before><code_after>@@ -13,7 +13,7 @@
 /**
  * Module local test of the basic property name building block.
  *
+ * @author Steinar Knutsen
  */
 public class CompoundNameTestCase {
 
@@ -30,31 +30,32 @@ void verifyStrict(String expected, CompoundName actual) {
     }
 
     @Test
+    void testLast() {
         assertEquals(NAME.substring(NAME.lastIndexOf('.') + 1), C_NAME.last());
     }
 
     @Test
+    void testFirst() {
         assertEquals(NAME.substring(0, NAME.indexOf('.')), C_NAME.first());
     }
 
     @Test
+    void testRest() {
         verifyStrict(NAME.substring(NAME.indexOf('.') + 1), C_NAME.rest());
     }
 
     @Test
+    void testRestN() {
         verifyStrict("a.b.c.d.e", C_abcde.rest(0));
         verifyStrict("b.c.d.e", C_abcde.rest(1));
         verifyStrict("c.d.e", C_abcde.rest(2));
         verifyStrict("d.e", C_abcde.rest(3));
         verifyStrict("e", C_abcde.rest(4));
         verifyStrict(CompoundName.empty, C_abcde.rest(5));
     }
+
     @Test
+    void testFirstN() {
         verifyStrict("a.b.c.d.e", C_abcde.first(5));
         verifyStrict("a.b.c.d", C_abcde.first(4));
         verifyStrict("a.b.c", C_abcde.first(3));
@@ -64,15 +65,16 @@ final void testFirstN() {
     }
 
     @Test
+    void testPrefix() {
+        CompoundName abcc = CompoundName.from("a.b.cc");
+        assertTrue(abcc.hasPrefix(CompoundName.empty));
+        assertTrue(abcc.hasPrefix(CompoundName.from("a")));
+        assertTrue(abcc.hasPrefix(CompoundName.from("a.b")));
+        assertTrue(abcc.hasPrefix(CompoundName.from("a.b.cc")));
 
+        assertFalse(abcc.hasPrefix(CompoundName.from("a.b.c")));
+        assertFalse(abcc.hasPrefix(CompoundName.from("a.b.c.d")));
+        assertFalse(abcc.hasPrefix(CompoundName.from("a.b.d")));
     }
 
     @Test
@@ -82,7 +84,7 @@ void testFromComponents() {
     }
 
     @Test
+    void testSize() {
         Splitter s = Splitter.on('.');
         Iterable&lt;String&gt; i = s.split(NAME);
         int n = 0;
@@ -93,23 +95,23 @@ final void testSize() {
     }
 
     @Test
+    void testGet() {
         String s = C_NAME.get(0);
         assertEquals(NAME.substring(0, NAME.indexOf('.')), s);
     }
 
     @Test
+    void testIsCompound() {
         assertTrue(C_NAME.isCompound());
     }
 
     @Test
+    void testIsEmpty() {
         assertFalse(C_NAME.isEmpty());
     }
 
     @Test
+    void testAsList() {
         List&lt;String&gt; l = C_NAME.asList();
         Splitter peoplesFront = Splitter.on('.');
         Iterable&lt;String&gt; answer = peoplesFront.split(NAME);
@@ -121,15 +123,15 @@ final void testAsList() {
     }
 
     @Test
+    void testEqualsObject() {
         assertNotEquals(C_NAME, NAME);
         assertNotEquals(C_NAME, null);
         verifyStrict(C_NAME, C_NAME);
         verifyStrict(C_NAME, CompoundName.from(NAME));
     }
 
     @Test
+    void testEmptyNonEmpty() {
         assertTrue(CompoundName.empty.isEmpty());
         assertEquals(0, CompoundName.empty.size());
         assertFalse(CompoundName.from("a").isEmpty());
@@ -140,7 +142,7 @@ final void testEmptyNonEmpty() {
     }
 
     @Test
+    void testGetLowerCasedName() {
         assertEquals(Lowercase.toLowerCase(NAME), C_NAME.getLowerCasedName());
     }
 
@@ -223,4 +225,5 @@ void testAsList2() {
         assertEquals("[one]", CompoundName.from("one").asList().toString());
         assertEquals("[one, two, three]", CompoundName.from("one.two.three").asList().toString());
     }
+
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>436765</refactoring_id><commit_sha>4d34917d2f0ceddd86dbed285391b05df19d46e9</commit_sha><commit_link>https://github.com/apache/cassandra/commit/4d34917d2f0ceddd86dbed285391b05df19d46e9</commit_link><file_path>src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java</file_path><description>Rename Variable columnSerializer : IColumnSerializer to atomSerializer : OnDiskAtom.Serializer in method private SimpleBlockFetcher() from class org.apache.cassandra.db.columniterator.IndexedSliceReader.SimpleBlockFetcher</description><code_before>@@ -28,10 +28,10 @@
 
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.DecoratedKey;
-import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.RowIndexEntry;
 import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.io.IColumnSerializer;
 import org.apache.cassandra.io.sstable.IndexHelper;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.FileDataInput;
@@ -43,7 +43,7 @@
  *  blocks before/after it for each next call. This function assumes that
  *  the CF is sorted by name and exploits the name index.
  */
-class IndexedSliceReader extends AbstractIterator&lt;IColumn&gt; implements IColumnIterator
 {
     private final ColumnFamily emptyColumnFamily;
 
@@ -56,7 +56,7 @@ class IndexedSliceReader extends AbstractIterator&lt;IColumn&gt; implements IColumnIte
     private final boolean reversed;
 
     private final BlockFetcher fetcher;
-    private final Deque&lt;IColumn&gt; blockColumns = new ArrayDeque&lt;IColumn&gt;();
     private final AbstractType&lt;?&gt; comparator;
 
     public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileDataInput input, ByteBuffer startColumn, ByteBuffer finishColumn, boolean reversed)
@@ -70,13 +70,14 @@ public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileD
 
         try
         {
-            if (sstable.descriptor.hasPromotedIndexes)
             {
                 this.indexes = indexEntry.columnsIndex();
                 if (indexes.isEmpty())
                 {
                     setToRowStart(sstable, indexEntry, input);
-                    this.emptyColumnFamily = ColumnFamily.serializer.deserializeFromSSTableNoColumns(ColumnFamily.create(sstable.metadata), file);
                     fetcher = new SimpleBlockFetcher();
                 }
                 else
@@ -91,7 +92,8 @@ public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileD
                 setToRowStart(sstable, indexEntry, input);
                 IndexHelper.skipBloomFilter(file);
                 this.indexes = IndexHelper.deserializeIndex(file);
-                this.emptyColumnFamily = ColumnFamily.serializer.deserializeFromSSTableNoColumns(ColumnFamily.create(sstable.metadata), file);
                 fetcher = indexes.isEmpty() ? new SimpleBlockFetcher() : new IndexedBlockFetcher();
             }
         }
@@ -127,7 +129,7 @@ public DecoratedKey getKey()
         throw new UnsupportedOperationException();
     }
 
-    private boolean isColumnNeeded(IColumn column)
     {
         if (startColumn.remaining() == 0 &amp;&amp; finishColumn.remaining() == 0)
             return true;
@@ -145,11 +147,11 @@ else if (!reversed)
             return comparator.compare(column.name(), startColumn) &lt;= 0 &amp;&amp; comparator.compare(column.name(), finishColumn) &gt;= 0;
     }
 
-    protected IColumn computeNext()
     {
         while (true)
         {
-            IColumn column = blockColumns.poll();
             if (column != null &amp;&amp; isColumnNeeded(column))
                 return column;
             try
@@ -222,12 +224,12 @@ public boolean getNextBlock() throws IOException
             if (file == null)
                 file = originalInput == null ? sstable.getFileDataInput(positionToSeek) : originalInput;
 
-            IColumnSerializer columnSerializer = emptyColumnFamily.getColumnSerializer();
             file.seek(positionToSeek);
             FileMark mark = file.mark();
             while (file.bytesPastMark(mark) &lt; curColPosition.width &amp;&amp; !outOfBounds)
             {
-                IColumn column = columnSerializer.deserialize(file);
                 if (reversed)
                     blockColumns.addFirst(column);
                 else
@@ -252,11 +254,11 @@ private class SimpleBlockFetcher implements BlockFetcher
     {
         private SimpleBlockFetcher() throws IOException
         {
-            IColumnSerializer columnSerializer = emptyColumnFamily.getColumnSerializer();
             int columns = file.readInt();
             for (int i = 0; i &lt; columns; i++)
             {
-                IColumn column = columnSerializer.deserialize(file);
                 if (reversed)
                     blockColumns.addFirst(column);
                 else
</code_before><code_after>@@ -28,10 +28,10 @@
 
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.db.DeletionInfo;
+import org.apache.cassandra.db.OnDiskAtom;
 import org.apache.cassandra.db.RowIndexEntry;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.IndexHelper;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.FileDataInput;
@@ -43,7 +43,7 @@
  *  blocks before/after it for each next call. This function assumes that
  *  the CF is sorted by name and exploits the name index.
  */
+class IndexedSliceReader extends AbstractIterator&lt;OnDiskAtom&gt; implements OnDiskAtomIterator
 {
     private final ColumnFamily emptyColumnFamily;
 
@@ -56,7 +56,7 @@ class IndexedSliceReader extends AbstractIterator&lt;IColumn&gt; implements IColumnIte
     private final boolean reversed;
 
     private final BlockFetcher fetcher;
+    private final Deque&lt;OnDiskAtom&gt; blockColumns = new ArrayDeque&lt;OnDiskAtom&gt;();
     private final AbstractType&lt;?&gt; comparator;
 
     public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileDataInput input, ByteBuffer startColumn, ByteBuffer finishColumn, boolean reversed)
@@ -70,13 +70,14 @@ public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileD
 
         try
         {
+            if (sstable.descriptor.version.hasPromotedIndexes)
             {
                 this.indexes = indexEntry.columnsIndex();
                 if (indexes.isEmpty())
                 {
                     setToRowStart(sstable, indexEntry, input);
+                    this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
+                    emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, sstable.descriptor.version));
                     fetcher = new SimpleBlockFetcher();
                 }
                 else
@@ -91,7 +92,8 @@ public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileD
                 setToRowStart(sstable, indexEntry, input);
                 IndexHelper.skipBloomFilter(file);
                 this.indexes = IndexHelper.deserializeIndex(file);
+                this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
+                emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, sstable.descriptor.version));
                 fetcher = indexes.isEmpty() ? new SimpleBlockFetcher() : new IndexedBlockFetcher();
             }
         }
@@ -127,7 +129,7 @@ public DecoratedKey getKey()
         throw new UnsupportedOperationException();
     }
 
+    private boolean isColumnNeeded(OnDiskAtom column)
     {
         if (startColumn.remaining() == 0 &amp;&amp; finishColumn.remaining() == 0)
             return true;
@@ -145,11 +147,11 @@ else if (!reversed)
             return comparator.compare(column.name(), startColumn) &lt;= 0 &amp;&amp; comparator.compare(column.name(), finishColumn) &gt;= 0;
     }
 
+    protected OnDiskAtom computeNext()
     {
         while (true)
         {
+            OnDiskAtom column = blockColumns.poll();
             if (column != null &amp;&amp; isColumnNeeded(column))
                 return column;
             try
@@ -222,12 +224,12 @@ public boolean getNextBlock() throws IOException
             if (file == null)
                 file = originalInput == null ? sstable.getFileDataInput(positionToSeek) : originalInput;
 
+            OnDiskAtom.Serializer atomSerializer = emptyColumnFamily.getOnDiskSerializer();
             file.seek(positionToSeek);
             FileMark mark = file.mark();
             while (file.bytesPastMark(mark) &lt; curColPosition.width &amp;&amp; !outOfBounds)
             {
+                OnDiskAtom column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);
                 if (reversed)
                     blockColumns.addFirst(column);
                 else
@@ -252,11 +254,11 @@ private class SimpleBlockFetcher implements BlockFetcher
     {
         private SimpleBlockFetcher() throws IOException
         {
+            OnDiskAtom.Serializer atomSerializer = emptyColumnFamily.getOnDiskSerializer();
             int columns = file.readInt();
             for (int i = 0; i &lt; columns; i++)
             {
+                OnDiskAtom column = atomSerializer.deserializeFromSSTable(file, sstable.descriptor.version);
                 if (reversed)
                     blockColumns.addFirst(column);
                 else
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>411735</refactoring_id><commit_sha>454045148c40ff2478ca8be1230ad5ba9d0bf397</commit_sha><commit_link>https://github.com/real-logic/aeron/commit/454045148c40ff2478ca8be1230ad5ba9d0bf397</commit_link><file_path>aeron-archive/src/main/java/io/aeron/archive/checksum/Crc32.java</file_path><description>Rename Variable e : Exception to ex : Exception in initializer Crc32 from class io.aeron.archive.checksum.Crc32</description><code_before>@@ -37,8 +37,8 @@ final class Crc32 implements Checksum
             method = lookupMethod("updateByteBuffer"); // JDK 8
             if (null == method)
             {
-                throw new Error("Failed to find method to compute a checksum from a ByteBuffer on " + CRC32.class
-                    .getName() + " class.");
             }
         }
 
@@ -49,9 +49,9 @@ final class Crc32 implements Checksum
             methodHandle = MethodHandles.insertArguments(methodHandle, 0, 0);
             UPDATE_BYTE_BUFFER = methodHandle;
         }
-        catch (final Exception e)
         {
-            throw new Error("Failed to acquire method handle for " + method, e);
         }
     }
 
@@ -61,7 +61,7 @@ private static Method lookupMethod(final String name)
         {
             return CRC32.class.getDeclaredMethod(name, int.class, long.class, int.class, int.class);
         }
-        catch (final NoSuchMethodException e)
         {
             return null;
         }
@@ -82,7 +82,7 @@ public int compute(final long address, final int offset, final int length)
         catch (final Throwable throwable)
         {
             LangUtil.rethrowUnchecked(throwable);
-            return -1; // make compiler happy
         }
     }
 }
</code_before><code_after>@@ -37,8 +37,8 @@ final class Crc32 implements Checksum
             method = lookupMethod("updateByteBuffer"); // JDK 8
             if (null == method)
             {
+                throw new Error("Failed to find method to compute a checksum from a ByteBuffer on " +
+                    CRC32.class.getName() + " class.");
             }
         }
 
@@ -49,9 +49,9 @@ final class Crc32 implements Checksum
             methodHandle = MethodHandles.insertArguments(methodHandle, 0, 0);
             UPDATE_BYTE_BUFFER = methodHandle;
         }
+        catch (final Exception ex)
         {
+            throw new Error("Failed to acquire method handle for " + method, ex);
         }
     }
 
@@ -61,7 +61,7 @@ private static Method lookupMethod(final String name)
         {
             return CRC32.class.getDeclaredMethod(name, int.class, long.class, int.class, int.class);
         }
+        catch (final NoSuchMethodException ignore)
         {
             return null;
         }
@@ -82,7 +82,7 @@ public int compute(final long address, final int offset, final int length)
         catch (final Throwable throwable)
         {
             LangUtil.rethrowUnchecked(throwable);
+            return -1;
         }
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>445921</refactoring_id><commit_sha>3c223159a01e2c86e0367f37ad206079814fbe6c</commit_sha><commit_link>https://github.com/flowable/flowable-engine/commit/3c223159a01e2c86e0367f37ad206079814fbe6c</commit_link><file_path>modules/flowable-camel/src/main/java/org/flowable/camel/CamelBehavior.java</file_path><description>Rename Variable activiti5CompatibilityHandler : Flowable5CompatibilityHandler to compatibilityHandler : Flowable5CompatibilityHandler in method public execute(execution DelegateExecution) : void from class org.flowable.camel.CamelBehavior</description><code_before>@@ -41,19 +41,19 @@
 
 /**
  * This abstract class takes the place of the now-deprecated CamelBehaviour class (which can still be used for legacy compatibility) and significantly improves on its flexibility. Additional
- * implementations can be created that change the way in which Activiti interacts with Camel per your specific needs.
  * 
  * Three out-of-the-box implementations of CamelBehavior are provided: (1) CamelBehaviorDefaultImpl: Works just like CamelBehaviour does; copies variables into and out of Camel as or from properties.
  * (2) CamelBehaviorBodyAsMapImpl: Works by copying variables into and out of Camel using a Map&lt;String,Object&gt; object in the body. (3) CamelBehaviorCamelBodyImpl: Works by copying a single variable
- * value into Camel as a String body and copying the Camel body into that same Activiti variable. The variable in Activiti must be named "camelBody".
  * 
  * The chosen implementation should be set within your ProcessEngineConfiguration. To specify the implementation using Spring, include the following line in your configuration file as part of the
  * properties for "org.flowable.spring.SpringProcessEngineConfiguration":
  * 
  * &lt;property name="camelBehaviorClass" value="org.flowable.camel.impl.CamelBehaviorCamelBodyImpl"/&gt;
  * 
- * Note also that the manner in which variables are copied to Activiti from Camel has changed. It will always copy Camel properties to the Activiti variable set; they can safely be ignored, of course,
- * if not required. It will conditionally copy the Camel body to the "camelBody" variable if it is of type java.lang.String, OR it will copy the Camel body to individual variables within Activiti if
  * it is of type Map&lt;String,Object&gt;.
  * 
  * @author Ryan Johnston (@rjfsu), Tijs Rademakers, Saeid Mirzaei
@@ -115,17 +115,17 @@ public void execute(DelegateExecution execution) {
     }
     execution.setVariables(ExchangeUtils.prepareVariables(exchange, endpoint));
     
-    boolean isActiviti5Execution = false;
     if ((Context.getCommandContext() != null &amp;&amp; Flowable5Util.isFlowable5ProcessDefinitionId(Context.getCommandContext(), execution.getProcessDefinitionId())) ||
         (Context.getCommandContext() == null &amp;&amp; Flowable5Util.getFlowable5CompatibilityHandler() != null)) {
       
-      isActiviti5Execution = true;
     }
     
-    if (!handleCamelException(exchange, execution, isActiviti5Execution)) {
-      if (isActiviti5Execution) {
-        Flowable5CompatibilityHandler activiti5CompatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
-        activiti5CompatibilityHandler.leaveExecution(execution);
         return;
       }
       leave(execution);
@@ -143,7 +143,7 @@ protected FlowableEndpoint getEndpoint(String key) {
         return (FlowableEndpoint) e;
       }
     }
-    throw new FlowableException("Activiti endpoint not defined for " + key);    
   }
 
   protected Exchange createExchange(DelegateExecution activityExecution, FlowableEndpoint endpoint) {
@@ -156,22 +156,22 @@ protected Exchange createExchange(DelegateExecution activityExecution, FlowableE
     return ex;
   }
 
-  protected boolean handleCamelException(Exchange exchange, DelegateExecution execution, boolean isActiviti5Execution) {
     Exception camelException = exchange.getException();
     boolean notHandledByCamel = exchange.isFailed() &amp;&amp; camelException != null;
     if (notHandledByCamel) {
       if (camelException instanceof BpmnError) {
-        if (isActiviti5Execution) {
-          Flowable5CompatibilityHandler activiti5CompatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
-          activiti5CompatibilityHandler.propagateError((BpmnError) camelException, execution);
           return true;
         }
         ErrorPropagation.propagateError((BpmnError) camelException, execution);
         return true;
       } else {
-        if (isActiviti5Execution) {
-          Flowable5CompatibilityHandler activiti5CompatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
-          if (activiti5CompatibilityHandler.mapException(camelException, execution, mapExceptions)) {
             return true;
           } else {
             throw new FlowableException("Unhandled exception on camel route", camelException);
@@ -233,11 +233,11 @@ protected void setAppropriateCamelContext(DelegateExecution execution) {
       if ((Context.getCommandContext() != null &amp;&amp; Flowable5Util.isFlowable5ProcessDefinitionId(Context.getCommandContext(), execution.getProcessDefinitionId())) ||
             (Context.getCommandContext() == null &amp;&amp; Flowable5Util.getFlowable5CompatibilityHandler() != null)) {
         
-        Flowable5CompatibilityHandler activiti5CompatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
-        camelContextObj = (CamelContext) activiti5CompatibilityHandler.getCamelContextObject(camelContextValue);
         
       } else {
-        // Convert it to a SpringProcessEngineConfiguration. If this doesn't work, throw a RuntimeException. (ActivitiException extends RuntimeException.)
         try {
           SpringProcessEngineConfiguration springConfiguration = (SpringProcessEngineConfiguration) engineConfiguration;
           if (StringUtils.isEmpty(camelContextValue) &amp;&amp; camelContextObj == null) {
@@ -252,7 +252,7 @@ protected void setAppropriateCamelContext(DelegateExecution execution) {
           camelContextObj = (CamelContext) ctx;
           
         } catch (Exception e) {
-          throw new FlowableException("Expecting a SpringProcessEngineConfiguration for the Activiti Camel module.", e);
         }
       }
     }
</code_before><code_after>@@ -41,19 +41,19 @@
 
 /**
  * This abstract class takes the place of the now-deprecated CamelBehaviour class (which can still be used for legacy compatibility) and significantly improves on its flexibility. Additional
+ * implementations can be created that change the way in which Flowable interacts with Camel per your specific needs.
  * 
  * Three out-of-the-box implementations of CamelBehavior are provided: (1) CamelBehaviorDefaultImpl: Works just like CamelBehaviour does; copies variables into and out of Camel as or from properties.
  * (2) CamelBehaviorBodyAsMapImpl: Works by copying variables into and out of Camel using a Map&lt;String,Object&gt; object in the body. (3) CamelBehaviorCamelBodyImpl: Works by copying a single variable
+ * value into Camel as a String body and copying the Camel body into that same variable. The process variable in must be named "camelBody".
  * 
  * The chosen implementation should be set within your ProcessEngineConfiguration. To specify the implementation using Spring, include the following line in your configuration file as part of the
  * properties for "org.flowable.spring.SpringProcessEngineConfiguration":
  * 
  * &lt;property name="camelBehaviorClass" value="org.flowable.camel.impl.CamelBehaviorCamelBodyImpl"/&gt;
  * 
+ * Note also that the manner in which variables are copied to the process engine from Camel has changed. It will always copy Camel properties to the process variables set; they can safely be ignored, of course,
+ * if not required. It will conditionally copy the Camel body to the "camelBody" variable if it is of type java.lang.String, OR it will copy the Camel body to individual variables within the process engine if
  * it is of type Map&lt;String,Object&gt;.
  * 
  * @author Ryan Johnston (@rjfsu), Tijs Rademakers, Saeid Mirzaei
@@ -115,17 +115,17 @@ public void execute(DelegateExecution execution) {
     }
     execution.setVariables(ExchangeUtils.prepareVariables(exchange, endpoint));
     
+    boolean isV5Execution = false;
     if ((Context.getCommandContext() != null &amp;&amp; Flowable5Util.isFlowable5ProcessDefinitionId(Context.getCommandContext(), execution.getProcessDefinitionId())) ||
         (Context.getCommandContext() == null &amp;&amp; Flowable5Util.getFlowable5CompatibilityHandler() != null)) {
       
+      isV5Execution = true;
     }
     
+    if (!handleCamelException(exchange, execution, isV5Execution)) {
+      if (isV5Execution) {
+        Flowable5CompatibilityHandler compatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
+        compatibilityHandler.leaveExecution(execution);
         return;
       }
       leave(execution);
@@ -143,7 +143,7 @@ protected FlowableEndpoint getEndpoint(String key) {
         return (FlowableEndpoint) e;
       }
     }
+    throw new FlowableException("Endpoint not defined for " + key);    
   }
 
   protected Exchange createExchange(DelegateExecution activityExecution, FlowableEndpoint endpoint) {
@@ -156,22 +156,22 @@ protected Exchange createExchange(DelegateExecution activityExecution, FlowableE
     return ex;
   }
 
+  protected boolean handleCamelException(Exchange exchange, DelegateExecution execution, boolean isV5Execution) {
     Exception camelException = exchange.getException();
     boolean notHandledByCamel = exchange.isFailed() &amp;&amp; camelException != null;
     if (notHandledByCamel) {
       if (camelException instanceof BpmnError) {
+        if (isV5Execution) {
+          Flowable5CompatibilityHandler compatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
+          compatibilityHandler.propagateError((BpmnError) camelException, execution);
           return true;
         }
         ErrorPropagation.propagateError((BpmnError) camelException, execution);
         return true;
       } else {
+        if (isV5Execution) {
+          Flowable5CompatibilityHandler ompatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
+          if (ompatibilityHandler.mapException(camelException, execution, mapExceptions)) {
             return true;
           } else {
             throw new FlowableException("Unhandled exception on camel route", camelException);
@@ -233,11 +233,11 @@ protected void setAppropriateCamelContext(DelegateExecution execution) {
       if ((Context.getCommandContext() != null &amp;&amp; Flowable5Util.isFlowable5ProcessDefinitionId(Context.getCommandContext(), execution.getProcessDefinitionId())) ||
             (Context.getCommandContext() == null &amp;&amp; Flowable5Util.getFlowable5CompatibilityHandler() != null)) {
         
+        Flowable5CompatibilityHandler compatibilityHandler = Flowable5Util.getFlowable5CompatibilityHandler(); 
+        camelContextObj = (CamelContext) compatibilityHandler.getCamelContextObject(camelContextValue);
         
       } else {
+        // Convert it to a SpringProcessEngineConfiguration. If this doesn't work, throw a RuntimeException.
         try {
           SpringProcessEngineConfiguration springConfiguration = (SpringProcessEngineConfiguration) engineConfiguration;
           if (StringUtils.isEmpty(camelContextValue) &amp;&amp; camelContextObj == null) {
@@ -252,7 +252,7 @@ protected void setAppropriateCamelContext(DelegateExecution execution) {
           camelContextObj = (CamelContext) ctx;
           
         } catch (Exception e) {
+          throw new FlowableException("Expecting a SpringProcessEngineConfiguration for the Camel module.", e);
         }
       }
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>371160</refactoring_id><commit_sha>d76c5d590319afc1aad81ea9fa3acbc8416fdd93</commit_sha><commit_link>https://github.com/apache/storm/commit/d76c5d590319afc1aad81ea9fa3acbc8416fdd93</commit_link><file_path>external/sql/storm-sql-core/src/jvm/org/apache/storm/sql/planner/trident/rel/TridentCalcRel.java</file_path><description>Rename Variable projectionExpr : String to projectionInstance : ExecutableExpression in method public tridentPlan(planCreator TridentPlanCreator) : void from class org.apache.storm.sql.planner.trident.rel.TridentCalcRel</description><code_before>@@ -29,9 +29,8 @@
 import org.apache.storm.sql.planner.StormRelUtils;
 import org.apache.storm.sql.planner.rel.StormCalcRelBase;
 import org.apache.storm.sql.planner.trident.TridentPlanCreator;
 import org.apache.storm.sql.runtime.trident.functions.EvaluationCalc;
-import org.apache.storm.sql.runtime.trident.functions.EvaluationFilter;
-import org.apache.storm.sql.runtime.trident.functions.ForwardFunction;
 import org.apache.storm.trident.Stream;
 import org.apache.storm.tuple.Fields;
 
@@ -54,41 +53,43 @@ public void tridentPlan(TridentPlanCreator planCreator) throws Exception {
         RelNode input = getInput();
         StormRelUtils.getStormRelInput(input).tridentPlan(planCreator);
         Stream inputStream = planCreator.pop().toStream();
-        Fields inputFields = inputStream.getOutputFields();
 
         String stageName = StormRelUtils.getStageName(this);
         RelDataType inputRowType = getInput(0).getRowType();
 
         List&lt;String&gt; outputFieldNames = getRowType().getFieldNames();
         int outputCount = outputFieldNames.size();
 
         // filter
         RexLocalRef condition = program.getCondition();
-        String conditionExpr = null;
         if (condition != null) {
             RexNode conditionNode = program.expandLocalRef(condition);
-            conditionExpr = planCreator.createExpression(Lists.newArrayList(conditionNode), inputRowType);
         }
 
         // projection
         List&lt;RexLocalRef&gt; projectList = program.getProjectList();
-        String projectionExpr = null;
         if (projectList != null &amp;&amp; !projectList.isEmpty()) {
             List&lt;RexNode&gt; expandedNodes = new ArrayList&lt;&gt;();
             for (RexLocalRef project : projectList) {
                 expandedNodes.add(program.expandLocalRef(project));
             }
 
-            projectionExpr = planCreator.createExpression(expandedNodes, inputRowType);
         }
 
-        if (projectionExpr == null &amp;&amp; conditionExpr == null) {
             // it shouldn't be happen
             throw new IllegalStateException("Either projection or condition, or both should be provided.");
         }
 
         final Stream finalStream = inputStream
-                .flatMap(new EvaluationCalc(conditionExpr, projectionExpr, outputCount, planCreator.getDataContext()), new Fields(outputFieldNames))
                 .name(stageName);
 
         planCreator.addStream(finalStream);
</code_before><code_after>@@ -29,9 +29,8 @@
 import org.apache.storm.sql.planner.StormRelUtils;
 import org.apache.storm.sql.planner.rel.StormCalcRelBase;
 import org.apache.storm.sql.planner.trident.TridentPlanCreator;
+import org.apache.storm.sql.runtime.calcite.ExecutableExpression;
 import org.apache.storm.sql.runtime.trident.functions.EvaluationCalc;
 import org.apache.storm.trident.Stream;
 import org.apache.storm.tuple.Fields;
 
@@ -54,41 +53,43 @@ public void tridentPlan(TridentPlanCreator planCreator) throws Exception {
         RelNode input = getInput();
         StormRelUtils.getStormRelInput(input).tridentPlan(planCreator);
         Stream inputStream = planCreator.pop().toStream();
 
         String stageName = StormRelUtils.getStageName(this);
+
         RelDataType inputRowType = getInput(0).getRowType();
 
         List&lt;String&gt; outputFieldNames = getRowType().getFieldNames();
         int outputCount = outputFieldNames.size();
 
         // filter
+        ExecutableExpression filterInstance = null;
         RexLocalRef condition = program.getCondition();
         if (condition != null) {
             RexNode conditionNode = program.expandLocalRef(condition);
+            filterInstance = planCreator.createScalarInstance(Lists.newArrayList(conditionNode), inputRowType,
+                    StormRelUtils.getClassName(this));
         }
 
         // projection
+        ExecutableExpression projectionInstance = null;
         List&lt;RexLocalRef&gt; projectList = program.getProjectList();
         if (projectList != null &amp;&amp; !projectList.isEmpty()) {
             List&lt;RexNode&gt; expandedNodes = new ArrayList&lt;&gt;();
             for (RexLocalRef project : projectList) {
                 expandedNodes.add(program.expandLocalRef(project));
             }
 
+            projectionInstance = planCreator.createScalarInstance(expandedNodes, inputRowType,
+                    StormRelUtils.getClassName(this));
         }
 
+        if (projectionInstance == null &amp;&amp; filterInstance == null) {
             // it shouldn't be happen
             throw new IllegalStateException("Either projection or condition, or both should be provided.");
         }
 
         final Stream finalStream = inputStream
+                .flatMap(new EvaluationCalc(filterInstance, projectionInstance, outputCount, planCreator.getDataContext()), new Fields(outputFieldNames))
                 .name(stageName);
 
         planCreator.addStream(finalStream);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>428704</refactoring_id><commit_sha>17402659845ea21b0dd9f9989d484fb32c3aa28b</commit_sha><commit_link>https://github.com/apache/maven/commit/17402659845ea21b0dd9f9989d484fb32c3aa28b</commit_link><file_path>maven-resolver-provider/src/main/java/org/apache/maven/repository/internal/ArtifactDescriptorReaderDelegate.java</file_path><description>Rename Variable mngt : DependencyManagement to mgmt : DependencyManagement in method public populateResult(session RepositorySystemSession, result ArtifactDescriptorResult, model Model) : void from class org.apache.maven.repository.internal.ArtifactDescriptorReaderDelegate</description><code_before>@@ -65,10 +65,10 @@ public void populateResult( RepositorySystemSession session, ArtifactDescriptorR
             result.addDependency( convert( dependency, stereotypes ) );
         }
 
-        DependencyManagement mngt = model.getDependencyManagement();
-        if ( mngt != null )
         {
-            for ( org.apache.maven.model.Dependency dependency : mngt.getDependencies() )
             {
                 result.addManagedDependency( convert( dependency, stereotypes ) );
             }
@@ -137,10 +137,10 @@ private Exclusion convert( org.apache.maven.model.Exclusion exclusion )
     private void setArtifactProperties( ArtifactDescriptorResult result, Model model )
     {
         String downloadUrl = null;
-        DistributionManagement distMngt = model.getDistributionManagement();
-        if ( distMngt != null )
         {
-            downloadUrl = distMngt.getDownloadUrl();
         }
         if ( downloadUrl != null &amp;&amp; downloadUrl.length() &gt; 0 )
         {
</code_before><code_after>@@ -65,10 +65,10 @@ public void populateResult( RepositorySystemSession session, ArtifactDescriptorR
             result.addDependency( convert( dependency, stereotypes ) );
         }
 
+        DependencyManagement mgmt = model.getDependencyManagement();
+        if ( mgmt != null )
         {
+            for ( org.apache.maven.model.Dependency dependency : mgmt.getDependencies() )
             {
                 result.addManagedDependency( convert( dependency, stereotypes ) );
             }
@@ -137,10 +137,10 @@ private Exclusion convert( org.apache.maven.model.Exclusion exclusion )
     private void setArtifactProperties( ArtifactDescriptorResult result, Model model )
     {
         String downloadUrl = null;
+        DistributionManagement distMgmt = model.getDistributionManagement();
+        if ( distMgmt != null )
         {
+            downloadUrl = distMgmt.getDownloadUrl();
         }
         if ( downloadUrl != null &amp;&amp; downloadUrl.length() &gt; 0 )
         {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>377434</refactoring_id><commit_sha>65874f56686975edf7cb3723024ce9a87cbbd754</commit_sha><commit_link>https://github.com/jabref/jabref/commit/65874f56686975edf7cb3723024ce9a87cbbd754</commit_link><file_path>src/test/java/org/jabref/model/groups/AutomaticKeywordGroupTest.java</file_path><description>Rename Variable expected : Set&lt;GroupTreeNode&gt; to expectedKeywordsSubgroup : Set&lt;GroupTreeNode&gt; in method private createIncludingKeywordsSubgroup() : Set&lt;GroupTreeNode&gt; from class org.jabref.model.groups.AutomaticKeywordGroupTest</description><code_before>@@ -17,9 +17,8 @@ void createSubgroupsForTwoKeywords() throws Exception {
         AutomaticKeywordGroup keywordsGroup = new AutomaticKeywordGroup("Keywords", GroupHierarchyType.INDEPENDENT, StandardField.KEYWORDS, ',', '&gt;');
         BibEntry entry = new BibEntry().withField(StandardField.KEYWORDS, "A, B");
 
-        Set&lt;GroupTreeNode&gt; expected = new HashSet&lt;&gt;();
-        expected.add(GroupTreeNode.fromGroup(new WordKeywordGroup("A", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, "A", true, ',', true)));
-        expected.add(GroupTreeNode.fromGroup(new WordKeywordGroup("B", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, "B", true, ',', true)));
         assertEquals(expected, keywordsGroup.createSubgroups(entry));
     }
 
@@ -28,9 +27,17 @@ void createSubgroupsIgnoresEmptyKeyword() throws Exception {
         AutomaticKeywordGroup keywordsGroup = new AutomaticKeywordGroup("Keywords", GroupHierarchyType.INDEPENDENT, StandardField.KEYWORDS, ',', '&gt;');
         BibEntry entry = new BibEntry().withField(StandardField.KEYWORDS, "A, ,B");
 
-        Set&lt;GroupTreeNode&gt; expected = new HashSet&lt;&gt;();
-        expected.add(GroupTreeNode.fromGroup(new WordKeywordGroup("A", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, "A", true, ',', true)));
-        expected.add(GroupTreeNode.fromGroup(new WordKeywordGroup("B", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, "B", true, ',', true)));
         assertEquals(expected, keywordsGroup.createSubgroups(entry));
     }
 }
</code_before><code_after>@@ -17,9 +17,8 @@ void createSubgroupsForTwoKeywords() throws Exception {
         AutomaticKeywordGroup keywordsGroup = new AutomaticKeywordGroup("Keywords", GroupHierarchyType.INDEPENDENT, StandardField.KEYWORDS, ',', '&gt;');
         BibEntry entry = new BibEntry().withField(StandardField.KEYWORDS, "A, B");
 
+        Set&lt;GroupTreeNode&gt; expected = createIncludingKeywordsSubgroup();
+
         assertEquals(expected, keywordsGroup.createSubgroups(entry));
     }
 
@@ -28,9 +27,17 @@ void createSubgroupsIgnoresEmptyKeyword() throws Exception {
         AutomaticKeywordGroup keywordsGroup = new AutomaticKeywordGroup("Keywords", GroupHierarchyType.INDEPENDENT, StandardField.KEYWORDS, ',', '&gt;');
         BibEntry entry = new BibEntry().withField(StandardField.KEYWORDS, "A, ,B");
 
+        Set&lt;GroupTreeNode&gt; expected = createIncludingKeywordsSubgroup();
+
         assertEquals(expected, keywordsGroup.createSubgroups(entry));
     }
+
+    private Set&lt;GroupTreeNode&gt; createIncludingKeywordsSubgroup() {
+        Set&lt;GroupTreeNode&gt; expectedKeywordsSubgroup = new HashSet&lt;&gt;();
+        expectedKeywordsSubgroup.add(GroupTreeNode.fromGroup(new WordKeywordGroup("A", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, "A", true, ',', true)));
+        expectedKeywordsSubgroup.add(GroupTreeNode.fromGroup(new WordKeywordGroup("B", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, "B", true, ',', true)));
+
+        return expectedKeywordsSubgroup;
+    }
+
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>375464</refactoring_id><commit_sha>3ed9b5e34e0b9e98a05b23d9d4ef24f7ae7265e1</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/3ed9b5e34e0b9e98a05b23d9d4ef24f7ae7265e1</commit_link><file_path>OsmAnd/src/net/osmand/plus/settings/fragments/GlobalSettingsFragment.java</file_path><description>Rename Variable enableProxy : SwitchPreferenceEx to uiPreference : Preference in method private setupEnableProxyPref() : void from class net.osmand.plus.settings.fragments.GlobalSettingsFragment</description><code_before>@@ -5,6 +5,7 @@
 
 import android.app.Activity;
 import android.app.backup.BackupManager;
 import android.os.Build;
 import android.os.Bundle;
 import android.widget.ImageView;
@@ -47,6 +48,7 @@ public class GlobalSettingsFragment extends BaseSettingsFragment
 	private static final String SEND_ANONYMOUS_DATA_PREF_ID = "send_anonymous_data";
 	private static final String DIALOGS_AND_NOTIFICATIONS_PREF_ID = "dialogs_and_notifications";
 	private static final String SEND_UNIQUE_USER_IDENTIFIER_PREF_ID = "send_unique_user_identifier";
 
 	@Override
 	protected void setupPreferences() {
@@ -298,8 +300,11 @@ private void setupLocationSourcePref() {
 	}
 
 	private void setupEnableProxyPref() {
-		SwitchPreferenceEx enableProxy = findPreference(settings.ENABLE_PROXY.getId());
-		enableProxy.setIcon(getPersistentPrefIcon(R.drawable.ic_action_proxy));
 	}
 
 	private void setupHistoryPref() {
</code_before><code_after>@@ -5,6 +5,7 @@
 
 import android.app.Activity;
 import android.app.backup.BackupManager;
+import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.os.Bundle;
 import android.widget.ImageView;
@@ -47,6 +48,7 @@ public class GlobalSettingsFragment extends BaseSettingsFragment
 	private static final String SEND_ANONYMOUS_DATA_PREF_ID = "send_anonymous_data";
 	private static final String DIALOGS_AND_NOTIFICATIONS_PREF_ID = "dialogs_and_notifications";
 	private static final String SEND_UNIQUE_USER_IDENTIFIER_PREF_ID = "send_unique_user_identifier";
+	private static final String ENABLE_PROXY_PREF_ID = "enable_proxy";
 
 	@Override
 	protected void setupPreferences() {
@@ -298,8 +300,11 @@ private void setupLocationSourcePref() {
 	}
 
 	private void setupEnableProxyPref() {
+		Preference uiPreference = findPreference(ENABLE_PROXY_PREF_ID);
+		int iconId = R.drawable.ic_action_proxy;
+		boolean enabled = settings.isProxyEnabled();
+		uiPreference.setIcon(enabled ? getActiveIcon(iconId) : getContentIcon(iconId));
+		uiPreference.setSummary(settings.isProxyEnabled() ? R.string.shared_string_on : R.string.shared_string_off);
 	}
 
 	private void setupHistoryPref() {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>412124</refactoring_id><commit_sha>990a83a3262017d375e6f84083e6363d7d7c50d7</commit_sha><commit_link>https://github.com/real-logic/aeron/commit/990a83a3262017d375e6f84083e6363d7d7c50d7</commit_link><file_path>aeron-examples/src/main/java/uk/co/real_logic/aeron/examples/raw/SendReceiveUdpPing.java</file_path><description>Rename Variable receiveChannel : DatagramChannel to receiveChannels : DatagramChannel[] in method public main(args String[]) : void from class uk.co.real_logic.aeron.examples.raw.SendReceiveUdpPing</description><code_before>@@ -38,14 +38,25 @@ public class SendReceiveUdpPing
 {
     public static void main(final String[] args) throws IOException
     {
         final Histogram histogram = new Histogram(TimeUnit.SECONDS.toNanos(10), 3);
-        final InetSocketAddress sendAddress = new InetSocketAddress("localhost", Common.PING_PORT);
         final ByteBuffer buffer = ByteBuffer.allocateDirect(MTU_LENGTH_DEFAULT);
 
-        final DatagramChannel receiveChannel = DatagramChannel.open();
-        setup(receiveChannel);
-        receiveChannel.bind(new InetSocketAddress("localhost", Common.PONG_PORT));
 
         final DatagramChannel sendChannel = DatagramChannel.open();
         setup(sendChannel);
 
@@ -54,7 +65,7 @@ public static void main(final String[] args) throws IOException
 
         while (running.get())
         {
-            measureRoundTrip(histogram, sendAddress, buffer, receiveChannel, sendChannel, running);
 
             histogram.reset();
             System.gc();
@@ -66,7 +77,7 @@ private static void measureRoundTrip(
         final Histogram histogram,
         final InetSocketAddress sendAddress,
         final ByteBuffer buffer,
-        final DatagramChannel receiveChannel,
         final DatagramChannel sendChannel,
         final AtomicBoolean running)
         throws IOException
@@ -83,12 +94,22 @@ private static void measureRoundTrip(
             sendChannel.send(buffer, sendAddress);
 
             buffer.clear();
-            while (receiveChannel.receive(buffer) == null)
             {
                 if (!running.get())
                 {
                     return;
                 }
             }
 
             final long receivedSequenceNumber = buffer.getLong(0);
</code_before><code_after>@@ -38,14 +38,25 @@ public class SendReceiveUdpPing
 {
     public static void main(final String[] args) throws IOException
     {
+        int numChannels = 1;
+        if (1 == args.length)
+        {
+            numChannels = Integer.parseInt(args[0]);
+        }
+
         final Histogram histogram = new Histogram(TimeUnit.SECONDS.toNanos(10), 3);
+
         final ByteBuffer buffer = ByteBuffer.allocateDirect(MTU_LENGTH_DEFAULT);
 
+        final DatagramChannel[] receiveChannels = new DatagramChannel[numChannels];
+        for (int i = 0; i &lt; receiveChannels.length; i++)
+        {
+            receiveChannels[i] = DatagramChannel.open();
+            setup(receiveChannels[i]);
+            receiveChannels[i].bind(new InetSocketAddress("localhost", Common.PONG_PORT + i));
+        }
 
+        final InetSocketAddress sendAddress = new InetSocketAddress("localhost", Common.PING_PORT);
         final DatagramChannel sendChannel = DatagramChannel.open();
         setup(sendChannel);
 
@@ -54,7 +65,7 @@ public static void main(final String[] args) throws IOException
 
         while (running.get())
         {
+            measureRoundTrip(histogram, sendAddress, buffer, receiveChannels, sendChannel, running);
 
             histogram.reset();
             System.gc();
@@ -66,7 +77,7 @@ private static void measureRoundTrip(
         final Histogram histogram,
         final InetSocketAddress sendAddress,
         final ByteBuffer buffer,
+        final DatagramChannel[] receiveChannels,
         final DatagramChannel sendChannel,
         final AtomicBoolean running)
         throws IOException
@@ -83,12 +94,22 @@ private static void measureRoundTrip(
             sendChannel.send(buffer, sendAddress);
 
             buffer.clear();
+            boolean available = false;
+            while (!available)
             {
                 if (!running.get())
                 {
                     return;
                 }
+
+                for (int i = receiveChannels.length - 1; i &gt;=0; i--)
+                {
+                    if (null != receiveChannels[i].receive(buffer))
+                    {
+                        available = true;
+                        break;
+                    }
+                }
             }
 
             final long receivedSequenceNumber = buffer.getLong(0);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>439600</refactoring_id><commit_sha>dd3ee7e8f8c91b6662f9e713250286b12dd502ba</commit_sha><commit_link>https://github.com/h2database/h2database/commit/dd3ee7e8f8c91b6662f9e713250286b12dd502ba</commit_link><file_path>h2/src/tools/org/h2/dev/fs/FileShell.java</file_path><description>Rename Variable in : InputStream to inFile : InputStream in method private unzip(zipFileName String, targetDir String) : void from class org.h2.dev.fs.FileShell</description><code_before>@@ -285,7 +285,7 @@ private boolean execute(String[] list) throws IOException {
         return true;
     }
 
-    private void end(String[] list, int index) throws IOException {
         if (list.length != index) {
             throw new IOException("End of command expected, got: " + list[index]);
         }
@@ -298,14 +298,14 @@ private void cat(String fileName, long length) {
         if (FileUtils.isDirectory(fileName)) {
             print("Is a directory: " + fileName);
         }
-        InputStream in = null;
         try {
-            in = FileUtils.newInputStream(fileName);
-            IOUtils.copy(in, out, length);
         } catch (IOException e) {
             error(e);
         } finally {
-            IOUtils.closeSilently(in);
         }
         println("");
     }
@@ -333,7 +333,7 @@ private void error(Exception e) {
         }
     }
 
-    private void zip(String zipFileName, String base, ArrayList&lt;String&gt; source) {
         FileUtils.delete(zipFileName);
         OutputStream fileOut = null;
         try {
@@ -376,10 +376,10 @@ private void zip(String zipFileName, String base, ArrayList&lt;String&gt; source) {
     }
 
     private void unzip(String zipFileName, String targetDir) {
-        InputStream in = null;
         try {
-            in = FileUtils.newInputStream(zipFileName);
-            ZipInputStream zipIn = new ZipInputStream(in);
             while (true) {
                 ZipEntry entry = zipIn.getNextEntry();
                 if (entry == null) {
@@ -407,7 +407,7 @@ private void unzip(String zipFileName, String targetDir) {
         } catch (IOException e) {
             error(e);
         } finally {
-            IOUtils.closeSilently(in);
         }
     }
 
</code_before><code_after>@@ -285,7 +285,7 @@ private boolean execute(String[] list) throws IOException {
         return true;
     }
 
+    private static void end(String[] list, int index) throws IOException {
         if (list.length != index) {
             throw new IOException("End of command expected, got: " + list[index]);
         }
@@ -298,14 +298,14 @@ private void cat(String fileName, long length) {
         if (FileUtils.isDirectory(fileName)) {
             print("Is a directory: " + fileName);
         }
+        InputStream inFile = null;
         try {
+            inFile = FileUtils.newInputStream(fileName);
+            IOUtils.copy(inFile, out, length);
         } catch (IOException e) {
             error(e);
         } finally {
+            IOUtils.closeSilently(inFile);
         }
         println("");
     }
@@ -333,7 +333,7 @@ private void error(Exception e) {
         }
     }
 
+    private static void zip(String zipFileName, String base, ArrayList&lt;String&gt; source) {
         FileUtils.delete(zipFileName);
         OutputStream fileOut = null;
         try {
@@ -376,10 +376,10 @@ private void zip(String zipFileName, String base, ArrayList&lt;String&gt; source) {
     }
 
     private void unzip(String zipFileName, String targetDir) {
+        InputStream inFile = null;
         try {
+            inFile = FileUtils.newInputStream(zipFileName);
+            ZipInputStream zipIn = new ZipInputStream(inFile);
             while (true) {
                 ZipEntry entry = zipIn.getNextEntry();
                 if (entry == null) {
@@ -407,7 +407,7 @@ private void unzip(String zipFileName, String targetDir) {
         } catch (IOException e) {
             error(e);
         } finally {
+            IOUtils.closeSilently(inFile);
         }
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>344898</refactoring_id><commit_sha>5cc8630b7d4b90eeff0480ec6d2a11ec907bccea</commit_sha><commit_link>https://github.com/killbill/killbill/commit/5cc8630b7d4b90eeff0480ec6d2a11ec907bccea</commit_link><file_path>entitlement/src/main/java/com/ning/billing/entitlement/api/DefaultSubscriptionBundleTimeline.java</file_path><description>Rename Variable correctedEvent : SubscriptionEvent to correctedBillingEvent : SubscriptionEvent in method private sanitizeForBaseRecreateEvents(input LinkedList&lt;SubscriptionEvent&gt;) : void from class com.ning.billing.entitlement.api.DefaultSubscriptionBundleTimeline</description><code_before>@@ -17,6 +17,7 @@
 package com.ning.billing.entitlement.api;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
@@ -226,39 +227,29 @@ private SubscriptionEvent[] findPrevNext(final List&lt;SubscriptionEvent&gt; events, f
         return result;
     }
 
-
     private LinkedList&lt;SubscriptionEvent&gt; computeSubscriptionBaseEvents(final List&lt;Entitlement&gt; entitlements, final DateTimeZone accountTimeZone) {
-
         final LinkedList&lt;SubscriptionEvent&gt; result = new LinkedList&lt;SubscriptionEvent&gt;();
-        for (Entitlement cur : entitlements) {
             final SubscriptionBase base = ((DefaultEntitlement) cur).getSubscriptionBase();
             final List&lt;SubscriptionBaseTransition&gt; baseTransitions = base.getAllTransitions();
-            for (SubscriptionBaseTransition tr : baseTransitions) {
-                final SubscriptionEventType eventType = toEventType(tr.getTransitionType());
-                if (eventType == null) {
-                    continue;
-                }
-                final SubscriptionEvent event = toSubscriptionEvent(tr, eventType, accountTimeZone);
-                insertSubscriptionEvent(event, result);
-                if (tr.getTransitionType() == SubscriptionBaseTransitionType.CREATE ||
-                    tr.getTransitionType() == SubscriptionBaseTransitionType.TRANSFER) {
-                    final SubscriptionEvent billingEvent = toSubscriptionEvent(tr, SubscriptionEventType.START_BILLING, accountTimeZone);
-                    insertSubscriptionEvent(billingEvent, result);
                 }
             }
         }
         sanitizeForBaseRecreateEvents(result);
         return result;
     }
 
-
     //
-    // Old version of code would use CANCEL/ RE_CREATE to simulate PAUSE_BILLING/RESUME_BILLING
     //
     private void sanitizeForBaseRecreateEvents(final LinkedList&lt;SubscriptionEvent&gt; input) {
-
-        final Set&lt;UUID&gt; guiltyEntitlementIds = new TreeSet&lt;UUID&gt;();
-        ListIterator&lt;SubscriptionEvent&gt; it = input.listIterator(input.size());
         while (it.hasPrevious()) {
             final SubscriptionEvent cur = it.previous();
             if (cur.getSubscriptionEventType() == SubscriptionEventType.RESUME_BILLING) {
@@ -268,13 +259,16 @@ private void sanitizeForBaseRecreateEvents(final LinkedList&lt;SubscriptionEvent&gt; i
             if (cur.getSubscriptionEventType() == SubscriptionEventType.STOP_BILLING &amp;&amp;
                 guiltyEntitlementIds.contains(cur.getEntitlementId())) {
                 guiltyEntitlementIds.remove(cur.getEntitlementId());
-                final SubscriptionEvent correctedEvent = new DefaultSubscriptionEvent((DefaultSubscriptionEvent) cur, SubscriptionEventType.PAUSE_BILLING);
-                it.set(correctedEvent);
             }
         }
     }
 
-
     private void insertSubscriptionEvent(final SubscriptionEvent event, final LinkedList&lt;SubscriptionEvent&gt; result) {
         int index = 0;
         for (SubscriptionEvent cur : result) {
@@ -374,25 +368,25 @@ private static String getServiceName(final SubscriptionEventType type) {
         }
     }
 
-    private SubscriptionEventType toEventType(final SubscriptionBaseTransitionType in) {
         switch (in) {
             case CREATE:
-                return SubscriptionEventType.START_ENTITLEMENT;
             case MIGRATE_ENTITLEMENT:
-                return SubscriptionEventType.START_ENTITLEMENT;
             case TRANSFER:
-                return SubscriptionEventType.START_ENTITLEMENT;
             case MIGRATE_BILLING:
-                return SubscriptionEventType.START_BILLING;
             case CHANGE:
-                return SubscriptionEventType.CHANGE;
             case CANCEL:
-                return SubscriptionEventType.STOP_BILLING;
             case PHASE:
-                return SubscriptionEventType.PHASE;
             // STEPH This is the old way of pausing billing; not used any longer, but kept for compatibility reason
             case RE_CREATE:
-                return SubscriptionEventType.RESUME_BILLING;
             /*
              * Those can be ignored:
              */
@@ -402,11 +396,10 @@ private SubscriptionEventType toEventType(final SubscriptionBaseTransitionType i
             case START_BILLING_DISABLED:
             case END_BILLING_DISABLED:
             default:
-                return null;
         }
     }
 
-
     @Override
     public UUID getAccountId() {
         return accountId;
</code_before><code_after>@@ -17,6 +17,7 @@
 package com.ning.billing.entitlement.api;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
@@ -226,39 +227,29 @@ private SubscriptionEvent[] findPrevNext(final List&lt;SubscriptionEvent&gt; events, f
         return result;
     }
 
     private LinkedList&lt;SubscriptionEvent&gt; computeSubscriptionBaseEvents(final List&lt;Entitlement&gt; entitlements, final DateTimeZone accountTimeZone) {
         final LinkedList&lt;SubscriptionEvent&gt; result = new LinkedList&lt;SubscriptionEvent&gt;();
+        for (final Entitlement cur : entitlements) {
             final SubscriptionBase base = ((DefaultEntitlement) cur).getSubscriptionBase();
             final List&lt;SubscriptionBaseTransition&gt; baseTransitions = base.getAllTransitions();
+            for (final SubscriptionBaseTransition tr : baseTransitions) {
+                final List&lt;SubscriptionEventType&gt; eventTypes = toEventTypes(tr.getTransitionType());
+                for (final SubscriptionEventType eventType : eventTypes) {
+                    final SubscriptionEvent event = toSubscriptionEvent(tr, eventType, accountTimeZone);
+                    insertSubscriptionEvent(event, result);
                 }
             }
         }
         sanitizeForBaseRecreateEvents(result);
         return result;
     }
 
     //
+    // Old version of code would use CANCEL/RE_CREATE to simulate PAUSE_BILLING/RESUME_BILLING
     //
     private void sanitizeForBaseRecreateEvents(final LinkedList&lt;SubscriptionEvent&gt; input) {
+        final Collection&lt;UUID&gt; guiltyEntitlementIds = new TreeSet&lt;UUID&gt;();
+        final ListIterator&lt;SubscriptionEvent&gt; it = input.listIterator(input.size());
         while (it.hasPrevious()) {
             final SubscriptionEvent cur = it.previous();
             if (cur.getSubscriptionEventType() == SubscriptionEventType.RESUME_BILLING) {
@@ -268,13 +259,16 @@ private void sanitizeForBaseRecreateEvents(final LinkedList&lt;SubscriptionEvent&gt; i
             if (cur.getSubscriptionEventType() == SubscriptionEventType.STOP_BILLING &amp;&amp;
                 guiltyEntitlementIds.contains(cur.getEntitlementId())) {
                 guiltyEntitlementIds.remove(cur.getEntitlementId());
+                final SubscriptionEvent correctedBillingEvent = new DefaultSubscriptionEvent((DefaultSubscriptionEvent) cur, SubscriptionEventType.PAUSE_BILLING);
+                it.set(correctedBillingEvent);
+
+                // Old versions of the code won't have an associated event in blocking_states - we need to add one on the fly
+                final SubscriptionEvent correctedEntitlementEvent = new DefaultSubscriptionEvent((DefaultSubscriptionEvent) cur, SubscriptionEventType.PAUSE_ENTITLEMENT);
+                it.add(correctedEntitlementEvent);
             }
         }
     }
 
     private void insertSubscriptionEvent(final SubscriptionEvent event, final LinkedList&lt;SubscriptionEvent&gt; result) {
         int index = 0;
         for (SubscriptionEvent cur : result) {
@@ -374,25 +368,25 @@ private static String getServiceName(final SubscriptionEventType type) {
         }
     }
 
+    private List&lt;SubscriptionEventType&gt; toEventTypes(final SubscriptionBaseTransitionType in) {
         switch (in) {
             case CREATE:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.START_ENTITLEMENT, SubscriptionEventType.START_BILLING);
             case MIGRATE_ENTITLEMENT:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.START_ENTITLEMENT, SubscriptionEventType.START_BILLING);
             case TRANSFER:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.START_ENTITLEMENT, SubscriptionEventType.START_BILLING);
             case MIGRATE_BILLING:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.START_BILLING);
             case CHANGE:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.CHANGE);
             case CANCEL:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.STOP_BILLING);
             case PHASE:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.PHASE);
             // STEPH This is the old way of pausing billing; not used any longer, but kept for compatibility reason
             case RE_CREATE:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of(SubscriptionEventType.RESUME_ENTITLEMENT, SubscriptionEventType.RESUME_BILLING);
             /*
              * Those can be ignored:
              */
@@ -402,11 +396,10 @@ private SubscriptionEventType toEventType(final SubscriptionBaseTransitionType i
             case START_BILLING_DISABLED:
             case END_BILLING_DISABLED:
             default:
+                return ImmutableList.&lt;SubscriptionEventType&gt;of();
         }
     }
 
     @Override
     public UUID getAccountId() {
         return accountId;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>365385</refactoring_id><commit_sha>48aaf51640462a1981fe8b25954ae8bf620e77a5</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/48aaf51640462a1981fe8b25954ae8bf620e77a5</commit_link><file_path>src/main/java/mekanism/client/render/transmitter/RenderLogisticalTransporter.java</file_path><description>Rename Variable progresses : Set&lt;Integer&gt; to information : Set&lt;TransportInformation&gt; in method private getReducedTransit(inTransit Collection&lt;TransporterStack&gt;) : Collection&lt;TransporterStack&gt; from class mekanism.client.render.transmitter.RenderLogisticalTransporter</description><code_before>@@ -3,18 +3,19 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumMap;
-import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import mekanism.api.EnumColor;
 import mekanism.client.model.ModelTransporterBox;
 import mekanism.client.render.MekanismRenderer;
 import mekanism.client.render.MekanismRenderer.DisplayInteger;
 import mekanism.client.render.MekanismRenderer.GlowInfo;
 import mekanism.client.render.MekanismRenderer.Model3D;
 import mekanism.common.config.MekanismConfig;
 import mekanism.common.content.transporter.TransporterStack;
 import mekanism.common.item.ItemConfigurator;
 import mekanism.common.tile.transmitter.TileEntityDiversionTransporter;
@@ -74,7 +75,8 @@ public void render(TileEntityLogisticalTransporter transporter, double x, double
             entityItem.world = transporter.getWorld();
 
             float partial = partialTick * transporter.tier.getSpeed();
-            for (TransporterStack stack : getReducedTransit(inTransit)) {
                 entityItem.setItem(stack.itemStack);
                 float[] pos = TransporterUtils.getStackPosition(transporter.getTransmitter(), stack, partial);
                 float xShifted = (float) x + pos[0];
@@ -147,21 +149,16 @@ public void render(TileEntityLogisticalTransporter transporter, double x, double
     }
 
     /**
-     * Shrink the in transit list as much as possible. Don't try to render things that are in the same spot with the same color
      */
     private Collection&lt;TransporterStack&gt; getReducedTransit(Collection&lt;TransporterStack&gt; inTransit) {
         Collection&lt;TransporterStack&gt; reducedTransit = new ArrayList&lt;&gt;();
-        //TODO: Should this check stack type also. Not sure if it really matters.
-        Set&lt;Integer&gt; progresses = new HashSet&lt;&gt;();
-        Set&lt;EnumColor&gt; colors = EnumSet.noneOf(EnumColor.class);
         for (TransporterStack stack : inTransit) {
-            if (stack == null || progresses.contains(stack.progress) || (stack.color != null &amp;&amp; colors.contains(stack.color))) {
-                continue;
-            }
-            reducedTransit.add(stack);
-            progresses.add(stack.progress);
-            if (stack.color != null) {
-                colors.add(stack.color);
             }
         }
         return reducedTransit;
@@ -261,4 +258,41 @@ private DisplayInteger getOverlayDisplay(EnumFacing side, int mode) {
         DisplayInteger.endList();
         return display;
     }
 }
\ No newline at end of file
</code_before><code_after>@@ -3,18 +3,19 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import javax.annotation.Nullable;
 import mekanism.api.EnumColor;
 import mekanism.client.model.ModelTransporterBox;
 import mekanism.client.render.MekanismRenderer;
 import mekanism.client.render.MekanismRenderer.DisplayInteger;
 import mekanism.client.render.MekanismRenderer.GlowInfo;
 import mekanism.client.render.MekanismRenderer.Model3D;
 import mekanism.common.config.MekanismConfig;
+import mekanism.common.content.transporter.HashedItem;
 import mekanism.common.content.transporter.TransporterStack;
 import mekanism.common.item.ItemConfigurator;
 import mekanism.common.tile.transmitter.TileEntityDiversionTransporter;
@@ -74,7 +75,8 @@ public void render(TileEntityLogisticalTransporter transporter, double x, double
             entityItem.world = transporter.getWorld();
 
             float partial = partialTick * transporter.tier.getSpeed();
+            Collection&lt;TransporterStack&gt; reducedTransit = getReducedTransit(inTransit);
+            for (TransporterStack stack : reducedTransit) {
                 entityItem.setItem(stack.itemStack);
                 float[] pos = TransporterUtils.getStackPosition(transporter.getTransmitter(), stack, partial);
                 float xShifted = (float) x + pos[0];
@@ -147,21 +149,16 @@ public void render(TileEntityLogisticalTransporter transporter, double x, double
     }
 
     /**
+     * Shrink the in transit list as much as possible. Don't try to render things of the same type that are in the same spot with the same color, ignoring stack size
      */
     private Collection&lt;TransporterStack&gt; getReducedTransit(Collection&lt;TransporterStack&gt; inTransit) {
         Collection&lt;TransporterStack&gt; reducedTransit = new ArrayList&lt;&gt;();
+        Set&lt;TransportInformation&gt; information = new HashSet&lt;&gt;();
         for (TransporterStack stack : inTransit) {
+            if (stack != null &amp;&amp; !stack.itemStack.isEmpty() &amp;&amp; information.add(new TransportInformation(stack))) {
+                //Ensure the stack is valid AND we did not already have information matching the stack
+                //We use add to check if it already contained the value, so that we only have to query the set once
+                reducedTransit.add(stack);
             }
         }
         return reducedTransit;
@@ -261,4 +258,41 @@ private DisplayInteger getOverlayDisplay(EnumFacing side, int mode) {
         DisplayInteger.endList();
         return display;
     }
+
+    private class TransportInformation {
+
+        @Nullable
+        private final EnumColor color;
+        private final HashedItem item;
+        private final int progress;
+
+        private TransportInformation(TransporterStack transporterStack) {
+            this.progress = transporterStack.progress;
+            this.color = transporterStack.color;
+            this.item = new HashedItem(transporterStack.itemStack);
+        }
+
+        @Override
+        public int hashCode() {
+            int code = 1;
+            code = 31 * code + progress;
+            code = 31 * code + item.hashCode();
+            if (color != null) {
+                code = 31 * code + color.hashCode();
+            }
+            return code;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (obj instanceof TransportInformation) {
+                TransportInformation other = (TransportInformation) obj;
+                return progress == other.progress &amp;&amp; color == other.color &amp;&amp; item.equals(other.item);
+            }
+            return false;
+        }
+    }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>446151</refactoring_id><commit_sha>9df5c86f39bcc0407a58e6b185129246f0bb64f5</commit_sha><commit_link>https://github.com/flowable/flowable-engine/commit/9df5c86f39bcc0407a58e6b185129246f0bb64f5</commit_link><file_path>modules/flowable-engine/src/main/java/org/flowable/engine/impl/cmd/DeployCmd.java</file_path><description>Rename Variable activiti5CompatibilityHandler : Activiti5CompatibilityHandler to flowable5CompatibilityHandler : Flowable5CompatibilityHandler in method protected deployAsFlowable5ProcessDefinition(commandContext CommandContext) : Deployment from class org.flowable.engine.impl.cmd.DeployCmd</description><code_before>@@ -21,7 +21,7 @@
 
 import org.flowable.engine.ProcessEngineConfiguration;
 import org.flowable.engine.common.api.FlowableException;
-import org.flowable.engine.compatibility.Activiti5CompatibilityHandler;
 import org.flowable.engine.delegate.event.FlowableEngineEventType;
 import org.flowable.engine.delegate.event.impl.FlowableEventBuilder;
 import org.flowable.engine.impl.interceptor.Command;
@@ -49,12 +49,12 @@ public DeployCmd(DeploymentBuilderImpl deploymentBuilder) {
   public Deployment execute(CommandContext commandContext) {
 
     // Backwards compatibility with Activiti v5
-    if (commandContext.getProcessEngineConfiguration().isActiviti5CompatibilityEnabled()
         &amp;&amp; deploymentBuilder.getDeploymentProperties() != null 
-        &amp;&amp; deploymentBuilder.getDeploymentProperties().containsKey(DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION)
-        &amp;&amp; deploymentBuilder.getDeploymentProperties().get(DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION).equals(Boolean.TRUE)) {
       
-        return deployAsActiviti5ProcessDefinition(commandContext);
     }
 
     return executeDeploy(commandContext);
@@ -120,13 +120,13 @@ protected Deployment executeDeploy(CommandContext commandContext) {
     return deployment;
   }
 
-  protected Deployment deployAsActiviti5ProcessDefinition(CommandContext commandContext) {
-    Activiti5CompatibilityHandler activiti5CompatibilityHandler = commandContext.getProcessEngineConfiguration().getActiviti5CompatibilityHandler();
-    if (activiti5CompatibilityHandler == null) {
-      throw new FlowableException("Found Activiti 5 process definition, but no compatibility handler on the classpath. " 
-          + "Cannot use the deployment property " + DeploymentProperties.DEPLOY_AS_ACTIVITI5_PROCESS_DEFINITION);
     }
-    return activiti5CompatibilityHandler.deploy(deploymentBuilder);
   }
 
   protected boolean deploymentsDiffer(DeploymentEntity deployment, DeploymentEntity saved) {
</code_before><code_after>@@ -21,7 +21,7 @@
 
 import org.flowable.engine.ProcessEngineConfiguration;
 import org.flowable.engine.common.api.FlowableException;
+import org.flowable.engine.compatibility.Flowable5CompatibilityHandler;
 import org.flowable.engine.delegate.event.FlowableEngineEventType;
 import org.flowable.engine.delegate.event.impl.FlowableEventBuilder;
 import org.flowable.engine.impl.interceptor.Command;
@@ -49,12 +49,12 @@ public DeployCmd(DeploymentBuilderImpl deploymentBuilder) {
   public Deployment execute(CommandContext commandContext) {
 
     // Backwards compatibility with Activiti v5
+    if (commandContext.getProcessEngineConfiguration().isFlowable5CompatibilityEnabled()
         &amp;&amp; deploymentBuilder.getDeploymentProperties() != null 
+        &amp;&amp; deploymentBuilder.getDeploymentProperties().containsKey(DeploymentProperties.DEPLOY_AS_FLOWABLE5_PROCESS_DEFINITION)
+        &amp;&amp; deploymentBuilder.getDeploymentProperties().get(DeploymentProperties.DEPLOY_AS_FLOWABLE5_PROCESS_DEFINITION).equals(Boolean.TRUE)) {
       
+        return deployAsFlowable5ProcessDefinition(commandContext);
     }
 
     return executeDeploy(commandContext);
@@ -120,13 +120,13 @@ protected Deployment executeDeploy(CommandContext commandContext) {
     return deployment;
   }
 
+  protected Deployment deployAsFlowable5ProcessDefinition(CommandContext commandContext) {
+    Flowable5CompatibilityHandler flowable5CompatibilityHandler = commandContext.getProcessEngineConfiguration().getFlowable5CompatibilityHandler();
+    if (flowable5CompatibilityHandler == null) {
+      throw new FlowableException("Found Flowable 5 process definition, but no compatibility handler on the classpath. " 
+          + "Cannot use the deployment property " + DeploymentProperties.DEPLOY_AS_FLOWABLE5_PROCESS_DEFINITION);
     }
+    return flowable5CompatibilityHandler.deploy(deploymentBuilder);
   }
 
   protected boolean deploymentsDiffer(DeploymentEntity deployment, DeploymentEntity saved) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>382973</refactoring_id><commit_sha>7bcf23279d99fb7d24b6f758ef3fe8ca58f45139</commit_sha><commit_link>https://github.com/apache/ignite/commit/7bcf23279d99fb7d24b6f758ef3fe8ca58f45139</commit_link><file_path>modules/control-utility/src/test/java/org/apache/ignite/util/GridCommandHandlerTest.java</file_path><description>Rename Variable isInstanse1Found : boolean to isInstance1Found : boolean in method public testBaselineAddOnNotActiveCluster() : void from class org.apache.ignite.util.GridCommandHandlerTest</description><code_before>@@ -2053,14 +2053,14 @@ public void testBaselineAddOnNotActiveCluster() throws Exception {
         String testOutStr = testOut.toString();
 
         // Ignite instase 1 can be logged only in arguments list.
-        boolean isInstanse1Found = Arrays.stream(testOutStr.split("\n"))
                                         .filter(s -&gt; s.contains("Arguments:"))
                                         .noneMatch(s -&gt; s.contains(getTestIgniteInstanceName() + "1"));
 
         assertTrue(testOutStr, testOutStr.contains("Node not found for consistent ID:"));
 
         if (commandHandler.equals(CLI_CMD_HND))
-            assertFalse(testOutStr, isInstanse1Found);
     }
 
     /** */
</code_before><code_after>@@ -2053,14 +2053,14 @@ public void testBaselineAddOnNotActiveCluster() throws Exception {
         String testOutStr = testOut.toString();
 
         // Ignite instase 1 can be logged only in arguments list.
+        boolean isInstance1Found = Arrays.stream(testOutStr.split("\n"))
                                         .filter(s -&gt; s.contains("Arguments:"))
                                         .noneMatch(s -&gt; s.contains(getTestIgniteInstanceName() + "1"));
 
         assertTrue(testOutStr, testOutStr.contains("Node not found for consistent ID:"));
 
         if (commandHandler.equals(CLI_CMD_HND))
+            assertFalse(testOutStr, isInstance1Found);
     }
 
     /** */
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>383124</refactoring_id><commit_sha>693a6e88e28ac4d8ee44824e77b522e31cb0edfd</commit_sha><commit_link>https://github.com/apache/ignite/commit/693a6e88e28ac4d8ee44824e77b522e31cb0edfd</commit_link><file_path>modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridMapQueryExecutor.java</file_path><description>Rename Variable distirbutedJoinCtx : DistributedJoinContext to distributedJoinCtx : DistributedJoinContext in method private onQueryRequest0(node ClusterNode, reqId long, segmentId int, schemaName String, qrys Collection&lt;GridCacheSqlQuery&gt;, cacheIds List&lt;Integer&gt;, topVer AffinityTopologyVersion, partsMap Map&lt;UUID,int[]&gt;, parts int[], pageSize int, distributeJoins boolean, local boolean, enforceJoinOrder boolean, replicated boolean, timeout int, params Object[], lazy boolean, mvccSnapshot MvccSnapshot, tx GridDhtTxLocalAdapter, txDetails GridH2SelectForUpdateTxDetails, lockFut CompoundLockFuture, runCntr AtomicInteger, dataPageScanEnabled Boolean) : void from class org.apache.ignite.internal.processors.query.h2.twostep.GridMapQueryExecutor</description><code_before>@@ -73,9 +73,9 @@
 import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;
 import org.apache.ignite.internal.processors.query.h2.ResultSetEnlistFuture;
 import org.apache.ignite.internal.processors.query.h2.UpdateResult;
-import org.apache.ignite.internal.processors.query.h2.opt.GridH2QueryContext;
-import org.apache.ignite.internal.processors.query.h2.opt.GridH2QueryType;
 import org.apache.ignite.internal.processors.query.h2.opt.GridH2RetryException;
 import org.apache.ignite.internal.processors.query.h2.opt.join.DistributedJoinContext;
 import org.apache.ignite.internal.processors.query.h2.sql.GridSqlQueryParser;
 import org.apache.ignite.internal.processors.query.h2.twostep.messages.GridQueryCancelRequest;
@@ -109,8 +109,7 @@
 import static org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion.NONE;
 import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.LOST;
 import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;
-import static org.apache.ignite.internal.processors.query.h2.opt.GridH2QueryType.MAP;
-import static org.apache.ignite.internal.processors.query.h2.opt.GridH2QueryType.REPLICATED;
 import static org.apache.ignite.internal.processors.query.h2.twostep.msg.GridH2QueryRequest.isDataPageScanEnabled;
 import static org.apache.ignite.internal.processors.query.h2.twostep.msg.GridH2ValueMessageFactory.toMessages;
 
@@ -131,6 +130,9 @@ public class GridMapQueryExecutor {
     /** */
     private IgniteH2Indexing h2;
 
     /** */
     private ConcurrentMap&lt;UUID, MapNodeResults&gt; qryRess = new ConcurrentHashMap&lt;&gt;();
 
@@ -165,15 +167,15 @@ public void start(final GridKernalContext ctx, IgniteH2Indexing h2) throws Ignit
         this.ctx = ctx;
         this.h2 = h2;
 
-        log = ctx.log(GridMapQueryExecutor.class);
 
-        final UUID locNodeId = ctx.localNodeId();
 
         ctx.event().addLocalEventListener(new GridLocalEventListener() {
             @Override public void onEvent(final Event evt) {
                 UUID nodeId = ((DiscoveryEvent)evt).eventNode().id();
 
-                GridH2QueryContext.clearAfterDeadNode(locNodeId, nodeId);
 
                 MapNodeResults nodeRess = qryRess.remove(nodeId);
 
@@ -268,12 +270,12 @@ private void onCancel(ClusterNode node, GridQueryCancelRequest msg) {
 
         MapNodeResults nodeRess = resultsForNode(node.id());
 
-        boolean clear = GridH2QueryContext.clear(ctx.localNodeId(), node.id(), qryReqId, MAP);
 
         if (!clear) {
             nodeRess.onCancel(qryReqId);
 
-            GridH2QueryContext.clear(ctx.localNodeId(), node.id(), qryReqId, MAP);
         }
 
         nodeRess.cancelRequest(qryReqId);
@@ -758,7 +760,7 @@ private void onQueryRequest0(
         if (lazy &amp;&amp; worker == null) {
             // Lazy queries must be re-submitted to dedicated workers.
             MapQueryLazyWorkerKey key = new MapQueryLazyWorkerKey(node.id(), reqId, segmentId);
-            worker = new MapQueryLazyWorker(ctx.igniteInstanceName(), key, log, this);
 
             worker.submit(new Runnable() {
                 @Override public void run() {
@@ -846,10 +848,10 @@ private void onQueryRequest0(
                 throw new IllegalStateException();
 
             // Prepare query context.
-            DistributedJoinContext distirbutedJoinCtx = null;
 
-            if (distributeJoins) {
-                distirbutedJoinCtx = new DistributedJoinContext(
                     local,
                     topVer,
                     partsMap,
@@ -860,32 +862,30 @@ private void onQueryRequest0(
                 );
             }
 
-            GridH2QueryType qryTyp = replicated ? REPLICATED : MAP;
-
-            GridH2QueryContext qctx = new GridH2QueryContext(ctx.localNodeId(),
-                node.id(),
-                reqId,
                 segmentId,
-                qryTyp,
-                h2.backupFilter(topVer, parts)
             )
-                .distributedJoinContext(distirbutedJoinCtx)
-                .reservations(reserved)
-                .mvccSnapshot(mvccSnapshot)
                 .lazyWorker(worker);
 
             Connection conn = h2.connections().connectionForThread().connection(schemaName);
 
             H2Utils.setupConnection(conn, distributeJoins, enforceJoinOrder);
 
-            GridH2QueryContext.set(qctx);
 
             // qctx is set, we have to release reservations inside of it.
             reserved = null;
 
             try {
                 if (nodeRess.cancelled(reqId)) {
-                    GridH2QueryContext.clear(ctx.localNodeId(), node.id(), reqId, qryTyp);
 
                     nodeRess.cancelRequest(reqId);
 
@@ -1074,10 +1074,10 @@ private GridCacheContext mainCacheContext(List&lt;Integer&gt; cacheIds) {
      * Releases reserved partitions.
      */
     private void releaseReservations() {
-        GridH2QueryContext qctx = GridH2QueryContext.get();
 
         if (qctx != null) { // No-op if already released.
-            GridH2QueryContext.clearThreadLocal();
 
             if (qctx.distributedJoinContext() == null)
                 qctx.clearContext(false);
</code_before><code_after>@@ -73,9 +73,9 @@
 import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;
 import org.apache.ignite.internal.processors.query.h2.ResultSetEnlistFuture;
 import org.apache.ignite.internal.processors.query.h2.UpdateResult;
 import org.apache.ignite.internal.processors.query.h2.opt.GridH2RetryException;
+import org.apache.ignite.internal.processors.query.h2.opt.QueryContext;
+import org.apache.ignite.internal.processors.query.h2.opt.QueryContextRegistry;
 import org.apache.ignite.internal.processors.query.h2.opt.join.DistributedJoinContext;
 import org.apache.ignite.internal.processors.query.h2.sql.GridSqlQueryParser;
 import org.apache.ignite.internal.processors.query.h2.twostep.messages.GridQueryCancelRequest;
@@ -109,8 +109,7 @@
 import static org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion.NONE;
 import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.LOST;
 import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;
+
 import static org.apache.ignite.internal.processors.query.h2.twostep.msg.GridH2QueryRequest.isDataPageScanEnabled;
 import static org.apache.ignite.internal.processors.query.h2.twostep.msg.GridH2ValueMessageFactory.toMessages;
 
@@ -131,6 +130,9 @@ public class GridMapQueryExecutor {
     /** */
     private IgniteH2Indexing h2;
 
+    /** Query context registry. */
+    private QueryContextRegistry qryCtxRegistry;
+
     /** */
     private ConcurrentMap&lt;UUID, MapNodeResults&gt; qryRess = new ConcurrentHashMap&lt;&gt;();
 
@@ -165,15 +167,15 @@ public void start(final GridKernalContext ctx, IgniteH2Indexing h2) throws Ignit
         this.ctx = ctx;
         this.h2 = h2;
 
+        qryCtxRegistry = h2.queryContextRegistry();
 
+        log = ctx.log(GridMapQueryExecutor.class);
 
         ctx.event().addLocalEventListener(new GridLocalEventListener() {
             @Override public void onEvent(final Event evt) {
                 UUID nodeId = ((DiscoveryEvent)evt).eventNode().id();
 
+                qryCtxRegistry.clearSharedOnRemoteNodeStop(nodeId);
 
                 MapNodeResults nodeRess = qryRess.remove(nodeId);
 
@@ -268,12 +270,12 @@ private void onCancel(ClusterNode node, GridQueryCancelRequest msg) {
 
         MapNodeResults nodeRess = resultsForNode(node.id());
 
+        boolean clear = qryCtxRegistry.clearShared(node.id(), qryReqId);
 
         if (!clear) {
             nodeRess.onCancel(qryReqId);
 
+            qryCtxRegistry.clearShared(node.id(), qryReqId);
         }
 
         nodeRess.cancelRequest(qryReqId);
@@ -758,7 +760,7 @@ private void onQueryRequest0(
         if (lazy &amp;&amp; worker == null) {
             // Lazy queries must be re-submitted to dedicated workers.
             MapQueryLazyWorkerKey key = new MapQueryLazyWorkerKey(node.id(), reqId, segmentId);
+            worker = new MapQueryLazyWorker(ctx.igniteInstanceName(), key, log, this, qryCtxRegistry);
 
             worker.submit(new Runnable() {
                 @Override public void run() {
@@ -846,10 +848,10 @@ private void onQueryRequest0(
                 throw new IllegalStateException();
 
             // Prepare query context.
+            DistributedJoinContext distributedJoinCtx = null;
 
+            if (distributeJoins &amp;&amp; !replicated) {
+                distributedJoinCtx = new DistributedJoinContext(
                     local,
                     topVer,
                     partsMap,
@@ -860,32 +862,30 @@ private void onQueryRequest0(
                 );
             }
 
+            QueryContext qctx = new QueryContext(
                 segmentId,
+                h2.backupFilter(topVer, parts),
+                distributedJoinCtx,
+                mvccSnapshot,
+                reserved
             )
                 .lazyWorker(worker);
 
             Connection conn = h2.connections().connectionForThread().connection(schemaName);
 
             H2Utils.setupConnection(conn, distributeJoins, enforceJoinOrder);
 
+            qryCtxRegistry.setThreadLocal(qctx);
+
+            if (distributedJoinCtx != null)
+                qryCtxRegistry.setShared(node.id(), reqId, qctx);
 
             // qctx is set, we have to release reservations inside of it.
             reserved = null;
 
             try {
                 if (nodeRess.cancelled(reqId)) {
+                    qryCtxRegistry.clearShared(node.id(), reqId);
 
                     nodeRess.cancelRequest(reqId);
 
@@ -1074,10 +1074,10 @@ private GridCacheContext mainCacheContext(List&lt;Integer&gt; cacheIds) {
      * Releases reserved partitions.
      */
     private void releaseReservations() {
+        QueryContext qctx = qryCtxRegistry.getThreadLocal();
 
         if (qctx != null) { // No-op if already released.
+            qryCtxRegistry.clearThreadLocal();
 
             if (qctx.distributedJoinContext() == null)
                 qctx.clearContext(false);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>399785</refactoring_id><commit_sha>834e050bc44ebdf5d6eb28d85667b206060da583</commit_sha><commit_link>https://github.com/apache/druid/commit/834e050bc44ebdf5d6eb28d85667b206060da583</commit_link><file_path>server/src/main/java/io/druid/server/http/OverlordProxyServlet.java</file_path><description>Rename Variable indexer : Server to overlordLeader : String in method protected rewriteTarget(request HttpServletRequest) : String from class io.druid.server.http.OverlordProxyServlet</description><code_before>@@ -21,12 +21,9 @@
 
 import com.google.common.base.Throwables;
 import com.google.inject.Inject;
-
 import io.druid.client.indexing.IndexingService;
-import io.druid.client.selector.Server;
-import io.druid.curator.discovery.ServerDiscoverySelector;
 import io.druid.java.util.common.ISE;
-
 import org.eclipse.jetty.proxy.ProxyServlet;
 
 import javax.servlet.http.HttpServletRequest;
@@ -38,27 +35,28 @@
  */
 public class OverlordProxyServlet extends ProxyServlet
 {
-  private final ServerDiscoverySelector selector;
 
   @Inject
   OverlordProxyServlet(
-      @IndexingService ServerDiscoverySelector selector
   )
   {
-    this.selector = selector;
   }
 
   @Override
   protected String rewriteTarget(HttpServletRequest request)
   {
     try {
-      final Server indexer = selector.pick();
-      if (indexer == null) {
-        throw new ISE("Can't find indexingService, did you configure druid.selectors.indexing.serviceName same as druid.service at overlord?");
       }
       return new URI(
           request.getScheme(),
-          indexer.getHost(),
           request.getRequestURI(),
           request.getQueryString(),
           null
</code_before><code_after>@@ -21,12 +21,9 @@
 
 import com.google.common.base.Throwables;
 import com.google.inject.Inject;
 import io.druid.client.indexing.IndexingService;
+import io.druid.discovery.DruidLeaderClient;
 import io.druid.java.util.common.ISE;
 import org.eclipse.jetty.proxy.ProxyServlet;
 
 import javax.servlet.http.HttpServletRequest;
@@ -38,27 +35,28 @@
  */
 public class OverlordProxyServlet extends ProxyServlet
 {
+  private final DruidLeaderClient druidLeaderClient;
 
   @Inject
   OverlordProxyServlet(
+      @IndexingService DruidLeaderClient druidLeaderClient
   )
   {
+    this.druidLeaderClient = druidLeaderClient;
   }
 
   @Override
   protected String rewriteTarget(HttpServletRequest request)
   {
     try {
+      final String overlordLeader = druidLeaderClient.findCurrentLeader();
+      if (overlordLeader == null) {
+        throw new ISE("Can't find Overlord leader.");
       }
+
       return new URI(
           request.getScheme(),
+          overlordLeader,
           request.getRequestURI(),
           request.getQueryString(),
           null
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>339956</refactoring_id><commit_sha>c0c63b5d89c46c74ee3097a9e46cb7661a99e7e1</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/c0c63b5d89c46c74ee3097a9e46cb7661a99e7e1</commit_link><file_path>backend/de.metas.migration/de.metas.migration.cli/src/main/java/de/metas/migration/cli/workspace_migrate/Main.java</file_path><description>Rename Variable valueStr : String to systemPropertyValue : String in method private getBooleanProperty(name String, defaultValue boolean) : boolean from class de.metas.migration.cli.workspace_migrate.Main</description><code_before>@@ -91,7 +91,7 @@ private static File getWorkspaceDir()
 			logger.warn("Using current working directory as workspace folder: {}. Run JVM with '-D{}=...' to override it.", cwd, PROP_WORKSPACE);
 			return cwd;
 		}
-		catch (Exception ex)
 		{
 			throw new RuntimeException("Failed getting CWD", ex);
 		}
@@ -105,35 +105,48 @@ private static ImmutableSet&lt;Label&gt; getLabels()
 
 	private static String getMandatoryProperty(final String name, final String defaultValue)
 	{
-		final String value = System.getProperty(name);
-		if (!isBlank(value))
 		{
-			return value;
 		}
 
 		if (!isBlank(defaultValue))
 		{
-			logger.info("Considering default config: {}={}. To override it start JVM with '-D{}=...'.", name, defaultValue, name);
 			return defaultValue;
 		}
 
 		throw new RuntimeException("Property '" + name + "' was not set. "
-				+ "\n Please set JVM property '-D" + name + "=...'.");
 	}
 
 	private static boolean getBooleanProperty(final String name, final boolean defaultValue)
 	{
-		final String valueStr = System.getProperty(name);
-		if (!isBlank(valueStr))
 		{
-			return Boolean.parseBoolean(valueStr.trim());
 		}
 
-		logger.info("Considering default config: {}={}. To override it start JVM with '-D{}=...'.", name, defaultValue, name);
 		return defaultValue;
 	}
 
-	private static final boolean isBlank(final String str)
 	{
 		return str == null || str.trim().isEmpty();
 	}
</code_before><code_after>@@ -91,7 +91,7 @@ private static File getWorkspaceDir()
 			logger.warn("Using current working directory as workspace folder: {}. Run JVM with '-D{}=...' to override it.", cwd, PROP_WORKSPACE);
 			return cwd;
 		}
+		catch (final Exception ex)
 		{
 			throw new RuntimeException("Failed getting CWD", ex);
 		}
@@ -105,35 +105,48 @@ private static ImmutableSet&lt;Label&gt; getLabels()
 
 	private static String getMandatoryProperty(final String name, final String defaultValue)
 	{
+		final String systemPropertyValue = System.getProperty(name);
+		if (!isBlank(systemPropertyValue))
 		{
+			return systemPropertyValue;
+		}
+
+		final String evnVarValue = System.getenv(name);
+		if (!isBlank(evnVarValue))
+		{
+			return evnVarValue;
 		}
 
 		if (!isBlank(defaultValue))
 		{
+			logger.info("Considering default config: {}={}. To override it start JVM with '-D{}=...' OR set environment-variable '{}=...'.", name, defaultValue, name, name);
 			return defaultValue;
 		}
 
 		throw new RuntimeException("Property '" + name + "' was not set. "
+										   + "\n Please start JVM with '-D" + name + "=...'"
+										   + " OR set environment-variable '" + name + "=...'.");
 	}
 
 	private static boolean getBooleanProperty(final String name, final boolean defaultValue)
 	{
+		final String systemPropertyValue = System.getProperty(name);
+		if (!isBlank(systemPropertyValue))
+		{
+			return Boolean.parseBoolean(systemPropertyValue.trim());
+		}
+
+		final String evnVarValue = System.getenv(name);
+		if (!isBlank(evnVarValue))
 		{
+			return Boolean.parseBoolean(evnVarValue);
 		}
 
+		logger.info("Considering default config: {}={}. To override it start JVM with '-D{}=...' OR set environment-variable '{}=...'.", name, defaultValue, name, name);
 		return defaultValue;
 	}
 
+	private static boolean isBlank(final String str)
 	{
 		return str == null || str.trim().isEmpty();
 	}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>355063</refactoring_id><commit_sha>177f51c6873f60313e4150812b34a0aac1eebc8f</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/177f51c6873f60313e4150812b34a0aac1eebc8f</commit_link><file_path>configserver/src/main/java/com/yahoo/vespa/config/server/session/SessionRepository.java</file_path><description>Rename Variable previousApplicationSet : Optional&lt;ApplicationSet&gt; to previousActiveApplicationVersions : Optional&lt;ApplicationVersions&gt; in method public ensureApplicationLoaded(session RemoteSession) : ApplicationVersions from class com.yahoo.vespa.config.server.session.SessionRepository</description><code_before>@@ -22,7 +22,7 @@
 import com.yahoo.transaction.Transaction;
 import com.yahoo.vespa.config.server.ConfigServerDB;
 import com.yahoo.vespa.config.server.TimeoutBudget;
-import com.yahoo.vespa.config.server.application.ApplicationSet;
 import com.yahoo.vespa.config.server.application.TenantApplications;
 import com.yahoo.vespa.config.server.configchange.ConfigChangeActions;
 import com.yahoo.vespa.config.server.deploy.TenantFileSystemDirs;
@@ -246,9 +246,9 @@ public ConfigChangeActions prepareLocalSession(Session session, DeployLogger log
         Optional&lt;CompletionWaiter&gt; waiter = params.isDryRun()
                 ? Optional.empty()
                 : Optional.of(sessionZooKeeperClient.createPrepareWaiter());
-        Optional&lt;ApplicationSet&gt; activeApplicationSet = getActiveApplicationSet(params.getApplicationId());
         ConfigChangeActions actions = sessionPreparer.prepare(applicationRepo, logger, params,
-                                                              activeApplicationSet, now, getSessionAppDir(sessionId),
                                                               session.getApplicationPackage(), sessionZooKeeperClient)
                 .getConfigChangeActions();
         setPrepared(session);
@@ -479,20 +479,20 @@ void prepareRemoteSession(long sessionId) {
         notifyCompletion(waiter);
     }
 
-    public ApplicationSet ensureApplicationLoaded(RemoteSession session) {
-        if (session.applicationSet().isPresent()) {
-            return session.applicationSet().get();
         }
         Optional&lt;Long&gt; activeSessionId = getActiveSessionId(session.getApplicationId());
-        Optional&lt;ApplicationSet&gt; previousApplicationSet = activeSessionId.filter(session::isNewerThan)
-                                                                         .flatMap(this::getApplicationSet);
-        ApplicationSet applicationSet = loadApplication(session, previousApplicationSet);
-        RemoteSession activated = session.activated(applicationSet);
         long sessionId = activated.getSessionId();
         remoteSessionCache.put(sessionId, activated);
         updateSessionStateWatcher(sessionId);
 
-        return applicationSet;
     }
 
     void confirmUpload(Session session) {
@@ -526,7 +526,7 @@ void notifyCompletion(CompletionWaiter completionWaiter) {
         }
     }
 
-    private ApplicationSet loadApplication(Session session, Optional&lt;ApplicationSet&gt; previousApplicationSet) {
         log.log(Level.FINE, () -&gt; "Loading application for " + session);
         SessionZooKeeperClient sessionZooKeeperClient = createSessionZooKeeperClient(session.getSessionId());
         ActivatedModelsBuilder builder = new ActivatedModelsBuilder(session.getTenantName(),
@@ -543,12 +543,12 @@ private ApplicationSet loadApplication(Session session, Optional&lt;ApplicationSet&gt;
                                                                     zone,
                                                                     modelFactoryRegistry,
                                                                     configDefinitionRepo);
-        return ApplicationSet.fromList(builder.buildModels(session.getApplicationId(),
-                                                           session.getDockerImageRepository(),
-                                                           session.getVespaVersion(),
-                                                           sessionZooKeeperClient.loadApplicationPackage(),
-                                                           new AllocatedHostsFromAllModels(),
-                                                           clock.instant()));
     }
 
     private void nodeChanged() {
@@ -775,11 +775,11 @@ private ApplicationPackage createApplicationPackage(File applicationDirectory,
         }
     }
 
-    public Optional&lt;ApplicationSet&gt; getActiveApplicationSet(ApplicationId appId) {
-        return applicationRepo.activeSessionOf(appId).flatMap(this::getApplicationSet);
     }
 
-    private Optional&lt;ApplicationSet&gt; getApplicationSet(long sessionId) {
         try {
             return Optional.ofNullable(getRemoteSession(sessionId)).map(this::ensureApplicationLoaded);
         } catch (IllegalArgumentException e) {
</code_before><code_after>@@ -22,7 +22,7 @@
 import com.yahoo.transaction.Transaction;
 import com.yahoo.vespa.config.server.ConfigServerDB;
 import com.yahoo.vespa.config.server.TimeoutBudget;
+import com.yahoo.vespa.config.server.application.ApplicationVersions;
 import com.yahoo.vespa.config.server.application.TenantApplications;
 import com.yahoo.vespa.config.server.configchange.ConfigChangeActions;
 import com.yahoo.vespa.config.server.deploy.TenantFileSystemDirs;
@@ -246,9 +246,9 @@ public ConfigChangeActions prepareLocalSession(Session session, DeployLogger log
         Optional&lt;CompletionWaiter&gt; waiter = params.isDryRun()
                 ? Optional.empty()
                 : Optional.of(sessionZooKeeperClient.createPrepareWaiter());
+        Optional&lt;ApplicationVersions&gt; activeApplicationVersions = activeApplicationVersions(params.getApplicationId());
         ConfigChangeActions actions = sessionPreparer.prepare(applicationRepo, logger, params,
+                                                              activeApplicationVersions, now, getSessionAppDir(sessionId),
                                                               session.getApplicationPackage(), sessionZooKeeperClient)
                 .getConfigChangeActions();
         setPrepared(session);
@@ -479,20 +479,20 @@ void prepareRemoteSession(long sessionId) {
         notifyCompletion(waiter);
     }
 
+    public ApplicationVersions ensureApplicationLoaded(RemoteSession session) {
+        if (session.applicationVersions().isPresent()) {
+            return session.applicationVersions().get();
         }
         Optional&lt;Long&gt; activeSessionId = getActiveSessionId(session.getApplicationId());
+        Optional&lt;ApplicationVersions&gt; previousActiveApplicationVersions = activeSessionId.filter(session::isNewerThan)
+                                                                         .flatMap(this::activeApplicationVersions);
+        ApplicationVersions applicationVersions = loadApplication(session, previousActiveApplicationVersions);
+        RemoteSession activated = session.activated(applicationVersions);
         long sessionId = activated.getSessionId();
         remoteSessionCache.put(sessionId, activated);
         updateSessionStateWatcher(sessionId);
 
+        return applicationVersions;
     }
 
     void confirmUpload(Session session) {
@@ -526,7 +526,7 @@ void notifyCompletion(CompletionWaiter completionWaiter) {
         }
     }
 
+    private ApplicationVersions loadApplication(Session session, Optional&lt;ApplicationVersions&gt; previousApplicationSet) {
         log.log(Level.FINE, () -&gt; "Loading application for " + session);
         SessionZooKeeperClient sessionZooKeeperClient = createSessionZooKeeperClient(session.getSessionId());
         ActivatedModelsBuilder builder = new ActivatedModelsBuilder(session.getTenantName(),
@@ -543,12 +543,12 @@ private ApplicationSet loadApplication(Session session, Optional&lt;ApplicationSet&gt;
                                                                     zone,
                                                                     modelFactoryRegistry,
                                                                     configDefinitionRepo);
+        return ApplicationVersions.fromList(builder.buildModels(session.getApplicationId(),
+                                                                session.getDockerImageRepository(),
+                                                                session.getVespaVersion(),
+                                                                sessionZooKeeperClient.loadApplicationPackage(),
+                                                                new AllocatedHostsFromAllModels(),
+                                                                clock.instant()));
     }
 
     private void nodeChanged() {
@@ -775,11 +775,11 @@ private ApplicationPackage createApplicationPackage(File applicationDirectory,
         }
     }
 
+    public Optional&lt;ApplicationVersions&gt; activeApplicationVersions(ApplicationId appId) {
+        return applicationRepo.activeSessionOf(appId).flatMap(this::activeApplicationVersions);
     }
 
+    private Optional&lt;ApplicationVersions&gt; activeApplicationVersions(long sessionId) {
         try {
             return Optional.ofNullable(getRemoteSession(sessionId)).map(this::ensureApplicationLoaded);
         } catch (IllegalArgumentException e) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>417182</refactoring_id><commit_sha>d845bce265a0156e7c297668c11cd9d1bdb4c845</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/d845bce265a0156e7c297668c11cd9d1bdb4c845</commit_link><file_path>src/edu/stanford/nlp/sentiment/SentimentModel.java</file_path><description>Rename Variable rawWordVectors : Map&lt;String,SimpleMatrix&gt; to embedding : Embedding in method package readWordVectors() : void from class edu.stanford.nlp.sentiment.SentimentModel</description><code_before>@@ -12,8 +12,9 @@
 
 import edu.stanford.nlp.io.IOUtils;
 import edu.stanford.nlp.io.RuntimeIOException;
-import edu.stanford.nlp.rnn.RNNUtils;
-import edu.stanford.nlp.rnn.SimpleTensor;
 import edu.stanford.nlp.trees.Tree;
 import edu.stanford.nlp.util.Generics;
 import edu.stanford.nlp.util.Pair;
@@ -289,7 +290,7 @@ SimpleMatrix randomWordVector() {
   }
 
   static SimpleMatrix randomWordVector(int size, Random rand) {
-    return RNNUtils.randomGaussian(size, 1, rand);
   }
 
   void initRandomWordVectors(List&lt;Tree&gt; trainingTrees) {
@@ -316,11 +317,13 @@ void initRandomWordVectors(List&lt;Tree&gt; trainingTrees) {
   }
 
   void readWordVectors() {
     this.wordVectors = Generics.newTreeMap();
-    Map&lt;String, SimpleMatrix&gt; rawWordVectors = RNNUtils.readRawWordVectors(op.wordVectors, op.numHid);
-    for (String word : rawWordVectors.keySet()) {
       // TODO: factor out unknown word vector code from DVParser
-      wordVectors.put(word, rawWordVectors.get(word));
     }
 
     String unkWord = op.unkWord;
@@ -343,11 +346,11 @@ public int totalParamSize() {
   
   public double[] paramsToVector() {
     int totalSize = totalParamSize();
-    return RNNUtils.paramsToVector(totalSize, binaryTransform.valueIterator(), binaryClassification.valueIterator(), SimpleTensor.iteratorSimpleMatrix(binaryTensors.valueIterator()), unaryClassification.values().iterator(), wordVectors.values().iterator());
   }
 
   public void vectorToParams(double[] theta) {
-    RNNUtils.vectorToParams(theta, binaryTransform.valueIterator(), binaryClassification.valueIterator(), SimpleTensor.iteratorSimpleMatrix(binaryTensors.valueIterator()), unaryClassification.values().iterator(), wordVectors.values().iterator());
   }
 
   // TODO: combine this and getClassWForNode?
</code_before><code_after>@@ -12,8 +12,9 @@
 
 import edu.stanford.nlp.io.IOUtils;
 import edu.stanford.nlp.io.RuntimeIOException;
+import edu.stanford.nlp.neural.Embedding;
+import edu.stanford.nlp.neural.NeuralUtils;
+import edu.stanford.nlp.neural.SimpleTensor;
 import edu.stanford.nlp.trees.Tree;
 import edu.stanford.nlp.util.Generics;
 import edu.stanford.nlp.util.Pair;
@@ -289,7 +290,7 @@ SimpleMatrix randomWordVector() {
   }
 
   static SimpleMatrix randomWordVector(int size, Random rand) {
+    return NeuralUtils.randomGaussian(size, 1, rand);
   }
 
   void initRandomWordVectors(List&lt;Tree&gt; trainingTrees) {
@@ -316,11 +317,13 @@ void initRandomWordVectors(List&lt;Tree&gt; trainingTrees) {
   }
 
   void readWordVectors() {
+    Embedding embedding = new Embedding(op.wordVectors, op.numHid);
     this.wordVectors = Generics.newTreeMap();
+//    Map&lt;String, SimpleMatrix&gt; rawWordVectors = NeuralUtils.readRawWordVectors(op.wordVectors, op.numHid);
+//    for (String word : rawWordVectors.keySet()) {
+    for (String word : embedding.keySet()) {
       // TODO: factor out unknown word vector code from DVParser
+      wordVectors.put(word, embedding.get(word));
     }
 
     String unkWord = op.unkWord;
@@ -343,11 +346,11 @@ public int totalParamSize() {
   
   public double[] paramsToVector() {
     int totalSize = totalParamSize();
+    return NeuralUtils.paramsToVector(totalSize, binaryTransform.valueIterator(), binaryClassification.valueIterator(), SimpleTensor.iteratorSimpleMatrix(binaryTensors.valueIterator()), unaryClassification.values().iterator(), wordVectors.values().iterator());
   }
 
   public void vectorToParams(double[] theta) {
+    NeuralUtils.vectorToParams(theta, binaryTransform.valueIterator(), binaryClassification.valueIterator(), SimpleTensor.iteratorSimpleMatrix(binaryTensors.valueIterator()), unaryClassification.values().iterator(), wordVectors.values().iterator());
   }
 
   // TODO: combine this and getClassWForNode?
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>397470</refactoring_id><commit_sha>d0f63186450e2e313dd425f3ce2ef30f9fcc0ba6</commit_sha><commit_link>https://github.com/zstackio/zstack/commit/d0f63186450e2e313dd425f3ce2ef30f9fcc0ba6</commit_link><file_path>test/src/test/java/org/zstack/test/ldap/TestLdap.java</file_path><description>Rename Variable ldapServerVO : LdapServerVO to msg1 : APIAddLdapServerMsg in method public test() : void from class org.zstack.test.ldap.TestLdap</description><code_before>@@ -7,25 +7,28 @@
 import org.zstack.core.cloudbus.CloudBus;
 import org.zstack.core.componentloader.ComponentLoader;
 import org.zstack.core.db.DatabaseFacade;
 import org.zstack.header.identity.SessionInventory;
-import org.zstack.ldap.LdapManager;
-import org.zstack.ldap.LdapServerVO;
 import org.zstack.network.service.eip.APIQueryEipMsg;
 import org.zstack.network.service.eip.APIQueryEipReply;
 import org.zstack.network.service.eip.EipInventory;
 import org.zstack.simulator.kvm.KVMSimulatorConfig;
 import org.zstack.simulator.virtualrouter.VirtualRouterSimulatorConfig;
-import org.zstack.test.Api;
-import org.zstack.test.ApiSenderException;
-import org.zstack.test.DBUtil;
-import org.zstack.test.WebBeanConstructor;
 import org.zstack.test.deployer.Deployer;
 import org.zstack.test.search.QueryTestValidator;
 
 /**
  * @author frank
  */
 public class TestLdap {
     Deployer deployer;
     Api api;
     ComponentLoader loader;
@@ -60,19 +63,52 @@ public void setUp() throws Exception {
 
     @Test
     public void test() throws ApiSenderException {
-        LdapServerVO ldapServerVO = new LdapServerVO();
-        ldapServerVO.setUuid(Platform.getUuid());
-        ldapServerVO.setName("miao");
-        ldapServerVO.setUrl("ldap://172.20.12.176:389");
-        ldapServerVO.setBase("dc=learnitguide,dc=net");
-        ldapServerVO.setUsername("");
-        ldapServerVO.setPassword("");
-        dbf.persistAndRefresh(ldapServerVO);
 
         ldapManager.readLdapServerConfiguration();
 
         Assert.assertFalse(ldapManager.isValid("ldapuser1", ""));
         Assert.assertFalse(ldapManager.isValid("miao", ""));
         Assert.assertTrue(ldapManager.isValid("ldapuser1", "redhat"));
     }
 }
</code_before><code_after>@@ -7,25 +7,28 @@
 import org.zstack.core.cloudbus.CloudBus;
 import org.zstack.core.componentloader.ComponentLoader;
 import org.zstack.core.db.DatabaseFacade;
+import org.zstack.header.host.APIAddHostEvent;
+import org.zstack.header.identity.APILogInReply;
+import org.zstack.header.identity.AccountInventory;
 import org.zstack.header.identity.SessionInventory;
+import org.zstack.ldap.*;
 import org.zstack.network.service.eip.APIQueryEipMsg;
 import org.zstack.network.service.eip.APIQueryEipReply;
 import org.zstack.network.service.eip.EipInventory;
 import org.zstack.simulator.kvm.KVMSimulatorConfig;
 import org.zstack.simulator.virtualrouter.VirtualRouterSimulatorConfig;
+import org.zstack.test.*;
 import org.zstack.test.deployer.Deployer;
 import org.zstack.test.search.QueryTestValidator;
+import org.zstack.utils.Utils;
+import org.zstack.utils.logging.CLogger;
 
 /**
  * @author frank
  */
 public class TestLdap {
+    CLogger logger = Utils.getLogger(TestLdap.class);
+
     Deployer deployer;
     Api api;
     ComponentLoader loader;
@@ -60,19 +63,52 @@ public void setUp() throws Exception {
 
     @Test
     public void test() throws ApiSenderException {
+//        LdapServerVO ldapServerVO = new LdapServerVO();
+//        ldapServerVO.setUuid(Platform.getUuid());
+//        ldapServerVO.setName("miao");
+//        ldapServerVO.setUrl("ldap://172.20.12.176:389");
+//        ldapServerVO.setBase("dc=learnitguide,dc=net");
+//        ldapServerVO.setUsername("");
+//        ldapServerVO.setPassword("");
+//        dbf.persistAndRefresh(ldapServerVO);
+
+        ApiSender sender = api.getApiSender();
+
+        // add ldap server
+        APIAddLdapServerMsg msg1 = new APIAddLdapServerMsg();
+        msg1.setName("miao");
+        msg1.setDescription("miao desc");
+        msg1.setUrl("ldap://172.20.12.176:389");
+        msg1.setBase("dc=learnitguide,dc=net");
+        msg1.setUsername("");
+        msg1.setPassword("");
+        msg1.setSession(session);
+        APIAddLdapServerEvent evt1 = sender.send(msg1, APIAddLdapServerEvent.class);
+        logger.debug(evt1.getInventory().getName());
 
+        // some assertions
         ldapManager.readLdapServerConfiguration();
 
         Assert.assertFalse(ldapManager.isValid("ldapuser1", ""));
         Assert.assertFalse(ldapManager.isValid("miao", ""));
         Assert.assertTrue(ldapManager.isValid("ldapuser1", "redhat"));
+        Assert.assertTrue(ldapManager.isValid("admin", "miao"));
+
+        // bind account
+        AccountInventory ai1 = api.createAccount("ldapuser1", "hello-kitty");
+        APIBindLdapAccountMsg msg2 = new APIBindLdapAccountMsg();
+        msg2.setAccountUuid(ai1.getUuid());
+        msg2.setLdapUid("ldapuser1");
+        msg2.setSession(session);
+        APIBindLdapAccountEvent evt2 = sender.send(msg2, APIBindLdapAccountEvent.class);
+        logger.debug(evt2.getInventory().getUuid());
+
+        // login account
+        APILoginByLdapMsg msg3 = new APILoginByLdapMsg();
+        msg3.setUid("ldapuser1");
+        msg3.setPassword("redhat");
+        msg3.setServiceId(bus.makeLocalServiceId(LdapConstant.SERVICE_ID));
+        APILogInReply reply3 = sender.call(msg3, APILogInReply.class);
+        logger.debug(reply3.getInventory().getAccountUuid());
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>427221</refactoring_id><commit_sha>b836212b39db067462bf453700641abf3fb27df3</commit_sha><commit_link>https://github.com/google/exoplayer/commit/b836212b39db067462bf453700641abf3fb27df3</commit_link><file_path>library/effect/src/main/java/com/google/android/exoplayer2/effect/MatrixTextureProcessor.java</file_path><description>Rename Variable colorTransfer : int to outputColorTransfer : int in method public createApplyingOetf(context Context, matrixTransformations List&lt;GlMatrixTransformation&gt;, rgbMatrices List&lt;RgbMatrix&gt;, outputColorInfo ColorInfo) : MatrixTextureProcessor from class com.google.android.exoplayer2.effect.MatrixTextureProcessor</description><code_before>@@ -23,6 +23,7 @@
 import android.opengl.Matrix;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.FrameProcessingException;
 import com.google.android.exoplayer2.util.GlProgram;
 import com.google.android.exoplayer2.util.GlUtil;
@@ -203,10 +204,6 @@ public static MatrixTextureProcessor createWithExternalSampler(
 
     @C.ColorTransfer int outputColorTransfer = outputColorInfo.colorTransfer;
     if (isInputTransferHdr) {
-      // TODO(b/239735341): Remove this after implementing in-app tone-mapping.
-      checkArgument(
-          outputColorInfo.colorSpace == C.COLOR_SPACE_BT2020,
-          "Converting from HDR to SDR is not yet supported.");
       checkArgument(inputColorInfo.colorSpace == C.COLOR_SPACE_BT2020);
 
       // In HDR editing mode the decoder output is sampled in YUV.
@@ -225,18 +222,18 @@ public static MatrixTextureProcessor createWithExternalSampler(
           inputColorTransfer == C.COLOR_TRANSFER_HLG
               || inputColorTransfer == C.COLOR_TRANSFER_ST2084);
       glProgram.setIntUniform("uInputColorTransfer", inputColorTransfer);
       checkArgument(
-          outputColorTransfer == C.COLOR_TRANSFER_HLG
-              || outputColorTransfer == C.COLOR_TRANSFER_ST2084
-              || outputColorTransfer == C.COLOR_TRANSFER_LINEAR);
       glProgram.setIntUniform("uOutputColorTransfer", outputColorTransfer);
     } else {
       checkArgument(
           outputColorInfo.colorSpace != C.COLOR_SPACE_BT2020,
           "Converting from SDR to HDR is not supported.");
-      checkArgument(
-          inputColorInfo.colorSpace == C.COLOR_SPACE_BT709
-              || inputColorInfo.colorSpace == C.COLOR_SPACE_BT601);
       checkArgument(
           outputColorTransfer == C.COLOR_TRANSFER_SDR
               || outputColorTransfer == C.COLOR_TRANSFER_LINEAR);
@@ -285,11 +282,17 @@ public static MatrixTextureProcessor createApplyingOetf(
             : FRAGMENT_SHADER_TRANSFORMATION_SDR_OETF_ES2_PATH;
     GlProgram glProgram = createGlProgram(context, vertexShaderFilePath, fragmentShaderFilePath);
 
     if (outputIsHdr) {
-      @C.ColorTransfer int colorTransfer = outputColorInfo.colorTransfer;
       checkArgument(
-          colorTransfer == C.COLOR_TRANSFER_HLG || colorTransfer == C.COLOR_TRANSFER_ST2084);
-      glProgram.setIntUniform("uOutputColorTransfer", colorTransfer);
     }
 
     return new MatrixTextureProcessor(
</code_before><code_after>@@ -23,6 +23,7 @@
 import android.opengl.Matrix;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.FrameProcessingException;
 import com.google.android.exoplayer2.util.GlProgram;
 import com.google.android.exoplayer2.util.GlUtil;
@@ -203,10 +204,6 @@ public static MatrixTextureProcessor createWithExternalSampler(
 
     @C.ColorTransfer int outputColorTransfer = outputColorInfo.colorTransfer;
     if (isInputTransferHdr) {
       checkArgument(inputColorInfo.colorSpace == C.COLOR_SPACE_BT2020);
 
       // In HDR editing mode the decoder output is sampled in YUV.
@@ -225,18 +222,18 @@ public static MatrixTextureProcessor createWithExternalSampler(
           inputColorTransfer == C.COLOR_TRANSFER_HLG
               || inputColorTransfer == C.COLOR_TRANSFER_ST2084);
       glProgram.setIntUniform("uInputColorTransfer", inputColorTransfer);
+      // TODO(b/239735341): Add a setBooleanUniform method to GlProgram.
+      glProgram.setIntUniform(
+          "uApplyHdrToSdrToneMapping",
+          /* value= */ (outputColorInfo.colorSpace != C.COLOR_SPACE_BT2020) ? 1 : 0);
       checkArgument(
+          outputColorTransfer != Format.NO_VALUE &amp;&amp; outputColorTransfer != C.COLOR_TRANSFER_SDR);
       glProgram.setIntUniform("uOutputColorTransfer", outputColorTransfer);
     } else {
       checkArgument(
           outputColorInfo.colorSpace != C.COLOR_SPACE_BT2020,
           "Converting from SDR to HDR is not supported.");
+      checkArgument(inputColorInfo.colorSpace == outputColorInfo.colorSpace);
       checkArgument(
           outputColorTransfer == C.COLOR_TRANSFER_SDR
               || outputColorTransfer == C.COLOR_TRANSFER_LINEAR);
@@ -285,11 +282,17 @@ public static MatrixTextureProcessor createApplyingOetf(
             : FRAGMENT_SHADER_TRANSFORMATION_SDR_OETF_ES2_PATH;
     GlProgram glProgram = createGlProgram(context, vertexShaderFilePath, fragmentShaderFilePath);
 
+    @C.ColorTransfer int outputColorTransfer = outputColorInfo.colorTransfer;
     if (outputIsHdr) {
       checkArgument(
+          outputColorTransfer == C.COLOR_TRANSFER_HLG
+              || outputColorTransfer == C.COLOR_TRANSFER_ST2084);
+      glProgram.setIntUniform("uOutputColorTransfer", outputColorTransfer);
+    } else {
+      checkArgument(
+          outputColorTransfer == C.COLOR_TRANSFER_SDR
+              || outputColorTransfer == C.COLOR_TRANSFER_GAMMA_2_2);
+      glProgram.setIntUniform("uOutputColorTransfer", outputColorTransfer);
     }
 
     return new MatrixTextureProcessor(
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>341938</refactoring_id><commit_sha>3db2f8b4b41f35bd135b15345d007863a1d0a8c0</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/3db2f8b4b41f35bd135b15345d007863a1d0a8c0</commit_link><file_path>engine/src/test/java/org/camunda/bpm/engine/test/api/identity/IdentityServiceTenantTest.java</file_path><description>Rename Variable invalidId2 : String to invalidId : String in method public testCustomTenantWhitelistPattern() : void from class org.camunda.bpm.engine.test.api.identity.IdentityServiceTenantTest</description><code_before>@@ -166,24 +166,41 @@ public void testInvalidTenantIdOnUpdate() {
     }
   }
 
   @Test
   public void testCustomTenantWhitelistPattern() {
     processEngine = ProcessEngineConfiguration
       .createProcessEngineConfigurationFromResource("org/camunda/bpm/engine/test/api/identity/generic.resource.id.whitelist.camunda.cfg.xml")
       .buildProcessEngine();
     processEngine.getProcessEngineConfiguration().setTenantResourceWhitelistPattern("[a-zA-Z]+");
 
-    String invalidId1 = "john's tenant";
-    String invalidId2 = "john!@#$%";
 
     try {
-      Tenant tenant = processEngine.getIdentityService().newTenant(invalidId1);
-      tenant.setId(invalidId2);
       processEngine.getIdentityService().saveTenant(tenant);
 
       fail("Invalid tenant id exception expected!");
     } catch (ProcessEngineException ex) {
-      assertEquals(String.format(INVALID_ID_MESSAGE, "Tenant", invalidId1), ex.getMessage());
     }
   }
 
</code_before><code_after>@@ -166,24 +166,41 @@ public void testInvalidTenantIdOnUpdate() {
     }
   }
 
+  @Test
+  public void testCustomCreateTenantWhitelistPattern() {
+    processEngine = ProcessEngineConfiguration
+      .createProcessEngineConfigurationFromResource("org/camunda/bpm/engine/test/api/identity/generic.resource.id.whitelist.camunda.cfg.xml")
+      .buildProcessEngine();
+    processEngine.getProcessEngineConfiguration().setTenantResourceWhitelistPattern("[a-zA-Z]+");
+
+    String invalidId = "john's tenant";
+
+    try {
+      processEngine.getIdentityService().newTenant(invalidId);
+      fail("Invalid tenant id exception expected!");
+    } catch (ProcessEngineException ex) {
+      assertEquals(String.format(INVALID_ID_MESSAGE, "Tenant", invalidId), ex.getMessage());
+    }
+  }
+
   @Test
   public void testCustomTenantWhitelistPattern() {
     processEngine = ProcessEngineConfiguration
       .createProcessEngineConfigurationFromResource("org/camunda/bpm/engine/test/api/identity/generic.resource.id.whitelist.camunda.cfg.xml")
       .buildProcessEngine();
     processEngine.getProcessEngineConfiguration().setTenantResourceWhitelistPattern("[a-zA-Z]+");
 
+    String validId = "johnsTenant";
+    String invalidId = "john!@#$%";
 
     try {
+      Tenant tenant = processEngine.getIdentityService().newTenant(validId);
+      tenant.setId(invalidId);
       processEngine.getIdentityService().saveTenant(tenant);
 
       fail("Invalid tenant id exception expected!");
     } catch (ProcessEngineException ex) {
+      assertEquals(String.format(INVALID_ID_MESSAGE, "Tenant", invalidId), ex.getMessage());
     }
   }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>350919</refactoring_id><commit_sha>48deafdf944fd320ba3663ee9579c353e1d03c93</commit_sha><commit_link>https://github.com/apache/pinot/commit/48deafdf944fd320ba3663ee9579c353e1d03c93</commit_link><file_path>pinot-broker/src/main/java/org/apache/pinot/broker/routing/segmentpruner/MultiPartitionColumnsSegmentPruner.java</file_path><description>Rename Variable i : int to idx : int in method public init(idealState IdealState, externalView ExternalView, onlineSegments List&lt;String&gt;, znRecords List&lt;ZNRecord&gt;) : void from class org.apache.pinot.broker.routing.segmentpruner.MultiPartitionColumnsSegmentPruner</description><code_before>@@ -19,7 +19,6 @@
 package org.apache.pinot.broker.routing.segmentpruner;
 
 import com.google.common.annotations.VisibleForTesting;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -28,12 +27,9 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.annotation.Nullable;
-import org.apache.helix.AccessOption;
 import org.apache.helix.model.ExternalView;
 import org.apache.helix.model.IdealState;
-import org.apache.helix.store.zk.ZkHelixPropertyStore;
 import org.apache.helix.zookeeper.datamodel.ZNRecord;
-import org.apache.pinot.common.metadata.ZKMetadataProvider;
 import org.apache.pinot.common.metadata.segment.SegmentPartitionMetadata;
 import org.apache.pinot.common.request.BrokerRequest;
 import org.apache.pinot.common.request.Expression;
@@ -58,33 +54,21 @@ public class MultiPartitionColumnsSegmentPruner implements SegmentPruner {
 
   private final String _tableNameWithType;
   private final Set&lt;String&gt; _partitionColumns;
-  private final ZkHelixPropertyStore&lt;ZNRecord&gt; _propertyStore;
-  private final String _segmentZKMetadataPathPrefix;
   private final Map&lt;String, Map&lt;String, PartitionInfo&gt;&gt; _segmentColumnPartitionInfoMap = new ConcurrentHashMap&lt;&gt;();
 
-  public MultiPartitionColumnsSegmentPruner(String tableNameWithType, Set&lt;String&gt; partitionColumns,
-      ZkHelixPropertyStore&lt;ZNRecord&gt; propertyStore) {
     _tableNameWithType = tableNameWithType;
     _partitionColumns = partitionColumns;
-    _propertyStore = propertyStore;
-    _segmentZKMetadataPathPrefix = ZKMetadataProvider.constructPropertyStorePathForResource(tableNameWithType) + "/";
   }
 
   @Override
-  public void init(IdealState idealState, ExternalView externalView, Set&lt;String&gt; onlineSegments) {
     // Bulk load partition info for all online segments
-    int numSegments = onlineSegments.size();
-    List&lt;String&gt; segments = new ArrayList&lt;&gt;(numSegments);
-    List&lt;String&gt; segmentZKMetadataPaths = new ArrayList&lt;&gt;(numSegments);
-    for (String segment : onlineSegments) {
-      segments.add(segment);
-      segmentZKMetadataPaths.add(_segmentZKMetadataPathPrefix + segment);
-    }
-    List&lt;ZNRecord&gt; znRecords = _propertyStore.get(segmentZKMetadataPaths, null, AccessOption.PERSISTENT, false);
-    for (int i = 0; i &lt; numSegments; i++) {
-      String segment = segments.get(i);
       Map&lt;String, PartitionInfo&gt; columnPartitionInfoMap =
-          extractColumnPartitionInfoMapFromSegmentZKMetadataZNRecord(segment, znRecords.get(i));
       if (columnPartitionInfoMap != null) {
         _segmentColumnPartitionInfoMap.put(segment, columnPartitionInfoMap);
       }
@@ -143,21 +127,22 @@ private Map&lt;String, PartitionInfo&gt; extractColumnPartitionInfoMapFromSegmentZKMet
 
   @Override
   public synchronized void onAssignmentChange(IdealState idealState, ExternalView externalView,
-      Set&lt;String&gt; onlineSegments) {
     // NOTE: We don't update all the segment ZK metadata for every external view change, but only the new added/removed
     //       ones. The refreshed segment ZK metadata change won't be picked up.
-    for (String segment : onlineSegments) {
       _segmentColumnPartitionInfoMap.computeIfAbsent(segment,
-          k -&gt; extractColumnPartitionInfoMapFromSegmentZKMetadataZNRecord(k,
-              _propertyStore.get(_segmentZKMetadataPathPrefix + k, null, AccessOption.PERSISTENT)));
     }
     _segmentColumnPartitionInfoMap.keySet().retainAll(onlineSegments);
   }
 
   @Override
-  public synchronized void refreshSegment(String segment) {
-    Map&lt;String, PartitionInfo&gt; columnPartitionInfo = extractColumnPartitionInfoMapFromSegmentZKMetadataZNRecord(segment,
-        _propertyStore.get(_segmentZKMetadataPathPrefix + segment, null, AccessOption.PERSISTENT));
     if (columnPartitionInfo != null) {
       _segmentColumnPartitionInfoMap.put(segment, columnPartitionInfo);
     } else {
</code_before><code_after>@@ -19,7 +19,6 @@
 package org.apache.pinot.broker.routing.segmentpruner;
 
 import com.google.common.annotations.VisibleForTesting;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -28,12 +27,9 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.annotation.Nullable;
 import org.apache.helix.model.ExternalView;
 import org.apache.helix.model.IdealState;
 import org.apache.helix.zookeeper.datamodel.ZNRecord;
 import org.apache.pinot.common.metadata.segment.SegmentPartitionMetadata;
 import org.apache.pinot.common.request.BrokerRequest;
 import org.apache.pinot.common.request.Expression;
@@ -58,33 +54,21 @@ public class MultiPartitionColumnsSegmentPruner implements SegmentPruner {
 
   private final String _tableNameWithType;
   private final Set&lt;String&gt; _partitionColumns;
   private final Map&lt;String, Map&lt;String, PartitionInfo&gt;&gt; _segmentColumnPartitionInfoMap = new ConcurrentHashMap&lt;&gt;();
 
+  public MultiPartitionColumnsSegmentPruner(String tableNameWithType, Set&lt;String&gt; partitionColumns) {
     _tableNameWithType = tableNameWithType;
     _partitionColumns = partitionColumns;
   }
 
   @Override
+  public void init(IdealState idealState, ExternalView externalView, List&lt;String&gt; onlineSegments,
+      List&lt;ZNRecord&gt; znRecords) {
     // Bulk load partition info for all online segments
+    for (int idx = 0; idx &lt; onlineSegments.size(); idx++) {
+      String segment = onlineSegments.get(idx);
       Map&lt;String, PartitionInfo&gt; columnPartitionInfoMap =
+          extractColumnPartitionInfoMapFromSegmentZKMetadataZNRecord(segment, znRecords.get(idx));
       if (columnPartitionInfoMap != null) {
         _segmentColumnPartitionInfoMap.put(segment, columnPartitionInfoMap);
       }
@@ -143,21 +127,22 @@ private Map&lt;String, PartitionInfo&gt; extractColumnPartitionInfoMapFromSegmentZKMet
 
   @Override
   public synchronized void onAssignmentChange(IdealState idealState, ExternalView externalView,
+      Set&lt;String&gt; onlineSegments, List&lt;String&gt; pulledSegments, List&lt;ZNRecord&gt; znRecords) {
     // NOTE: We don't update all the segment ZK metadata for every external view change, but only the new added/removed
     //       ones. The refreshed segment ZK metadata change won't be picked up.
+    for (int idx = 0; idx &lt; pulledSegments.size(); idx++) {
+      String segment = pulledSegments.get(idx);
+      ZNRecord znRecord = znRecords.get(idx);
       _segmentColumnPartitionInfoMap.computeIfAbsent(segment,
+          k -&gt; extractColumnPartitionInfoMapFromSegmentZKMetadataZNRecord(k, znRecord));
     }
     _segmentColumnPartitionInfoMap.keySet().retainAll(onlineSegments);
   }
 
   @Override
+  public synchronized void refreshSegment(String segment, @Nullable ZNRecord znRecord) {
+    Map&lt;String, PartitionInfo&gt; columnPartitionInfo =
+        extractColumnPartitionInfoMapFromSegmentZKMetadataZNRecord(segment, znRecord);
     if (columnPartitionInfo != null) {
       _segmentColumnPartitionInfoMap.put(segment, columnPartitionInfo);
     } else {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>430464</refactoring_id><commit_sha>2f904883237c476fd82a202f7ddda93fe56eef36</commit_sha><commit_link>https://github.com/apache/kafka/commit/2f904883237c476fd82a202f7ddda93fe56eef36</commit_link><file_path>connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java</file_path><description>Rename Variable record : SourceRecord to preTransformRecord : SourceRecord in method private sendRecords() : boolean from class org.apache.kafka.connect.runtime.WorkerSourceTask</description><code_before>@@ -55,6 +55,7 @@ class WorkerSourceTask extends WorkerTask {
     private final SourceTask task;
     private final Converter keyConverter;
     private final Converter valueConverter;
     private KafkaProducer&lt;byte[], byte[]&gt; producer;
     private final OffsetStorageReader offsetReader;
     private final OffsetStorageWriter offsetWriter;
@@ -80,6 +81,7 @@ public WorkerSourceTask(ConnectorTaskId id,
                             TargetState initialState,
                             Converter keyConverter,
                             Converter valueConverter,
                             KafkaProducer&lt;byte[], byte[]&gt; producer,
                             OffsetStorageReader offsetReader,
                             OffsetStorageWriter offsetWriter,
@@ -91,6 +93,7 @@ public WorkerSourceTask(ConnectorTaskId id,
         this.task = task;
         this.keyConverter = keyConverter;
         this.valueConverter = valueConverter;
         this.producer = producer;
         this.offsetReader = offsetReader;
         this.offsetWriter = offsetWriter;
@@ -116,6 +119,7 @@ public void initialize(TaskConfig taskConfig) {
 
     protected void close() {
         producer.close(30, TimeUnit.SECONDS);
     }
 
     @Override
@@ -181,7 +185,14 @@ public void execute() {
      */
     private boolean sendRecords() {
         int processed = 0;
-        for (final SourceRecord record : toSend) {
             byte[] key = keyConverter.fromConnectData(record.topic(), record.keySchema(), record.key());
             byte[] value = valueConverter.fromConnectData(record.topic(), record.valueSchema(), record.value());
             final ProducerRecord&lt;byte[], byte[]&gt; producerRecord = new ProducerRecord&lt;&gt;(record.topic(), record.kafkaPartition(), record.timestamp(), key, value);
@@ -219,7 +230,7 @@ public void onCompletion(RecordMetadata recordMetadata, Exception e) {
                                     log.trace("Wrote record successfully: topic {} partition {} offset {}",
                                             recordMetadata.topic(), recordMetadata.partition(),
                                             recordMetadata.offset());
-                                    commitTaskRecord(record);
                                 }
                                 recordSent(producerRecord);
                             }
</code_before><code_after>@@ -55,6 +55,7 @@ class WorkerSourceTask extends WorkerTask {
     private final SourceTask task;
     private final Converter keyConverter;
     private final Converter valueConverter;
+    private final TransformationChain&lt;SourceRecord&gt; transformationChain;
     private KafkaProducer&lt;byte[], byte[]&gt; producer;
     private final OffsetStorageReader offsetReader;
     private final OffsetStorageWriter offsetWriter;
@@ -80,6 +81,7 @@ public WorkerSourceTask(ConnectorTaskId id,
                             TargetState initialState,
                             Converter keyConverter,
                             Converter valueConverter,
+                            TransformationChain&lt;SourceRecord&gt; transformationChain,
                             KafkaProducer&lt;byte[], byte[]&gt; producer,
                             OffsetStorageReader offsetReader,
                             OffsetStorageWriter offsetWriter,
@@ -91,6 +93,7 @@ public WorkerSourceTask(ConnectorTaskId id,
         this.task = task;
         this.keyConverter = keyConverter;
         this.valueConverter = valueConverter;
+        this.transformationChain = transformationChain;
         this.producer = producer;
         this.offsetReader = offsetReader;
         this.offsetWriter = offsetWriter;
@@ -116,6 +119,7 @@ public void initialize(TaskConfig taskConfig) {
 
     protected void close() {
         producer.close(30, TimeUnit.SECONDS);
+        transformationChain.close();
     }
 
     @Override
@@ -181,7 +185,14 @@ public void execute() {
      */
     private boolean sendRecords() {
         int processed = 0;
+        for (final SourceRecord preTransformRecord : toSend) {
+            final SourceRecord record = transformationChain.apply(preTransformRecord);
+
+            if (record == null) {
+                commitTaskRecord(preTransformRecord);
+                continue;
+            }
+
             byte[] key = keyConverter.fromConnectData(record.topic(), record.keySchema(), record.key());
             byte[] value = valueConverter.fromConnectData(record.topic(), record.valueSchema(), record.value());
             final ProducerRecord&lt;byte[], byte[]&gt; producerRecord = new ProducerRecord&lt;&gt;(record.topic(), record.kafkaPartition(), record.timestamp(), key, value);
@@ -219,7 +230,7 @@ public void onCompletion(RecordMetadata recordMetadata, Exception e) {
                                     log.trace("Wrote record successfully: topic {} partition {} offset {}",
                                             recordMetadata.topic(), recordMetadata.partition(),
                                             recordMetadata.offset());
+                                    commitTaskRecord(preTransformRecord);
                                 }
                                 recordSent(producerRecord);
                             }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>343810</refactoring_id><commit_sha>08782bd997fa4c814c7b94cb8285543316209862</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/08782bd997fa4c814c7b94cb8285543316209862</commit_link><file_path>plugins/org.jkiss.dbeaver.ext.ui.tipoftheday/src/org/jkiss/dbeaver/ext/ui/tipoftheday/TipOfTheDayInitializer.java</file_path><description>Rename Variable enabled : boolean to tipsEnabledStr : String in method private isTipsEnabled() : boolean from class org.jkiss.dbeaver.ext.ui.tipoftheday.TipOfTheDayInitializer</description><code_before>@@ -4,21 +4,27 @@
 import org.jkiss.dbeaver.registry.DataSourceRegistry;
 import org.jkiss.dbeaver.runtime.DBWorkbench;
 import org.jkiss.dbeaver.ui.IWorkbenchWindowInitializer;
 
 public class TipOfTheDayInitializer implements IWorkbenchWindowInitializer {
 
     @Override
     public void initializeWorkbenchWindow(IWorkbenchWindow window) {
-        if (doNotShowTips()) {
             return;
         }
         ShowTipOfTheDayHandler.showTipOfTheDay(window);
     }
 
-    private static boolean doNotShowTips() {
-        boolean enabled = DBWorkbench.getPlatform().getPreferenceStore().getBoolean(ShowTipOfTheDayHandler.UI_SHOW_TIP_OF_THE_DAY_ON_STARTUP);
-        boolean emptyDatasource = DataSourceRegistry.getAllDataSources().isEmpty();
-        return !enabled || emptyDatasource;
     }
 
 }
</code_before><code_after>@@ -4,21 +4,27 @@
 import org.jkiss.dbeaver.registry.DataSourceRegistry;
 import org.jkiss.dbeaver.runtime.DBWorkbench;
 import org.jkiss.dbeaver.ui.IWorkbenchWindowInitializer;
+import org.jkiss.utils.CommonUtils;
 
 public class TipOfTheDayInitializer implements IWorkbenchWindowInitializer {
 
     @Override
     public void initializeWorkbenchWindow(IWorkbenchWindow window) {
+        if (!isTipsEnabled()) {
             return;
         }
         ShowTipOfTheDayHandler.showTipOfTheDay(window);
     }
 
+    private static boolean isTipsEnabled() {
+        if (DataSourceRegistry.getAllDataSources().isEmpty()) {
+            return false;
+        }
+        String tipsEnabledStr = DBWorkbench.getPlatform().getPreferenceStore().getString(ShowTipOfTheDayHandler.UI_SHOW_TIP_OF_THE_DAY_ON_STARTUP);
+        if (CommonUtils.isEmpty(tipsEnabledStr)) {
+            return true;
+        }
+        return CommonUtils.toBoolean(tipsEnabledStr);
     }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>339968</refactoring_id><commit_sha>a49e73541f66fb5242146ffb5cbfd94f78926c79</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/a49e73541f66fb5242146ffb5cbfd94f78926c79</commit_link><file_path>de.metas.handlingunits.base/src/main/java/de/metas/picking/service/impl/PackingService.java</file_path><description>Rename Variable key : PackingItemsMapKey to packedItemsSlot : PackingSlot in method public packItem(packingContext PackingContext, itemToPack IFreshPackingItem, qtyToPack Quantity, packingHandler IPackingHandler) : void from class de.metas.picking.service.impl.PackingService</description><code_before>@@ -29,7 +29,7 @@
 import de.metas.picking.service.IPackingService;
 import de.metas.picking.service.PackingContext;
 import de.metas.picking.service.PackingItemsMap;
-import de.metas.picking.service.PackingItemsMapKey;
 import de.metas.quantity.Quantity;
 import de.metas.util.Services;
 import de.metas.util.time.SystemTime;
@@ -109,11 +109,11 @@ public void packItem(
 			@NonNull final Quantity qtyToPack,
 			@NonNull final IPackingHandler packingHandler)
 	{
-		final PackingItemsMapKey key = packingContext.getPackingItemsMapKey();
 
 		// Packing items
 		// NOTE: we are doing a copy and work on it, in case something fails. At the end we will set it back
-		final PackingItemsMap packingItems = packingContext.getPackingItemsMap().copy();
 
 		//
 		// Remove the itemToPack from unpacked items
@@ -136,7 +136,7 @@ public void packItem(
 			// Add our itemPacked to packed items
 			// If an existing matching packed item will be found, our item will be merged there
 			// If not, it will be added as a new packed item
-			packingItems.appendPackedItem(key, itemPacked);
 
 			//
 			// Update back "itemToPack" to have a up2date version
@@ -153,6 +153,6 @@ public void packItem(
 		}
 
 		// Set back the packing items
-		packingContext.setPackingItemsMap(packingItems);
 	}
 }
</code_before><code_after>@@ -29,7 +29,7 @@
 import de.metas.picking.service.IPackingService;
 import de.metas.picking.service.PackingContext;
 import de.metas.picking.service.PackingItemsMap;
+import de.metas.picking.service.PackingSlot;
 import de.metas.quantity.Quantity;
 import de.metas.util.Services;
 import de.metas.util.time.SystemTime;
@@ -109,11 +109,11 @@ public void packItem(
 			@NonNull final Quantity qtyToPack,
 			@NonNull final IPackingHandler packingHandler)
 	{
+		final PackingSlot packedItemsSlot = packingContext.getPackedItemsSlot();
 
 		// Packing items
 		// NOTE: we are doing a copy and work on it, in case something fails. At the end we will set it back
+		final PackingItemsMap packingItems = packingContext.getPackingItems().copy();
 
 		//
 		// Remove the itemToPack from unpacked items
@@ -136,7 +136,7 @@ public void packItem(
 			// Add our itemPacked to packed items
 			// If an existing matching packed item will be found, our item will be merged there
 			// If not, it will be added as a new packed item
+			packingItems.appendPackedItem(packedItemsSlot, itemPacked);
 
 			//
 			// Update back "itemToPack" to have a up2date version
@@ -153,6 +153,6 @@ public void packItem(
 		}
 
 		// Set back the packing items
+		packingContext.setPackingItems(packingItems);
 	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>462175</refactoring_id><commit_sha>c26f970db68a335b2d7689d0583f05857af1f45a</commit_sha><commit_link>https://github.com/oracle/graal/commit/c26f970db68a335b2d7689d0583f05857af1f45a</commit_link><file_path>substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/meta/KnownOffsetsFeature.java</file_path><description>Rename Variable hubLayout : HybridLayout&lt;DynamicHub&gt; to dynamicHubLayout : DynamicHubLayout in method public beforeCompilation(a BeforeCompilationAccess) : void from class com.oracle.svm.hosted.meta.KnownOffsetsFeature</description><code_before>@@ -33,17 +33,16 @@
 
 import com.oracle.svm.core.SubstrateOptions;
 import com.oracle.svm.core.code.ImageCodeInfo;
-import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.feature.InternalFeature;
 import com.oracle.svm.core.graal.meta.KnownOffsets;
 import com.oracle.svm.core.hub.DynamicHub;
 import com.oracle.svm.core.stack.JavaFrameAnchor;
 import com.oracle.svm.core.thread.VMThreads;
-import com.oracle.svm.core.feature.AutomaticallyRegisteredFeature;
 import com.oracle.svm.hosted.FeatureImpl.BeforeCompilationAccessImpl;
 import com.oracle.svm.hosted.c.info.AccessorInfo;
 import com.oracle.svm.hosted.c.info.StructFieldInfo;
-import com.oracle.svm.hosted.config.HybridLayout;
 import com.oracle.svm.hosted.thread.VMThreadMTFeature;
 import com.oracle.svm.util.ReflectionUtil;
 
@@ -68,10 +67,10 @@ public void afterRegistration(AfterRegistrationAccess access) {
     public void beforeCompilation(BeforeCompilationAccess a) {
         BeforeCompilationAccessImpl access = (BeforeCompilationAccessImpl) a;
 
-        HybridLayout&lt;DynamicHub&gt; hubLayout = new HybridLayout&lt;&gt;(DynamicHub.class, ConfigurationValues.getObjectLayout(), access.getMetaAccess());
-        int vtableBaseOffset = hubLayout.getArrayBaseOffset();
-        int vtableEntrySize = ConfigurationValues.getObjectLayout().sizeInBytes(hubLayout.getArrayElementStorageKind());
-        int typeIDSlotsOffset = HybridLayout.getTypeIDSlotsFieldOffset(ConfigurationValues.getObjectLayout());
 
         int componentHubOffset = findFieldOffset(access, DynamicHub.class, "componentType");
 
</code_before><code_after>@@ -33,17 +33,16 @@
 
 import com.oracle.svm.core.SubstrateOptions;
 import com.oracle.svm.core.code.ImageCodeInfo;
+import com.oracle.svm.core.feature.AutomaticallyRegisteredFeature;
 import com.oracle.svm.core.feature.InternalFeature;
 import com.oracle.svm.core.graal.meta.KnownOffsets;
 import com.oracle.svm.core.hub.DynamicHub;
 import com.oracle.svm.core.stack.JavaFrameAnchor;
 import com.oracle.svm.core.thread.VMThreads;
 import com.oracle.svm.hosted.FeatureImpl.BeforeCompilationAccessImpl;
 import com.oracle.svm.hosted.c.info.AccessorInfo;
 import com.oracle.svm.hosted.c.info.StructFieldInfo;
+import com.oracle.svm.hosted.config.DynamicHubLayout;
 import com.oracle.svm.hosted.thread.VMThreadMTFeature;
 import com.oracle.svm.util.ReflectionUtil;
 
@@ -68,10 +67,10 @@ public void afterRegistration(AfterRegistrationAccess access) {
     public void beforeCompilation(BeforeCompilationAccess a) {
         BeforeCompilationAccessImpl access = (BeforeCompilationAccessImpl) a;
 
+        DynamicHubLayout dynamicHubLayout = DynamicHubLayout.singleton();
+        int vtableBaseOffset = dynamicHubLayout.vTableOffset();
+        int vtableEntrySize = dynamicHubLayout.vTableSlotSize;
+        int typeIDSlotsOffset = dynamicHubLayout.typeIDSlotsOffset;
 
         int componentHubOffset = findFieldOffset(access, DynamicHub.class, "componentType");
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>405859</refactoring_id><commit_sha>396a3bcd6d154d155dbd2d22052def01f2462df3</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/396a3bcd6d154d155dbd2d22052def01f2462df3</commit_link><file_path>profiler/src/main/java/com/navercorp/pinpoint/profiler/receiver/service/ActiveThreadCountService.java</file_path><description>Rename Variable activeTraceHistogram : ActiveTraceHistogram to histogram : ActiveTraceHistogram in method private getActiveThreadCountResponse() : TCmdActiveThreadCountRes from class com.navercorp.pinpoint.profiler.receiver.service.ActiveThreadCountService</description><code_before>@@ -17,6 +17,7 @@
 package com.navercorp.pinpoint.profiler.receiver.service;
 
 import com.navercorp.pinpoint.profiler.context.active.ActiveTraceHistogram;
 import com.navercorp.pinpoint.profiler.context.active.ActiveTraceRepository;
 import com.navercorp.pinpoint.profiler.receiver.CommandSerializer;
 import com.navercorp.pinpoint.profiler.receiver.ProfilerRequestCommandService;
@@ -96,12 +97,17 @@ public StreamCode streamCommandService(TBase tBase, ServerStreamChannelContext s
     }
 
     private TCmdActiveThreadCountRes getActiveThreadCountResponse() {
-        ActiveTraceHistogram activeTraceHistogram = this.activeTraceRepository.getActiveTraceHistogram();
 
         TCmdActiveThreadCountRes response = new TCmdActiveThreadCountRes();
-        response.setHistogramSchemaType(activeTraceHistogram.getHistogramSchema().getTypeCode());
-        response.setActiveThreadCount(activeTraceHistogram.getActiveTraceCounts());
-        response.setTimeStamp(System.currentTimeMillis());
 
         return response;
     }
</code_before><code_after>@@ -17,6 +17,7 @@
 package com.navercorp.pinpoint.profiler.receiver.service;
 
 import com.navercorp.pinpoint.profiler.context.active.ActiveTraceHistogram;
+import com.navercorp.pinpoint.profiler.context.active.ActiveTraceHistogramUtils;
 import com.navercorp.pinpoint.profiler.context.active.ActiveTraceRepository;
 import com.navercorp.pinpoint.profiler.receiver.CommandSerializer;
 import com.navercorp.pinpoint.profiler.receiver.ProfilerRequestCommandService;
@@ -96,12 +97,17 @@ public StreamCode streamCommandService(TBase tBase, ServerStreamChannelContext s
     }
 
     private TCmdActiveThreadCountRes getActiveThreadCountResponse() {
+
+        final long currentTime = System.currentTimeMillis();
+        final ActiveTraceHistogram histogram = this.activeTraceRepository.getActiveTraceHistogram(currentTime);
+
 
         TCmdActiveThreadCountRes response = new TCmdActiveThreadCountRes();
+        response.setHistogramSchemaType(histogram.getHistogramSchema().getTypeCode());
+
+        final List&lt;Integer&gt; activeTraceCounts = ActiveTraceHistogramUtils.asList(histogram);
+        response.setActiveThreadCount(activeTraceCounts);
+        response.setTimeStamp(currentTime);
 
         return response;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>454477</refactoring_id><commit_sha>84444d5071984a8543a81574dc69c0c9849a8a4a</commit_sha><commit_link>https://github.com/apache/flink/commit/84444d5071984a8543a81574dc69c0c9849a8a4a</commit_link><file_path>flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializerConcurrencyTest.java</file_path><description>Rename Variable executionConfig : ExecutionConfig to serializerConfigImpl : SerializerConfigImpl in method public testDuplicateSerializerWithRegisteredSerializerClass() : void from class org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializerConcurrencyTest</description><code_before>@@ -18,7 +18,7 @@
 
 package org.apache.flink.api.java.typeutils.runtime.kryo;
 
-import org.apache.flink.api.common.ExecutionConfig;
 import org.apache.flink.core.memory.DataOutputSerializer;
 import org.apache.flink.core.memory.DataOutputView;
 import org.apache.flink.core.testutils.BlockerSync;
@@ -47,35 +47,37 @@ public class KryoSerializerConcurrencyTest {
 
     @Test
     public void testDuplicateSerializerWithDefaultSerializerClass() {
-        ExecutionConfig executionConfig = new ExecutionConfig();
-        executionConfig.addDefaultKryoSerializer(WrappedString.class, TestSerializer.class);
-        runDuplicateSerializerTest(executionConfig);
     }
 
     @Test
     public void testDuplicateSerializerWithDefaultSerializerInstance() {
-        ExecutionConfig executionConfig = new ExecutionConfig();
-        executionConfig.addDefaultKryoSerializer(WrappedString.class, new TestSerializer());
-        runDuplicateSerializerTest(executionConfig);
     }
 
     @Test
     public void testDuplicateSerializerWithRegisteredSerializerClass() {
-        ExecutionConfig executionConfig = new ExecutionConfig();
-        executionConfig.registerTypeWithKryoSerializer(WrappedString.class, TestSerializer.class);
-        runDuplicateSerializerTest(executionConfig);
     }
 
     @Test
     public void testDuplicateSerializerWithRegisteredSerializerInstance() {
-        ExecutionConfig executionConfig = new ExecutionConfig();
-        executionConfig.registerTypeWithKryoSerializer(WrappedString.class, new TestSerializer());
-        runDuplicateSerializerTest(executionConfig);
     }
 
-    private void runDuplicateSerializerTest(ExecutionConfig executionConfig) {
         final KryoSerializer&lt;WrappedString&gt; original =
-                new KryoSerializer&lt;&gt;(WrappedString.class, executionConfig);
         final KryoSerializer&lt;WrappedString&gt; duplicate = original.duplicate();
 
         WrappedString testString = new WrappedString("test");
@@ -93,7 +95,7 @@ private void runDuplicateSerializerTest(ExecutionConfig executionConfig) {
     @Test
     public void testConcurrentUseOfSerializer() throws Exception {
         final KryoSerializer&lt;String&gt; serializer =
-                new KryoSerializer&lt;&gt;(String.class, new ExecutionConfig());
 
         final BlockerSync sync = new BlockerSync();
 
</code_before><code_after>@@ -18,7 +18,7 @@
 
 package org.apache.flink.api.java.typeutils.runtime.kryo;
 
+import org.apache.flink.api.common.serialization.SerializerConfigImpl;
 import org.apache.flink.core.memory.DataOutputSerializer;
 import org.apache.flink.core.memory.DataOutputView;
 import org.apache.flink.core.testutils.BlockerSync;
@@ -47,35 +47,37 @@ public class KryoSerializerConcurrencyTest {
 
     @Test
     public void testDuplicateSerializerWithDefaultSerializerClass() {
+        SerializerConfigImpl serializerConfigImpl = new SerializerConfigImpl();
+        serializerConfigImpl.addDefaultKryoSerializer(WrappedString.class, TestSerializer.class);
+        runDuplicateSerializerTest(serializerConfigImpl);
     }
 
     @Test
     public void testDuplicateSerializerWithDefaultSerializerInstance() {
+        SerializerConfigImpl serializerConfigImpl = new SerializerConfigImpl();
+        serializerConfigImpl.addDefaultKryoSerializer(WrappedString.class, new TestSerializer());
+        runDuplicateSerializerTest(serializerConfigImpl);
     }
 
     @Test
     public void testDuplicateSerializerWithRegisteredSerializerClass() {
+        SerializerConfigImpl serializerConfigImpl = new SerializerConfigImpl();
+        serializerConfigImpl.registerTypeWithKryoSerializer(
+                WrappedString.class, TestSerializer.class);
+        runDuplicateSerializerTest(serializerConfigImpl);
     }
 
     @Test
     public void testDuplicateSerializerWithRegisteredSerializerInstance() {
+        SerializerConfigImpl serializerConfigImpl = new SerializerConfigImpl();
+        serializerConfigImpl.registerTypeWithKryoSerializer(
+                WrappedString.class, new TestSerializer());
+        runDuplicateSerializerTest(serializerConfigImpl);
     }
 
+    private void runDuplicateSerializerTest(SerializerConfigImpl serializerConfigImpl) {
         final KryoSerializer&lt;WrappedString&gt; original =
+                new KryoSerializer&lt;&gt;(WrappedString.class, serializerConfigImpl);
         final KryoSerializer&lt;WrappedString&gt; duplicate = original.duplicate();
 
         WrappedString testString = new WrappedString("test");
@@ -93,7 +95,7 @@ private void runDuplicateSerializerTest(ExecutionConfig executionConfig) {
     @Test
     public void testConcurrentUseOfSerializer() throws Exception {
         final KryoSerializer&lt;String&gt; serializer =
+                new KryoSerializer&lt;&gt;(String.class, new SerializerConfigImpl());
 
         final BlockerSync sync = new BlockerSync();
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>435510</refactoring_id><commit_sha>6a663edf2f24fe4271b57fcf513b9a1e1a73c279</commit_sha><commit_link>https://github.com/datahub-project/datahub/commit/6a663edf2f24fe4271b57fcf513b9a1e1a73c279</commit_link><file_path>datahub-graphql-core/src/main/java/com/linkedin/datahub/graphql/analytics/resolver/GetChartsResolver.java</file_path><description>Rename Variable granularity : DateInterval to dailyInterval : DateInterval in method private getProductAnalyticsCharts() : List&lt;AnalyticsChart&gt; from class com.linkedin.datahub.graphql.analytics.resolver.GetChartsResolver</description><code_before>@@ -45,59 +45,77 @@ public final List&lt;AnalyticsChartGroup&gt; get(DataFetchingEnvironment environment)
    */
   private List&lt;AnalyticsChart&gt; getProductAnalyticsCharts() {
     final List&lt;AnalyticsChart&gt; charts = new ArrayList&lt;&gt;();
-    final DateTime endDate = DateTime.now();
-    final DateTime startDate = endDate.minusWeeks(1);
-    final DateRange dateRange =
-        new DateRange(String.valueOf(startDate.getMillis()), String.valueOf(endDate.getMillis()));
 
     // Chart 1:  Time Series Chart
-    String title = "Searches Last Week";
-    DateInterval granularity = DateInterval.DAY;
-    String eventType = "SearchEvent";
 
     final List&lt;NamedLine&gt; searchesTimeseries =
-        _analyticsService.getTimeseriesChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, dateRange, granularity,
-            Optional.empty(), ImmutableMap.of("type", ImmutableList.of("SearchEvent")), Optional.empty());
     charts.add(TimeSeriesChart.builder()
-        .setTitle(title)
-        .setDateRange(dateRange)
-        .setInterval(granularity)
         .setLines(searchesTimeseries)
         .build());
 
-    // Chart 2: Table Chart
-    final String title2 = "Top Search Queries";
     final List&lt;String&gt; columns = ImmutableList.of("Query", "Count");
 
     final List&lt;Row&gt; topSearchQueries =
-        _analyticsService.getTopNTableChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(dateRange),
-            "query.keyword", ImmutableMap.of("type", ImmutableList.of(eventType)), Optional.empty(), 10);
-    charts.add(TableChart.builder().setTitle(title2).setColumns(columns).setRows(topSearchQueries).build());
 
-    // Chart 3: Bar Graph Chart
-    final String title3 = "Section Views across Entity Types";
     final List&lt;NamedBar&gt; sectionViewsPerEntityType =
-        _analyticsService.getBarChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(dateRange),
             ImmutableList.of("entityType.keyword", "section.keyword"),
             ImmutableMap.of("type", ImmutableList.of("EntitySectionViewEvent")), Optional.empty());
-    charts.add(BarChart.builder().setTitle(title3).setBars(sectionViewsPerEntityType).build());
 
-    // Chart 4: Bar Graph Chart
-    final String title4 = "Actions by Entity Type";
     final List&lt;NamedBar&gt; eventsByEventType =
-        _analyticsService.getBarChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(dateRange),
             ImmutableList.of("entityType.keyword", "actionType.keyword"),
             ImmutableMap.of("type", ImmutableList.of("EntityActionEvent")), Optional.empty());
-    charts.add(BarChart.builder().setTitle(title4).setBars(eventsByEventType).build());
 
-    // Chart 5: Table Chart
-    final String title5 = "Top Viewed Dataset";
     final List&lt;String&gt; columns5 = ImmutableList.of("Dataset", "#Views");
 
     final List&lt;Row&gt; topViewedDatasets =
-        _analyticsService.getTopNTableChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(dateRange),
             "dataset_name.keyword", ImmutableMap.of("type", ImmutableList.of("EntityViewEvent")), Optional.empty(), 10);
-    charts.add(TableChart.builder().setTitle(title5).setColumns(columns5).setRows(topViewedDatasets).build());
     
     return charts;
   }
</code_before><code_after>@@ -45,59 +45,77 @@ public final List&lt;AnalyticsChartGroup&gt; get(DataFetchingEnvironment environment)
    */
   private List&lt;AnalyticsChart&gt; getProductAnalyticsCharts() {
     final List&lt;AnalyticsChart&gt; charts = new ArrayList&lt;&gt;();
+    final DateTime now = DateTime.now();
+    final DateTime aWeekAgo = now.minusWeeks(1);
+    final DateRange lastWeekDateRange =
+        new DateRange(String.valueOf(aWeekAgo.getMillis()), String.valueOf(now.getMillis()));
+
+    final DateTime twoMonthsAgo = now.minusMonths(2);
+    final DateRange twoMonthsDateRange =
+        new DateRange(String.valueOf(twoMonthsAgo.getMillis()), String.valueOf(now.getMillis()));
 
     // Chart 1:  Time Series Chart
+    String wauTitle = "Weekly Active Users";
+    DateInterval weeklyInterval = DateInterval.WEEK;
+
+    final List&lt;NamedLine&gt; wauTimeseries =
+        _analyticsService.getTimeseriesChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, twoMonthsDateRange, weeklyInterval,
+            Optional.empty(), ImmutableMap.of(), Optional.of("browserId"));
+    charts.add(TimeSeriesChart.builder()
+        .setTitle(wauTitle)
+        .setDateRange(twoMonthsDateRange)
+        .setInterval(weeklyInterval)
+        .setLines(wauTimeseries)
+        .build());
+
+    // Chart 2:  Time Series Chart
+    String searchesTitle = "Searches Last Week";
+    DateInterval dailyInterval = DateInterval.DAY;
+    String searchEventType = "SearchEvent";
 
     final List&lt;NamedLine&gt; searchesTimeseries =
+        _analyticsService.getTimeseriesChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, lastWeekDateRange, dailyInterval,
+            Optional.empty(), ImmutableMap.of("type", ImmutableList.of(searchEventType)), Optional.empty());
     charts.add(TimeSeriesChart.builder()
+        .setTitle(searchesTitle)
+        .setDateRange(lastWeekDateRange)
+        .setInterval(dailyInterval)
         .setLines(searchesTimeseries)
         .build());
 
+    // Chart 3: Table Chart
+    final String topSearchTitle = "Top Search Queries";
     final List&lt;String&gt; columns = ImmutableList.of("Query", "Count");
 
     final List&lt;Row&gt; topSearchQueries =
+        _analyticsService.getTopNTableChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(lastWeekDateRange),
+            "query.keyword", ImmutableMap.of("type", ImmutableList.of(searchEventType)), Optional.empty(), 10);
+    charts.add(TableChart.builder().setTitle(topSearchTitle).setColumns(columns).setRows(topSearchQueries).build());
 
+    // Chart 4: Bar Graph Chart
+    final String sectionViewsTitle = "Section Views across Entity Types";
     final List&lt;NamedBar&gt; sectionViewsPerEntityType =
+        _analyticsService.getBarChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(lastWeekDateRange),
             ImmutableList.of("entityType.keyword", "section.keyword"),
             ImmutableMap.of("type", ImmutableList.of("EntitySectionViewEvent")), Optional.empty());
+    charts.add(BarChart.builder().setTitle(sectionViewsTitle).setBars(sectionViewsPerEntityType).build());
 
+    // Chart 5: Bar Graph Chart
+    final String actionsByTypeTitle = "Actions by Entity Type";
     final List&lt;NamedBar&gt; eventsByEventType =
+        _analyticsService.getBarChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(lastWeekDateRange),
             ImmutableList.of("entityType.keyword", "actionType.keyword"),
             ImmutableMap.of("type", ImmutableList.of("EntityActionEvent")), Optional.empty());
+    charts.add(BarChart.builder().setTitle(actionsByTypeTitle).setBars(eventsByEventType).build());
 
+    // Chart 6: Table Chart
+    final String topViewedTitle = "Top Viewed Dataset";
     final List&lt;String&gt; columns5 = ImmutableList.of("Dataset", "#Views");
 
     final List&lt;Row&gt; topViewedDatasets =
+        _analyticsService.getTopNTableChart(AnalyticsService.DATAHUB_USAGE_EVENT_INDEX, Optional.of(lastWeekDateRange),
             "dataset_name.keyword", ImmutableMap.of("type", ImmutableList.of("EntityViewEvent")), Optional.empty(), 10);
+    charts.add(TableChart.builder().setTitle(topViewedTitle).setColumns(columns5).setRows(topViewedDatasets).build());
     
     return charts;
   }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>403429</refactoring_id><commit_sha>17fdaef177202e09e5e111cbaa3f45c15f167142</commit_sha><commit_link>https://github.com/apache/tomcat/commit/17fdaef177202e09e5e111cbaa3f45c15f167142</commit_link><file_path>java/org/apache/catalina/util/DOMWriter.java</file_path><description>Rename Variable ch : char to c : char in method public xml(ifNull String, escapeCRLF boolean, content String) : String from class org.apache.tomcat.util.security.Escape</description><code_before>@@ -19,6 +19,7 @@
 import java.io.PrintWriter;
 import java.io.Writer;
 
 import org.w3c.dom.Attr;
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
@@ -35,6 +36,12 @@ public class DOMWriter {
     private final boolean canonical;
 
 
     public DOMWriter(Writer writer, boolean canonical) {
         out = new PrintWriter(writer);
         this.canonical = canonical;
@@ -74,7 +81,7 @@ public void print(Node node) {
                     out.print(attr.getLocalName());
 
                     out.print("=\"");
-                    out.print(escape(attr.getNodeValue()));
                     out.print('"');
                 }
                 out.print('&gt;');
@@ -95,7 +102,7 @@ public void print(Node node) {
             // print cdata sections
             case Node.CDATA_SECTION_NODE:
                 if (canonical) {
-                    out.print(escape(node.getNodeValue()));
                 } else {
                     out.print("&lt;![CDATA[");
                     out.print(node.getNodeValue());
@@ -105,7 +112,7 @@ public void print(Node node) {
 
             // print text
             case Node.TEXT_NODE:
-                out.print(escape(node.getNodeValue()));
                 break;
 
             // print processing instruction
@@ -180,50 +187,4 @@ private Attr[] sortAttributes(NamedNodeMap attrs) {
 
         return array;
     }
-
-    /**
-     * Normalizes the given string.
-     * @param s The string to escape
-     * @return the escaped string
-     */
-    private String escape(String s) {
-        if (s == null) {
-            return "";
-        }
-
-        StringBuilder str = new StringBuilder();
-
-        int len = s.length();
-        for (int i = 0; i &lt; len; i++) {
-            char ch = s.charAt(i);
-            switch (ch) {
-                case '&lt;':
-                    str.append("&amp;lt;");
-                    break;
-                case '&gt;':
-                    str.append("&amp;gt;");
-                    break;
-                case '&amp;':
-                    str.append("&amp;amp;");
-                    break;
-                case '"':
-                    str.append("&amp;quot;");
-                    break;
-                case '\r':
-                case '\n':
-                    if (canonical) {
-                        str.append("&amp;#");
-                        str.append(Integer.toString(ch));
-                        str.append(';');
-                        break;
-                    }
-                    // else, default append char
-                //$FALL-THROUGH$
-                default:
-                    str.append(ch);
-            }
-        }
-
-        return str.toString();
-    }
 }
</code_before><code_after>@@ -19,6 +19,7 @@
 import java.io.PrintWriter;
 import java.io.Writer;
 
+import org.apache.tomcat.util.security.Escape;
 import org.w3c.dom.Attr;
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
@@ -35,6 +36,12 @@ public class DOMWriter {
     private final boolean canonical;
 
 
+    public DOMWriter(Writer writer) {
+        this (writer, true);
+    }
+
+
+    @Deprecated
     public DOMWriter(Writer writer, boolean canonical) {
         out = new PrintWriter(writer);
         this.canonical = canonical;
@@ -74,7 +81,7 @@ public void print(Node node) {
                     out.print(attr.getLocalName());
 
                     out.print("=\"");
+                    out.print(Escape.xml("", canonical, attr.getNodeValue()));
                     out.print('"');
                 }
                 out.print('&gt;');
@@ -95,7 +102,7 @@ public void print(Node node) {
             // print cdata sections
             case Node.CDATA_SECTION_NODE:
                 if (canonical) {
+                    out.print(Escape.xml("", canonical, node.getNodeValue()));
                 } else {
                     out.print("&lt;![CDATA[");
                     out.print(node.getNodeValue());
@@ -105,7 +112,7 @@ public void print(Node node) {
 
             // print text
             case Node.TEXT_NODE:
+                out.print(Escape.xml("", canonical, node.getNodeValue()));
                 break;
 
             // print processing instruction
@@ -180,50 +187,4 @@ private Attr[] sortAttributes(NamedNodeMap attrs) {
 
         return array;
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>401591</refactoring_id><commit_sha>490436c136a6e7e44a3d907378afebd264d3cd3b</commit_sha><commit_link>https://github.com/apache/activemq/commit/490436c136a6e7e44a3d907378afebd264d3cd3b</commit_link><file_path>activemq-amqp/src/main/java/org/apache/activemq/transport/amqp/protocol/AmqpReceiver.java</file_path><description>Rename Variable er : ExceptionResponse to error : ExceptionResponse in method public onResponse(converter AmqpProtocolConverter, response Response) : void from class org.apache.activemq.transport.amqp.protocol.AmqpReceiver.processDelivery.sendToActiveMQ.new ResponseHandler</description><code_before>@@ -21,6 +21,7 @@
 import java.io.IOException;
 
 import javax.jms.Destination;
 
 import org.apache.activemq.command.ActiveMQDestination;
 import org.apache.activemq.command.ActiveMQMessage;
@@ -45,6 +46,7 @@
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.transaction.TransactionalState;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.engine.Delivery;
@@ -219,11 +221,19 @@ protected void processDelivery(final Delivery delivery, Buffer deliveryBytes) th
                     @Override
                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
                         if (response.isException()) {
-                            ExceptionResponse er = (ExceptionResponse) response;
                             Rejected rejected = new Rejected();
                             ErrorCondition condition = new ErrorCondition();
-                            condition.setCondition(Symbol.valueOf("failed"));
-                            condition.setDescription(er.getException().getMessage());
                             rejected.setError(condition);
                             delivery.disposition(rejected);
                         } else {
</code_before><code_after>@@ -21,6 +21,7 @@
 import java.io.IOException;
 
 import javax.jms.Destination;
+import javax.jms.ResourceAllocationException;
 
 import org.apache.activemq.command.ActiveMQDestination;
 import org.apache.activemq.command.ActiveMQMessage;
@@ -45,6 +46,7 @@
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.transaction.TransactionalState;
+import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.engine.Delivery;
@@ -219,11 +221,19 @@ protected void processDelivery(final Delivery delivery, Buffer deliveryBytes) th
                     @Override
                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
                         if (response.isException()) {
+                            ExceptionResponse error = (ExceptionResponse) response;
                             Rejected rejected = new Rejected();
                             ErrorCondition condition = new ErrorCondition();
+
+                            if (error.getException() instanceof SecurityException) {
+                                condition.setCondition(AmqpError.UNAUTHORIZED_ACCESS);
+                            } else if (error.getException() instanceof ResourceAllocationException) {
+                                condition.setCondition(AmqpError.RESOURCE_LIMIT_EXCEEDED);
+                            } else {
+                                condition.setCondition(Symbol.valueOf("failed"));
+                            }
+
+                            condition.setDescription(error.getException().getMessage());
                             rejected.setError(condition);
                             delivery.disposition(rejected);
                         } else {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>400577</refactoring_id><commit_sha>cb3da686e49071b644d21c7fe678f13e57849ab4</commit_sha><commit_link>https://github.com/apache/tinkerpop/commit/cb3da686e49071b644d21c7fe678f13e57849ab4</commit_link><file_path>gremlin-test/src/main/java/com/tinkerpop/gremlin/process/graph/step/map/BackTest.java</file_path><description>Rename Variable step : Iterator&lt;Vertex&gt; to traversal : Traversal&lt;Vertex,Vertex&gt; in method public g_v4_out_asXhereX_hasXlang_javaX_backXhereX() : void from class com.tinkerpop.gremlin.process.graph.step.map.BackTest</description><code_before>@@ -8,7 +8,6 @@
 import org.junit.Test;
 
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.Set;
 
 import static com.tinkerpop.gremlin.LoadGraphWith.GraphData.CLASSIC;
@@ -33,12 +32,12 @@ public abstract class BackTest extends AbstractGremlinProcessTest {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v1_asXhereX_out_backXhereX() {
-        final Iterator&lt;Vertex&gt; step = get_g_v1_asXhereX_out_backXhereX(convertToVertexId("marko"));
-        System.out.println("Testing: " + step);
         int counter = 0;
-        while (step.hasNext()) {
             counter++;
-            assertEquals("marko", step.next().&lt;String&gt;value("name"));
         }
         assertEquals(3, counter);
     }
@@ -47,12 +46,12 @@ public void g_v1_asXhereX_out_backXhereX() {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX() {
-        final Iterator&lt;Vertex&gt; step = get_g_v4_out_asXhereX_hasXlang_javaX_backXhereX(convertToVertexId("josh"));
-        System.out.println("Testing: " + step);
         int counter = 0;
-        while (step.hasNext()) {
             counter++;
-            final Vertex vertex = step.next();
             assertEquals("java", vertex.&lt;String&gt;value("lang"));
             assertTrue(vertex.value("name").equals("ripple") || vertex.value("name").equals("lop"));
         }
@@ -62,26 +61,26 @@ public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX() {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v1_outE_asXhereX_inV_hasXname_vadasX_backXhereX() {
-        final Iterator&lt;Edge&gt; step = get_g_v1_outE_asXhereX_inV_hasXname_vadasX_backXhereX(convertToVertexId("marko"));
-        System.out.println("Testing: " + step);
-        final Edge edge = step.next();
         assertEquals("knows", edge.label());
         assertEquals(convertToVertexId("vadas"), edge.inV().id().next());
         assertEquals(convertToVertexId("marko"), edge.outV().id().next());
         assertEquals(0.5f, edge.&lt;Float&gt;value("weight"), 0.0001f);
-        assertFalse(step.hasNext());
     }
 
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX_valueXnameX() {
-        final Iterator&lt;String&gt; step = get_g_v4_out_asXhereX_hasXlang_javaX_backXhereX_valueXnameX(convertToVertexId("josh"));
-        System.out.println("Testing: " + step);
         int counter = 0;
         final Set&lt;String&gt; names = new HashSet&lt;&gt;();
-        while (step.hasNext()) {
             counter++;
-            names.add(step.next());
         }
         assertEquals(2, counter);
         assertEquals(2, names.size());
@@ -92,15 +91,15 @@ public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX_valueXnameX() {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v1_outEXknowsX_hasXweight_1X_asXhereX_inV_hasXname_joshX_backXhereX() {
-        final Iterator&lt;Edge&gt; step = get_g_v1_outEXknowsX_hasXweight_1X_asXhereX_inV_hasXname_joshX_backXhereX(convertToVertexId("marko"));
-        System.out.println("Testing: " + step);
-        assertTrue(step.hasNext());
-        assertTrue(step.hasNext());
-        final Edge edge = step.next();
         assertEquals("knows", edge.label());
         assertEquals(Float.valueOf(1.0f), edge.&lt;Float&gt;value("weight"));
-        assertFalse(step.hasNext());
-        assertFalse(step.hasNext());
     }
 
     public static class JavaBackTest extends BackTest {
</code_before><code_after>@@ -8,7 +8,6 @@
 import org.junit.Test;
 
 import java.util.HashSet;
 import java.util.Set;
 
 import static com.tinkerpop.gremlin.LoadGraphWith.GraphData.CLASSIC;
@@ -33,12 +32,12 @@ public abstract class BackTest extends AbstractGremlinProcessTest {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v1_asXhereX_out_backXhereX() {
+        final Traversal&lt;Vertex, Vertex&gt; traversal = get_g_v1_asXhereX_out_backXhereX(convertToVertexId("marko"));
+        printTraversalForm(traversal);
         int counter = 0;
+        while (traversal.hasNext()) {
             counter++;
+            assertEquals("marko", traversal.next().&lt;String&gt;value("name"));
         }
         assertEquals(3, counter);
     }
@@ -47,12 +46,12 @@ public void g_v1_asXhereX_out_backXhereX() {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX() {
+        final Traversal&lt;Vertex, Vertex&gt; traversal = get_g_v4_out_asXhereX_hasXlang_javaX_backXhereX(convertToVertexId("josh"));
+        printTraversalForm(traversal);
         int counter = 0;
+        while (traversal.hasNext()) {
             counter++;
+            final Vertex vertex = traversal.next();
             assertEquals("java", vertex.&lt;String&gt;value("lang"));
             assertTrue(vertex.value("name").equals("ripple") || vertex.value("name").equals("lop"));
         }
@@ -62,26 +61,26 @@ public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX() {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v1_outE_asXhereX_inV_hasXname_vadasX_backXhereX() {
+        final Traversal&lt;Vertex, Edge&gt; traversal = get_g_v1_outE_asXhereX_inV_hasXname_vadasX_backXhereX(convertToVertexId("marko"));
+        printTraversalForm(traversal);
+        final Edge edge = traversal.next();
         assertEquals("knows", edge.label());
         assertEquals(convertToVertexId("vadas"), edge.inV().id().next());
         assertEquals(convertToVertexId("marko"), edge.outV().id().next());
         assertEquals(0.5f, edge.&lt;Float&gt;value("weight"), 0.0001f);
+        assertFalse(traversal.hasNext());
     }
 
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX_valueXnameX() {
+        final Traversal&lt;Vertex, String&gt; traversal = get_g_v4_out_asXhereX_hasXlang_javaX_backXhereX_valueXnameX(convertToVertexId("josh"));
+        printTraversalForm(traversal);
         int counter = 0;
         final Set&lt;String&gt; names = new HashSet&lt;&gt;();
+        while (traversal.hasNext()) {
             counter++;
+            names.add(traversal.next());
         }
         assertEquals(2, counter);
         assertEquals(2, names.size());
@@ -92,15 +91,15 @@ public void g_v4_out_asXhereX_hasXlang_javaX_backXhereX_valueXnameX() {
     @Test
     @LoadGraphWith(CLASSIC)
     public void g_v1_outEXknowsX_hasXweight_1X_asXhereX_inV_hasXname_joshX_backXhereX() {
+        final Traversal&lt;Vertex, Edge&gt; traversal = get_g_v1_outEXknowsX_hasXweight_1X_asXhereX_inV_hasXname_joshX_backXhereX(convertToVertexId("marko"));
+        printTraversalForm(traversal);
+        assertTrue(traversal.hasNext());
+        assertTrue(traversal.hasNext());
+        final Edge edge = traversal.next();
         assertEquals("knows", edge.label());
         assertEquals(Float.valueOf(1.0f), edge.&lt;Float&gt;value("weight"));
+        assertFalse(traversal.hasNext());
+        assertFalse(traversal.hasNext());
     }
 
     public static class JavaBackTest extends BackTest {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>435662</refactoring_id><commit_sha>7fb645b0ab782d496418a9b6cab6455d214a2187</commit_sha><commit_link>https://github.com/yacy/yacy_search_server/commit/7fb645b0ab782d496418a9b6cab6455d214a2187</commit_link><file_path>source/de/anomic/plasma/plasmaSwitchboard.java</file_path><description>Rename Variable ramPURL : int to ramNURL : int in method public plasmaSwitchboard(rootPath String, initPath String, configPath String) from class de.anomic.plasma.plasmaSwitchboard</description><code_before>@@ -190,19 +190,20 @@ public plasmaSwitchboard(String rootPath, String initPath, String configPath) th
         }
         
 	// read memory amount
-        int ramCacheKB = Integer.parseInt(getConfig("ramCacheSize", "1")) * 0x400;
-        int ramLURL =  ramCacheKB * Integer.parseInt(getConfig("ramCachePercentLURL", "1")) / 100;
-        int ramPURL = ramLURL / 2;
-        int ramEURL = ramLURL / 2;
-        int ramRWI  =  ramCacheKB * Integer.parseInt(getConfig("ramCachePercentRWI", "1")) / 100;
-        int ramHTTP =  ramCacheKB * Integer.parseInt(getConfig("ramCachePercentHTTP", "1")) / 100;
-        int ramMessage = ramCacheKB * Integer.parseInt(getConfig("ramCachePercentMessage", "1")) / 100;
-        int ramWiki =  ramCacheKB * Integer.parseInt(getConfig("ramCachePercentWiki", "1")) / 100;
-        log.logSystem("LURL    Cache memory = " + ramLURL + " KB");
-        log.logSystem("RWI     Cache memory = " + ramRWI  + " KB");
-        log.logSystem("HTTP    Cache memory = " + ramHTTP + " KB");
-        log.logSystem("Message Cache memory = " + ramMessage + " KB");
-        log.logSystem("Wiki    Cache memory = " + ramWiki + " KB");
         
 	// make crawl profiles database and default profiles
         profiles = new plasmaCrawlProfile(new File(plasmaPath, "crawlProfiles0.db"));
@@ -213,10 +214,10 @@ public plasmaSwitchboard(String rootPath, String initPath, String configPath) th
         
         // start indexing management
         loadedURL = new plasmaCrawlLURL(new File(plasmaPath, "urlHash.db"), ramLURL);
-        noticeURL = new plasmaCrawlNURL(plasmaPath, ramPURL);
         errorURL = new plasmaCrawlEURL(new File(plasmaPath, "urlErr0.db"), ramEURL);
-	//indexCache = new plasmaWordIndexRAMCache(plasmaPath, 2000, ramRWI);
-        wordIndex = new plasmaWordIndex(plasmaPath, ramRWI);
 	searchManager = new plasmaSearch(loadedURL, wordIndex);
         
         // start a cache manager
@@ -290,6 +291,15 @@ public plasmaSwitchboard(String rootPath, String initPath, String configPath) th
                      new serverInstantThread(indexDistribution, "job", null), log, 120000);
     }
     
     public void handleBusyState(int jobs) {
         this.serverJobs = jobs;
     }
@@ -359,7 +369,7 @@ public void close() {
         log.logSystem("SWITCHBOARD SHUTDOWN STEP 1: sending termination signal to managed threads:");
         terminateAllThreads(true);
         log.logSystem("SWITCHBOARD SHUTDOWN STEP 2: sending termination signal to threaded indexing (stand by..)");
-        int waitingBoundSeconds = Integer.parseInt(getConfig("shutdownWaiting", "120"));
         wordIndex.close(waitingBoundSeconds);
         log.logSystem("SWITCHBOARD SHUTDOWN STEP 3: sending termination signal to database manager");
         try {
@@ -397,16 +407,18 @@ public void enQueue(Object job) {
         processStack.addLast(entry);
     }
 
-    public synchronized void deQueue() {
         if (serverJobs &lt; 6) {
             if (processStack.size() &gt; 0) {
                 processResourceStack((plasmaHTCache.Entry) processStack.removeFirst());
             }
         } else {
             //if (processStack.size() &gt; 0) {
                 log.logDebug("DEQUEUE: serverJobs=" + serverJobs + " 'busy' - no dequeueing (processStack=" + processStack.size() + ", localStackSize=" + noticeURL.localStackSize() + ", remoteStackSize=" + noticeURL.remoteStackSize() + ")");
             //}
         }
     }
     
     public int cleanupJobSize() {
@@ -444,7 +456,7 @@ public int localCrawlJobSize() {
     }
     
     public boolean localCrawlJob() {
-        if ((serverJobs &lt; 2) &amp;&amp;
             (processStack.size() &lt; crawlSlots) &amp;&amp;
             (noticeURL.localStackSize() &gt; 0) &amp;&amp;
             (cacheLoader.size() &lt; crawlSlots)) {
</code_before><code_after>@@ -190,19 +190,20 @@ public plasmaSwitchboard(String rootPath, String initPath, String configPath) th
         }
         
 	// read memory amount
+        int ramLURL    = Integer.parseInt(getConfig("ramCacheLURL", "1024")) / 1024;
+        int ramNURL    = Integer.parseInt(getConfig("ramCacheNURL", "1024")) / 1024;
+        int ramEURL    = Integer.parseInt(getConfig("ramCacheEURL", "1024")) / 1024;
+        int ramRWI     = Integer.parseInt(getConfig("ramCacheRWI",  "1024")) / 1024;
+        int ramHTTP    = Integer.parseInt(getConfig("ramCacheHTTP", "1024")) / 1024;
+        int ramMessage = Integer.parseInt(getConfig("ramCacheMessage", "1024")) / 1024;
+        int ramWiki    = Integer.parseInt(getConfig("ramCacheWiki", "1024")) / 1024;
+        log.logSystem("LURL    Cache memory = " + ppRamString(ramLURL));
+        log.logSystem("NURL    Cache memory = " + ppRamString(ramNURL));
+        log.logSystem("EURL    Cache memory = " + ppRamString(ramEURL));
+        log.logSystem("RWI     Cache memory = " + ppRamString(ramRWI));
+        log.logSystem("HTTP    Cache memory = " + ppRamString(ramHTTP));
+        log.logSystem("Message Cache memory = " + ppRamString(ramMessage));
+        log.logSystem("Wiki    Cache memory = " + ppRamString(ramWiki));
         
 	// make crawl profiles database and default profiles
         profiles = new plasmaCrawlProfile(new File(plasmaPath, "crawlProfiles0.db"));
@@ -213,10 +214,10 @@ public plasmaSwitchboard(String rootPath, String initPath, String configPath) th
         
         // start indexing management
         loadedURL = new plasmaCrawlLURL(new File(plasmaPath, "urlHash.db"), ramLURL);
+        noticeURL = new plasmaCrawlNURL(plasmaPath, ramNURL);
         errorURL = new plasmaCrawlEURL(new File(plasmaPath, "urlErr0.db"), ramEURL);
+	wordIndex = new plasmaWordIndex(plasmaPath, ramRWI);
+        wordIndex.setMaxWords(10000);
 	searchManager = new plasmaSearch(loadedURL, wordIndex);
         
         // start a cache manager
@@ -290,6 +291,15 @@ public plasmaSwitchboard(String rootPath, String initPath, String configPath) th
                      new serverInstantThread(indexDistribution, "job", null), log, 120000);
     }
     
+    private static String ppRamString(int bytes) {
+        if (bytes &lt; 1024) return bytes + " KByte";
+        bytes = bytes / 1024;
+        if (bytes &lt; 1024) return bytes + " MByte";
+        bytes = bytes / 1024;
+        if (bytes &lt; 1024) return bytes + " GByte";
+        return (bytes / 1024) + "TByte";
+    }
+    
     public void handleBusyState(int jobs) {
         this.serverJobs = jobs;
     }
@@ -359,7 +369,7 @@ public void close() {
         log.logSystem("SWITCHBOARD SHUTDOWN STEP 1: sending termination signal to managed threads:");
         terminateAllThreads(true);
         log.logSystem("SWITCHBOARD SHUTDOWN STEP 2: sending termination signal to threaded indexing (stand by..)");
+        int waitingBoundSeconds = Integer.parseInt(getConfig("maxWaitingWordFlush", "120"));
         wordIndex.close(waitingBoundSeconds);
         log.logSystem("SWITCHBOARD SHUTDOWN STEP 3: sending termination signal to database manager");
         try {
@@ -397,16 +407,18 @@ public void enQueue(Object job) {
         processStack.addLast(entry);
     }
 
+    public synchronized boolean deQueue() {
         if (serverJobs &lt; 6) {
             if (processStack.size() &gt; 0) {
                 processResourceStack((plasmaHTCache.Entry) processStack.removeFirst());
+                return true;
             }
         } else {
             //if (processStack.size() &gt; 0) {
                 log.logDebug("DEQUEUE: serverJobs=" + serverJobs + " 'busy' - no dequeueing (processStack=" + processStack.size() + ", localStackSize=" + noticeURL.localStackSize() + ", remoteStackSize=" + noticeURL.remoteStackSize() + ")");
             //}
         }
+        return false;
     }
     
     public int cleanupJobSize() {
@@ -444,7 +456,7 @@ public int localCrawlJobSize() {
     }
     
     public boolean localCrawlJob() {
+        if ((serverJobs &lt; 6) &amp;&amp;
             (processStack.size() &lt; crawlSlots) &amp;&amp;
             (noticeURL.localStackSize() &gt; 0) &amp;&amp;
             (cacheLoader.size() &lt; crawlSlots)) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>386222</refactoring_id><commit_sha>2224eeb3037fb09b140a207270c0d74a06f76de4</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/2224eeb3037fb09b140a207270c0d74a06f76de4</commit_link><file_path>core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java</file_path><description>Rename Variable t : Throwable to e : Exception in method public snapshot(writer SnapshotWriter) : void from class alluxio.master.journal.raft.JournalStateMachine</description><code_before>@@ -185,9 +185,9 @@ public void snapshot(SnapshotWriter writer) {
     try (SnapshotWriterStream sws = new SnapshotWriterStream(writer)) {
       writer.writeLong(snapshotId);
       JournalUtils.writeToCheckpoint(sws, getStateMachines());
-    } catch (Throwable t) {
-      ProcessUtils.fatalError(LOG, t, "Failed to snapshot");
-      throw new RuntimeException(t);
     }
     LOG.info("Completed snapshot up to SN {} in {}ms", snapshotId,
         System.currentTimeMillis() - mLastSnapshotStartTime);
@@ -208,9 +208,8 @@ public void install(SnapshotReader snapshotReader) {
     try (InputStream srs = new SnapshotReaderStream(snapshotReader)) {
       snapshotId = snapshotReader.readLong();
       JournalUtils.restoreFromCheckpoint(new CheckpointInputStream(srs), getStateMachines());
-    } catch (Throwable t) {
-      JournalUtils.handleJournalReplayFailure(LOG, t,
-          "Failed to install snapshot");
       if (ServerConfiguration.getBoolean(PropertyKey.MASTER_JOURNAL_TOLERATE_CORRUPTION)) {
         return;
       }
</code_before><code_after>@@ -185,9 +185,9 @@ public void snapshot(SnapshotWriter writer) {
     try (SnapshotWriterStream sws = new SnapshotWriterStream(writer)) {
       writer.writeLong(snapshotId);
       JournalUtils.writeToCheckpoint(sws, getStateMachines());
+    } catch (Exception e) {
+      ProcessUtils.fatalError(LOG, e, "Failed to take snapshot: %s", snapshotId);
+      throw new RuntimeException(e);
     }
     LOG.info("Completed snapshot up to SN {} in {}ms", snapshotId,
         System.currentTimeMillis() - mLastSnapshotStartTime);
@@ -208,9 +208,8 @@ public void install(SnapshotReader snapshotReader) {
     try (InputStream srs = new SnapshotReaderStream(snapshotReader)) {
       snapshotId = snapshotReader.readLong();
       JournalUtils.restoreFromCheckpoint(new CheckpointInputStream(srs), getStateMachines());
+    } catch (Exception e) {
+      JournalUtils.handleJournalReplayFailure(LOG, e, "Failed to install snapshot: %s", snapshotId);
       if (ServerConfiguration.getBoolean(PropertyKey.MASTER_JOURNAL_TOLERATE_CORRUPTION)) {
         return;
       }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>416242</refactoring_id><commit_sha>6da54fdf3f9cbded3213c5c7b754b159c0b85d3f</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/6da54fdf3f9cbded3213c5c7b754b159c0b85d3f</commit_link><file_path>src/edu/stanford/nlp/ling/tokensregex/types/ValueFunctions.java</file_path><description>Rename Variable entry : Map.Entry&lt;String,Collection&lt;ValueFunction&gt;&gt; to name : String in method public main(args String[]) : void from class edu.stanford.nlp.ling.tokensregex.types.ValueFunctions</description><code_before>@@ -97,7 +97,7 @@ public TypeCheckedFunction(String name, List&lt;ParamInfo&gt; paramInfos) {
     public TypeCheckedFunction(String name, ParamInfo... paramInfos) {
       super(name);
       this.paramInfos = Arrays.asList(paramInfos);
-      nargs = paramInfos.length;
     }
 
     @Override
@@ -718,7 +718,8 @@ public static class NumericComparator implements Comparator&lt;Number&gt; {
     @Override
     public int compare(Number o1, Number o2) {
       if (isInteger(o1) &amp;&amp; isInteger(o2)) {
-        return Long.compare(o1.longValue(), o2.longValue());
       } else {
         return Double.compare(o1.doubleValue(),o2.doubleValue());
       }
@@ -732,8 +733,7 @@ public int compare(T o1, T o2) {
     }
   }
 
-  public enum CompareType { GT, LT, GE, LE, EQ, NE }
-
   public static class CompareFunction&lt;T&gt; extends NamedValueFunction {
     Comparator&lt;T&gt; comparator;
     CompareType compType;
@@ -1634,9 +1634,9 @@ public Value apply(Env env, List&lt;Value&gt; in) {
 
   public static void main(String[] args) {
     // Dumps the registered functions
-    for (Map.Entry&lt;String, Collection&lt;ValueFunction&gt;&gt; entry : registeredFunctions.entrySet()) {
-      for (ValueFunction vf: entry.getValue()) {
-        System.out.println(entry.getKey() + ": " + vf);
       }
     }
   }
</code_before><code_after>@@ -97,7 +97,7 @@ public TypeCheckedFunction(String name, List&lt;ParamInfo&gt; paramInfos) {
     public TypeCheckedFunction(String name, ParamInfo... paramInfos) {
       super(name);
       this.paramInfos = Arrays.asList(paramInfos);
+      nargs = (paramInfos != null)? paramInfos.length:0;
     }
 
     @Override
@@ -718,7 +718,8 @@ public static class NumericComparator implements Comparator&lt;Number&gt; {
     @Override
     public int compare(Number o1, Number o2) {
       if (isInteger(o1) &amp;&amp; isInteger(o2)) {
+        Long l1 = o1.longValue();
+        return l1.compareTo(o2.longValue());
       } else {
         return Double.compare(o1.doubleValue(),o2.doubleValue());
       }
@@ -732,8 +733,7 @@ public int compare(T o1, T o2) {
     }
   }
 
+  public static enum CompareType { GT, LT, GE, LE, EQ, NE }
   public static class CompareFunction&lt;T&gt; extends NamedValueFunction {
     Comparator&lt;T&gt; comparator;
     CompareType compType;
@@ -1634,9 +1634,9 @@ public Value apply(Env env, List&lt;Value&gt; in) {
 
   public static void main(String[] args) {
     // Dumps the registered functions
+    for (String name: registeredFunctions.keySet()) {
+      for (ValueFunction vf: registeredFunctions.get(name)) {
+        System.out.println(name + ": " + vf);
       }
     }
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>354769</refactoring_id><commit_sha>090b2faec4fe68689521872db90043665cdf1018</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/090b2faec4fe68689521872db90043665cdf1018</commit_link><file_path>node-admin/src/main/java/com/yahoo/vespa/hosted/node/admin/nodeagent/NodeAgentImpl.java</file_path><description>Rename Variable memoryPercentUsed : double to memoryUsageRatio : double in method public updateContainerNodeMetrics() : void from class com.yahoo.vespa.hosted.node.admin.nodeagent.NodeAgentImpl</description><code_before>@@ -524,6 +524,7 @@ public void updateContainerNodeMetrics() {
         Docker.ContainerStats stats = containerStats.get();
         final String APP = MetricReceiverWrapper.APPLICATION_NODE;
         final int totalNumCpuCores = ((List&lt;Number&gt;) ((Map) stats.getCpuStats().get("cpu_usage")).get("percpu_usage")).size();
         final long cpuContainerTotalTime = ((Number) ((Map) stats.getCpuStats().get("cpu_usage")).get("total_usage")).longValue();
         final long cpuSystemTotalTime = ((Number) stats.getCpuStats().get("system_cpu_usage")).longValue();
         final long memoryTotalBytes = ((Number) stats.getMemoryStats().get("limit")).longValue();
@@ -532,26 +533,32 @@ public void updateContainerNodeMetrics() {
         final long diskTotalBytes = (long) (nodeSpec.minDiskAvailableGb * BYTES_IN_GB);
         final Optional&lt;Long&gt; diskTotalBytesUsed = storageMaintainer.getDiskUsageFor(containerName);
 
         // CPU usage by a container as percentage of total host CPU, cpuPercentageOfHost, is given by dividing used
-        // CPU time by the container with CPU time used by the entire system.
         // CPU usage by a container as percentage of total CPU allocated to it is given by dividing the
         // cpuPercentageOfHost with the ratio of container minCpuCores by total number of CPU cores.
-        double cpuPercentageOfHost = lastCpuMetric.getCpuUsagePercentage(cpuContainerTotalTime, cpuSystemTotalTime);
-        double cpuPercentageOfAllocated = totalNumCpuCores * cpuPercentageOfHost / nodeSpec.minCpuCores;
         long memoryTotalBytesUsed = memoryTotalBytesUsage - memoryTotalBytesCache;
-        double memoryPercentUsed = 100.0 * memoryTotalBytesUsed / memoryTotalBytes;
-        Optional&lt;Double&gt; diskPercentUsed = diskTotalBytesUsed.map(used -&gt; 100.0 * used / diskTotalBytes);
 
         List&lt;DimensionMetrics&gt; metrics = new ArrayList&lt;&gt;();
         DimensionMetrics.Builder systemMetricsBuilder = new DimensionMetrics.Builder(APP, dimensions)
                 .withMetric("mem.limit", memoryTotalBytes)
                 .withMetric("mem.used", memoryTotalBytesUsed)
-                .withMetric("mem.util", memoryPercentUsed)
-                .withMetric("cpu.util", cpuPercentageOfAllocated)
                 .withMetric("disk.limit", diskTotalBytes);
 
         diskTotalBytesUsed.ifPresent(diskUsed -&gt; systemMetricsBuilder.withMetric("disk.used", diskUsed));
-        diskPercentUsed.ifPresent(diskUtil -&gt; systemMetricsBuilder.withMetric("disk.util", diskUtil));
         metrics.add(systemMetricsBuilder.build());
 
         stats.getNetworks().forEach((interfaceName, interfaceStats) -&gt; {
@@ -612,17 +619,30 @@ public int getAndResetNumberOfUnhandledExceptions() {
     }
 
     class CpuUsageReporter {
         private long totalContainerUsage = 0;
         private long totalSystemUsage = 0;
 
-        double getCpuUsagePercentage(long currentContainerUsage, long currentSystemUsage) {
-            long deltaSystemUsage = currentSystemUsage - totalSystemUsage;
-            double cpuUsagePct = (deltaSystemUsage == 0 || totalSystemUsage == 0) ?
-                    0 : 100.0 * (currentContainerUsage - totalContainerUsage) / deltaSystemUsage;
 
-            totalContainerUsage = currentContainerUsage;
-            totalSystemUsage = currentSystemUsage;
-            return cpuUsagePct;
         }
     }
 
</code_before><code_after>@@ -524,6 +524,7 @@ public void updateContainerNodeMetrics() {
         Docker.ContainerStats stats = containerStats.get();
         final String APP = MetricReceiverWrapper.APPLICATION_NODE;
         final int totalNumCpuCores = ((List&lt;Number&gt;) ((Map) stats.getCpuStats().get("cpu_usage")).get("percpu_usage")).size();
+        final long cpuContainerKernelTime = ((Number) ((Map) stats.getCpuStats().get("cpu_usage")).get("usage_in_kernelmode")).longValue();
         final long cpuContainerTotalTime = ((Number) ((Map) stats.getCpuStats().get("cpu_usage")).get("total_usage")).longValue();
         final long cpuSystemTotalTime = ((Number) stats.getCpuStats().get("system_cpu_usage")).longValue();
         final long memoryTotalBytes = ((Number) stats.getMemoryStats().get("limit")).longValue();
@@ -532,26 +533,32 @@ public void updateContainerNodeMetrics() {
         final long diskTotalBytes = (long) (nodeSpec.minDiskAvailableGb * BYTES_IN_GB);
         final Optional&lt;Long&gt; diskTotalBytesUsed = storageMaintainer.getDiskUsageFor(containerName);
 
+        lastCpuMetric.updateCpuDeltas(cpuSystemTotalTime, cpuContainerTotalTime, cpuContainerKernelTime);
+
         // CPU usage by a container as percentage of total host CPU, cpuPercentageOfHost, is given by dividing used
+        // CPU time used by the container with CPU time used by the entire system.
+        double cpuUsageRatioOfHost = lastCpuMetric.getCpuUsageRatio();
+
         // CPU usage by a container as percentage of total CPU allocated to it is given by dividing the
         // cpuPercentageOfHost with the ratio of container minCpuCores by total number of CPU cores.
+        double cpuUsageRatioOfAllocated = totalNumCpuCores * cpuUsageRatioOfHost / nodeSpec.minCpuCores;
+        double cpuKernelUsageRatioOfAllocated = cpuUsageRatioOfAllocated * lastCpuMetric.getCpuKernelUsageRatio();
+
         long memoryTotalBytesUsed = memoryTotalBytesUsage - memoryTotalBytesCache;
+        double memoryUsageRatio = (double) memoryTotalBytesUsed / memoryTotalBytes;
+        Optional&lt;Double&gt; diskUsageRatio = diskTotalBytesUsed.map(used -&gt; (double) used / diskTotalBytes);
 
         List&lt;DimensionMetrics&gt; metrics = new ArrayList&lt;&gt;();
         DimensionMetrics.Builder systemMetricsBuilder = new DimensionMetrics.Builder(APP, dimensions)
                 .withMetric("mem.limit", memoryTotalBytes)
                 .withMetric("mem.used", memoryTotalBytesUsed)
+                .withMetric("mem.util", 100 * memoryUsageRatio)
+                .withMetric("cpu.util", 100 * cpuUsageRatioOfAllocated)
+                .withMetric("cpu.sys.util", 100 * cpuKernelUsageRatioOfAllocated)
                 .withMetric("disk.limit", diskTotalBytes);
 
         diskTotalBytesUsed.ifPresent(diskUsed -&gt; systemMetricsBuilder.withMetric("disk.used", diskUsed));
+        diskUsageRatio.ifPresent(diskRatio -&gt; systemMetricsBuilder.withMetric("disk.util", 100 * diskRatio));
         metrics.add(systemMetricsBuilder.build());
 
         stats.getNetworks().forEach((interfaceName, interfaceStats) -&gt; {
@@ -612,17 +619,30 @@ public int getAndResetNumberOfUnhandledExceptions() {
     }
 
     class CpuUsageReporter {
+        private long containerKernelUsage = 0;
         private long totalContainerUsage = 0;
         private long totalSystemUsage = 0;
 
+        private long deltaContainerKernelUsage;
+        private long deltaContainerUsage;
+        private long deltaSystemUsage;
+
+        private void updateCpuDeltas(long totalSystemUsage, long totalContainerUsage, long containerKernelUsage) {
+            deltaSystemUsage = totalSystemUsage - this.totalSystemUsage;
+            deltaContainerUsage = totalContainerUsage - this.totalContainerUsage;
+            deltaContainerKernelUsage = containerKernelUsage - this.containerKernelUsage;
+
+            this.totalSystemUsage = totalSystemUsage;
+            this.totalContainerUsage = totalContainerUsage;
+            this.containerKernelUsage = containerKernelUsage;
+        }
+
+        double getCpuKernelUsageRatio() {
+            return deltaContainerUsage == 0 ? 0 : (double) deltaContainerKernelUsage / deltaContainerUsage;
+        }
 
+        double getCpuUsageRatio() {
+            return deltaSystemUsage == 0 ? 0 : (double) deltaContainerUsage / deltaSystemUsage;
         }
     }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>420696</refactoring_id><commit_sha>27b4bdc3f7834983e017ce765bd3a753b0462dfc</commit_sha><commit_link>https://github.com/apache/poi/commit/27b4bdc3f7834983e017ce765bd3a753b0462dfc</commit_link><file_path>poi/src/test/java/org/apache/poi/hssf/dev/TestBiffDrawingToXml.java</file_path><description>Rename Variable wb : InputStream to inp : InputStream in method package runOneFile(pFile File) : void from class org.apache.poi.hssf.dev.TestBiffDrawingToXml</description><code_before>@@ -20,11 +20,25 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.InputStream;
 import java.util.Map;
 
 import org.apache.poi.EncryptedDocumentException;
 import org.apache.poi.hssf.record.RecordInputStream;
 
 class TestBiffDrawingToXml extends BaseTestIteratingXLS {
 
@@ -42,10 +56,69 @@ protected Map&lt;String, Class&lt;? extends Throwable&gt;&gt; getExcludes() {
         return excludes;
     }
 
     @Override
     void runOneFile(File pFile) throws Exception {
-        try (InputStream wb = new FileInputStream(pFile)) {
-            BiffDrawingToXml.writeToFile(NULL_OUTPUT_STREAM, wb, false, new String[0]);
         }
     }
 }
</code_before><code_after>@@ -20,11 +20,25 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 import org.apache.poi.EncryptedDocumentException;
+import org.apache.poi.ddf.EscherRecord;
+import org.apache.poi.hssf.model.InternalWorkbook;
+import org.apache.poi.hssf.record.DrawingGroupRecord;
 import org.apache.poi.hssf.record.RecordInputStream;
+import org.apache.poi.hssf.usermodel.HSSFPatriarch;
+import org.apache.poi.hssf.usermodel.HSSFSheet;
+import org.apache.poi.hssf.usermodel.HSSFWorkbook;
+import org.apache.poi.ss.usermodel.Sheet;
+import org.apache.poi.util.StringUtil;
 
 class TestBiffDrawingToXml extends BaseTestIteratingXLS {
 
@@ -42,10 +56,69 @@ protected Map&lt;String, Class&lt;? extends Throwable&gt;&gt; getExcludes() {
         return excludes;
     }
 
+    // output sheets with specified name
+    private static final String[] SHEET_NAMES = {};
+
+    // output sheets with specified indexes
+    private static final int[] SHEET_IDX = {};
+
+    // exclude workbook-level records
+    private static final boolean EXCLUDE_WORKBOOK = false;
+
+
     @Override
     void runOneFile(File pFile) throws Exception {
+        try (InputStream inp = new FileInputStream(pFile);
+             OutputStream outputStream = NULL_OUTPUT_STREAM) {
+            writeToFile(outputStream, inp);
+        }
+    }
+
+    public static void writeToFile(OutputStream fos, InputStream xlsWorkbook) throws IOException {
+        try (HSSFWorkbook workbook = new HSSFWorkbook(xlsWorkbook)) {
+            InternalWorkbook internalWorkbook = workbook.getInternalWorkbook();
+            DrawingGroupRecord r = (DrawingGroupRecord) internalWorkbook.findFirstRecordBySid(DrawingGroupRecord.sid);
+
+            StringBuilder builder = new StringBuilder();
+            builder.append("&lt;workbook&gt;\n");
+            String tab = "\t";
+            if (!EXCLUDE_WORKBOOK &amp;&amp; r != null) {
+                r.decode();
+                List&lt;EscherRecord&gt; escherRecords = r.getEscherRecords();
+                for (EscherRecord record : escherRecords) {
+                    builder.append(record.toXml(tab));
+                }
+            }
+            int i = 0;
+            for (HSSFSheet sheet : getSheets(workbook)) {
+                HSSFPatriarch p = sheet.getDrawingPatriarch();
+                if (p != null) {
+                    builder.append(tab).append("&lt;sheet").append(i).append("&gt;\n");
+                    builder.append(p.getBoundAggregate().toXml(tab + "\t"));
+                    builder.append(tab).append("&lt;/sheet").append(i).append("&gt;\n");
+                    i++;
+                }
+            }
+            builder.append("&lt;/workbook&gt;\n");
+            fos.write(builder.toString().getBytes(StringUtil.UTF8));
         }
     }
+
+    private static List&lt;HSSFSheet&gt; getSheets(HSSFWorkbook workbook) {
+        List&lt;Integer&gt; sheetIdx = Arrays.stream(SHEET_IDX).boxed().collect(Collectors.toList());
+        List&lt;String&gt; sheetNms = Arrays.stream(SHEET_NAMES).collect(Collectors.toList());
+
+        List&lt;HSSFSheet&gt; list = new ArrayList&lt;&gt;();
+
+        for (Sheet sheet : workbook) {
+            if ((sheetIdx.isEmpty() &amp;&amp; sheetNms.isEmpty()) ||
+                sheetIdx.contains(workbook.getSheetIndex(sheet)) ||
+                sheetNms.contains(sheet.getSheetName())
+            ) {
+                list.add((HSSFSheet)sheet);
+            }
+        }
+
+        return list;
+    }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>339055</refactoring_id><commit_sha>6107666156856f0e95610272faa840714b9d481f</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/6107666156856f0e95610272faa840714b9d481f</commit_link><file_path>de.metas.util.web/src/main/java/de/metas/util/web/security/UserAuthTokenService.java</file_path><description>Rename Variable userRolePermissions : IUserRolePermissions to permissions : IUserRolePermissions in method private createContext(token UserAuthToken) : Properties from class de.metas.util.web.security.UserAuthTokenService</description><code_before>@@ -3,6 +3,7 @@
 import java.util.Properties;
 
 import org.adempiere.exceptions.AdempiereException;
 import org.adempiere.util.lang.IAutoCloseable;
 import org.compiere.util.Env;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -12,10 +13,12 @@
 
 import de.metas.security.IUserRolePermissions;
 import de.metas.security.IUserRolePermissionsDAO;
 import de.metas.security.UserAuthToken;
 import de.metas.security.UserAuthTokenRepository;
 import de.metas.security.UserNotAuthorizedException;
 import de.metas.security.UserRolePermissionsKey;
 import de.metas.util.Services;
 import de.metas.util.time.SystemTime;
 import lombok.NonNull;
@@ -84,18 +87,18 @@ public &lt;R&gt; R call(final Supplier&lt;String&gt; authTokenStringSupplier, @NonNull final
 	private final Properties createContext(final UserAuthToken token)
 	{
 		final IUserRolePermissionsDAO userRolePermissionsDAO = Services.get(IUserRolePermissionsDAO.class);
-		final IUserRolePermissions userRolePermissions = userRolePermissionsDAO.retrieveUserRolePermissions(UserRolePermissionsKey.builder()
-				.adUserId(token.getUserId())
-				.adRoleId(token.getRoleId())
-				.adClientId(token.getClientId())
 				.date(SystemTime.asDayTimestamp())
 				.build());
 
 		final Properties ctx = Env.newTemporaryCtx();
-		Env.setContext(ctx, Env.CTXNAME_AD_Client_ID, userRolePermissions.getAD_Client_ID());
-		Env.setContext(ctx, Env.CTXNAME_AD_Org_ID, token.getOrgId());
-		Env.setContext(ctx, Env.CTXNAME_AD_User_ID, userRolePermissions.getAD_User_ID());
-		Env.setContext(ctx, Env.CTXNAME_AD_Role_ID, userRolePermissions.getAD_Role_ID());
 		// TODO: set other properties like language, warehouse etc...
 		return ctx;
 	}
</code_before><code_after>@@ -3,6 +3,7 @@
 import java.util.Properties;
 
 import org.adempiere.exceptions.AdempiereException;
+import org.adempiere.service.OrgId;
 import org.adempiere.util.lang.IAutoCloseable;
 import org.compiere.util.Env;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -12,10 +13,12 @@
 
 import de.metas.security.IUserRolePermissions;
 import de.metas.security.IUserRolePermissionsDAO;
+import de.metas.security.RoleId;
 import de.metas.security.UserAuthToken;
 import de.metas.security.UserAuthTokenRepository;
 import de.metas.security.UserNotAuthorizedException;
 import de.metas.security.UserRolePermissionsKey;
+import de.metas.user.UserId;
 import de.metas.util.Services;
 import de.metas.util.time.SystemTime;
 import lombok.NonNull;
@@ -84,18 +87,18 @@ public &lt;R&gt; R call(final Supplier&lt;String&gt; authTokenStringSupplier, @NonNull final
 	private final Properties createContext(final UserAuthToken token)
 	{
 		final IUserRolePermissionsDAO userRolePermissionsDAO = Services.get(IUserRolePermissionsDAO.class);
+		final IUserRolePermissions permissions = userRolePermissionsDAO.retrieveUserRolePermissions(UserRolePermissionsKey.builder()
+				.userId(token.getUserId())
+				.roleId(token.getRoleId())
+				.clientId(token.getClientId())
 				.date(SystemTime.asDayTimestamp())
 				.build());
 
 		final Properties ctx = Env.newTemporaryCtx();
+		Env.setContext(ctx, Env.CTXNAME_AD_Client_ID, permissions.getClientId().getRepoId());
+		Env.setContext(ctx, Env.CTXNAME_AD_Org_ID, OrgId.toRepoId(token.getOrgId()));
+		Env.setContext(ctx, Env.CTXNAME_AD_User_ID, UserId.toRepoId(permissions.getUserId()));
+		Env.setContext(ctx, Env.CTXNAME_AD_Role_ID, RoleId.toRepoId(permissions.getRoleId()));
 		// TODO: set other properties like language, warehouse etc...
 		return ctx;
 	}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>339369</refactoring_id><commit_sha>0bfc2373f6c11dc3344d8075a86631d1427cb047</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/0bfc2373f6c11dc3344d8075a86631d1427cb047</commit_link><file_path>de.metas.business/src/main/java/de/metas/pricing/rules/PriceListVersion.java</file_path><description>Rename Variable plv : I_M_PriceList_Version to priceListVersion : I_M_PriceList_Version in method public calculate(pricingCtx IPricingContext, result IPricingResult) : void from class de.metas.pricing.rules.PriceListVersion</description><code_before>@@ -34,9 +34,8 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		}
 
 		final ProductId productId = pricingCtx.getProductId();
-
-		final I_M_PriceList_Version plv = getPriceListVersionEffective(pricingCtx);
-		if (plv == null || !plv.isActive())
 		{
 			return;
 		}
@@ -45,15 +44,15 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		// we get rid of the hardcoded SQL. For the time beeing it's still here (commented), so we can see how it used to be.
 		// !!IMPORTANT!! with this change of implementation, we loose the bomPriceList calculation.
 		// Should bomPricing be needed in future, please consider adding a dedicated pricing rule
-		final I_M_ProductPrice productPrice = ProductPrices.retrieveMainProductPriceOrNull(plv, productId);
 		if (productPrice == null)
 		{
 			log.trace("Not found (PLV)");
 			return;
 		}
 
-		final I_M_PriceList priceList = plv.getM_PriceList();
-		
 		final ProductCategoryId productCategoryId = Services.get(IProductDAO.class).retrieveProductCategoryByProductId(productId);
 
 		result.setPriceStd(productPrice.getPriceStd());
@@ -66,7 +65,7 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		result.setEnforcePriceLimit(priceList.isEnforcePriceLimit());
 		result.setTaxIncluded(priceList.isTaxIncluded());
 		result.setC_TaxCategory_ID(productPrice.getC_TaxCategory_ID());
-		result.setPriceListVersionId(PriceListVersionId.ofRepoId(plv.getM_PriceList_Version_ID())); // make sure that the result doesn't lack this important info, even if it was already known from the context!
 		result.setCalculated(true);
 
 		// 06942 : use product price uom all the time
@@ -79,21 +78,40 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		{
 			result.setPrice_UOM_ID(productPrice.getC_UOM_ID());
 		}
 	}
 
-	private I_M_PriceList_Version getPriceListVersionEffective(final IPricingContext pricingCtx)
 	{
-		final I_M_PriceList_Version plv = pricingCtx.getM_PriceList_Version();
-		if(plv != null)
 		{
-			return plv;
 		}
-		
-		return Services.get(IPriceListDAO.class).retrievePriceListVersionOrNull(Env.getCtx(),
 				pricingCtx.getPriceListId(),
 				pricingCtx.getPriceDate(),
 				(Boolean)null // processed
 		);
 
 	}
 }
</code_before><code_after>@@ -34,9 +34,8 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		}
 
 		final ProductId productId = pricingCtx.getProductId();
+		final I_M_PriceList_Version priceListVersion = getPriceListVersionEffective(pricingCtx);
+		if (priceListVersion == null)
 		{
 			return;
 		}
@@ -45,15 +44,15 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		// we get rid of the hardcoded SQL. For the time beeing it's still here (commented), so we can see how it used to be.
 		// !!IMPORTANT!! with this change of implementation, we loose the bomPriceList calculation.
 		// Should bomPricing be needed in future, please consider adding a dedicated pricing rule
+		final I_M_ProductPrice productPrice = ProductPrices.retrieveMainProductPriceOrNull(priceListVersion, productId);
 		if (productPrice == null)
 		{
 			log.trace("Not found (PLV)");
 			return;
 		}
 
+		final I_M_PriceList priceList = Services.get(IPriceListDAO.class).getById(priceListVersion.getM_PriceList_ID());
+
 		final ProductCategoryId productCategoryId = Services.get(IProductDAO.class).retrieveProductCategoryByProductId(productId);
 
 		result.setPriceStd(productPrice.getPriceStd());
@@ -66,7 +65,7 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		result.setEnforcePriceLimit(priceList.isEnforcePriceLimit());
 		result.setTaxIncluded(priceList.isTaxIncluded());
 		result.setC_TaxCategory_ID(productPrice.getC_TaxCategory_ID());
+		result.setPriceListVersionId(PriceListVersionId.ofRepoId(priceListVersion.getM_PriceList_Version_ID())); // make sure that the result doesn't lack this important info, even if it was already known from the context!
 		result.setCalculated(true);
 
 		// 06942 : use product price uom all the time
@@ -79,21 +78,40 @@ public void calculate(final IPricingContext pricingCtx, final IPricingResult res
 		{
 			result.setPrice_UOM_ID(productPrice.getC_UOM_ID());
 		}
+
+		//
+		// Override with calculated BOM price if suitable
+		BOMPriceCalculator.builder()
+				.bomProductId(productId)
+				.asiAware(pricingCtx.getAttributeSetInstanceAware().orElse(null))
+				.priceListVersion(priceListVersion)
+				.calculate()
+				.ifPresent(bomPrices -&gt; updatePricingResultFromBOMPrices(result, bomPrices));
 	}
 
+	private static I_M_PriceList_Version getPriceListVersionEffective(final IPricingContext pricingCtx)
 	{
+		final I_M_PriceList_Version contextPLV = pricingCtx.getM_PriceList_Version();
+		if (contextPLV != null)
 		{
+			return contextPLV.isActive() ? contextPLV : null;
 		}
+
+		final IPriceListDAO priceListsRepo = Services.get(IPriceListDAO.class);
+
+		final I_M_PriceList_Version plv = priceListsRepo.retrievePriceListVersionOrNull(Env.getCtx(),
 				pricingCtx.getPriceListId(),
 				pricingCtx.getPriceDate(),
 				(Boolean)null // processed
 		);
 
+		return plv != null &amp;&amp; plv.isActive() ? plv : null;
+	}
+
+	private static void updatePricingResultFromBOMPrices(final IPricingResult to, final BOMPrices from)
+	{
+		to.setPriceStd(from.getPriceStd());
+		to.setPriceList(from.getPriceList());
+		to.setPriceLimit(from.getPriceLimit());
 	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>362660</refactoring_id><commit_sha>7776aebe0c6aecb10f83e2954a14dbd83aaa5366</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/7776aebe0c6aecb10f83e2954a14dbd83aaa5366</commit_link><file_path>logstreams/src/main/java/org/camunda/tngp/logstreams/impl/LogBlockIndexController.java</file_path><description>Rename Variable foundAddress : boolean to foundPosition : boolean in method private readTillTruncatePosition(truncateAddress long) : long from class org.camunda.tngp.logstreams.impl.LogBlockIndexController.TruncateState</description><code_before>@@ -13,8 +13,9 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.CompletableFuture;
 
-import static org.camunda.tngp.logstreams.impl.LogEntryDescriptor.getFragmentLength;
-import static org.camunda.tngp.logstreams.impl.LogEntryDescriptor.getPosition;
 import static org.camunda.tngp.logstreams.impl.LogStateMachineAgent.*;
 import static org.camunda.tngp.logstreams.spi.LogStorage.OP_RESULT_INSUFFICIENT_BUFFER_CAPACITY;
 import static org.camunda.tngp.logstreams.spi.LogStorage.OP_RESULT_INVALID_ADDR;
@@ -28,6 +29,7 @@ public class LogBlockIndexController implements Agent
     private static final int ILLEGAL_ADDRESS = -1;
     protected static final int TRANSITION_SNAPSHOT = 3;
     protected static final int TRANSITION_TRUNCATE = 4;
 
     // STATES /////////////////////////////////////////////////////////
 
@@ -392,17 +394,14 @@ public int doWork(LogContext logContext) throws Exception
             try
             {
                 long truncateAddress = blockIndex.size() &gt; 0
-                                     ? blockIndex.lookupBlockAddress(truncatePosition)
-                                     : logStorage.getFirstBlockAddress();
 
                 // find event with given position to calculate address
-                ioBuffer.clear();
-                logStorage.read(ioBuffer, truncateAddress);
-
-                truncateAddress = findAddressForTruncateEvent(truncateAddress);
 
                 // truncate
-                transition = truncate(logContext, transition, truncateAddress);
             }
             finally
             {
@@ -414,8 +413,58 @@ public int doWork(LogContext logContext) throws Exception
             return 0;
         }
 
-        private int truncate(LogContext logContext, int transition, long truncateAddress)
         {
             if (truncateAddress != ILLEGAL_ADDRESS)
             {
                 blockIndex.truncate(truncatePosition);
@@ -435,38 +484,13 @@ private int truncate(LogContext logContext, int transition, long truncateAddress
                     // if all blocks are deleted we need to clean up the snapshots as well
                     snapshotStorage.purgeSnapshot(name);
                 }
             }
             else
             {
                 truncateFuture.completeExceptionally(new IllegalArgumentException(String.format(EXCEPTION_MSG_TRUNCATE_FAILED, truncatePosition)));
             }
             return transition;
         }
-
-        private long findAddressForTruncateEvent(long truncateAddress)
-        {
-            buffer.wrap(ioBuffer);
-
-            int offset = 0;
-            boolean foundAddress = false;
-            while (!foundAddress)
-            {
-                if (offset &gt;= buffer.capacity())
-                {
-                    return ILLEGAL_ADDRESS;
-                }
-
-                final long position = getPosition(buffer, offset);
-                if (position == truncatePosition)
-                {
-                    foundAddress = true;
-                }
-                else
-                {
-                    offset += getFragmentLength(buffer, offset);
-                }
-            }
-            return truncateAddress + offset;
-        }
     }
 }
</code_before><code_after>@@ -13,8 +13,9 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.CompletableFuture;
 
+import static org.agrona.BitUtil.SIZE_OF_LONG;
+import static org.camunda.tngp.dispatcher.impl.log.DataFrameDescriptor.messageOffset;
+import static org.camunda.tngp.logstreams.impl.LogEntryDescriptor.*;
 import static org.camunda.tngp.logstreams.impl.LogStateMachineAgent.*;
 import static org.camunda.tngp.logstreams.spi.LogStorage.OP_RESULT_INSUFFICIENT_BUFFER_CAPACITY;
 import static org.camunda.tngp.logstreams.spi.LogStorage.OP_RESULT_INVALID_ADDR;
@@ -28,6 +29,7 @@ public class LogBlockIndexController implements Agent
     private static final int ILLEGAL_ADDRESS = -1;
     protected static final int TRANSITION_SNAPSHOT = 3;
     protected static final int TRANSITION_TRUNCATE = 4;
+    private static final int POSITION_LENGTH = positionOffset(messageOffset(0)) + SIZE_OF_LONG;
 
     // STATES /////////////////////////////////////////////////////////
 
@@ -392,17 +394,14 @@ public int doWork(LogContext logContext) throws Exception
             try
             {
                 long truncateAddress = blockIndex.size() &gt; 0
+                    ? blockIndex.lookupBlockAddress(truncatePosition)
+                    : logStorage.getFirstBlockAddress();
 
                 // find event with given position to calculate address
+                truncateAddress = readTillTruncatePosition(truncateAddress);
 
                 // truncate
+                transition = truncate(logContext, truncateAddress);
             }
             finally
             {
@@ -414,8 +413,58 @@ public int doWork(LogContext logContext) throws Exception
             return 0;
         }
 
+        private long readTillTruncatePosition(long truncateAddress)
         {
+            long currentAddress = truncateAddress;
+            boolean foundPosition = false;
+
+            while (currentAddress &gt; 0 &amp;&amp; !foundPosition)
+            {
+                ioBuffer.clear();
+                currentAddress = logStorage.read(ioBuffer, currentAddress);
+
+                int remainingBytes = ioBuffer.position();
+                int position = 0;
+                buffer.wrap(ioBuffer);
+
+                while (remainingBytes &gt;= POSITION_LENGTH)
+                {
+                    final int messageLength = getFragmentLength(buffer, position);
+                    final long loggedEventPosition = getPosition(buffer, position);
+                    if (loggedEventPosition == truncatePosition)
+                    {
+                        foundPosition = true;
+                        currentAddress -= remainingBytes;
+                        remainingBytes = 0;
+                    }
+                    else if (messageLength &lt;= remainingBytes)
+                    {
+                        remainingBytes -= messageLength;
+                        position += messageLength;
+                    }
+                    else
+                    {
+                        currentAddress -= remainingBytes;
+                        remainingBytes = 0;
+                    }
+                }
+
+                if (remainingBytes &lt; POSITION_LENGTH)
+                {
+                    currentAddress -= remainingBytes;
+                }
+            }
+
+            if (!foundPosition)
+            {
+                currentAddress = ILLEGAL_ADDRESS;
+            }
+            return currentAddress;
+        }
+
+        private int truncate(LogContext logContext, long truncateAddress)
+        {
+            int transition = TRANSITION_DEFAULT;
             if (truncateAddress != ILLEGAL_ADDRESS)
             {
                 blockIndex.truncate(truncatePosition);
@@ -435,38 +484,13 @@ private int truncate(LogContext logContext, int transition, long truncateAddress
                     // if all blocks are deleted we need to clean up the snapshots as well
                     snapshotStorage.purgeSnapshot(name);
                 }
+                nextAddress = truncateAddress;
             }
             else
             {
                 truncateFuture.completeExceptionally(new IllegalArgumentException(String.format(EXCEPTION_MSG_TRUNCATE_FAILED, truncatePosition)));
             }
             return transition;
         }
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>436617</refactoring_id><commit_sha>c325fcab720418f68cccdf1046afff24d86c3542</commit_sha><commit_link>https://github.com/apache/cassandra/commit/c325fcab720418f68cccdf1046afff24d86c3542</commit_link><file_path>interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java</file_path><description>Rename Variable _map12 : TMap to _map16 : TMap in method public read(iprot TProtocol) : void from class org.apache.cassandra.thrift.AuthenticationRequest</description><code_before>@@ -266,15 +266,15 @@ public void read(TProtocol iprot) throws TException {
           case CREDENTIALS:
             if (field.type == TType.MAP) {
               {
-                TMap _map12 = iprot.readMapBegin();
-                this.credentials = new HashMap&lt;String,String&gt;(2*_map12.size);
-                for (int _i13 = 0; _i13 &lt; _map12.size; ++_i13)
                 {
-                  String _key14;
-                  String _val15;
-                  _key14 = iprot.readString();
-                  _val15 = iprot.readString();
-                  this.credentials.put(_key14, _val15);
                 }
                 iprot.readMapEnd();
               }
@@ -300,10 +300,10 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldBegin(CREDENTIALS_FIELD_DESC);
       {
         oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.credentials.size()));
-        for (Map.Entry&lt;String, String&gt; _iter16 : this.credentials.entrySet())
         {
-          oprot.writeString(_iter16.getKey());
-          oprot.writeString(_iter16.getValue());
         }
         oprot.writeMapEnd();
       }
</code_before><code_after>@@ -266,15 +266,15 @@ public void read(TProtocol iprot) throws TException {
           case CREDENTIALS:
             if (field.type == TType.MAP) {
               {
+                TMap _map16 = iprot.readMapBegin();
+                this.credentials = new HashMap&lt;String,String&gt;(2*_map16.size);
+                for (int _i17 = 0; _i17 &lt; _map16.size; ++_i17)
                 {
+                  String _key18;
+                  String _val19;
+                  _key18 = iprot.readString();
+                  _val19 = iprot.readString();
+                  this.credentials.put(_key18, _val19);
                 }
                 iprot.readMapEnd();
               }
@@ -300,10 +300,10 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldBegin(CREDENTIALS_FIELD_DESC);
       {
         oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.credentials.size()));
+        for (Map.Entry&lt;String, String&gt; _iter20 : this.credentials.entrySet())
         {
+          oprot.writeString(_iter20.getKey());
+          oprot.writeString(_iter20.getValue());
         }
         oprot.writeMapEnd();
       }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>461522</refactoring_id><commit_sha>83819376f48d95d7bd05378a41ae4c1c94fea99a</commit_sha><commit_link>https://github.com/oracle/graal/commit/83819376f48d95d7bd05378a41ae4c1c94fea99a</commit_link><file_path>compiler/src/org.graalvm.compiler.hotspot.lir.test/src/org/graalvm/compiler/hotspot/lir/test/MitigateExceedingMaxOopMapStackOffsetTest.java</file_path><description>Rename Variable src : AllocatableValue to srcPrimitive : AllocatableValue in method public generate(gen LIRGeneratorTool) : void from class org.graalvm.compiler.hotspot.lir.test.MitigateExceedingMaxOopMapStackOffsetTest.WriteStackValues</description><code_before>@@ -76,23 +76,22 @@ public void generate(LIRGeneratorTool gen) {
             // Place reference slots at top and bottom of virtual frame
             // with primitive slots in the middle. This tests that slot
             // partitioning works.
             for (int i = 0; i &lt; numReferenceSlots / 2; i++) {
-                AllocatableValue src = gen.emitLoadConstant(objectLirKind, objectConstant);
                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(objectLirKind);
                 slotList.add(slot);
-                gen.emitMove(slot, src);
             }
             for (int i = 0; i &lt; numPrimitiveSlots; i++) {
-                AllocatableValue src = gen.emitLoadConstant(objectLirKind, primitiveConstant);
                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(primitiveLirKind);
                 slotList.add(slot);
-                gen.emitMove(slot, src);
             }
             for (int i = numReferenceSlots / 2; i &lt; numReferenceSlots; i++) {
-                AllocatableValue src = gen.emitLoadConstant(objectLirKind, objectConstant);
                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(objectLirKind);
                 slotList.add(slot);
-                gen.emitMove(slot, src);
             }
             slots = slotList.toArray(new AllocatableValue[slotList.size()]);
         }
</code_before><code_after>@@ -76,23 +76,22 @@ public void generate(LIRGeneratorTool gen) {
             // Place reference slots at top and bottom of virtual frame
             // with primitive slots in the middle. This tests that slot
             // partitioning works.
+            AllocatableValue srcObject = gen.emitLoadConstant(objectLirKind, objectConstant);
             for (int i = 0; i &lt; numReferenceSlots / 2; i++) {
                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(objectLirKind);
                 slotList.add(slot);
+                gen.emitMove(slot, srcObject);
             }
+            AllocatableValue srcPrimitive = gen.emitLoadConstant(objectLirKind, primitiveConstant);
             for (int i = 0; i &lt; numPrimitiveSlots; i++) {
                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(primitiveLirKind);
                 slotList.add(slot);
+                gen.emitMove(slot, srcPrimitive);
             }
             for (int i = numReferenceSlots / 2; i &lt; numReferenceSlots; i++) {
                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(objectLirKind);
                 slotList.add(slot);
+                gen.emitMove(slot, srcObject);
             }
             slots = slotList.toArray(new AllocatableValue[slotList.size()]);
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>386215</refactoring_id><commit_sha>f1586fa88212ea8dbcd3a4fadb69db720f21e2f6</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/f1586fa88212ea8dbcd3a4fadb69db720f21e2f6</commit_link><file_path>tests/src/test/java/alluxio/master/lineage/LineageMasterIntegrationTest.java</file_path><description>Rename Variable files : ArrayList&lt;AlluxioURI&gt; to inputFiles : ArrayList&lt;AlluxioURI&gt; in method public docExampleTest() : void from class alluxio.master.lineage.LineageMasterIntegrationTest</description><code_before>@@ -214,23 +214,23 @@ public void docExampleTest() throws Exception {
     // input file paths
     AlluxioURI input1 = new AlluxioURI("/inputFile1");
     AlluxioURI input2 = new AlluxioURI("/inputFile2");
-    ArrayList&lt;AlluxioURI&gt; files = new ArrayList&lt;&gt;();
-    Collections.addAll(files, input1, input2);
     // output file paths
     AlluxioURI output = new AlluxioURI("/outputFile");
-    ArrayList&lt;AlluxioURI&gt; files2 = new ArrayList&lt;&gt;();
-    Collections.addAll(files2, output);
     // command-line job
     JobConf conf = new JobConf("/tmp/recompute.log");
     CommandLineJob job = new CommandLineJob("my-spark-job.sh", conf);
-    long lineageId = tl.createLineage(files, files2, job);
 
     // ------ code block from docs ------
     DeleteLineageOptions options = DeleteLineageOptions.defaults().setCascade(true);
     tl.deleteLineage(lineageId);
 
     fs.delete(new AlluxioURI("/outputFile"));
-    lineageId = tl.createLineage(files, files2, job);
 
     // ------ code block from docs ------
     tl.deleteLineage(lineageId, options);
</code_before><code_after>@@ -214,23 +214,23 @@ public void docExampleTest() throws Exception {
     // input file paths
     AlluxioURI input1 = new AlluxioURI("/inputFile1");
     AlluxioURI input2 = new AlluxioURI("/inputFile2");
+    ArrayList&lt;AlluxioURI&gt; inputFiles = new ArrayList&lt;&gt;();
+    Collections.addAll(inputFiles, input1, input2);
     // output file paths
     AlluxioURI output = new AlluxioURI("/outputFile");
+    ArrayList&lt;AlluxioURI&gt; outputFiles = new ArrayList&lt;&gt;();
+    Collections.addAll(outputFiles, output);
     // command-line job
     JobConf conf = new JobConf("/tmp/recompute.log");
     CommandLineJob job = new CommandLineJob("my-spark-job.sh", conf);
+    long lineageId = tl.createLineage(inputFiles, outputFiles, job);
 
     // ------ code block from docs ------
     DeleteLineageOptions options = DeleteLineageOptions.defaults().setCascade(true);
     tl.deleteLineage(lineageId);
 
     fs.delete(new AlluxioURI("/outputFile"));
+    lineageId = tl.createLineage(inputFiles, outputFiles, job);
 
     // ------ code block from docs ------
     tl.deleteLineage(lineageId, options);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>356050</refactoring_id><commit_sha>de315c066a6dd0b78431230a5035fa519ebac601</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/de315c066a6dd0b78431230a5035fa519ebac601</commit_link><file_path>config-model/src/main/java/com/yahoo/schema/expressiontransforms/TokenTransformer.java</file_path><description>Rename Variable functionName : String to f : var in method private createTokenLengthFunctions(feature ReferenceNode, context RankProfileTransformContext) : void from class com.yahoo.schema.expressiontransforms.TokenTransformer</description><code_before>@@ -1,6 +1,8 @@
 // Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
 package com.yahoo.schema.expressiontransforms;
 
 import com.yahoo.searchlib.rankingexpression.Reference;
 import com.yahoo.searchlib.rankingexpression.evaluation.DoubleValue;
 import com.yahoo.searchlib.rankingexpression.rule.OperationNode;
@@ -11,14 +13,17 @@
 import com.yahoo.searchlib.rankingexpression.rule.ExpressionNode;
 import com.yahoo.searchlib.rankingexpression.rule.IfNode;
 import com.yahoo.searchlib.rankingexpression.rule.ReferenceNode;
 import com.yahoo.searchlib.rankingexpression.rule.TensorFunctionNode;
 import com.yahoo.searchlib.rankingexpression.transform.ExpressionTransformer;
 import com.yahoo.tensor.TensorType;
 import com.yahoo.tensor.functions.Generate;
 import com.yahoo.tensor.functions.Slice;
 import com.yahoo.tensor.functions.TensorFunction;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import static com.yahoo.searchlib.rankingexpression.rule.TensorFunctionNode.wrapScalar;
@@ -207,8 +212,21 @@ public static TensorType createTensorType(String featureName, ExpressionNode arg
         }
     }
 
-    private String lengthFunctionName(ReferenceNode arg) {
-        return "__token_length@" + Integer.toHexString(arg.hashCode());
     }
 
     private List&lt;ExpressionNode&gt; createTokenSequence(ReferenceNode feature) {
@@ -229,14 +247,13 @@ private List&lt;ExpressionNode&gt; createTokenSequence(ReferenceNode feature) {
     private void createTokenLengthFunctions(ReferenceNode feature, RankProfileTransformContext context) {
         for (int i = 1; i &lt; feature.getArguments().size(); ++i) {
             ExpressionNode arg = feature.getArguments().expressions().get(i);
-            if ( ! (arg instanceof ReferenceNode)) {
                 throw new IllegalArgumentException("Invalid argument " + i + " to " + feature.getName() + ": " +
                         "the argument must be a reference. Got " + arg.toString());
             }
-            ReferenceNode ref = (ReferenceNode) arg;
-            String functionName = lengthFunctionName(ref);
-            if ( ! context.rankProfile().getFunctions().containsKey(functionName)) {
-                context.rankProfile().addFunction(functionName, List.of(), "sum(map(" + ref + ", f(x)(x &gt; 0)))", false);
             }
         }
     }
@@ -282,8 +299,9 @@ private ExpressionNode createLengthExpr(int iter, List&lt;ExpressionNode&gt; sequence)
         for (int i = 0; i &lt; iter + 1; ++i) {
             if (sequence.get(i) instanceof ConstantNode) {
                 factors.add(ONE);
-            } else if (sequence.get(i) instanceof ReferenceNode) {
-                factors.add(new ReferenceNode(lengthFunctionName((ReferenceNode) sequence.get(i))));
             }
             if (i &gt;= 1) {
                 operators.add(Operator.plus);
</code_before><code_after>@@ -1,6 +1,8 @@
 // Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
 package com.yahoo.schema.expressiontransforms;
 
+import com.yahoo.searchlib.rankingexpression.ExpressionFunction;
+import com.yahoo.searchlib.rankingexpression.RankingExpression;
 import com.yahoo.searchlib.rankingexpression.Reference;
 import com.yahoo.searchlib.rankingexpression.evaluation.DoubleValue;
 import com.yahoo.searchlib.rankingexpression.rule.OperationNode;
@@ -11,14 +13,17 @@
 import com.yahoo.searchlib.rankingexpression.rule.ExpressionNode;
 import com.yahoo.searchlib.rankingexpression.rule.IfNode;
 import com.yahoo.searchlib.rankingexpression.rule.ReferenceNode;
+import com.yahoo.searchlib.rankingexpression.rule.SerializationContext;
 import com.yahoo.searchlib.rankingexpression.rule.TensorFunctionNode;
 import com.yahoo.searchlib.rankingexpression.transform.ExpressionTransformer;
 import com.yahoo.tensor.TensorType;
 import com.yahoo.tensor.functions.Generate;
 import com.yahoo.tensor.functions.Slice;
 import com.yahoo.tensor.functions.TensorFunction;
 
+import java.io.StringReader;
 import java.util.ArrayList;
+import java.util.ArrayDeque;
 import java.util.List;
 
 import static com.yahoo.searchlib.rankingexpression.rule.TensorFunctionNode.wrapScalar;
@@ -207,8 +212,21 @@ public static TensorType createTensorType(String featureName, ExpressionNode arg
         }
     }
 
+    private static final ExpressionFunction commonLengthFunction = makeLengthFunction();
+    private static ExpressionFunction makeLengthFunction() {
+        String func = "sum(map(input, f(x)(x &gt; 0)))";
+        String name = "__token_length";
+        try (var r = new StringReader(func)) {
+            return new ExpressionFunction(name, List.of("input"), new RankingExpression(name, r));
+        }
+        catch (com.yahoo.searchlib.rankingexpression.parser.ParseException e) {
+            throw new IllegalStateException("unexpected", e);
+        }
+    }
+
+    private ExpressionFunction.Instance lengthFunctionFor(ReferenceNode arg) {
+        var ctx = new SerializationContext();
+        return commonLengthFunction.expand(ctx, List.of(arg), new ArrayDeque&lt;String&gt;());
     }
 
     private List&lt;ExpressionNode&gt; createTokenSequence(ReferenceNode feature) {
@@ -229,14 +247,13 @@ private List&lt;ExpressionNode&gt; createTokenSequence(ReferenceNode feature) {
     private void createTokenLengthFunctions(ReferenceNode feature, RankProfileTransformContext context) {
         for (int i = 1; i &lt; feature.getArguments().size(); ++i) {
             ExpressionNode arg = feature.getArguments().expressions().get(i);
+            if ( ! (arg instanceof ReferenceNode ref)) {
                 throw new IllegalArgumentException("Invalid argument " + i + " to " + feature.getName() + ": " +
                         "the argument must be a reference. Got " + arg.toString());
             }
+            var f = lengthFunctionFor(ref);
+            if ( ! context.rankProfile().getFunctions().containsKey(f.getName())) {
+                context.rankProfile().addFunction(f.getName(), List.of(), f.getExpressionString(), false);
             }
         }
     }
@@ -282,8 +299,9 @@ private ExpressionNode createLengthExpr(int iter, List&lt;ExpressionNode&gt; sequence)
         for (int i = 0; i &lt; iter + 1; ++i) {
             if (sequence.get(i) instanceof ConstantNode) {
                 factors.add(ONE);
+            } else if (sequence.get(i) instanceof ReferenceNode ref) {
+                var f = lengthFunctionFor(ref);
+                factors.add(new ReferenceNode(f.getName()));
             }
             if (i &gt;= 1) {
                 operators.add(Operator.plus);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>375251</refactoring_id><commit_sha>35ca729c16f1ebf9908a0b7017f74fad1842e065</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/35ca729c16f1ebf9908a0b7017f74fad1842e065</commit_link><file_path>OsmAnd/src/net/osmand/aidl/ConnectedApp.java</file_path><description>Rename Variable control : TextInfoWidget to widget : TextInfoWidget in method package registerWidgetControls(mapActivity MapActivity) : void from class net.osmand.aidl.ConnectedApp</description><code_before>@@ -8,9 +8,6 @@
 import android.view.View;
 import android.widget.CompoundButton;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.activities.MapActivity;
@@ -23,7 +20,6 @@
 import net.osmand.plus.views.layers.base.OsmandMapLayer.DrawSettings;
 import net.osmand.plus.views.mapwidgets.WidgetsPanel;
 import net.osmand.plus.views.mapwidgets.widgets.RightTextInfoWidget;
-import net.osmand.plus.views.layers.base.OsmandMapLayer;
 import net.osmand.plus.views.mapwidgets.widgets.TextInfoWidget;
 import net.osmand.plus.widgets.ctxmenu.ContextMenuAdapter;
 import net.osmand.plus.widgets.ctxmenu.callback.ItemClickListener;
@@ -37,11 +33,10 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
-import static net.osmand.aidlapi.OsmAndCustomizationConstants.CONFIGURE_MAP_ITEM_ID_SCHEME;
-
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import static net.osmand.aidlapi.OsmAndCustomizationConstants.CONFIGURE_MAP_ITEM_ID_SCHEME;
 
 public class ConnectedApp implements Comparable&lt;ConnectedApp&gt; {
@@ -181,15 +176,16 @@ public boolean onContextMenuClick(@Nullable OnDataChangeUiAdapter uiAdapter,
 	}
 
 	void registerWidgetControls(@NonNull MapActivity mapActivity) {
-		for (AidlMapWidgetWrapper widget : widgets.values()) {
 			MapInfoLayer layer = mapActivity.getMapLayers().getMapInfoLayer();
 			if (layer != null) {
-				TextInfoWidget control = createWidgetControl(mapActivity, widget.getId());
-				widgetControls.put(widget.getId(), control);
-				int iconId = AndroidUtils.getDrawableId(mapActivity.getMyApplication(), widget.getMenuIconName());
 				int menuIconId = iconId != 0 ? iconId : ContextMenuItem.INVALID_ID;
-				String widgetKey = "aidl_widget_" + widget.getId();
-				layer.registerWidget(widgetKey, control, menuIconId, widget.getMenuTitle(), WidgetsPanel.RIGHT, widget.getOrder());
 			}
 		}
 	}
</code_before><code_after>@@ -8,9 +8,6 @@
 import android.view.View;
 import android.widget.CompoundButton;
 
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.activities.MapActivity;
@@ -23,7 +20,6 @@
 import net.osmand.plus.views.layers.base.OsmandMapLayer.DrawSettings;
 import net.osmand.plus.views.mapwidgets.WidgetsPanel;
 import net.osmand.plus.views.mapwidgets.widgets.RightTextInfoWidget;
 import net.osmand.plus.views.mapwidgets.widgets.TextInfoWidget;
 import net.osmand.plus.widgets.ctxmenu.ContextMenuAdapter;
 import net.osmand.plus.widgets.ctxmenu.callback.ItemClickListener;
@@ -37,11 +33,10 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
+import static net.osmand.aidl.OsmandAidlApi.WIDGET_ID_PREFIX;
 import static net.osmand.aidlapi.OsmAndCustomizationConstants.CONFIGURE_MAP_ITEM_ID_SCHEME;
 
 public class ConnectedApp implements Comparable&lt;ConnectedApp&gt; {
@@ -181,15 +176,16 @@ public boolean onContextMenuClick(@Nullable OnDataChangeUiAdapter uiAdapter,
 	}
 
 	void registerWidgetControls(@NonNull MapActivity mapActivity) {
+		for (AidlMapWidgetWrapper widgetData : widgets.values()) {
 			MapInfoLayer layer = mapActivity.getMapLayers().getMapInfoLayer();
 			if (layer != null) {
+				TextInfoWidget widget = createWidgetControl(mapActivity, widgetData.getId());
+				widgetControls.put(widgetData.getId(), widget);
+				int iconId = AndroidUtils.getDrawableId(mapActivity.getMyApplication(), widgetData.getMenuIconName());
 				int menuIconId = iconId != 0 ? iconId : ContextMenuItem.INVALID_ID;
+				String widgetKey = WIDGET_ID_PREFIX + widgetData.getId();
+				layer.registerExternalWidget(widgetKey, widget, menuIconId, widgetData.getMenuTitle(), pack,
+						WidgetsPanel.RIGHT, widgetData.getOrder());
 			}
 		}
 	}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>393126</refactoring_id><commit_sha>8d280e4a9940b54553a8e894d6fb12e0abb81750</commit_sha><commit_link>https://github.com/spring-projects/spring-integration/commit/8d280e4a9940b54553a8e894d6fb12e0abb81750</commit_link><file_path>spring-integration-twitter/src/test/java/org/springframework/integration/twitter/core/Twitter4jTemplateTests.java</file_path><description>Rename Variable statusUpdate : StatusUpdate to status : StatusUpdate in method public testUpdateStatus() : void from class org.springframework.integration.twitter.core.Twitter4jTemplateTests</description><code_before>@@ -110,8 +110,8 @@ public void testSendDirectMessage() throws Exception{
 	
 	@Test
 	public void testUpdateStatus() throws Exception{
-		StatusUpdate statusUpdate = new StatusUpdate("writing twitter test");
-		template.updateStatus(statusUpdate);
-		verify(twitter, times(1)).updateStatus(statusUpdate);
 	}
 }
</code_before><code_after>@@ -110,8 +110,8 @@ public void testSendDirectMessage() throws Exception{
 	
 	@Test
 	public void testUpdateStatus() throws Exception{
+		StatusUpdate status = new StatusUpdate("writing twitter test");
+		template.updateStatus(status);
+		verify(twitter, times(1)).updateStatus(Mockito.any(StatusUpdate.class));
 	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>388151</refactoring_id><commit_sha>4d38db7bd5dfb0110d4149f8f55f17047e897973</commit_sha><commit_link>https://github.com/jenkinsci/jenkins/commit/4d38db7bd5dfb0110d4149f8f55f17047e897973</commit_link><file_path>remoting/src/main/java/hudson/remoting/RemoteClassLoader.java</file_path><description>Rename Variable url : URL to res : File in method protected findResource(name String) : URL from class hudson.remoting.RemoteClassLoader</description><code_before>@@ -7,6 +7,7 @@
 import java.io.InputStream;
 import java.io.Serializable;
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
@@ -26,8 +27,8 @@ final class RemoteClassLoader extends ClassLoader {
      */
     private final Channel channel;
 
-    private final Map&lt;String,URL&gt; resourceMap = new HashMap&lt;String,URL&gt;();
-    private final Map&lt;String,Vector&lt;URL&gt;&gt; resourcesMap = new HashMap&lt;String,Vector&lt;URL&gt;&gt;();
 
     public static ClassLoader create(ClassLoader parent, IClassLoader proxy) {
         if(proxy instanceof ClassLoaderProxy) {
@@ -54,10 +55,16 @@ protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
     }
 
     protected URL findResource(String name) {
-        if(resourceMap.containsKey(name))
-            return resourceMap.get(name);
-
         try {
             long startTime = System.nanoTime();
             byte[] image = proxy.getResource(name);
             channel.resourceLoadingTime.addAndGet(System.nanoTime()-startTime);
@@ -67,41 +74,53 @@ protected URL findResource(String name) {
                 return null;
             }
     
-            URL url = makeResource(name, image);
-            resourceMap.put(name,url);
-            return url;
         } catch (IOException e) {
             throw new Error("Unable to load resource "+name,e);
         }
     }
 
     protected Enumeration&lt;URL&gt; findResources(String name) throws IOException {
-        Vector&lt;URL&gt; urls = resourcesMap.get(name);
-        if(urls!=null)
-            return urls.elements();
 
         long startTime = System.nanoTime();
         byte[][] images = proxy.getResources(name);
         channel.resourceLoadingTime.addAndGet(System.nanoTime()-startTime);
         channel.resourceLoadingCount.incrementAndGet();
 
-        urls = new Vector&lt;URL&gt;();
         for( byte[] image: images )
-            urls.add(makeResource(name,image));
-        resourcesMap.put(name,urls);
 
-        return urls.elements();
     }
 
-    private URL makeResource(String name, byte[] image) throws IOException {
         int idx = name.lastIndexOf('/');
         File f = File.createTempFile("hudson-remoting","."+name.substring(idx+1));
         FileOutputStream fos = new FileOutputStream(f);
         fos.write(image);
         fos.close();
         f.deleteOnExit();
 
-        return f.toURL();
     }
 
     /**
</code_before><code_after>@@ -7,6 +7,7 @@
 import java.io.InputStream;
 import java.io.Serializable;
 import java.net.URL;
+import java.net.MalformedURLException;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
@@ -26,8 +27,8 @@ final class RemoteClassLoader extends ClassLoader {
      */
     private final Channel channel;
 
+    private final Map&lt;String,File&gt; resourceMap = new HashMap&lt;String,File&gt;();
+    private final Map&lt;String,Vector&lt;File&gt;&gt; resourcesMap = new HashMap&lt;String,Vector&lt;File&gt;&gt;();
 
     public static ClassLoader create(ClassLoader parent, IClassLoader proxy) {
         if(proxy instanceof ClassLoaderProxy) {
@@ -54,10 +55,16 @@ protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
     }
 
     protected URL findResource(String name) {
         try {
+            if(resourceMap.containsKey(name)) {
+                File f = resourceMap.get(name);
+                if(f==null) return null;    // no such resource
+                if(f.exists())
+                    // be defensive against external factors that might have deleted this file, since we use /tmp
+                    // see http://www.nabble.com/Surefire-reports-tt17554215.html
+                    return f.toURL();
+            }
+
             long startTime = System.nanoTime();
             byte[] image = proxy.getResource(name);
             channel.resourceLoadingTime.addAndGet(System.nanoTime()-startTime);
@@ -67,41 +74,53 @@ protected URL findResource(String name) {
                 return null;
             }
     
+            File res = makeResource(name, image);
+            resourceMap.put(name,res);
+            return res.toURL();
         } catch (IOException e) {
             throw new Error("Unable to load resource "+name,e);
         }
     }
 
+    private static Vector&lt;URL&gt; toURLs(Vector&lt;File&gt; files) throws MalformedURLException {
+        Vector&lt;URL&gt; r = new Vector&lt;URL&gt;(files.size());
+        for (File f : files) {
+            if(!f.exists()) return null;    // abort
+            r.add(f.toURL());
+        }
+        return r;
+    }
+
     protected Enumeration&lt;URL&gt; findResources(String name) throws IOException {
+        Vector&lt;File&gt; files = resourcesMap.get(name);
+        if(files!=null) {
+            Vector&lt;URL&gt; urls = toURLs(files);
+            if(urls!=null)
+                return urls.elements();
+        }
 
         long startTime = System.nanoTime();
         byte[][] images = proxy.getResources(name);
         channel.resourceLoadingTime.addAndGet(System.nanoTime()-startTime);
         channel.resourceLoadingCount.incrementAndGet();
 
+        files = new Vector&lt;File&gt;();
         for( byte[] image: images )
+            files.add(makeResource(name,image));
+        resourcesMap.put(name,files);
 
+        return toURLs(files).elements();
     }
 
+    private File makeResource(String name, byte[] image) throws IOException {
         int idx = name.lastIndexOf('/');
         File f = File.createTempFile("hudson-remoting","."+name.substring(idx+1));
         FileOutputStream fos = new FileOutputStream(f);
         fos.write(image);
         fos.close();
         f.deleteOnExit();
 
+        return f;
     }
 
     /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>368644</refactoring_id><commit_sha>57a1de5c1291d35ac7de4ea055f4f0cd162540d3</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/57a1de5c1291d35ac7de4ea055f4f0cd162540d3</commit_link><file_path>src/main/java/com/google/devtools/build/lib/rules/cpp/CcSkyframeSupportValue.java</file_path><description>Rename Variable that : Key to key : Key in method public equals(o Object) : boolean from class com.google.devtools.build.lib.rules.cpp.CcSkyframeSupportValue.Key</description><code_before>@@ -19,6 +19,7 @@
 import com.google.devtools.build.lib.skyframe.serialization.autocodec.AutoCodec;
 import com.google.devtools.build.lib.vfs.Path;
 import com.google.devtools.build.lib.vfs.PathFragment;
 import com.google.devtools.build.skyframe.SkyFunction;
 import com.google.devtools.build.skyframe.SkyFunctionName;
 import com.google.devtools.build.skyframe.SkyKey;
@@ -28,9 +29,9 @@
 /**
  * A container for the path to the FDO profile.
  *
- * &lt;p&gt;{@link CcSkyframeSupportValue} is created from {@link CcSupportFunction} (a {@link
  * SkyFunction}), which is requested from Skyframe by the {@code cc_toolchain}/{@code
- * cc_toolchain_suite} rule. It's done this way because the path depends on both a command line
  * argument and the location of the workspace and the latter is not available either during
  * configuration creation or during the analysis phase.
  */
@@ -45,39 +46,45 @@ public class CcSkyframeSupportValue implements SkyValue {
   public static class Key implements SkyKey {
     private static final Interner&lt;Key&gt; interner = BlazeInterners.newWeakInterner();
 
-    private final PathFragment filePath;
 
-    private Key(PathFragment filePath) {
-      this.filePath = filePath;
     }
 
     @AutoCodec.Instantiator
     @AutoCodec.VisibleForSerialization
-    static Key of(PathFragment filePath) {
-      return interner.intern(new Key(filePath));
     }
 
-    public PathFragment getFilePath() {
-      return filePath;
     }
 
     @Override
     public boolean equals(Object o) {
       if (this == o) {
         return true;
       }
-
       if (!(o instanceof Key)) {
         return false;
       }
-
-      Key that = (Key) o;
-      return Objects.equals(this.filePath, that.filePath);
     }
 
     @Override
     public int hashCode() {
-      return Objects.hash(filePath);
     }
 
     @Override
@@ -88,19 +95,26 @@ public SkyFunctionName functionName() {
 
   /** Path of the profile file passed to {@code --fdo_optimize} */
   // TODO(lberki): This should be a PathFragment.
-  // Except that CcProtoProfileProvider#getProfile() calls #exists() on it, which is ridiculously
-  // incorrect.
-  private final Path filePath;
 
-  CcSkyframeSupportValue(Path filePath) {
-    this.filePath = filePath;
   }
 
-  public Path getFilePath() {
-    return filePath;
   }
 
-  public static SkyKey key(PathFragment fdoProfileArgument) {
-    return Key.of(fdoProfileArgument);
   }
 }
</code_before><code_after>@@ -19,6 +19,7 @@
 import com.google.devtools.build.lib.skyframe.serialization.autocodec.AutoCodec;
 import com.google.devtools.build.lib.vfs.Path;
 import com.google.devtools.build.lib.vfs.PathFragment;
+import com.google.devtools.build.lib.view.config.crosstool.CrosstoolConfig.CrosstoolRelease;
 import com.google.devtools.build.skyframe.SkyFunction;
 import com.google.devtools.build.skyframe.SkyFunctionName;
 import com.google.devtools.build.skyframe.SkyKey;
@@ -28,9 +29,9 @@
 /**
  * A container for the path to the FDO profile.
  *
+ * &lt;p&gt;{@link CcSkyframeSupportValue} is created from {@link CcSkyframeSupportFunction} (a {@link
  * SkyFunction}), which is requested from Skyframe by the {@code cc_toolchain}/{@code
+ * cc_toolchain_suite} rules. It's done this way because the path depends on both a command line
  * argument and the location of the workspace and the latter is not available either during
  * configuration creation or during the analysis phase.
  */
@@ -45,39 +46,45 @@ public class CcSkyframeSupportValue implements SkyValue {
   public static class Key implements SkyKey {
     private static final Interner&lt;Key&gt; interner = BlazeInterners.newWeakInterner();
 
+    private final PathFragment fdoZipPath;
+    private final PathFragment crosstoolPath;
 
+    private Key(PathFragment fdoZipPath, PathFragment crosstoolPath) {
+      this.fdoZipPath = fdoZipPath;
+      this.crosstoolPath = crosstoolPath;
     }
 
     @AutoCodec.Instantiator
     @AutoCodec.VisibleForSerialization
+    static Key of(PathFragment fdoZipPath, PathFragment crosstoolPath) {
+      return interner.intern(new Key(fdoZipPath, crosstoolPath));
     }
 
+    public PathFragment getCrosstoolPath() {
+      return crosstoolPath;
+    }
+
+    public PathFragment getFdoZipPath() {
+      return fdoZipPath;
     }
 
     @Override
     public boolean equals(Object o) {
       if (this == o) {
         return true;
       }
       if (!(o instanceof Key)) {
         return false;
       }
+      Key key = (Key) o;
+      return Objects.equals(fdoZipPath, key.fdoZipPath)
+          &amp;&amp; Objects.equals(crosstoolPath, key.crosstoolPath);
     }
 
     @Override
     public int hashCode() {
+
+      return Objects.hash(fdoZipPath, crosstoolPath);
     }
 
     @Override
@@ -88,19 +95,26 @@ public SkyFunctionName functionName() {
 
   /** Path of the profile file passed to {@code --fdo_optimize} */
   // TODO(lberki): This should be a PathFragment.
+  // Except that CcProtoProfileProvider#getProfile() calls #exists() on it,
+  // This is all ridiculously incorrect and should be removed asap.
+  private final Path fdoZipPath;
+
+  private final CrosstoolRelease crosstoolRelease;
+
+  CcSkyframeSupportValue(Path fdoZipPath, CrosstoolRelease crosstoolRelease) {
+    this.fdoZipPath = fdoZipPath;
+    this.crosstoolRelease = crosstoolRelease;
+  }
 
+  public Path getFdoZipPath() {
+    return fdoZipPath;
   }
 
+  public CrosstoolRelease getCrosstoolRelease() {
+    return crosstoolRelease;
   }
 
+  public static SkyKey key(PathFragment fdoZipPath, PathFragment crosstoolPath) {
+    return Key.of(fdoZipPath, crosstoolPath);
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>391213</refactoring_id><commit_sha>579e18c98137552ac54fe169c750b7a5326bd8f9</commit_sha><commit_link>https://github.com/teammates/teammates/commit/579e18c98137552ac54fe169c750b7a5326bd8f9</commit_link><file_path>src/main/java/teammates/ui/controller/InstructorFeedbackQuestionAddAction.java</file_path><description>Rename Variable nChoices : int to numOfMcqChoices : int in method private extractFeedbackQuestionData() : FeedbackQuestionAttributes from class teammates.ui.controller.InstructorFeedbackQuestionAddAction</description><code_before>@@ -117,20 +117,20 @@ private FeedbackQuestionAttributes extractFeedbackQuestionData() {
 			Assumption.assertNotNull("Null number of choice for MCQ", numberOfChoicesCreatedString);
 			int numberOfChoicesCreated = Integer.parseInt(numberOfChoicesCreatedString);
 			
-			int nChoices = 0;
 			List&lt;String&gt; mcqChoices = new LinkedList&lt;String&gt;();
 			for(int i = 0; i &lt; numberOfChoicesCreated; i++) {
 				String mcqChoice = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_MCQCHOICE + "-" + i);
 				if(mcqChoice != null &amp;&amp; !mcqChoice.trim().isEmpty()) {
 					mcqChoices.add(mcqChoice);
-					nChoices++;
 				}
 			}
 			
 			boolean otherEnabled = false; // TODO change this when implementing "other, please specify" field
 			
 			FeedbackMcqQuestionDetails mcqDetails = 
-					new FeedbackMcqQuestionDetails(questionText, nChoices, mcqChoices, otherEnabled);
 			newQuestion.setQuestionDetails(mcqDetails);
 			break;
 		default:
</code_before><code_after>@@ -117,20 +117,20 @@ private FeedbackQuestionAttributes extractFeedbackQuestionData() {
 			Assumption.assertNotNull("Null number of choice for MCQ", numberOfChoicesCreatedString);
 			int numberOfChoicesCreated = Integer.parseInt(numberOfChoicesCreatedString);
 			
+			int numOfMcqChoices = 0;
 			List&lt;String&gt; mcqChoices = new LinkedList&lt;String&gt;();
 			for(int i = 0; i &lt; numberOfChoicesCreated; i++) {
 				String mcqChoice = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_MCQCHOICE + "-" + i);
 				if(mcqChoice != null &amp;&amp; !mcqChoice.trim().isEmpty()) {
 					mcqChoices.add(mcqChoice);
+					numOfMcqChoices++;
 				}
 			}
 			
 			boolean otherEnabled = false; // TODO change this when implementing "other, please specify" field
 			
 			FeedbackMcqQuestionDetails mcqDetails = 
+					new FeedbackMcqQuestionDetails(questionText, numOfMcqChoices, mcqChoices, otherEnabled);
 			newQuestion.setQuestionDetails(mcqDetails);
 			break;
 		default:
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>403435</refactoring_id><commit_sha>6df78f31ecf8c4587ecf1daf62f693af6e52bbdc</commit_sha><commit_link>https://github.com/apache/tomcat/commit/6df78f31ecf8c4587ecf1daf62f693af6e52bbdc</commit_link><file_path>java/org/apache/catalina/core/ApplicationHttpRequest.java</file_path><description>Rename Variable entryKey : String to dispParamName : String in method private mergeParameters() : void from class org.apache.catalina.core.ApplicationHttpRequest</description><code_before>@@ -25,7 +25,6 @@
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.NoSuchElementException;
 
 import javax.servlet.DispatcherType;
@@ -40,7 +39,8 @@
 import org.apache.catalina.Globals;
 import org.apache.catalina.Manager;
 import org.apache.catalina.Session;
-import org.apache.catalina.util.RequestUtil;
 
 
 /**
@@ -885,24 +885,32 @@ private void mergeParameters() {
             return;
 
         HashMap&lt;String, String[]&gt; queryParameters = new HashMap&lt;&gt;();
-        String encoding = getCharacterEncoding();
-        if (encoding == null)
-            encoding = "ISO-8859-1";
-        RequestUtil.parseParameters(queryParameters, queryParamString,
-                encoding);
-        for (Entry&lt;String, String[]&gt; entry : parameters.entrySet()) {
-            String entryKey = entry.getKey();
-            String[] entryValue = entry.getValue();
-            Object value = queryParameters.get(entryKey);
-            if (value == null) {
-                queryParameters.put(entryKey, entryValue);
                 continue;
             }
-            queryParameters.put
-                (entryKey, mergeValues(value, entryValue));
         }
-        parameters = queryParameters;
 
     }
 
 
</code_before><code_after>@@ -25,7 +25,6 @@
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.NoSuchElementException;
 
 import javax.servlet.DispatcherType;
@@ -40,7 +39,8 @@
 import org.apache.catalina.Globals;
 import org.apache.catalina.Manager;
 import org.apache.catalina.Session;
+import org.apache.tomcat.util.buf.MessageBytes;
+import org.apache.tomcat.util.http.Parameters;
 
 
 /**
@@ -885,24 +885,32 @@ private void mergeParameters() {
             return;
 
         HashMap&lt;String, String[]&gt; queryParameters = new HashMap&lt;&gt;();
+
+        // Parse the query string from the dispatch target
+        Parameters paramParser = new Parameters();
+        MessageBytes queryMB = MessageBytes.newInstance();
+        queryMB.setString(queryParamString);
+        paramParser.setQuery(queryMB);
+        paramParser.setQueryStringEncoding(getCharacterEncoding());
+        paramParser.handleQueryParameters();
+
+        // Copy the original parameters
+        queryParameters.putAll(parameters);
+
+        // Insert the additional parameters from the dispatch target
+        Enumeration&lt;String&gt; dispParamNames = paramParser.getParameterNames();
+        while (dispParamNames.hasMoreElements()) {
+            String dispParamName = dispParamNames.nextElement();
+            String[] dispParamValues = paramParser.getParameterValues(dispParamName);
+            String[] originalValues = queryParameters.get(dispParamName);
+            if (originalValues == null) {
+                queryParameters.put(dispParamName, dispParamValues);
                 continue;
             }
+            queryParameters.put(dispParamName, mergeValues(dispParamValues, originalValues));
         }
 
+        parameters = queryParameters;
     }
 
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>425326</refactoring_id><commit_sha>dd27a9a8df09601ed6e162fdd78d58902f94c349</commit_sha><commit_link>https://github.com/androidx/media/commit/dd27a9a8df09601ed6e162fdd78d58902f94c349</commit_link><file_path>library/common/src/test/java/com/google/android/exoplayer2/ForwardingPlayerTest.java</file_path><description>Rename Variable currentInterface : Class&lt;?&gt; to supertype : Class&lt;?&gt; in method public getPublicMethods(clazz Class&lt;?&gt;) : List&lt;Method&gt; from class com.google.android.exoplayer2.testutil.TestUtil</description><code_before>@@ -18,23 +18,18 @@
 import static com.google.android.exoplayer2.Player.EVENT_IS_PLAYING_CHANGED;
 import static com.google.android.exoplayer2.Player.EVENT_MEDIA_ITEM_TRANSITION;
 import static com.google.android.exoplayer2.Player.EVENT_TIMELINE_CHANGED;
-import static com.google.android.exoplayer2.util.Assertions.checkArgument;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.ArgumentMatchers.same;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.StubPlayer;
 import com.google.android.exoplayer2.util.FlagSet;
 import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Queue;
 import java.util.Set;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -106,7 +101,7 @@ public void onEvents_passesForwardingPlayerAsArgument() {
   @Test
   public void forwardingPlayer_overridesAllPlayerMethods() throws Exception {
     // Check with reflection that ForwardingPlayer overrides all Player methods.
-    List&lt;Method&gt; methods = getPublicMethods(Player.class);
     for (Method method : methods) {
       assertThat(
               ForwardingPlayer.class
@@ -120,7 +115,7 @@ public void forwardingPlayer_overridesAllPlayerMethods() throws Exception {
   public void forwardingListener_overridesAllListenerMethods() throws Exception {
     // Check with reflection that ForwardingListener overrides all Listener methods.
     Class&lt;?&gt; forwardingListenerClass = getInnerClass("ForwardingListener");
-    List&lt;Method&gt; methods = getPublicMethods(Player.Listener.class);
     for (Method method : methods) {
       assertThat(
               forwardingListenerClass
@@ -130,32 +125,6 @@ public void forwardingListener_overridesAllListenerMethods() throws Exception {
     }
   }
 
-  /** Returns all the public methods of a Java interface. */
-  private static List&lt;Method&gt; getPublicMethods(Class&lt;?&gt; anInterface) {
-    checkArgument(anInterface.isInterface());
-    // Run a BFS over all extended interfaces to inspect them all.
-    Queue&lt;Class&lt;?&gt;&gt; interfacesQueue = new ArrayDeque&lt;&gt;();
-    interfacesQueue.add(anInterface);
-    Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;&gt;();
-    while (!interfacesQueue.isEmpty()) {
-      Class&lt;?&gt; currentInterface = interfacesQueue.remove();
-      if (interfaces.add(currentInterface)) {
-        Collections.addAll(interfacesQueue, currentInterface.getInterfaces());
-      }
-    }
-
-    List&lt;Method&gt; list = new ArrayList&lt;&gt;();
-    for (Class&lt;?&gt; currentInterface : interfaces) {
-      for (Method method : currentInterface.getDeclaredMethods()) {
-        if (Modifier.isPublic(method.getModifiers())) {
-          list.add(method);
-        }
-      }
-    }
-
-    return list;
-  }
-
   private static Class&lt;?&gt; getInnerClass(String className) {
     for (Class&lt;?&gt; innerClass : ForwardingPlayer.class.getDeclaredClasses()) {
       if (innerClass.getSimpleName().equals(className)) {
</code_before><code_after>@@ -18,23 +18,18 @@
 import static com.google.android.exoplayer2.Player.EVENT_IS_PLAYING_CHANGED;
 import static com.google.android.exoplayer2.Player.EVENT_MEDIA_ITEM_TRANSITION;
 import static com.google.android.exoplayer2.Player.EVENT_TIMELINE_CHANGED;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.ArgumentMatchers.same;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.StubPlayer;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.FlagSet;
 import java.lang.reflect.Method;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -106,7 +101,7 @@ public void onEvents_passesForwardingPlayerAsArgument() {
   @Test
   public void forwardingPlayer_overridesAllPlayerMethods() throws Exception {
     // Check with reflection that ForwardingPlayer overrides all Player methods.
+    List&lt;Method&gt; methods = TestUtil.getPublicMethods(Player.class);
     for (Method method : methods) {
       assertThat(
               ForwardingPlayer.class
@@ -120,7 +115,7 @@ public void forwardingPlayer_overridesAllPlayerMethods() throws Exception {
   public void forwardingListener_overridesAllListenerMethods() throws Exception {
     // Check with reflection that ForwardingListener overrides all Listener methods.
     Class&lt;?&gt; forwardingListenerClass = getInnerClass("ForwardingListener");
+    List&lt;Method&gt; methods = TestUtil.getPublicMethods(Player.Listener.class);
     for (Method method : methods) {
       assertThat(
               forwardingListenerClass
@@ -130,32 +125,6 @@ public void forwardingListener_overridesAllListenerMethods() throws Exception {
     }
   }
 
   private static Class&lt;?&gt; getInnerClass(String className) {
     for (Class&lt;?&gt; innerClass : ForwardingPlayer.class.getDeclaredClasses()) {
       if (innerClass.getSimpleName().equals(className)) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>377733</refactoring_id><commit_sha>01ec5c6f299febb5ffa8ba7909bd14bcf3666180</commit_sha><commit_link>https://github.com/camunda/camunda/commit/01ec5c6f299febb5ffa8ba7909bd14bcf3666180</commit_link><file_path>backend/src/it/java/org/camunda/optimize/service/entities/report/DecisionReportImportIT.java</file_path><description>Rename Variable importedId : IdResponseDto to importedIds : List&lt;IdResponseDto&gt; in method public importReport_partiallyMissingTenants() : void from class org.camunda.optimize.service.entities.report.DecisionReportImportIT</description><code_before>@@ -22,9 +22,11 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 
 import javax.ws.rs.core.Response;
 import java.time.OffsetDateTime;
 import java.util.Collections;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.camunda.optimize.test.it.extension.EngineIntegrationExtension.DEFAULT_FIRSTNAME;
@@ -47,9 +49,10 @@ public void importReport(final SingleDecisionReportDefinitionRequestDto reportDe
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
-    final IdResponseDto importedId = response.readEntity(IdResponseDto.class);
     final SingleDecisionReportDefinitionRequestDto importedReport =
-      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedId.getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -157,9 +160,10 @@ public void importReport_partiallyMissingVersions() {
 
     // then all non version related data is accurate
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
-    final IdResponseDto importedId = response.readEntity(IdResponseDto.class);
     final SingleDecisionReportDefinitionRequestDto importedReport =
-      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedId.getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -232,9 +236,10 @@ public void importReport_partiallyMissingTenants() {
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
-    final IdResponseDto importedId = response.readEntity(IdResponseDto.class);
     final SingleDecisionReportDefinitionRequestDto importedReport =
-      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedId.getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -270,9 +275,10 @@ public void importReport_sharedDefinitionButSpecificReportTenant() {
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
-    final IdResponseDto importedId = response.readEntity(IdResponseDto.class);
     final SingleDecisionReportDefinitionRequestDto importedReport =
-      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedId.getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -314,9 +320,10 @@ public void importReportIntoCollection(final SingleDecisionReportDefinitionReque
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
-    final IdResponseDto importedId = response.readEntity(IdResponseDto.class);
     final SingleDecisionReportDefinitionRequestDto importedReport =
-      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedId.getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
</code_before><code_after>@@ -22,9 +22,11 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 
+import javax.ws.rs.core.GenericType;
 import javax.ws.rs.core.Response;
 import java.time.OffsetDateTime;
 import java.util.Collections;
+import java.util.List;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.camunda.optimize.test.it.extension.EngineIntegrationExtension.DEFAULT_FIRSTNAME;
@@ -47,9 +49,10 @@ public void importReport(final SingleDecisionReportDefinitionRequestDto reportDe
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
+    final List&lt;IdResponseDto&gt; importedIds = response.readEntity(new GenericType&lt;List&lt;IdResponseDto&gt;&gt;(){});
+    assertThat(importedIds).hasSize(1);
     final SingleDecisionReportDefinitionRequestDto importedReport =
+      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedIds.get(0).getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -157,9 +160,10 @@ public void importReport_partiallyMissingVersions() {
 
     // then all non version related data is accurate
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
+    final List&lt;IdResponseDto&gt; importedIds = response.readEntity(new GenericType&lt;List&lt;IdResponseDto&gt;&gt;(){});
+    assertThat(importedIds).hasSize(1);
     final SingleDecisionReportDefinitionRequestDto importedReport =
+      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedIds.get(0).getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -232,9 +236,10 @@ public void importReport_partiallyMissingTenants() {
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
+    final List&lt;IdResponseDto&gt; importedIds = response.readEntity(new GenericType&lt;List&lt;IdResponseDto&gt;&gt;(){});
+    assertThat(importedIds).hasSize(1);
     final SingleDecisionReportDefinitionRequestDto importedReport =
+      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedIds.get(0).getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -270,9 +275,10 @@ public void importReport_sharedDefinitionButSpecificReportTenant() {
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
+    final List&lt;IdResponseDto&gt; importedIds = response.readEntity(new GenericType&lt;List&lt;IdResponseDto&gt;&gt;(){});
+    assertThat(importedIds).hasSize(1);
     final SingleDecisionReportDefinitionRequestDto importedReport =
+      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedIds.get(0).getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
@@ -314,9 +320,10 @@ public void importReportIntoCollection(final SingleDecisionReportDefinitionReque
 
     // then
     assertThat(response.getStatus()).isEqualTo(Response.Status.OK.getStatusCode());
+    final List&lt;IdResponseDto&gt; importedIds = response.readEntity(new GenericType&lt;List&lt;IdResponseDto&gt;&gt;(){});
+    assertThat(importedIds).hasSize(1);
     final SingleDecisionReportDefinitionRequestDto importedReport =
+      (SingleDecisionReportDefinitionRequestDto) reportClient.getReportById(importedIds.get(0).getId());
 
     assertThat(importedReport.getOwner()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
     assertThat(importedReport.getLastModifier()).isEqualTo(DEFAULT_FIRSTNAME + " " + DEFAULT_LASTNAME);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>454182</refactoring_id><commit_sha>3507d59f969485dd735487e6bf3eb893b2e3d8ed</commit_sha><commit_link>https://github.com/apache/flink/commit/3507d59f969485dd735487e6bf3eb893b2e3d8ed</commit_link><file_path>flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java</file_path><description>Rename Variable i : int to endPos : int in method protected nextStringEndPos(bytes byte[], startPos int, limit int, delimiter byte[]) : int from class org.apache.flink.types.parser.FieldParser</description><code_before>@@ -33,31 +33,21 @@ public class DoubleParser extends FieldParser&lt;Double&gt; {
 
 	@Override
 	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Double reusable) {
-		int i = startPos;
-
-		final int delimLimit = limit - delimiter.length + 1;
-
-		while (i &lt; limit) {
-			if (i &lt; delimLimit &amp;&amp; delimiterNext(bytes, i, delimiter)) {
-				if (i == startPos) {
-					setErrorState(ParseErrorState.EMPTY_COLUMN);
-					return -1;
-				}
-				break;
-			}
-			i++;
 		}
 
-		if (i &gt; startPos &amp;&amp;
-				(Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[(i - 1)]))) {
 			setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
 			return -1;
 		}
 
-		String str = new String(bytes, startPos, i - startPos);
 		try {
 			this.result = Double.parseDouble(str);
-			return (i == limit) ? limit : i + delimiter.length;
 		} catch (NumberFormatException e) {
 			setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);
 			return -1;
@@ -83,7 +73,7 @@ public Double getLastResult() {
 	 * @param startPos The offset to start the parsing.
 	 * @param length   The length of the byte sequence (counting from the offset).
 	 * @return The parsed value.
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
 	 * represents not a correct number.
 	 */
 	public static final double parseField(byte[] bytes, int startPos, int length) {
@@ -100,26 +90,18 @@ public static final double parseField(byte[] bytes, int startPos, int length) {
 	 * @param length    The length of the byte sequence (counting from the offset).
 	 * @param delimiter The delimiter that terminates the field.
 	 * @return The parsed value.
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
 	 * represents not a correct number.
 	 */
 	public static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {
-		if (length &lt;= 0) {
-			throw new NumberFormatException("Invalid input: Empty string");
-		}
-		int i = 0;
-		final byte delByte = (byte) delimiter;
-
-		while (i &lt; length &amp;&amp; bytes[startPos + i] != delByte) {
-			i++;
-		}
 
-		if (i &gt; 0 &amp;&amp;
-				(Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[startPos + i - 1]))) {
 			throw new NumberFormatException("There is leading or trailing whitespace in the numeric field.");
 		}
 
-		String str = new String(bytes, startPos, i);
 		return Double.parseDouble(str);
 	}
 }
</code_before><code_after>@@ -33,31 +33,21 @@ public class DoubleParser extends FieldParser&lt;Double&gt; {
 
 	@Override
 	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Double reusable) {
+		final int endPos = nextStringEndPos(bytes, startPos, limit, delimiter);
+		if (endPos &lt; 0) {
+			return -1;
 		}
 
+		if (endPos &gt; startPos &amp;&amp;
+				(Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[(endPos - 1)]))) {
 			setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
 			return -1;
 		}
 
+		String str = new String(bytes, startPos, endPos - startPos);
 		try {
 			this.result = Double.parseDouble(str);
+			return (endPos == limit) ? limit : endPos + delimiter.length;
 		} catch (NumberFormatException e) {
 			setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);
 			return -1;
@@ -83,7 +73,7 @@ public Double getLastResult() {
 	 * @param startPos The offset to start the parsing.
 	 * @param length   The length of the byte sequence (counting from the offset).
 	 * @return The parsed value.
+	 * @throws IllegalArgumentException Thrown when the value cannot be parsed because the text
 	 * represents not a correct number.
 	 */
 	public static final double parseField(byte[] bytes, int startPos, int length) {
@@ -100,26 +90,18 @@ public static final double parseField(byte[] bytes, int startPos, int length) {
 	 * @param length    The length of the byte sequence (counting from the offset).
 	 * @param delimiter The delimiter that terminates the field.
 	 * @return The parsed value.
+	 * @throws IllegalArgumentException Thrown when the value cannot be parsed because the text
 	 * represents not a correct number.
 	 */
 	public static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {
+		final int limitedLen = nextStringLength(bytes, startPos, length, delimiter);
 
+		if (limitedLen &gt; 0 &amp;&amp;
+				(Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[startPos + limitedLen - 1]))) {
 			throw new NumberFormatException("There is leading or trailing whitespace in the numeric field.");
 		}
 
+		final String str = new String(bytes, startPos, limitedLen);
 		return Double.parseDouble(str);
 	}
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>383086</refactoring_id><commit_sha>05dd08b993e2d7f88176c051463b178431714f85</commit_sha><commit_link>https://github.com/apache/ignite/commit/05dd08b993e2d7f88176c051463b178431714f85</commit_link><file_path>modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/IgniteCacheMessageRecoveryAbstractTest.java</file_path><description>Rename Variable client : GridCommunicationClient to clients0 : GridCommunicationClient[] in method package closeSessions(ignite Ignite) : boolean from class org.apache.ignite.internal.processors.cache.distributed.IgniteCacheMessageRecoveryAbstractTest</description><code_before>@@ -58,6 +58,7 @@ public abstract class IgniteCacheMessageRecoveryAbstractTest extends GridCommonA
 
         commSpi.setSocketWriteTimeout(1000);
         commSpi.setSharedMemoryPort(-1);
 
         cfg.setCommunicationSpi(commSpi);
 
@@ -75,6 +76,13 @@ public abstract class IgniteCacheMessageRecoveryAbstractTest extends GridCommonA
         return cfg;
     }
 
     /**
      * @return Cache atomicity mode.
      */
@@ -174,18 +182,22 @@ public void testMessageRecovery() throws Exception {
     static boolean closeSessions(Ignite ignite) throws Exception {
         TcpCommunicationSpi commSpi = (TcpCommunicationSpi)ignite.configuration().getCommunicationSpi();
 
-        Map&lt;UUID, GridCommunicationClient&gt; clients = U.field(commSpi, "clients");
 
         boolean closed = false;
 
-        for (GridCommunicationClient client : clients.values()) {
-            GridTcpNioCommunicationClient client0 = (GridTcpNioCommunicationClient)client;
 
-            GridNioSession ses = client0.session();
 
-            ses.close();
 
-            closed = true;
         }
 
         return closed;
</code_before><code_after>@@ -58,6 +58,7 @@ public abstract class IgniteCacheMessageRecoveryAbstractTest extends GridCommonA
 
         commSpi.setSocketWriteTimeout(1000);
         commSpi.setSharedMemoryPort(-1);
+        commSpi.setConnectionsPerNode(connectionsPerNode());
 
         cfg.setCommunicationSpi(commSpi);
 
@@ -75,6 +76,13 @@ public abstract class IgniteCacheMessageRecoveryAbstractTest extends GridCommonA
         return cfg;
     }
 
+    /**
+     * @return Value for {@link TcpCommunicationSpi#setConnectionsPerNode(int)}.
+     */
+    protected int connectionsPerNode() {
+        return TcpCommunicationSpi.DFLT_CONN_PER_NODE;
+    }
+
     /**
      * @return Cache atomicity mode.
      */
@@ -174,18 +182,22 @@ public void testMessageRecovery() throws Exception {
     static boolean closeSessions(Ignite ignite) throws Exception {
         TcpCommunicationSpi commSpi = (TcpCommunicationSpi)ignite.configuration().getCommunicationSpi();
 
+        Map&lt;UUID, GridCommunicationClient[]&gt; clients = U.field(commSpi, "clients");
 
         boolean closed = false;
 
+        for (GridCommunicationClient[] clients0 : clients.values()) {
+            for (GridCommunicationClient client : clients0) {
+                if (client != null) {
+                    GridTcpNioCommunicationClient client0 = (GridTcpNioCommunicationClient)client;
 
+                    GridNioSession ses = client0.session();
 
+                    ses.close();
 
+                    closed = true;
+                }
+            }
         }
 
         return closed;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>449382</refactoring_id><commit_sha>cc8f4369d0a860098cd3d4a4d9d933dc45e0fea8</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/cc8f4369d0a860098cd3d4a4d9d933dc45e0fea8</commit_link><file_path>engine/src/main/java/org/terasology/rendering/nui/contextMenu/ContextMenuBuilder.java</file_path><description>Rename Variable firstLevel : ContextMenuLevel to primaryLevel : ContextMenuLevel in method public show(manager NUIManager, position Vector2i) : void from class org.terasology.rendering.nui.contextMenu.ContextMenuBuilder</description><code_before>@@ -15,7 +15,6 @@
  */
 package org.terasology.rendering.nui.contextMenu;
 
-import com.google.api.client.util.Maps;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import org.terasology.math.geom.Vector2i;
@@ -24,15 +23,17 @@
 import org.terasology.rendering.nui.widgets.UpdateListener;
 
 import java.util.List;
-import java.util.Map;
 
 /**
  * A builder class to construct and show {@link ContextMenuScreen} instances.
  * &lt;p&gt;
  * Should be used in favor of manually creating the screen.
  */
 public class ContextMenuBuilder {
-    private Map&lt;String, ContextMenuLevel&gt; menuLevels = Maps.newLinkedHashMap();
     /**
      * Listeners fired when an item is selected.
      */
@@ -42,17 +43,21 @@ public class ContextMenuBuilder {
      */
     private List&lt;UpdateListener&gt; closeListeners = Lists.newArrayList();
     /**
-     *
      */
     private List&lt;UpdateListener&gt; screenClosedListeners = Lists.newArrayList();
 
-    public ContextMenuLevel getLevel(String key) {
-        return menuLevels.get(key);
-    }
-
-    public ContextMenuLevel addLevel(String key) {
         ContextMenuLevel level = new ContextMenuLevel();
-        menuLevels.put(key, level);
         return level;
     }
 
@@ -67,10 +72,10 @@ public void show(NUIManager manager, Vector2i position) {
             manager.pushScreen(ContextMenuScreen.ASSET_URI, ContextMenuScreen.class);
         }
 
-        ContextMenuLevel firstLevel = menuLevels.entrySet().iterator().next().getValue();
-        firstLevel.setVisible(true);
-        firstLevel.setPosition(position);
-        for (ContextMenuLevel level : menuLevels.values()) {
             level.getMenuWidget().bindSelection(new Binding&lt;String&gt;() {
                 @Override
                 public String get() {
@@ -89,7 +94,7 @@ public void set(String value) {
         }
 
         ContextMenuScreen contextMenuScreen = (ContextMenuScreen) manager.getScreen(ContextMenuScreen.ASSET_URI);
-        contextMenuScreen.setMenuLevels(Lists.newArrayList(menuLevels.values()));
 
         contextMenuScreen.subscribeClose(() -&gt; {
             closeListeners.forEach(UpdateListener::onAction);
</code_before><code_after>@@ -15,7 +15,6 @@
  */
 package org.terasology.rendering.nui.contextMenu;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import org.terasology.math.geom.Vector2i;
@@ -24,15 +23,17 @@
 import org.terasology.rendering.nui.widgets.UpdateListener;
 
 import java.util.List;
 
 /**
  * A builder class to construct and show {@link ContextMenuScreen} instances.
  * &lt;p&gt;
  * Should be used in favor of manually creating the screen.
  */
 public class ContextMenuBuilder {
+    /**
+     * A list of context menu levels used within the menu.
+     */
+    private List&lt;ContextMenuLevel&gt; menuLevels = Lists.newArrayList();
     /**
      * Listeners fired when an item is selected.
      */
@@ -42,17 +43,21 @@ public class ContextMenuBuilder {
      */
     private List&lt;UpdateListener&gt; closeListeners = Lists.newArrayList();
     /**
+     * Listeners fired when the menu is closed, either with or without
+     * selecting an option.
      */
     private List&lt;UpdateListener&gt; screenClosedListeners = Lists.newArrayList();
 
+    /**
+     * Adds a new level to the context menu.
+     *
+     * @param visible Whether the level should be initialized as visible.
+     * @return The newly added level.
+     */
+    public ContextMenuLevel addLevel(boolean visible) {
         ContextMenuLevel level = new ContextMenuLevel();
+        level.setVisible(visible);
+        menuLevels.add(level);
         return level;
     }
 
@@ -67,10 +72,10 @@ public void show(NUIManager manager, Vector2i position) {
             manager.pushScreen(ContextMenuScreen.ASSET_URI, ContextMenuScreen.class);
         }
 
+        ContextMenuLevel primaryLevel = menuLevels.get(0);
+        primaryLevel.setVisible(true);
+        primaryLevel.setPosition(position);
+        for (ContextMenuLevel level : menuLevels) {
             level.getMenuWidget().bindSelection(new Binding&lt;String&gt;() {
                 @Override
                 public String get() {
@@ -89,7 +94,7 @@ public void set(String value) {
         }
 
         ContextMenuScreen contextMenuScreen = (ContextMenuScreen) manager.getScreen(ContextMenuScreen.ASSET_URI);
+        contextMenuScreen.setMenuLevels(menuLevels);
 
         contextMenuScreen.subscribeClose(() -&gt; {
             closeListeners.forEach(UpdateListener::onAction);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>389311</refactoring_id><commit_sha>c4ac00a7ac2fd1123e22f209be1d92c42ef56130</commit_sha><commit_link>https://github.com/apache/beam/commit/c4ac00a7ac2fd1123e22f209be1d92c42ef56130</commit_link><file_path>sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/integrationtest/BeamSqlBuiltinFunctionsIntegrationTestBase.java</file_path><description>Rename Variable recordType : BeamRecordType to rowType : RowType in method public buildRunAndCheck() : void from class org.apache.beam.sdk.extensions.sql.integrationtest.BeamSqlBuiltinFunctionsIntegrationTestBase.ExpressionChecker</description><code_before>@@ -19,7 +19,7 @@
 package org.apache.beam.sdk.extensions.sql.integrationtest;
 
 import static java.util.stream.Collectors.toList;
-import static org.apache.beam.sdk.values.BeamRecordType.toRecordType;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
@@ -30,17 +30,17 @@
 import java.util.List;
 import java.util.Map;
 import java.util.TimeZone;
-import org.apache.beam.sdk.extensions.sql.BeamRecordSqlType;
 import org.apache.beam.sdk.extensions.sql.BeamSql;
 import org.apache.beam.sdk.extensions.sql.SqlTypeCoder;
 import org.apache.beam.sdk.extensions.sql.SqlTypeCoders;
 import org.apache.beam.sdk.extensions.sql.TestUtils;
 import org.apache.beam.sdk.extensions.sql.mock.MockedBoundedTable;
 import org.apache.beam.sdk.testing.PAssert;
 import org.apache.beam.sdk.testing.TestPipeline;
-import org.apache.beam.sdk.values.BeamRecord;
-import org.apache.beam.sdk.values.BeamRecordType;
 import org.apache.beam.sdk.values.PCollection;
 import org.apache.calcite.util.Pair;
 import org.junit.Rule;
 
@@ -62,7 +62,7 @@ public class BeamSqlBuiltinFunctionsIntegrationTestBase {
       .put(Boolean.class, SqlTypeCoders.BOOLEAN)
       .build();
 
-  private static final BeamRecordType RECORD_TYPE = BeamRecordSqlType.builder()
       .withDateField("ts")
       .withTinyIntField("c_tinyint")
       .withSmallIntField("c_smallint")
@@ -80,10 +80,10 @@ public class BeamSqlBuiltinFunctionsIntegrationTestBase {
   @Rule
   public final TestPipeline pipeline = TestPipeline.create();
 
-  protected PCollection&lt;BeamRecord&gt; getTestPCollection() {
     try {
       return MockedBoundedTable
-          .of(RECORD_TYPE)
           .addRows(
               parseDate("1986-02-15 11:35:26"),
               (byte) 1,
@@ -99,7 +99,7 @@ protected PCollection&lt;BeamRecord&gt; getTestPCollection() {
               9223372036854775807L
           )
           .buildIOReader(pipeline)
-          .setCoder(RECORD_TYPE.getRecordCoder());
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
@@ -150,22 +150,22 @@ private String getSql() {
      * Build the corresponding SQL, compile to Beam Pipeline, run it, and check the result.
      */
     public void buildRunAndCheck() {
-      PCollection&lt;BeamRecord&gt; inputCollection = getTestPCollection();
       System.out.println("SQL:&gt;\n" + getSql());
       try {
-        BeamRecordType recordType =
             exps.stream()
-                .map(exp -&gt; BeamRecordType.newField(
                     exp.getKey(),
                     JAVA_CLASS_TO_CODER.get(exp.getValue().getClass())))
-                .collect(toRecordType());
 
         List&lt;Object&gt; values = exps.stream().map(Pair::getValue).collect(toList());
 
-        PCollection&lt;BeamRecord&gt; rows = inputCollection.apply(BeamSql.query(getSql()));
         PAssert.that(rows).containsInAnyOrder(
             TestUtils.RowsBuilder
-                .of(recordType)
                 .addRows(values)
                 .getRows()
         );
</code_before><code_after>@@ -19,7 +19,7 @@
 package org.apache.beam.sdk.extensions.sql.integrationtest;
 
 import static java.util.stream.Collectors.toList;
+import static org.apache.beam.sdk.values.RowType.toRowType;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
@@ -30,17 +30,17 @@
 import java.util.List;
 import java.util.Map;
 import java.util.TimeZone;
 import org.apache.beam.sdk.extensions.sql.BeamSql;
+import org.apache.beam.sdk.extensions.sql.RowSqlType;
 import org.apache.beam.sdk.extensions.sql.SqlTypeCoder;
 import org.apache.beam.sdk.extensions.sql.SqlTypeCoders;
 import org.apache.beam.sdk.extensions.sql.TestUtils;
 import org.apache.beam.sdk.extensions.sql.mock.MockedBoundedTable;
 import org.apache.beam.sdk.testing.PAssert;
 import org.apache.beam.sdk.testing.TestPipeline;
 import org.apache.beam.sdk.values.PCollection;
+import org.apache.beam.sdk.values.Row;
+import org.apache.beam.sdk.values.RowType;
 import org.apache.calcite.util.Pair;
 import org.junit.Rule;
 
@@ -62,7 +62,7 @@ public class BeamSqlBuiltinFunctionsIntegrationTestBase {
       .put(Boolean.class, SqlTypeCoders.BOOLEAN)
       .build();
 
+  private static final RowType ROW_TYPE = RowSqlType.builder()
       .withDateField("ts")
       .withTinyIntField("c_tinyint")
       .withSmallIntField("c_smallint")
@@ -80,10 +80,10 @@ public class BeamSqlBuiltinFunctionsIntegrationTestBase {
   @Rule
   public final TestPipeline pipeline = TestPipeline.create();
 
+  protected PCollection&lt;Row&gt; getTestPCollection() {
     try {
       return MockedBoundedTable
+          .of(ROW_TYPE)
           .addRows(
               parseDate("1986-02-15 11:35:26"),
               (byte) 1,
@@ -99,7 +99,7 @@ protected PCollection&lt;BeamRecord&gt; getTestPCollection() {
               9223372036854775807L
           )
           .buildIOReader(pipeline)
+          .setCoder(ROW_TYPE.getRowCoder());
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
@@ -150,22 +150,22 @@ private String getSql() {
      * Build the corresponding SQL, compile to Beam Pipeline, run it, and check the result.
      */
     public void buildRunAndCheck() {
+      PCollection&lt;Row&gt; inputCollection = getTestPCollection();
       System.out.println("SQL:&gt;\n" + getSql());
       try {
+        RowType rowType =
             exps.stream()
+                .map(exp -&gt; RowType.newField(
                     exp.getKey(),
                     JAVA_CLASS_TO_CODER.get(exp.getValue().getClass())))
+                .collect(toRowType());
 
         List&lt;Object&gt; values = exps.stream().map(Pair::getValue).collect(toList());
 
+        PCollection&lt;Row&gt; rows = inputCollection.apply(BeamSql.query(getSql()));
         PAssert.that(rows).containsInAnyOrder(
             TestUtils.RowsBuilder
+                .of(rowType)
                 .addRows(values)
                 .getRows()
         );
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>457520</refactoring_id><commit_sha>27146505558b72868695ef5db21c96370367339b</commit_sha><commit_link>https://github.com/knowm/xchange/commit/27146505558b72868695ef5db21c96370367339b</commit_link><file_path>xchange-quoine/src/main/java/com/xeiam/xchange/quoine/QuoineAdapters.java</file_path><description>Rename Variable wallets : Map&lt;String,Balance&gt; to balances : List&lt;Balance&gt; in method public adaptTradingAccountInfo(quoineAccountInfo QuoineTradingAccountInfo[]) : AccountInfo from class com.xeiam.xchange.quoine.QuoineAdapters</description><code_before>@@ -12,6 +12,7 @@
 import com.xeiam.xchange.dto.Order;
 import com.xeiam.xchange.dto.Order.OrderType;
 import com.xeiam.xchange.dto.account.AccountInfo;
 import com.xeiam.xchange.dto.marketdata.OrderBook;
 import com.xeiam.xchange.dto.marketdata.Ticker;
 import com.xeiam.xchange.dto.trade.Balance;
@@ -68,41 +69,41 @@ public static void checkArgument(boolean argument, String msgPattern, Object...
   }
 
   public static AccountInfo adaptTradingAccountInfo(QuoineTradingAccountInfo[] quoineAccountInfo) {
-    Map&lt;String, Balance&gt; wallets = new HashMap&lt;String, Balance&gt;(quoineAccountInfo.length);
 
     // btc position is sum of all positions in margin. Asuming all currencies are using the same margin level.
     BigDecimal btcPosition = BigDecimal.ZERO;
 
     for (int i = 0; i &lt; quoineAccountInfo.length; i++) {
       QuoineTradingAccountInfo info = quoineAccountInfo[i];
 
-      wallets.put(info.getCollateralCurrency(), new Balance(info.getCollateralCurrency(), info.getFreeMargin()));
 
       btcPosition = btcPosition.add(info.getPosition());
     }
 
-    wallets.put("BTC", new Balance("BTC", btcPosition));
 
-    return new AccountInfo(null, wallets);
   }
 
   public static AccountInfo adaptAccountinfo(QuoineAccountInfo quoineAccountInfo) {
 
-    Map&lt;String, Balance&gt; wallets = new HashMap&lt;String, Balance&gt;();
 
     // Adapt to XChange DTOs
     Balance btcBalance = new Balance(quoineAccountInfo.getBitcoinAccount().getCurrency(), quoineAccountInfo.getBitcoinAccount().getBalance(),
         quoineAccountInfo.getBitcoinAccount().getFreeBalance(),
         quoineAccountInfo.getBitcoinAccount().getBalance().subtract(quoineAccountInfo.getBitcoinAccount().getFreeBalance()));
-    wallets.put(quoineAccountInfo.getBitcoinAccount().getCurrency(), btcBalance);
 
     for (FiatAccount fiatAccount : quoineAccountInfo.getFiatAccounts()) {
       Balance fiatBalance = new Balance(fiatAccount.getCurrency(), fiatAccount.getBalance(), fiatAccount.getFreeBalance(),
           fiatAccount.getBalance().subtract(fiatAccount.getFreeBalance()));
-      wallets.put(fiatAccount.getCurrency(), fiatBalance);
     }
 
-    return new AccountInfo(null, wallets);
 
   }
 
</code_before><code_after>@@ -12,6 +12,7 @@
 import com.xeiam.xchange.dto.Order;
 import com.xeiam.xchange.dto.Order.OrderType;
 import com.xeiam.xchange.dto.account.AccountInfo;
+import com.xeiam.xchange.dto.account.Wallet;
 import com.xeiam.xchange.dto.marketdata.OrderBook;
 import com.xeiam.xchange.dto.marketdata.Ticker;
 import com.xeiam.xchange.dto.trade.Balance;
@@ -68,41 +69,41 @@ public static void checkArgument(boolean argument, String msgPattern, Object...
   }
 
   public static AccountInfo adaptTradingAccountInfo(QuoineTradingAccountInfo[] quoineAccountInfo) {
+    List&lt;Balance&gt; balances = new ArrayList&lt;Balance&gt;(quoineAccountInfo.length);
 
     // btc position is sum of all positions in margin. Asuming all currencies are using the same margin level.
     BigDecimal btcPosition = BigDecimal.ZERO;
 
     for (int i = 0; i &lt; quoineAccountInfo.length; i++) {
       QuoineTradingAccountInfo info = quoineAccountInfo[i];
 
+      balances.add(new Balance(info.getCollateralCurrency(), info.getFreeMargin()));
 
       btcPosition = btcPosition.add(info.getPosition());
     }
 
+    balances.add(new Balance("BTC", btcPosition));
 
+    return new AccountInfo(new Wallet(balances));
   }
 
   public static AccountInfo adaptAccountinfo(QuoineAccountInfo quoineAccountInfo) {
 
+    List&lt;Balance&gt; balances = new ArrayList&lt;Balance&gt;();
 
     // Adapt to XChange DTOs
     Balance btcBalance = new Balance(quoineAccountInfo.getBitcoinAccount().getCurrency(), quoineAccountInfo.getBitcoinAccount().getBalance(),
         quoineAccountInfo.getBitcoinAccount().getFreeBalance(),
         quoineAccountInfo.getBitcoinAccount().getBalance().subtract(quoineAccountInfo.getBitcoinAccount().getFreeBalance()));
+    balances.add(btcBalance);
 
     for (FiatAccount fiatAccount : quoineAccountInfo.getFiatAccounts()) {
       Balance fiatBalance = new Balance(fiatAccount.getCurrency(), fiatAccount.getBalance(), fiatAccount.getFreeBalance(),
           fiatAccount.getBalance().subtract(fiatAccount.getFreeBalance()));
+      balances.add(fiatBalance);
     }
 
+    return new AccountInfo(new Wallet(balances));
 
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>408946</refactoring_id><commit_sha>cc5300c4d558e3f86d592ef615104ab9092a34f4</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/cc5300c4d558e3f86d592ef615104ab9092a34f4</commit_link><file_path>spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessor.java</file_path><description>Rename Variable lastModified : long to lastModifiedTimestamp : long in method private isResourceNotModified(inputMessage ServletServerHttpRequest, outputMessage ServletServerHttpResponse) : boolean from class org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor</description><code_before>@@ -28,8 +28,6 @@
 import org.springframework.core.ResolvableType;
 import org.springframework.http.HttpEntity;
 import org.springframework.http.HttpHeaders;
-import org.springframework.http.HttpMethod;
-import org.springframework.http.HttpStatus;
 import org.springframework.http.RequestEntity;
 import org.springframework.http.ResponseEntity;
 import org.springframework.http.converter.HttpMessageConverter;
@@ -41,6 +39,7 @@
 import org.springframework.web.accept.ContentNegotiationManager;
 import org.springframework.web.bind.support.WebDataBinderFactory;
 import org.springframework.web.context.request.NativeWebRequest;
 import org.springframework.web.method.support.ModelAndViewContainer;
 
 /**
@@ -182,15 +181,15 @@ public void handleReturnValue(Object returnValue, MethodParameter returnType,
 		}
 
 		if (responseEntity instanceof ResponseEntity) {
-			outputMessage.getServletResponse().setStatus(((ResponseEntity&lt;?&gt;) responseEntity).getStatusCodeValue());
-			HttpMethod method = inputMessage.getMethod();
-			boolean isGetOrHead = (HttpMethod.GET == method || HttpMethod.HEAD == method);
-			if (isGetOrHead &amp;&amp; isResourceNotModified(inputMessage, outputMessage)) {
-				outputMessage.setStatusCode(HttpStatus.NOT_MODIFIED);
-				// Ensure headers are flushed, no body should be written.
-				outputMessage.flush();
-				// Skip call to converters, as they may update the body.
-				return;
 			}
 		}
 
@@ -223,55 +222,15 @@ private List&lt;String&gt; getVaryRequestHeadersToAdd(HttpHeaders responseHeaders, Htt
 	}
 
 	private boolean isResourceNotModified(ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) {
-		boolean notModified = false;
-		try {
-			long ifModifiedSince = inputMessage.getHeaders().getIfModifiedSince();
-			String eTag = addEtagPadding(outputMessage.getHeaders().getETag());
-			long lastModified = outputMessage.getHeaders().getLastModified();
-			List&lt;String&gt; ifNoneMatch = inputMessage.getHeaders().getIfNoneMatch();
-			if (!ifNoneMatch.isEmpty() &amp;&amp; (inputMessage.getHeaders().containsKey(HttpHeaders.IF_UNMODIFIED_SINCE)
-					|| inputMessage.getHeaders().containsKey(HttpHeaders.IF_MATCH))) {
-				// invalid conditional request, do not process
-			}
-			else if (lastModified != -1 &amp;&amp; StringUtils.hasLength(eTag)) {
-				notModified = isETagNotModified(ifNoneMatch, eTag) &amp;&amp; isTimeStampNotModified(ifModifiedSince, lastModified);
-			}
-			else if (lastModified != -1) {
-				notModified = isTimeStampNotModified(ifModifiedSince, lastModified);
-			}
-			else if (StringUtils.hasLength(eTag)) {
-				notModified = isETagNotModified(ifNoneMatch, eTag);
-			}
-		}
-		catch (IllegalArgumentException exc) {
-			// invalid conditional request, do not process
-		}
-		return notModified;
-	}
-
-	private boolean isETagNotModified(List&lt;String&gt; ifNoneMatch, String etag) {
-		if (StringUtils.hasLength(etag)) {
-			for (String clientETag : ifNoneMatch) {
-				// Compare weak/strong ETags as per https://tools.ietf.org/html/rfc7232#section-2.3
-				if (StringUtils.hasLength(clientETag) &amp;&amp;
-						(clientETag.replaceFirst("^W/", "").equals(etag.replaceFirst("^W/", "")))) {
-					return true;
-				}
-			}
-		}
-		return false;
-	}
-
-	private boolean isTimeStampNotModified(long ifModifiedSince, long lastModifiedTimestamp) {
-		return (ifModifiedSince &gt;= (lastModifiedTimestamp / 1000 * 1000));
-	}
-
-	private String addEtagPadding(String etag) {
-		if (StringUtils.hasLength(etag) &amp;&amp;
-				(!(etag.startsWith("\"") || etag.startsWith("W/\"")) || !etag.endsWith("\"")) ) {
-			etag = "\"" + etag + "\"";
-		}
-		return etag;
 	}
 
 	@Override
</code_before><code_after>@@ -28,8 +28,6 @@
 import org.springframework.core.ResolvableType;
 import org.springframework.http.HttpEntity;
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.RequestEntity;
 import org.springframework.http.ResponseEntity;
 import org.springframework.http.converter.HttpMessageConverter;
@@ -41,6 +39,7 @@
 import org.springframework.web.accept.ContentNegotiationManager;
 import org.springframework.web.bind.support.WebDataBinderFactory;
 import org.springframework.web.context.request.NativeWebRequest;
+import org.springframework.web.context.request.ServletWebRequest;
 import org.springframework.web.method.support.ModelAndViewContainer;
 
 /**
@@ -182,15 +181,15 @@ public void handleReturnValue(Object returnValue, MethodParameter returnType,
 		}
 
 		if (responseEntity instanceof ResponseEntity) {
+			int returnStatus = ((ResponseEntity&lt;?&gt;) responseEntity).getStatusCodeValue();
+			outputMessage.getServletResponse().setStatus(returnStatus);
+			if(returnStatus == 200) {
+				if (isResourceNotModified(inputMessage, outputMessage)) {
+					// Ensure headers are flushed, no body should be written.
+					outputMessage.flush();
+					// Skip call to converters, as they may update the body.
+					return;
+				}
 			}
 		}
 
@@ -223,55 +222,15 @@ private List&lt;String&gt; getVaryRequestHeadersToAdd(HttpHeaders responseHeaders, Htt
 	}
 
 	private boolean isResourceNotModified(ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) {
+		ServletWebRequest servletWebRequest =
+				new ServletWebRequest(inputMessage.getServletRequest(), outputMessage.getServletResponse());
+		HttpHeaders responseHeaders = outputMessage.getHeaders();
+		String etag = responseHeaders.getETag();
+		long lastModifiedTimestamp = responseHeaders.getLastModified();
+		responseHeaders.remove(HttpHeaders.ETAG);
+		responseHeaders.remove(HttpHeaders.LAST_MODIFIED);
+
+		return servletWebRequest.checkNotModified(etag, lastModifiedTimestamp);
 	}
 
 	@Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>429280</refactoring_id><commit_sha>cf300a7dbd07ca4072fbdda8f6fe592bc0b2cce0</commit_sha><commit_link>https://github.com/universalmediaserver/universalmediaserver/commit/cf300a7dbd07ca4072fbdda8f6fe592bc0b2cce0</commit_link><file_path>src/main/java/net/pms/network/mediaserver/nettyserver/NettyServer.java</file_path><description>Rename Variable thread : Thread to t : Thread in method public newThread(r Runnable) : Thread from class net.pms.util.SimpleThreadFactory</description><code_before>@@ -16,14 +16,14 @@
  */
 package net.pms.network.mediaserver.nettyserver;
 
-import net.pms.network.mediaserver.*;
 import java.io.IOException;
-import java.net.*;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
 import net.pms.gui.EConnectionState;
 import net.pms.gui.GuiManager;
 import org.jboss.netty.bootstrap.ServerBootstrap;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFactory;
@@ -54,8 +54,12 @@ public boolean start() throws IOException {
 		InetSocketAddress address = new InetSocketAddress(serverInetAddress, port);
 		ThreadRenamingRunnable.setThreadNameDeterminer(ThreadNameDeterminer.CURRENT);
 		ChannelFactory factory = new NioServerSocketChannelFactory(
-			Executors.newCachedThreadPool(new NettyBossThreadFactory()),
-			Executors.newCachedThreadPool(new NettyWorkerThreadFactory())
 		);
 
 		bootstrap = new ServerBootstrap(factory);
@@ -103,53 +107,4 @@ public synchronized void stop() {
 		LOGGER.info("HTTP server stopped");
 	}
 
-	/**
-	 * A {@link ThreadFactory} that creates Netty worker threads.
-	 */
-	static class NettyWorkerThreadFactory implements ThreadFactory {
-		private final ThreadGroup group;
-		private final AtomicInteger threadNumber = new AtomicInteger(1);
-
-		NettyWorkerThreadFactory() {
-			group = new ThreadGroup("Netty worker group");
-			group.setDaemon(false);
-		}
-
-		@Override
-		public Thread newThread(Runnable runnable) {
-			Thread thread = new Thread(group, runnable, "HTTPv2 Request Worker " + threadNumber.getAndIncrement());
-			if (thread.isDaemon()) {
-				thread.setDaemon(false);
-			}
-			if (thread.getPriority() != Thread.NORM_PRIORITY) {
-				thread.setPriority(Thread.NORM_PRIORITY);
-			}
-			return thread;
-		}
-	}
-
-	/**
-	 * A {@link ThreadFactory} that creates Netty boss threads.
-	 */
-	static class NettyBossThreadFactory implements ThreadFactory {
-		private final ThreadGroup group;
-		private final AtomicInteger threadNumber = new AtomicInteger(1);
-
-		NettyBossThreadFactory() {
-			group = new ThreadGroup("Netty boss group");
-			group.setDaemon(false);
-		}
-
-		@Override
-		public Thread newThread(Runnable runnable) {
-			Thread thread = new Thread(group, runnable, "HTTPv2 Request Handler " + threadNumber.getAndIncrement());
-			if (thread.isDaemon()) {
-				thread.setDaemon(false);
-			}
-			if (thread.getPriority() != Thread.NORM_PRIORITY) {
-				thread.setPriority(Thread.NORM_PRIORITY);
-			}
-			return thread;
-		}
-	}
 }
</code_before><code_after>@@ -16,14 +16,14 @@
  */
 package net.pms.network.mediaserver.nettyserver;
 
 import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.util.concurrent.Executors;
 import net.pms.gui.EConnectionState;
 import net.pms.gui.GuiManager;
+import net.pms.network.mediaserver.HttpMediaServer;
+import net.pms.util.SimpleThreadFactory;
 import org.jboss.netty.bootstrap.ServerBootstrap;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelFactory;
@@ -54,8 +54,12 @@ public boolean start() throws IOException {
 		InetSocketAddress address = new InetSocketAddress(serverInetAddress, port);
 		ThreadRenamingRunnable.setThreadNameDeterminer(ThreadNameDeterminer.CURRENT);
 		ChannelFactory factory = new NioServerSocketChannelFactory(
+			Executors.newCachedThreadPool(
+				new SimpleThreadFactory("HTTPv2 Request Handler", "Netty boss group")
+			),
+			Executors.newCachedThreadPool(
+				new SimpleThreadFactory("HTTPv2 Request Worker", "Netty worker group")
+			)
 		);
 
 		bootstrap = new ServerBootstrap(factory);
@@ -103,53 +107,4 @@ public synchronized void stop() {
 		LOGGER.info("HTTP server stopped");
 	}
 
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>359892</refactoring_id><commit_sha>6ee1e6415123793f4c0119ecb5588a26f5b28002</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/6ee1e6415123793f4c0119ecb5588a26f5b28002</commit_link><file_path>community/shell/src/test/java/org/neo4j/shell/TestRmiPublication.java</file_path><description>Rename Variable propsFile : File to configFile : File in method public createDefaultConfigFile(path String) : File from class org.neo4j.shell.TestRmiPublication</description><code_before>@@ -19,36 +19,37 @@
  */
 package org.neo4j.shell;
 
-import org.junit.Rule;
-import org.junit.Test;
-
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.lang.reflect.Field;
 import java.util.Properties;
 
 import org.neo4j.graphdb.factory.GraphDatabaseSettings;
 import org.neo4j.test.ProcessStreamHandler;
 import org.neo4j.test.TargetDirectory;
 
 import static java.lang.Runtime.getRuntime;
 import static java.lang.System.getProperty;
 import static org.junit.Assert.assertEquals;
 
 public class TestRmiPublication
 {
-    public static File createDefaultPropertiesFile( String path ) throws IOException
     {
-        File propsFile = new File( path, "neo4j.conf" );
         Properties config = new Properties();
         config.setProperty( GraphDatabaseSettings.pagecache_memory.name(), "8m" );
-        try ( Writer writer = new FileWriter( propsFile ) )
         {
             config.store( writer, "" );
         }
-        return propsFile;
     }
 
     @Test
</code_before><code_after>@@ -19,36 +19,37 @@
  */
 package org.neo4j.shell;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.lang.reflect.Field;
 import java.util.Properties;
 
+import org.junit.Rule;
+import org.junit.Test;
+
 import org.neo4j.graphdb.factory.GraphDatabaseSettings;
 import org.neo4j.test.ProcessStreamHandler;
 import org.neo4j.test.TargetDirectory;
 
 import static java.lang.Runtime.getRuntime;
 import static java.lang.System.getProperty;
+
 import static org.junit.Assert.assertEquals;
 
 public class TestRmiPublication
 {
+    public static File createDefaultConfigFile( String path ) throws IOException
     {
+        File configFile = new File( path, "neo4j.conf" );
         Properties config = new Properties();
         config.setProperty( GraphDatabaseSettings.pagecache_memory.name(), "8m" );
+        try ( Writer writer = new FileWriter( configFile ) )
         {
             config.store( writer, "" );
         }
+        return configFile;
     }
 
     @Test
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>392629</refactoring_id><commit_sha>5afe552d82f6950854ce0a225a16041f134e40fb</commit_sha><commit_link>https://github.com/spring-projects/spring-integration/commit/5afe552d82f6950854ce0a225a16041f134e40fb</commit_link><file_path>spring-integration-core/src/main/java/org/springframework/integration/core/MessagingTemplate.java</file_path><description>Rename Variable message : Message&lt;?&gt; to requestMessage : Message&lt;?&gt; in method public convertSendAndReceive(channelName String, request Object) : Object from class org.springframework.integration.core.MessagingTemplate</description><code_before>@@ -244,6 +244,30 @@ public &lt;T&gt; void convertAndSend(String channelName, T object) {
 		}
 	}
 
 	public &lt;P&gt; Message&lt;P&gt; receive() {
 		MessageChannel channel = this.getRequiredDefaultChannel();
 		Assert.state(channel instanceof PollableChannel,
@@ -312,15 +336,36 @@ public Object convertSendAndReceive(final Object request) {
 	}
 
 	public Object convertSendAndReceive(final MessageChannel channel, final Object request) {
-		Message&lt;?&gt; message = this.messageConverter.toMessage(request);
-		Message&lt;?&gt; reply = this.sendAndReceive(channel, message);
-		return this.messageConverter.fromMessage(reply);
 	}
 
 	public Object convertSendAndReceive(final String channelName, final Object request) {
-		Message&lt;?&gt; message = this.messageConverter.toMessage(request);
-		Message&lt;?&gt; reply = this.sendAndReceive(channelName, message);
-		return this.messageConverter.fromMessage(reply);
 	}
 
 	private void doSend(MessageChannel channel, Message&lt;?&gt; message) {
</code_before><code_after>@@ -244,6 +244,30 @@ public &lt;T&gt; void convertAndSend(String channelName, T object) {
 		}
 	}
 
+	public &lt;T&gt; void convertAndSend(T object, MessagePostProcessor postProcessor) {
+		Message&lt;?&gt; message = this.messageConverter.toMessage(object);
+		message = postProcessor.postProcessMessage(message);
+		if (message != null) {
+			this.send(message);
+		}
+	}
+
+	public &lt;T&gt; void convertAndSend(MessageChannel channel, T object, MessagePostProcessor postProcessor) {
+		Message&lt;?&gt; message = this.messageConverter.toMessage(object);
+		message = postProcessor.postProcessMessage(message);
+		if (message != null) {
+			this.send(channel, message);
+		}
+	}
+
+	public &lt;T&gt; void convertAndSend(String channelName, T object, MessagePostProcessor postProcessor) {
+		Message&lt;?&gt; message = this.messageConverter.toMessage(object);
+		message = postProcessor.postProcessMessage(message);
+		if (message != null) {
+			this.send(channelName, message);
+		}
+	}
+
 	public &lt;P&gt; Message&lt;P&gt; receive() {
 		MessageChannel channel = this.getRequiredDefaultChannel();
 		Assert.state(channel instanceof PollableChannel,
@@ -312,15 +336,36 @@ public Object convertSendAndReceive(final Object request) {
 	}
 
 	public Object convertSendAndReceive(final MessageChannel channel, final Object request) {
+		Message&lt;?&gt; requestMessage = this.messageConverter.toMessage(request);
+		Message&lt;?&gt; replyMessage = this.sendAndReceive(channel, requestMessage);
+		return this.messageConverter.fromMessage(replyMessage);
 	}
 
 	public Object convertSendAndReceive(final String channelName, final Object request) {
+		Message&lt;?&gt; requestMessage = this.messageConverter.toMessage(request);
+		Message&lt;?&gt; replyMessage = this.sendAndReceive(channelName, requestMessage);
+		return this.messageConverter.fromMessage(replyMessage);
+	}
+
+	public Object convertSendAndReceive(final Object request, MessagePostProcessor requestPostProcessor) {
+		Message&lt;?&gt; requestMessage = this.messageConverter.toMessage(request);
+		requestMessage = requestPostProcessor.postProcessMessage(requestMessage);
+		Message&lt;?&gt; replyMessage = this.sendAndReceive(requestMessage);
+		return this.messageConverter.fromMessage(replyMessage);
+	}
+
+	public Object convertSendAndReceive(final MessageChannel channel, final Object request, MessagePostProcessor requestPostProcessor) {
+		Message&lt;?&gt; requestMessage = this.messageConverter.toMessage(request);
+		requestMessage = requestPostProcessor.postProcessMessage(requestMessage);
+		Message&lt;?&gt; replyMessage = this.sendAndReceive(channel, requestMessage);
+		return this.messageConverter.fromMessage(replyMessage);
+	}
+
+	public Object convertSendAndReceive(final String channelName, final Object request, MessagePostProcessor requestPostProcessor) {
+		Message&lt;?&gt; requestMessage = this.messageConverter.toMessage(request);
+		requestMessage = requestPostProcessor.postProcessMessage(requestMessage);
+		Message&lt;?&gt; replyMessage = this.sendAndReceive(channelName, requestMessage);
+		return this.messageConverter.fromMessage(replyMessage);
 	}
 
 	private void doSend(MessageChannel channel, Message&lt;?&gt; message) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>350912</refactoring_id><commit_sha>ed2daaaa7057872d32007364e6e5b8150c341f1d</commit_sha><commit_link>https://github.com/apache/pinot/commit/ed2daaaa7057872d32007364e6e5b8150c341f1d</commit_link><file_path>pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java</file_path><description>Rename Variable intermediateResultToMerge : Object to resultToMerge : Object in method private mergeResultMap(mergedResultMap Map&lt;String,Object&gt;, ResultMapToMerge Map&lt;String,Object&gt;, aggregationFunction AggregationFunction) : void from class org.apache.pinot.core.query.reduce.GroupByDataTableReducer</description><code_before>@@ -35,12 +35,14 @@
 import org.apache.pinot.common.response.broker.ResultTable;
 import org.apache.pinot.common.utils.DataSchema;
 import org.apache.pinot.common.utils.DataTable;
 import org.apache.pinot.core.data.table.ConcurrentIndexedTable;
 import org.apache.pinot.core.data.table.IndexedTable;
 import org.apache.pinot.core.data.table.Record;
 import org.apache.pinot.core.query.aggregation.function.AggregationFunction;
 import org.apache.pinot.core.query.aggregation.function.AggregationFunctionUtils;
 import org.apache.pinot.core.query.aggregation.groupby.AggregationGroupByTrimmingService;
 import org.apache.pinot.core.query.request.context.ExpressionContext;
 import org.apache.pinot.core.query.request.context.FunctionContext;
 import org.apache.pinot.core.query.request.context.QueryContext;
@@ -413,24 +415,26 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, Collec
     // Merge results from all data tables.
     String[] columnNames = new String[_numAggregationFunctions];
     Map&lt;String, Object&gt;[] intermediateResultMaps = new Map[_numAggregationFunctions];
-    for (DataTable dataTable : dataTables) {
-      for (int i = 0; i &lt; _numAggregationFunctions; i++) {
-        if (columnNames[i] == null) {
-          columnNames[i] = dataTable.getString(i, 0);
-          intermediateResultMaps[i] = dataTable.getObject(i, 1);
-        } else {
-          Map&lt;String, Object&gt; mergedIntermediateResultMap = intermediateResultMaps[i];
-          Map&lt;String, Object&gt; intermediateResultMapToMerge = dataTable.getObject(i, 1);
-          for (Map.Entry&lt;String, Object&gt; entry : intermediateResultMapToMerge.entrySet()) {
-            String groupKey = entry.getKey();
-            Object intermediateResultToMerge = entry.getValue();
-            if (mergedIntermediateResultMap.containsKey(groupKey)) {
-              Object mergedIntermediateResult = mergedIntermediateResultMap.get(groupKey);
-              mergedIntermediateResultMap
-                  .put(groupKey, _aggregationFunctions[i].merge(mergedIntermediateResult, intermediateResultToMerge));
-            } else {
-              mergedIntermediateResultMap.put(groupKey, intermediateResultToMerge);
-            }
           }
         }
       }
@@ -450,7 +454,7 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, Collec
 
     // Trim the final result maps and set them into the broker response.
     AggregationGroupByTrimmingService aggregationGroupByTrimmingService =
-        new AggregationGroupByTrimmingService(_aggregationFunctions, _queryContext.getLimit());
     List&lt;GroupByResult&gt;[] groupByResultLists = aggregationGroupByTrimmingService.trimFinalResults(finalResultMaps);
 
     if (_responseFormatSql) {
@@ -488,4 +492,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, Collec
       brokerResponseNative.setAggregationResults(aggregationResults);
     }
   }
 }
</code_before><code_after>@@ -35,12 +35,14 @@
 import org.apache.pinot.common.response.broker.ResultTable;
 import org.apache.pinot.common.utils.DataSchema;
 import org.apache.pinot.common.utils.DataTable;
+import org.apache.pinot.common.utils.HashUtil;
 import org.apache.pinot.core.data.table.ConcurrentIndexedTable;
 import org.apache.pinot.core.data.table.IndexedTable;
 import org.apache.pinot.core.data.table.Record;
 import org.apache.pinot.core.query.aggregation.function.AggregationFunction;
 import org.apache.pinot.core.query.aggregation.function.AggregationFunctionUtils;
 import org.apache.pinot.core.query.aggregation.groupby.AggregationGroupByTrimmingService;
+import org.apache.pinot.core.query.aggregation.groupby.GroupKeyGenerator;
 import org.apache.pinot.core.query.request.context.ExpressionContext;
 import org.apache.pinot.core.query.request.context.FunctionContext;
 import org.apache.pinot.core.query.request.context.QueryContext;
@@ -413,24 +415,26 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, Collec
     // Merge results from all data tables.
     String[] columnNames = new String[_numAggregationFunctions];
     Map&lt;String, Object&gt;[] intermediateResultMaps = new Map[_numAggregationFunctions];
+    if (_numGroupByExpressions == 1) {
+      for (DataTable dataTable : dataTables) {
+        for (int i = 0; i &lt; _numAggregationFunctions; i++) {
+          if (columnNames[i] == null) {
+            columnNames[i] = dataTable.getString(i, 0);
+            intermediateResultMaps[i] = dataTable.getObject(i, 1);
+          } else {
+            mergeResultMap(intermediateResultMaps[i], dataTable.getObject(i, 1), _aggregationFunctions[i]);
+          }
+        }
+      }
+    } else {
+      for (DataTable dataTable : dataTables) {
+        for (int i = 0; i &lt; _numAggregationFunctions; i++) {
+          if (columnNames[i] == null) {
+            columnNames[i] = dataTable.getString(i, 0);
+            intermediateResultMaps[i] = convertLegacyGroupKeyDelimiter(dataTable.getObject(i, 1));
+          } else {
+            mergeResultMap(intermediateResultMaps[i], convertLegacyGroupKeyDelimiter(dataTable.getObject(i, 1)),
+                _aggregationFunctions[i]);
           }
         }
       }
@@ -450,7 +454,7 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, Collec
 
     // Trim the final result maps and set them into the broker response.
     AggregationGroupByTrimmingService aggregationGroupByTrimmingService =
+        new AggregationGroupByTrimmingService(_queryContext);
     List&lt;GroupByResult&gt;[] groupByResultLists = aggregationGroupByTrimmingService.trimFinalResults(finalResultMaps);
 
     if (_responseFormatSql) {
@@ -488,4 +492,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, Collec
       brokerResponseNative.setAggregationResults(aggregationResults);
     }
   }
+
+  /**
+   * Helper method to merge 2 intermediate result maps.
+   */
+  private void mergeResultMap(Map&lt;String, Object&gt; mergedResultMap, Map&lt;String, Object&gt; ResultMapToMerge,
+      AggregationFunction aggregationFunction) {
+    for (Map.Entry&lt;String, Object&gt; entry : ResultMapToMerge.entrySet()) {
+      String groupKey = entry.getKey();
+      Object resultToMerge = entry.getValue();
+      mergedResultMap.compute(groupKey, (k, v) -&gt; {
+        if (v == null) {
+          return resultToMerge;
+        } else {
+          return aggregationFunction.merge(v, resultToMerge);
+        }
+      });
+    }
+  }
+
+  /**
+   * Helper method to convert the result map with legacy group key delimiter to the new delimiter for
+   * backward-compatibility.
+   */
+  private Map&lt;String, Object&gt; convertLegacyGroupKeyDelimiter(Map&lt;String, Object&gt; resultMap) {
+    assert _numGroupByExpressions &gt; 1;
+    if (resultMap.isEmpty()) {
+      return resultMap;
+    }
+    String sampleKey = resultMap.keySet().iterator().next();
+    if (sampleKey.indexOf(GroupKeyGenerator.DELIMITER) != -1) {
+      // Already using the new delimiter, no need to convert
+      return resultMap;
+    }
+    Map&lt;String, Object&gt; convertedResultMap = new HashMap&lt;&gt;(HashUtil.getHashMapCapacity(resultMap.size()));
+    for (Map.Entry&lt;String, Object&gt; entry : resultMap.entrySet()) {
+      convertedResultMap.put(entry.getKey().replace(GroupKeyGenerator.LEGACY_DELIMITER, GroupKeyGenerator.DELIMITER),
+          entry.getValue());
+    }
+    return convertedResultMap;
+  }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>348744</refactoring_id><commit_sha>01de707ee0f6f47cfcb576f0e82e0c65ed8e418a</commit_sha><commit_link>https://github.com/cgeo/cgeo/commit/01de707ee0f6f47cfcb576f0e82e0c65ed8e418a</commit_link><file_path>main/src/cgeo/geocaching/ui/AbstractUserClickListener.java</file_path><description>Rename Variable context : AbstractActivity to activity : AbstractActivity in method private showUserActionsDialog(userName String, view View) : void from class cgeo.geocaching.ui.AbstractUserClickListener</description><code_before>@@ -1,102 +1,66 @@
 package cgeo.geocaching.ui;
 
-import cgeo.contacts.IContacts;
-import cgeo.geocaching.CacheListActivity;
 import cgeo.geocaching.R;
 import cgeo.geocaching.activity.AbstractActivity;
-import cgeo.geocaching.network.Network;
-import cgeo.geocaching.network.Parameters;
-import cgeo.geocaching.utils.ProcessUtils;
 
 import android.app.AlertDialog;
 import android.content.DialogInterface;
-import android.content.Intent;
 import android.content.res.Resources;
-import android.net.Uri;
 import android.view.View;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 abstract class AbstractUserClickListener implements View.OnClickListener {
 
-    private final boolean enabled;
 
-    public AbstractUserClickListener(final boolean enabled) {
-        this.enabled = enabled;
     }
 
     @Override
     public void onClick(View view) {
         if (view == null) {
             return;
         }
-        if (!enabled) {
-            return;
-        }
 
         showUserActionsDialog(getUserName(view), view);
     }
 
-    protected abstract CharSequence getUserName(View view);
 
     /**
      * Opens a dialog to do actions on an user name
      */
-    protected static void showUserActionsDialog(final CharSequence name, final View view) {
-        final AbstractActivity context = (AbstractActivity) view.getContext();
-        final Resources res = context.getResources();
-        List&lt;String&gt; actions = new ArrayList&lt;String&gt;(Arrays.asList(res.getString(R.string.user_menu_view_hidden),
-                res.getString(R.string.user_menu_view_found),
-                res.getString(R.string.user_menu_open_browser),
-                res.getString(R.string.user_menu_send_message)));
-        if (isContactsAddonAvailable()) {
-            actions.add(res.getString(R.string.user_menu_open_contact));
         }
-        final CharSequence[] items = actions.toArray(new String[actions.size()]);
 
-        final AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        builder.setTitle(res.getString(R.string.user_menu_title) + " " + name);
         builder.setItems(items, new DialogInterface.OnClickListener() {
             @Override
             public void onClick(DialogInterface dialog, int item) {
-                switch (item) {
-                    case 0:
-                        CacheListActivity.startActivityOwner(context, name.toString());
-                        return;
-                    case 1:
-                        CacheListActivity.startActivityUserName(context, name.toString());
-                        return;
-                    case 2:
-                        context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/profile/?u=" + Network.encode(name.toString()))));
-                        return;
-                    case 3:
-                        context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/email/?u=" + Network.encode(name.toString()))));
-                        return;
-                    case 4:
-                        openContactCard(context, name.toString());
-                        return;
-                    default:
-                        break;
-                }
             }
         });
         final AlertDialog alert = builder.create();
         alert.show();
     }
 
-    protected static void openContactCard(AbstractActivity context, String userName) {
-        final Parameters params = new Parameters(
-                IContacts.PARAM_NAME, userName
-                );
-
-        context.startActivity(new Intent(IContacts.INTENT,
-                Uri.parse(IContacts.URI_SCHEME + "://" + IContacts.URI_HOST + "?" + params.toString())));
-    }
-
-    private static boolean isContactsAddonAvailable() {
-        return ProcessUtils.isIntentAvailable(IContacts.INTENT, Uri.parse(IContacts.URI_SCHEME + "://" + IContacts.URI_HOST));
-    }
-
 }
</code_before><code_after>@@ -1,102 +1,66 @@
 package cgeo.geocaching.ui;
 
 import cgeo.geocaching.R;
 import cgeo.geocaching.activity.AbstractActivity;
+import cgeo.geocaching.connector.UserAction;
+import cgeo.geocaching.connector.UserAction.Context;
+
+import org.eclipse.jdt.annotation.NonNull;
 
 import android.app.AlertDialog;
 import android.content.DialogInterface;
 import android.content.res.Resources;
 import android.view.View;
 
 import java.util.ArrayList;
 import java.util.List;
 
 abstract class AbstractUserClickListener implements View.OnClickListener {
 
+    private final List&lt;UserAction&gt; userActions;
 
+    public AbstractUserClickListener(final @NonNull List&lt;UserAction&gt; userActions) {
+        this.userActions = userActions;
     }
 
     @Override
     public void onClick(View view) {
         if (view == null) {
             return;
         }
 
         showUserActionsDialog(getUserName(view), view);
     }
 
+    protected abstract String getUserName(View view);
 
     /**
      * Opens a dialog to do actions on an user name
      */
+    private void showUserActionsDialog(final String userName, final View view) {
+        if (userActions.isEmpty()) {
+            return;
+        }
+
+        final AbstractActivity activity = (AbstractActivity) view.getContext();
+        final Resources res = activity.getResources();
+
+        ArrayList&lt;String&gt; labels = new ArrayList&lt;String&gt;(userActions.size());
+        for (UserAction action : userActions) {
+            labels.add(res.getString(action.displayResourceId));
         }
+        final CharSequence[] items = labels.toArray(new String[labels.size()]);
 
+        final AlertDialog.Builder builder = new AlertDialog.Builder(activity);
+        builder.setTitle(res.getString(R.string.user_menu_title) + " " + userName);
         builder.setItems(items, new DialogInterface.OnClickListener() {
             @Override
             public void onClick(DialogInterface dialog, int item) {
+                userActions.get(item).run(new Context(userName, activity));
             }
         });
         final AlertDialog alert = builder.create();
         alert.show();
     }
 
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>365430</refactoring_id><commit_sha>8893250ba00b29db619895fea308437980f7e08a</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/8893250ba00b29db619895fea308437980f7e08a</commit_link><file_path>src/main/java/mekanism/common/inventory/container/sync/dynamic/SyncMapper.java</file_path><description>Rename Variable setter : MethodHandle to setterMH : MethodHandle in method public createSetter(field Field, objType Class&lt;?&gt;, setterName String) : BiConsumer&lt;O,V&gt; from class mekanism.common.util.LambdaMetaFactoryUtil</description><code_before>@@ -4,11 +4,6 @@
 import com.google.common.collect.Multimap;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import java.lang.annotation.ElementType;
-import java.lang.invoke.CallSite;
-import java.lang.invoke.LambdaMetafactory;
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.MethodType;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -43,6 +38,7 @@
 import mekanism.common.inventory.container.sync.SyncableEnum;
 import mekanism.common.lib.math.voxel.VoxelCuboid;
 import mekanism.common.network.container.property.PropertyType;
 import net.minecraft.util.math.BlockPos;
 import net.minecraftforge.fluids.FluidStack;
 import net.minecraftforge.fluids.IFluidTank;
@@ -54,7 +50,6 @@
 public class SyncMapper {
 
     public static final String DEFAULT_TAG = "default";
-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
     private static final List&lt;SpecialPropertyHandler&lt;?&gt;&gt; specialProperties = new ArrayList&lt;&gt;();
     private static final Map&lt;Class&lt;?&gt;, PropertyDataClassCache&gt; syncablePropertyMap = new Object2ObjectOpenHashMap&lt;&gt;();
 
@@ -144,11 +139,11 @@ private static void collectScanDataUnsafe() throws Throwable {
                         PropertyType type = PropertyType.getFromType(field.getType());
                         String setterName = (String) annotationData.getOrDefault("setter", "");
                         if (type != null) {
-                            newField = new PropertyField(new TrackedFieldData(createGetter(field, annotatedClass, getterName),
-                                  createSetter(field, annotatedClass, setterName), type));
                         } else if (field.getType().isEnum()) {
-                            newField = new PropertyField(new EnumFieldData(createGetter(field, annotatedClass, getterName),
-                                  createSetter(field, annotatedClass, setterName), field.getType()));
                         } else {
                             Mekanism.logger.error("Attempted to sync an invalid field '{}'", fieldName);
                             return;
@@ -240,7 +235,7 @@ private static &lt;O&gt; PropertyField createSpecialProperty(SpecialPropertyHandler&lt;O&gt;
         PropertyField ret = new PropertyField();
         for (SpecialPropertyData&lt;O&gt; data : handler.specialData) {
             // create a getter for the actual property field itself
-            Function&lt;Object, O&gt; fieldGetter = createGetter(field, objType, getterName);
             // create a new tracked field
             TrackedFieldData trackedField = TrackedFieldData.create(data.propertyType, obj -&gt; data.get(fieldGetter.apply(obj)), (obj, val) -&gt; data.set(fieldGetter.apply(obj), val));
             if (trackedField != null) {
@@ -250,38 +245,6 @@ private static &lt;O&gt; PropertyField createSpecialProperty(SpecialPropertyHandler&lt;O&gt;
         return ret;
     }
 
-    private static &lt;O, V&gt; Function&lt;O, V&gt; createGetter(Field field, Class&lt;?&gt; objType, String getterName) throws Throwable {
-        if (getterName.isEmpty()) {
-            MethodHandle getter = LOOKUP.unreflectGetter(field);
-            MethodType type = getter.type();
-            if (field.getType().isPrimitive()) {
-                type = type.wrap().dropParameterTypes(0, 0);
-            }
-            CallSite site = LambdaMetafactory.metafactory(LOOKUP, "apply", MethodType.methodType(Function.class, MethodHandle.class), type.erase(), MethodHandles.exactInvoker(getter.type()), type);
-            return (Function&lt;O, V&gt;) site.getTarget().invokeExact(getter);
-        } else {
-            CallSite site = LambdaMetafactory.metafactory(LOOKUP, "apply", MethodType.methodType(Function.class), MethodType.methodType(Object.class, Object.class),
-                  LOOKUP.findVirtual(objType, getterName, MethodType.methodType(field.getType())), MethodType.methodType(field.getType(), objType));
-            return (Function&lt;O, V&gt;) site.getTarget().invokeExact();
-        }
-    }
-
-    private static &lt;O, V&gt; BiConsumer&lt;O, V&gt; createSetter(Field field, Class&lt;?&gt; objType, String setterName) throws Throwable {
-        if (setterName.isEmpty()) {
-            MethodHandle setter = LOOKUP.unreflectSetter(field);
-            MethodType type = setter.type();
-            if (field.getType().isPrimitive()) {
-                type = type.wrap().changeReturnType(void.class);
-            }
-            CallSite site = LambdaMetafactory.metafactory(LOOKUP, "accept", MethodType.methodType(BiConsumer.class, MethodHandle.class), type.erase(), MethodHandles.exactInvoker(setter.type()), type);
-            return (BiConsumer&lt;O, V&gt;) site.getTarget().invokeExact(setter);
-        } else {
-            CallSite site = LambdaMetafactory.metafactory(LOOKUP, "accept", MethodType.methodType(BiConsumer.class), MethodType.methodType(void.class, Object.class, Object.class),
-                  LOOKUP.findVirtual(objType, setterName, MethodType.methodType(void.class, field.getType())), MethodType.methodType(void.class, objType, field.getType()));
-            return (BiConsumer&lt;O, V&gt;) site.getTarget().invokeExact();
-        }
-    }
-
     private static class PropertyDataClassCache {
 
         //Note: This needs to be a linked map to ensure that the order is preserved
</code_before><code_after>@@ -4,11 +4,6 @@
 import com.google.common.collect.Multimap;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import java.lang.annotation.ElementType;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -43,6 +38,7 @@
 import mekanism.common.inventory.container.sync.SyncableEnum;
 import mekanism.common.lib.math.voxel.VoxelCuboid;
 import mekanism.common.network.container.property.PropertyType;
+import mekanism.common.util.LambdaMetaFactoryUtil;
 import net.minecraft.util.math.BlockPos;
 import net.minecraftforge.fluids.FluidStack;
 import net.minecraftforge.fluids.IFluidTank;
@@ -54,7 +50,6 @@
 public class SyncMapper {
 
     public static final String DEFAULT_TAG = "default";
     private static final List&lt;SpecialPropertyHandler&lt;?&gt;&gt; specialProperties = new ArrayList&lt;&gt;();
     private static final Map&lt;Class&lt;?&gt;, PropertyDataClassCache&gt; syncablePropertyMap = new Object2ObjectOpenHashMap&lt;&gt;();
 
@@ -144,11 +139,11 @@ private static void collectScanDataUnsafe() throws Throwable {
                         PropertyType type = PropertyType.getFromType(field.getType());
                         String setterName = (String) annotationData.getOrDefault("setter", "");
                         if (type != null) {
+                            newField = new PropertyField(new TrackedFieldData(LambdaMetaFactoryUtil.createGetter(field, annotatedClass, getterName),
+                                  LambdaMetaFactoryUtil.createSetter(field, annotatedClass, setterName), type));
                         } else if (field.getType().isEnum()) {
+                            newField = new PropertyField(new EnumFieldData(LambdaMetaFactoryUtil.createGetter(field, annotatedClass, getterName),
+                                  LambdaMetaFactoryUtil.createSetter(field, annotatedClass, setterName), field.getType()));
                         } else {
                             Mekanism.logger.error("Attempted to sync an invalid field '{}'", fieldName);
                             return;
@@ -240,7 +235,7 @@ private static &lt;O&gt; PropertyField createSpecialProperty(SpecialPropertyHandler&lt;O&gt;
         PropertyField ret = new PropertyField();
         for (SpecialPropertyData&lt;O&gt; data : handler.specialData) {
             // create a getter for the actual property field itself
+            Function&lt;Object, O&gt; fieldGetter = LambdaMetaFactoryUtil.createGetter(field, objType, getterName);
             // create a new tracked field
             TrackedFieldData trackedField = TrackedFieldData.create(data.propertyType, obj -&gt; data.get(fieldGetter.apply(obj)), (obj, val) -&gt; data.set(fieldGetter.apply(obj), val));
             if (trackedField != null) {
@@ -250,38 +245,6 @@ private static &lt;O&gt; PropertyField createSpecialProperty(SpecialPropertyHandler&lt;O&gt;
         return ret;
     }
 
     private static class PropertyDataClassCache {
 
         //Note: This needs to be a linked map to ensure that the order is preserved
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>380057</refactoring_id><commit_sha>bedf680dab9f9cc2b827a276983eb4d3f93d60c8</commit_sha><commit_link>https://github.com/camunda/camunda/commit/bedf680dab9f9cc2b827a276983eb4d3f93d60c8</commit_link><file_path>backend/src/main/java/org/camunda/optimize/service/es/report/command/modules/group_by/process/ProcessGroupByUserTask.java</file_path><description>Rename Variable userTaskKey : String to flowNodeKey : String in method public addQueryResult(compositeCommandResult CompositeCommandResult, response SearchResponse, context ExecutionContext&lt;ProcessReportDataDto&gt;) : void from class org.camunda.optimize.service.es.report.command.modules.group_by.process.ProcessGroupByFlowNode</description><code_before>@@ -12,6 +12,7 @@
 import org.camunda.optimize.dto.optimize.query.report.single.process.group.FlowNodesGroupByDto;
 import org.camunda.optimize.service.es.reader.ProcessDefinitionReader;
 import org.camunda.optimize.service.es.report.command.exec.ExecutionContext;
 import org.camunda.optimize.service.es.report.command.modules.result.CompositeCommandResult;
 import org.camunda.optimize.service.es.report.command.modules.result.CompositeCommandResult.DistributedByResult;
 import org.camunda.optimize.service.util.configuration.ConfigurationService;
@@ -45,7 +46,7 @@
 @RequiredArgsConstructor
 @Component
 @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
-public class ProcessGroupByUserTask extends ProcessGroupByPart {
 
   private static final String USER_TASK_ID_TERMS_AGGREGATION = "tasks";
   private static final String USER_TASKS_AGGREGATION = "userTasks";
@@ -79,9 +80,9 @@ public List&lt;AggregationBuilder&gt; createAggregation(final SearchSourceBuilder sear
     return Collections.singletonList(groupByAssigneeAggregation);
   }
 
-  @Override
-  public CompositeCommandResult retrieveQueryResult(final SearchResponse response,
-                                                    final ExecutionContext&lt;ProcessReportDataDto&gt; context) {
 
     final Aggregations aggregations = response.getAggregations();
     final Nested userTasks = aggregations.get(USER_TASKS_AGGREGATION);
@@ -108,11 +109,8 @@ public CompositeCommandResult retrieveQueryResult(final SearchResponse response,
       groupedData.add(emptyResult);
     });
 
-    CompositeCommandResult compositeCommandResult = new CompositeCommandResult();
     compositeCommandResult.setGroups(groupedData);
     compositeCommandResult.setIsComplete(byTaskIdAggregation.getSumOfOtherDocCounts() == 0L);
-
-    return compositeCommandResult;
   }
 
   private Map&lt;String, String&gt; getUserTaskNames(final ProcessReportDataDto reportData) {
</code_before><code_after>@@ -12,6 +12,7 @@
 import org.camunda.optimize.dto.optimize.query.report.single.process.group.FlowNodesGroupByDto;
 import org.camunda.optimize.service.es.reader.ProcessDefinitionReader;
 import org.camunda.optimize.service.es.report.command.exec.ExecutionContext;
+import org.camunda.optimize.service.es.report.command.modules.group_by.GroupByPart;
 import org.camunda.optimize.service.es.report.command.modules.result.CompositeCommandResult;
 import org.camunda.optimize.service.es.report.command.modules.result.CompositeCommandResult.DistributedByResult;
 import org.camunda.optimize.service.util.configuration.ConfigurationService;
@@ -45,7 +46,7 @@
 @RequiredArgsConstructor
 @Component
 @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
+public class ProcessGroupByUserTask extends GroupByPart&lt;ProcessReportDataDto&gt; {
 
   private static final String USER_TASK_ID_TERMS_AGGREGATION = "tasks";
   private static final String USER_TASKS_AGGREGATION = "userTasks";
@@ -79,9 +80,9 @@ public List&lt;AggregationBuilder&gt; createAggregation(final SearchSourceBuilder sear
     return Collections.singletonList(groupByAssigneeAggregation);
   }
 
+  public void addQueryResult(final CompositeCommandResult compositeCommandResult,
+                             final SearchResponse response,
+                             final ExecutionContext&lt;ProcessReportDataDto&gt; context) {
 
     final Aggregations aggregations = response.getAggregations();
     final Nested userTasks = aggregations.get(USER_TASKS_AGGREGATION);
@@ -108,11 +109,8 @@ public CompositeCommandResult retrieveQueryResult(final SearchResponse response,
       groupedData.add(emptyResult);
     });
 
     compositeCommandResult.setGroups(groupedData);
     compositeCommandResult.setIsComplete(byTaskIdAggregation.getSumOfOtherDocCounts() == 0L);
   }
 
   private Map&lt;String, String&gt; getUserTaskNames(final ProcessReportDataDto reportData) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>355371</refactoring_id><commit_sha>70290819f83da07f76c2e5d70513a09ef6fd4f52</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/70290819f83da07f76c2e5d70513a09ef6fd4f52</commit_link><file_path>controller-server/src/main/java/com/yahoo/vespa/hosted/controller/persistence/ApplicationSerializer.java</file_path><description>Rename Variable pemDeployKeys : Set&lt;String&gt; to deployKeys : Set&lt;PublicKey&gt; in method public fromSlime(slime Slime) : Application from class com.yahoo.vespa.hosted.controller.persistence.ApplicationSerializer</description><code_before>@@ -1,14 +1,13 @@
 // Copyright 2018 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
 package com.yahoo.vespa.hosted.controller.persistence;
 
-import com.google.common.collect.BiMap;
-import com.google.common.collect.ImmutableBiMap;
 import com.yahoo.component.Version;
 import com.yahoo.config.application.api.DeploymentSpec;
 import com.yahoo.config.application.api.ValidationOverrides;
 import com.yahoo.config.provision.ClusterSpec;
 import com.yahoo.config.provision.InstanceName;
 import com.yahoo.config.provision.zone.ZoneId;
 import com.yahoo.slime.ArrayTraverser;
 import com.yahoo.slime.Cursor;
 import com.yahoo.slime.Inspector;
@@ -21,7 +20,6 @@
 import com.yahoo.vespa.hosted.controller.api.integration.deployment.SourceRevision;
 import com.yahoo.vespa.hosted.controller.api.integration.organization.IssueId;
 import com.yahoo.vespa.hosted.controller.api.integration.organization.User;
-import com.yahoo.vespa.hosted.controller.api.role.SimplePrincipal;
 import com.yahoo.vespa.hosted.controller.application.AssignedRotation;
 import com.yahoo.vespa.hosted.controller.application.Change;
 import com.yahoo.vespa.hosted.controller.application.ClusterInfo;
@@ -39,7 +37,7 @@
 import com.yahoo.vespa.hosted.controller.rotation.RotationState;
 import com.yahoo.vespa.hosted.controller.rotation.RotationStatus;
 
-import java.security.Principal;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -54,7 +52,6 @@
 import java.util.OptionalLong;
 import java.util.Set;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 /**
  * Serializes {@link Application}s to/from slime.
@@ -192,7 +189,7 @@ public Slime toSlime(Application application) {
         application.majorVersion().ifPresent(majorVersion -&gt; root.setLong(majorVersionField, majorVersion));
         root.setDouble(queryQualityField, application.metrics().queryServiceQuality());
         root.setDouble(writeQualityField, application.metrics().writeServiceQuality());
-        deployKeysToSlime(application.pemDeployKeys().stream(), root.setArray(pemDeployKeysField));
         instancesToSlime(application, root.setArray(instancesField));
         return slime;
     }
@@ -208,8 +205,8 @@ private void instancesToSlime(Application application, Cursor array) {
         }
     }
 
-    private void deployKeysToSlime(Stream&lt;String&gt; pemDeployKeys, Cursor array) {
-        pemDeployKeys.forEach(array::addString);
     }
 
     private void deploymentsToSlime(Collection&lt;Deployment&gt; deployments, Cursor array) {
@@ -384,14 +381,14 @@ public Application fromSlime(Slime slime) {
         OptionalInt majorVersion = Serializers.optionalInteger(root.field(majorVersionField));
         ApplicationMetrics metrics = new ApplicationMetrics(root.field(queryQualityField).asDouble(),
                                                             root.field(writeQualityField).asDouble());
-        Set&lt;String&gt; pemDeployKeys = pemDeployKeysFromSlime(root.field(pemDeployKeysField));
         List&lt;Instance&gt; instances = instancesFromSlime(id, deploymentSpec, root.field(instancesField));
         OptionalLong projectId = Serializers.optionalLong(root.field(projectIdField));
         boolean builtInternally = root.field(builtInternallyField).asBool();
 
         return new Application(id, createdAt, deploymentSpec, validationOverrides, deploying, outstandingChange,
                                deploymentIssueId, ownershipIssueId, owner, majorVersion, metrics,
-                               pemDeployKeys, projectId, builtInternally, instances);
     }
 
     private List&lt;Instance&gt; instancesFromSlime(TenantAndApplicationId id, DeploymentSpec deploymentSpec, Inspector field) {
@@ -411,9 +408,9 @@ private List&lt;Instance&gt; instancesFromSlime(TenantAndApplicationId id, DeploymentS
         return instances;
     }
 
-    private Set&lt;String&gt; pemDeployKeysFromSlime(Inspector array) {
-        Set&lt;String&gt; keys = new LinkedHashSet&lt;&gt;();
-        array.traverse((ArrayTraverser) (__, key) -&gt; keys.add(key.asString()));
         return keys;
     }
 
</code_before><code_after>@@ -1,14 +1,13 @@
 // Copyright 2018 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
 package com.yahoo.vespa.hosted.controller.persistence;
 
 import com.yahoo.component.Version;
 import com.yahoo.config.application.api.DeploymentSpec;
 import com.yahoo.config.application.api.ValidationOverrides;
 import com.yahoo.config.provision.ClusterSpec;
 import com.yahoo.config.provision.InstanceName;
 import com.yahoo.config.provision.zone.ZoneId;
+import com.yahoo.security.KeyUtils;
 import com.yahoo.slime.ArrayTraverser;
 import com.yahoo.slime.Cursor;
 import com.yahoo.slime.Inspector;
@@ -21,7 +20,6 @@
 import com.yahoo.vespa.hosted.controller.api.integration.deployment.SourceRevision;
 import com.yahoo.vespa.hosted.controller.api.integration.organization.IssueId;
 import com.yahoo.vespa.hosted.controller.api.integration.organization.User;
 import com.yahoo.vespa.hosted.controller.application.AssignedRotation;
 import com.yahoo.vespa.hosted.controller.application.Change;
 import com.yahoo.vespa.hosted.controller.application.ClusterInfo;
@@ -39,7 +37,7 @@
 import com.yahoo.vespa.hosted.controller.rotation.RotationState;
 import com.yahoo.vespa.hosted.controller.rotation.RotationStatus;
 
+import java.security.PublicKey;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -54,7 +52,6 @@
 import java.util.OptionalLong;
 import java.util.Set;
 import java.util.stream.Collectors;
 
 /**
  * Serializes {@link Application}s to/from slime.
@@ -192,7 +189,7 @@ public Slime toSlime(Application application) {
         application.majorVersion().ifPresent(majorVersion -&gt; root.setLong(majorVersionField, majorVersion));
         root.setDouble(queryQualityField, application.metrics().queryServiceQuality());
         root.setDouble(writeQualityField, application.metrics().writeServiceQuality());
+        deployKeysToSlime(application.deployKeys(), root.setArray(pemDeployKeysField));
         instancesToSlime(application, root.setArray(instancesField));
         return slime;
     }
@@ -208,8 +205,8 @@ private void instancesToSlime(Application application, Cursor array) {
         }
     }
 
+    private void deployKeysToSlime(Set&lt;PublicKey&gt; deployKeys, Cursor array) {
+        deployKeys.forEach(key -&gt; array.addString(KeyUtils.toPem(key)));
     }
 
     private void deploymentsToSlime(Collection&lt;Deployment&gt; deployments, Cursor array) {
@@ -384,14 +381,14 @@ public Application fromSlime(Slime slime) {
         OptionalInt majorVersion = Serializers.optionalInteger(root.field(majorVersionField));
         ApplicationMetrics metrics = new ApplicationMetrics(root.field(queryQualityField).asDouble(),
                                                             root.field(writeQualityField).asDouble());
+        Set&lt;PublicKey&gt; deployKeys = deployKeysFromSlime(root.field(pemDeployKeysField));
         List&lt;Instance&gt; instances = instancesFromSlime(id, deploymentSpec, root.field(instancesField));
         OptionalLong projectId = Serializers.optionalLong(root.field(projectIdField));
         boolean builtInternally = root.field(builtInternallyField).asBool();
 
         return new Application(id, createdAt, deploymentSpec, validationOverrides, deploying, outstandingChange,
                                deploymentIssueId, ownershipIssueId, owner, majorVersion, metrics,
+                               deployKeys, projectId, builtInternally, instances);
     }
 
     private List&lt;Instance&gt; instancesFromSlime(TenantAndApplicationId id, DeploymentSpec deploymentSpec, Inspector field) {
@@ -411,9 +408,9 @@ private List&lt;Instance&gt; instancesFromSlime(TenantAndApplicationId id, DeploymentS
         return instances;
     }
 
+    private Set&lt;PublicKey&gt; deployKeysFromSlime(Inspector array) {
+        Set&lt;PublicKey&gt; keys = new LinkedHashSet&lt;&gt;();
+        array.traverse((ArrayTraverser) (__, key) -&gt; keys.add(KeyUtils.fromPemEncodedPublicKey(key.asString())));
         return keys;
     }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>344575</refactoring_id><commit_sha>58af06b0c5e9e5b58b8d0d3f7872a22c2e6741db</commit_sha><commit_link>https://github.com/spotbugs/spotbugs/commit/58af06b0c5e9e5b58b8d0d3f7872a22c2e6741db</commit_link><file_path>spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/Issue2547Test.java</file_path><description>Rename Variable bugTypeMatcher : BugInstanceMatcher to matcher : BugInstanceMatcher in method protected assertBugInMethodAtLine(bugType String, className String, method String, line int) : void from class edu.umd.cs.findbugs.AbstractIntegrationTest</description><code_before>@@ -1,15 +1,8 @@
 package edu.umd.cs.findbugs.detect;
 
 import edu.umd.cs.findbugs.AbstractIntegrationTest;
-import edu.umd.cs.findbugs.test.matcher.BugInstanceMatcher;
-import edu.umd.cs.findbugs.test.matcher.BugInstanceMatcherBuilder;
 import org.junit.jupiter.api.Test;
 
-import static edu.umd.cs.findbugs.test.CountMatcher.containsExactly;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.hasItem;
-
-
 /**
  * @see &lt;a href="https://github.com/spotbugs/spotbugs/issues/2547"&gt;GitHub issue #2547&lt;/a&gt;
  */
@@ -21,25 +14,8 @@ void testIssue() {
                 "ghIssues/issue2547/MyEx.class",
                 "ghIssues/issue2547/ExceptionFactory.class");
 
-        assertBug(2);
-        assertBug("notThrowingExCtor", 15);
-        assertBug("notThrowingExCtorCaller", 26);
-    }
-
-    private void assertBug(int num) {
-        BugInstanceMatcher bugTypeMatcher = new BugInstanceMatcherBuilder()
-                .bugType("RV_EXCEPTION_NOT_THROWN")
-                .build();
-        assertThat(getBugCollection(), containsExactly(num, bugTypeMatcher));
-    }
-
-    private void assertBug(String method, int line) {
-        BugInstanceMatcher bugTypeMatcher = new BugInstanceMatcherBuilder()
-                .bugType("RV_EXCEPTION_NOT_THROWN")
-                .inClass("Issue2547")
-                .inMethod(method)
-                .atLine(line)
-                .build();
-        assertThat(getBugCollection(), hasItem(bugTypeMatcher));
     }
 }
</code_before><code_after>@@ -1,15 +1,8 @@
 package edu.umd.cs.findbugs.detect;
 
 import edu.umd.cs.findbugs.AbstractIntegrationTest;
 import org.junit.jupiter.api.Test;
 
 /**
  * @see &lt;a href="https://github.com/spotbugs/spotbugs/issues/2547"&gt;GitHub issue #2547&lt;/a&gt;
  */
@@ -21,25 +14,8 @@ void testIssue() {
                 "ghIssues/issue2547/MyEx.class",
                 "ghIssues/issue2547/ExceptionFactory.class");
 
+        assertBugTypeCount("RV_EXCEPTION_NOT_THROWN", 2);
+        assertBugInMethodAtLine("RV_EXCEPTION_NOT_THROWN", "Issue2547", "notThrowingExCtor", 15);
+        assertBugInMethodAtLine("RV_EXCEPTION_NOT_THROWN", "Issue2547", "notThrowingExCtorCaller", 26);
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>437190</refactoring_id><commit_sha>e50d6af12fabac98e3cb4bd589e2b92212b041f4</commit_sha><commit_link>https://github.com/apache/cassandra/commit/e50d6af12fabac98e3cb4bd589e2b92212b041f4</commit_link><file_path>src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java</file_path><description>Rename Variable sortedColumns : Collection&lt;Column&gt; to sortedCells : Collection&lt;Cell&gt; in method protected computeNext() : Row from class org.apache.cassandra.db.index.keys.KeysSearcher.getIndexedIterator.new ColumnFamilyStore.AbstractScanIterator</description><code_before>@@ -87,7 +87,7 @@ private ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final Extended
         return new ColumnFamilyStore.AbstractScanIterator()
         {
             private Composite lastSeenKey = startKey;
-            private Iterator&lt;Column&gt; indexColumns;
             private int columnsRead = Integer.MAX_VALUE;
 
             protected Row computeNext()
@@ -124,19 +124,19 @@ protected Row computeNext()
                             return endOfData();
                         }
 
-                        Collection&lt;Column&gt; sortedColumns = indexRow.getSortedColumns();
-                        columnsRead = sortedColumns.size();
-                        indexColumns = sortedColumns.iterator();
-                        Column firstColumn = sortedColumns.iterator().next();
 
                         // Paging is racy, so it is possible the first column of a page is not the last seen one.
-                        if (lastSeenKey != startKey &amp;&amp; lastSeenKey.equals(firstColumn.name()))
                         {
                             // skip the row we already saw w/ the last page of results
                             indexColumns.next();
-                            logger.trace("Skipping {}", baseCfs.metadata.getKeyValidator().getString(firstColumn.name().toByteBuffer()));
                         }
-                        else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstColumn.name().equals(startKey))
                         {
                             // skip key excluded by range
                             indexColumns.next();
@@ -146,11 +146,11 @@ else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstColumn.name().
 
                     while (indexColumns.hasNext())
                     {
-                        Column column = indexColumns.next();
-                        lastSeenKey = column.name();
-                        if (column.isMarkedForDelete(filter.timestamp))
                         {
-                            logger.trace("skipping {}", column.name());
                             continue;
                         }
 
@@ -168,7 +168,7 @@ else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstColumn.name().
 
                         logger.trace("Returning index hit for {}", dk);
                         ColumnFamily data = baseCfs.getColumnFamily(new QueryFilter(dk, baseCfs.name, filter.columnFilter(lastSeenKey.toByteBuffer()), filter.timestamp));
-                        // While the column family we'll get in the end should contains the primary clause column, the initialFilter may not have found it and can thus be null
                         if (data == null)
                             data = TreeMapBackedSortedColumns.factory.create(baseCfs.metadata);
 
@@ -185,8 +185,8 @@ else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstColumn.name().
                         if (((KeysIndex)index).isIndexEntryStale(indexKey.key, data, filter.timestamp))
                         {
                             // delete the index entry w/ its own timestamp
-                            Column dummyColumn = new Column(primaryColumn, indexKey.key, column.timestamp());
-                            ((PerColumnSecondaryIndex)index).delete(dk.key, dummyColumn);
                             continue;
                         }
                         return new Row(dk, data);
</code_before><code_after>@@ -87,7 +87,7 @@ private ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final Extended
         return new ColumnFamilyStore.AbstractScanIterator()
         {
             private Composite lastSeenKey = startKey;
+            private Iterator&lt;Cell&gt; indexColumns;
             private int columnsRead = Integer.MAX_VALUE;
 
             protected Row computeNext()
@@ -124,19 +124,19 @@ protected Row computeNext()
                             return endOfData();
                         }
 
+                        Collection&lt;Cell&gt; sortedCells = indexRow.getSortedColumns();
+                        columnsRead = sortedCells.size();
+                        indexColumns = sortedCells.iterator();
+                        Cell firstCell = sortedCells.iterator().next();
 
                         // Paging is racy, so it is possible the first column of a page is not the last seen one.
+                        if (lastSeenKey != startKey &amp;&amp; lastSeenKey.equals(firstCell.name()))
                         {
                             // skip the row we already saw w/ the last page of results
                             indexColumns.next();
+                            logger.trace("Skipping {}", baseCfs.metadata.getKeyValidator().getString(firstCell.name().toByteBuffer()));
                         }
+                        else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstCell.name().equals(startKey))
                         {
                             // skip key excluded by range
                             indexColumns.next();
@@ -146,11 +146,11 @@ else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstColumn.name().
 
                     while (indexColumns.hasNext())
                     {
+                        Cell cell = indexColumns.next();
+                        lastSeenKey = cell.name();
+                        if (cell.isMarkedForDelete(filter.timestamp))
                         {
+                            logger.trace("skipping {}", cell.name());
                             continue;
                         }
 
@@ -168,7 +168,7 @@ else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstColumn.name().
 
                         logger.trace("Returning index hit for {}", dk);
                         ColumnFamily data = baseCfs.getColumnFamily(new QueryFilter(dk, baseCfs.name, filter.columnFilter(lastSeenKey.toByteBuffer()), filter.timestamp));
+                        // While the column family we'll get in the end should contains the primary clause cell, the initialFilter may not have found it and can thus be null
                         if (data == null)
                             data = TreeMapBackedSortedColumns.factory.create(baseCfs.metadata);
 
@@ -185,8 +185,8 @@ else if (range instanceof Range &amp;&amp; indexColumns.hasNext() &amp;&amp; firstColumn.name().
                         if (((KeysIndex)index).isIndexEntryStale(indexKey.key, data, filter.timestamp))
                         {
                             // delete the index entry w/ its own timestamp
+                            Cell dummyCell = new Cell(primaryColumn, indexKey.key, cell.timestamp());
+                            ((PerColumnSecondaryIndex)index).delete(dk.key, dummyCell);
                             continue;
                         }
                         return new Row(dk, data);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>382485</refactoring_id><commit_sha>6d1104372142898f7d46fa72265473d06e1eb959</commit_sha><commit_link>https://github.com/apache/ignite/commit/6d1104372142898f7d46fa72265473d06e1eb959</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/managers/discovery/GridDiscoveryManager.java</file_path><description>Rename Variable predicate : CachePredicate to pred : CachePredicate in method public cacheClientNode(node ClusterNode, cacheName String) : boolean from class org.apache.ignite.internal.managers.discovery.GridDiscoveryManager</description><code_before>@@ -214,6 +214,7 @@ private MemoryUsage nonHeapMemoryUsage() {
      *
      * @param cacheName Cache name.
      * @param filter Cache filter.
      * @param loc {@code True} if cache is local.
      */
     public void setCacheFilter(
@@ -240,12 +241,13 @@ public void removeCacheFilter(String cacheName) {
      *
      * @param cacheName Cache name.
      * @param clientNodeId Near node ID.
      */
     public void addClientNode(String cacheName, UUID clientNodeId, boolean nearEnabled) {
-        CachePredicate predicate = registeredCaches.get(cacheName);
 
-        if (predicate != null)
-            predicate.addClientNode(clientNodeId, nearEnabled);
     }
 
     /**
@@ -1256,9 +1258,9 @@ public Collection&lt;ClusterNode&gt; cacheAffinityNodes(@Nullable String cacheName, Af
      * @return {@code True} if node is a cache data node.
      */
     public boolean cacheAffinityNode(ClusterNode node, String cacheName) {
-        CachePredicate predicate = registeredCaches.get(cacheName);
 
-        return predicate != null &amp;&amp; predicate.dataNode(node);
     }
 
     /**
@@ -1267,9 +1269,9 @@ public boolean cacheAffinityNode(ClusterNode node, String cacheName) {
      * @return {@code True} if node has near cache enabled.
      */
     public boolean cacheNearNode(ClusterNode node, String cacheName) {
-        CachePredicate predicate = registeredCaches.get(cacheName);
 
-        return predicate != null &amp;&amp; predicate.nearNode(node);
     }
 
     /**
@@ -1278,9 +1280,9 @@ public boolean cacheNearNode(ClusterNode node, String cacheName) {
      * @return {@code True} if node has client cache (without near cache).
      */
     public boolean cacheClientNode(ClusterNode node, String cacheName) {
-        CachePredicate predicate = registeredCaches.get(cacheName);
 
-        return predicate != null &amp;&amp; predicate.clientNode(node);
     }
 
     /**
@@ -1289,9 +1291,9 @@ public boolean cacheClientNode(ClusterNode node, String cacheName) {
      * @return If cache with the given name is accessible on the given node.
      */
     public boolean cacheNode(ClusterNode node, String cacheName) {
-        CachePredicate predicate = registeredCaches.get(cacheName);
 
-        return predicate != null &amp;&amp; predicate.cacheNode(node);
     }
 
     /**
@@ -2480,11 +2482,12 @@ private static class CachePredicate {
         private boolean loc;
 
         /** Collection of client near nodes. */
-        private Map&lt;UUID, Boolean&gt; clientNodes;
 
         /**
          * @param cacheFilter Cache filter.
          * @param nearEnabled Near enabled flag.
          */
         private CachePredicate(IgnitePredicate&lt;ClusterNode&gt; cacheFilter, boolean nearEnabled, boolean loc) {
             assert cacheFilter != null;
@@ -2498,9 +2501,10 @@ private CachePredicate(IgnitePredicate&lt;ClusterNode&gt; cacheFilter, boolean nearEna
 
         /**
          * @param nodeId Near node ID to add.
          */
         public void addClientNode(UUID nodeId, boolean nearEnabled) {
-            clientNodes.put(nodeId, nearEnabled);
         }
 
         /**
@@ -2515,16 +2519,15 @@ public void onNodeLeft(UUID leftNodeId) {
          * @return {@code True} if this node is a data node for given cache.
          */
         public boolean dataNode(ClusterNode node) {
-            return !node.isDaemon() &amp;&amp; !CU.clientModeNode(node) &amp;&amp; cacheFilter.apply(node);
         }
 
         /**
          * @param node Node to check.
          * @return {@code True} if cache is accessible on the given node.
          */
         public boolean cacheNode(ClusterNode node) {
-            return !node.isDaemon() &amp;&amp;
-                ((!CU.clientModeNode(node) &amp;&amp; cacheFilter.apply(node)) || clientNodes.containsKey(node.id()));
         }
 
         /**
@@ -2535,7 +2538,7 @@ public boolean nearNode(ClusterNode node) {
             if (node.isDaemon())
                 return false;
 
-            if (nearEnabled &amp;&amp; cacheFilter.apply(node))
                 return true;
 
             Boolean near = clientNodes.get(node.id());
</code_before><code_after>@@ -214,6 +214,7 @@ private MemoryUsage nonHeapMemoryUsage() {
      *
      * @param cacheName Cache name.
      * @param filter Cache filter.
+     * @param nearEnabled Near enabled flag.
      * @param loc {@code True} if cache is local.
      */
     public void setCacheFilter(
@@ -240,12 +241,13 @@ public void removeCacheFilter(String cacheName) {
      *
      * @param cacheName Cache name.
      * @param clientNodeId Near node ID.
+     * @param nearEnabled Near enabled flag.
      */
     public void addClientNode(String cacheName, UUID clientNodeId, boolean nearEnabled) {
+        CachePredicate pred = registeredCaches.get(cacheName);
 
+        if (pred != null)
+            pred.addClientNode(clientNodeId, nearEnabled);
     }
 
     /**
@@ -1256,9 +1258,9 @@ public Collection&lt;ClusterNode&gt; cacheAffinityNodes(@Nullable String cacheName, Af
      * @return {@code True} if node is a cache data node.
      */
     public boolean cacheAffinityNode(ClusterNode node, String cacheName) {
+        CachePredicate pred = registeredCaches.get(cacheName);
 
+        return pred != null &amp;&amp; pred.dataNode(node);
     }
 
     /**
@@ -1267,9 +1269,9 @@ public boolean cacheAffinityNode(ClusterNode node, String cacheName) {
      * @return {@code True} if node has near cache enabled.
      */
     public boolean cacheNearNode(ClusterNode node, String cacheName) {
+        CachePredicate pred = registeredCaches.get(cacheName);
 
+        return pred != null &amp;&amp; pred.nearNode(node);
     }
 
     /**
@@ -1278,9 +1280,9 @@ public boolean cacheNearNode(ClusterNode node, String cacheName) {
      * @return {@code True} if node has client cache (without near cache).
      */
     public boolean cacheClientNode(ClusterNode node, String cacheName) {
+        CachePredicate pred = registeredCaches.get(cacheName);
 
+        return pred != null &amp;&amp; pred.clientNode(node);
     }
 
     /**
@@ -1289,9 +1291,9 @@ public boolean cacheClientNode(ClusterNode node, String cacheName) {
      * @return If cache with the given name is accessible on the given node.
      */
     public boolean cacheNode(ClusterNode node, String cacheName) {
+        CachePredicate pred = registeredCaches.get(cacheName);
 
+        return pred != null &amp;&amp; pred.cacheNode(node);
     }
 
     /**
@@ -2480,11 +2482,12 @@ private static class CachePredicate {
         private boolean loc;
 
         /** Collection of client near nodes. */
+        private ConcurrentHashMap&lt;UUID, Boolean&gt; clientNodes;
 
         /**
          * @param cacheFilter Cache filter.
          * @param nearEnabled Near enabled flag.
+         * @param loc {@code True} if cache is local.
          */
         private CachePredicate(IgnitePredicate&lt;ClusterNode&gt; cacheFilter, boolean nearEnabled, boolean loc) {
             assert cacheFilter != null;
@@ -2498,9 +2501,10 @@ private CachePredicate(IgnitePredicate&lt;ClusterNode&gt; cacheFilter, boolean nearEna
 
         /**
          * @param nodeId Near node ID to add.
+         * @param nearEnabled Near enabled flag.
          */
         public void addClientNode(UUID nodeId, boolean nearEnabled) {
+            clientNodes.putIfAbsent(nodeId, nearEnabled);
         }
 
         /**
@@ -2515,16 +2519,15 @@ public void onNodeLeft(UUID leftNodeId) {
          * @return {@code True} if this node is a data node for given cache.
          */
         public boolean dataNode(ClusterNode node) {
+            return !node.isDaemon() &amp;&amp; CU.affinityNode(node, cacheFilter);
         }
 
         /**
          * @param node Node to check.
          * @return {@code True} if cache is accessible on the given node.
          */
         public boolean cacheNode(ClusterNode node) {
+            return !node.isDaemon() &amp;&amp; (CU.affinityNode(node, cacheFilter) || clientNodes.containsKey(node.id()));
         }
 
         /**
@@ -2535,7 +2538,7 @@ public boolean nearNode(ClusterNode node) {
             if (node.isDaemon())
                 return false;
 
+            if (nearEnabled &amp;&amp; CU.affinityNode(node, cacheFilter))
                 return true;
 
             Boolean near = clientNodes.get(node.id());
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>379906</refactoring_id><commit_sha>a13e6af42e08f47e9954ef0dfb2a35d32fa69de2</commit_sha><commit_link>https://github.com/camunda/camunda/commit/a13e6af42e08f47e9954ef0dfb2a35d32fa69de2</commit_link><file_path>backend/src/main/java/org/camunda/optimize/rest/WebhookRestService.java</file_path><description>Rename Variable sortedWebhookNames : List&lt;String&gt; to sortedWebhooksList : List&lt;String&gt; in method private getConfiguredWebhooks() : List&lt;String&gt; from class org.camunda.optimize.service.UIConfigurationService</description><code_before>@@ -1,42 +0,0 @@
-/*
- * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
- * under one or more contributor license agreements. Licensed under a commercial license.
- * You may not use this file except in compliance with the commercial license.
- */
-package org.camunda.optimize.rest;
-
-import com.google.common.collect.Lists;
-import lombok.AllArgsConstructor;
-import lombok.extern.slf4j.Slf4j;
-import org.camunda.optimize.rest.providers.Secured;
-import org.camunda.optimize.service.security.SessionService;
-import org.camunda.optimize.service.util.configuration.ConfigurationService;
-import org.springframework.stereotype.Component;
-
-import javax.ws.rs.GET;
-import javax.ws.rs.Path;
-import javax.ws.rs.Produces;
-import javax.ws.rs.container.ContainerRequestContext;
-import javax.ws.rs.core.Context;
-import javax.ws.rs.core.MediaType;
-import java.util.Comparator;
-import java.util.List;
-
-@AllArgsConstructor
-@Slf4j
-@Secured
-@Path("/webhooks")
-@Component
-public class WebhookRestService {
-  private final SessionService sessionService;
-  private final ConfigurationService configurationService;
-
-  @GET
-  @Produces(MediaType.APPLICATION_JSON)
-  @Path("/")
-  public List&lt;String&gt; getAllWebhookNames(@Context ContainerRequestContext requestContext) {
-    List&lt;String&gt; sortedWebhookNames = Lists.newArrayList(configurationService.getConfiguredWebhooks().keySet());
-    sortedWebhookNames.sort(Comparator.naturalOrder());
-    return sortedWebhookNames;
-  }
-}
</code_before><code_after>@@ -1,42 +0,0 @@
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>456650</refactoring_id><commit_sha>63ce4bd8b84418b454d03ee21e14973007de320e</commit_sha><commit_link>https://github.com/robolectric/robolectric/commit/63ce4bd8b84418b454d03ee21e14973007de320e</commit_link><file_path>robolectric/src/main/java/org/robolectric/internal/dependency/MavenDependencyResolver.java</file_path><description>Rename Variable sonatypeRepository : RemoteRepository to remoteRepository : RemoteRepository in method public getLocalArtifactUrls(dependencies DependencyJar...) : URL[] from class org.robolectric.internal.dependency.MavenDependencyResolver</description><code_before>@@ -16,7 +16,8 @@ public class MavenDependencyResolver implements DependencyResolver {
   private final String repositoryId;
 
   public MavenDependencyResolver() {
-    this("https://oss.sonatype.org/content/groups/public/", "sonatype");
   }
 
   public MavenDependencyResolver(String repositoryUrl, String repositoryId) {
@@ -32,10 +33,10 @@ public MavenDependencyResolver(String repositoryUrl, String repositoryId) {
   public URL[] getLocalArtifactUrls(DependencyJar... dependencies) {
     DependenciesTask dependenciesTask = new DependenciesTask();
     configureMaven(dependenciesTask);
-    RemoteRepository sonatypeRepository = new RemoteRepository();
-    sonatypeRepository.setUrl(repositoryUrl);
-    sonatypeRepository.setId(repositoryId);
-    dependenciesTask.addConfiguredRemoteRepository(sonatypeRepository);
     dependenciesTask.setProject(project);
     for (DependencyJar dependencyJar : dependencies) {
       Dependency dependency = new Dependency();
</code_before><code_after>@@ -16,7 +16,8 @@ public class MavenDependencyResolver implements DependencyResolver {
   private final String repositoryId;
 
   public MavenDependencyResolver() {
+    this(System.getProperty("robolectric.dependency.repo.url", "https://oss.sonatype.org/content/groups/public/"),
+        System.getProperty("robolectric.dependency.repo.id", "sonatype"));
   }
 
   public MavenDependencyResolver(String repositoryUrl, String repositoryId) {
@@ -32,10 +33,10 @@ public MavenDependencyResolver(String repositoryUrl, String repositoryId) {
   public URL[] getLocalArtifactUrls(DependencyJar... dependencies) {
     DependenciesTask dependenciesTask = new DependenciesTask();
     configureMaven(dependenciesTask);
+    RemoteRepository remoteRepository = new RemoteRepository();
+    remoteRepository.setUrl(repositoryUrl);
+    remoteRepository.setId(repositoryId);
+    dependenciesTask.addConfiguredRemoteRepository(remoteRepository);
     dependenciesTask.setProject(project);
     for (DependencyJar dependencyJar : dependencies) {
       Dependency dependency = new Dependency();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>408851</refactoring_id><commit_sha>48a5938cd4dcbfcf8198b08cf078a774f8ba6b1f</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/48a5938cd4dcbfcf8198b08cf078a774f8ba6b1f</commit_link><file_path>spring-webmvc/src/main/java/org/springframework/web/servlet/support/AbstractFlashMapManager.java</file_path><description>Rename Variable queryString : String to query : String in method private getOriginatingRequestParams(request HttpServletRequest) : MultiValueMap&lt;String,String&gt; from class org.springframework.web.servlet.support.AbstractFlashMapManager</description><code_before>@@ -33,7 +33,6 @@
 import org.springframework.util.StringUtils;
 import org.springframework.web.servlet.FlashMap;
 import org.springframework.web.servlet.FlashMapManager;
-import org.springframework.web.util.UriComponents;
 import org.springframework.web.util.UrlPathHelper;
 
 
@@ -167,15 +166,13 @@ private FlashMap getMatchingFlashMap(List&lt;FlashMap&gt; allMaps, HttpServletRequest
 	 */
 	protected boolean isFlashMapForRequest(FlashMap flashMap, HttpServletRequest request) {
 		String expectedPath = flashMap.getTargetRequestPath();
-		String requestUri = getUrlPathHelper().getOriginatingRequestUri(request);
 		if (expectedPath != null) {
 			if (!requestUri.equals(expectedPath) &amp;&amp; !requestUri.equals(expectedPath + "/")) {
 				return false;
 			}
 		}
-		String queryString = getUrlPathHelper().getOriginatingQueryString(request);
-		UriComponents uriComponents = ServletUriComponentsBuilder.fromUriString(requestUri).query(queryString).build();
-		MultiValueMap&lt;String, String&gt; actualParams = uriComponents.getQueryParams();
 		MultiValueMap&lt;String, String&gt; expectedParams = flashMap.getTargetRequestParams();
 		for (String expectedName : expectedParams.keySet()) {
 			List&lt;String&gt; actualValues = actualParams.get(expectedName);
@@ -191,6 +188,11 @@ protected boolean isFlashMapForRequest(FlashMap flashMap, HttpServletRequest req
 		return true;
 	}
 
 	@Override
 	public final void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response) {
 		if (CollectionUtils.isEmpty(flashMap)) {
</code_before><code_after>@@ -33,7 +33,6 @@
 import org.springframework.util.StringUtils;
 import org.springframework.web.servlet.FlashMap;
 import org.springframework.web.servlet.FlashMapManager;
 import org.springframework.web.util.UrlPathHelper;
 
 
@@ -167,15 +166,13 @@ private FlashMap getMatchingFlashMap(List&lt;FlashMap&gt; allMaps, HttpServletRequest
 	 */
 	protected boolean isFlashMapForRequest(FlashMap flashMap, HttpServletRequest request) {
 		String expectedPath = flashMap.getTargetRequestPath();
 		if (expectedPath != null) {
+			String requestUri = getUrlPathHelper().getOriginatingRequestUri(request);
 			if (!requestUri.equals(expectedPath) &amp;&amp; !requestUri.equals(expectedPath + "/")) {
 				return false;
 			}
 		}
+		MultiValueMap&lt;String, String&gt; actualParams = getOriginatingRequestParams(request);
 		MultiValueMap&lt;String, String&gt; expectedParams = flashMap.getTargetRequestParams();
 		for (String expectedName : expectedParams.keySet()) {
 			List&lt;String&gt; actualValues = actualParams.get(expectedName);
@@ -191,6 +188,11 @@ protected boolean isFlashMapForRequest(FlashMap flashMap, HttpServletRequest req
 		return true;
 	}
 
+	private MultiValueMap&lt;String, String&gt; getOriginatingRequestParams(HttpServletRequest request) {
+		String query = getUrlPathHelper().getOriginatingQueryString(request);
+		return ServletUriComponentsBuilder.fromPath("/").query(query).build().getQueryParams();
+	}
+
 	@Override
 	public final void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response) {
 		if (CollectionUtils.isEmpty(flashMap)) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>423557</refactoring_id><commit_sha>457369b7b43021c26a77f0b91ba8b6c640776abd</commit_sha><commit_link>https://github.com/apache/logging-log4j2/commit/457369b7b43021c26a77f0b91ba8b6c640776abd</commit_link><file_path>log4j-core/src/main/java/org/apache/logging/log4j/core/async/DisruptorUtil.java</file_path><description>Rename Variable cls : String to handler : ExceptionHandler&lt;AsyncLoggerConfigDisruptor.Log4jEventWrapper&gt; in method package getAsyncLoggerConfigExceptionHandler() : ExceptionHandler&lt;AsyncLoggerConfigDisruptor.Log4jEventWrapper&gt; from class org.apache.logging.log4j.core.async.DisruptorUtil</description><code_before>@@ -26,6 +26,7 @@
 import org.apache.logging.log4j.core.util.Integers;
 import org.apache.logging.log4j.core.util.Loader;
 import org.apache.logging.log4j.status.StatusLogger;
 import org.apache.logging.log4j.util.PropertiesUtil;
 
 /**
@@ -36,6 +37,8 @@ final class DisruptorUtil {
     private static final int RINGBUFFER_MIN_SIZE = 128;
     private static final int RINGBUFFER_DEFAULT_SIZE = 256 * 1024;
     private static final int RINGBUFFER_NO_GC_DEFAULT_SIZE = 4 * 1024;
 
     /**
      * LOG4J2-2606: Users encountered excessive CPU utilization with Disruptor v3.4.2 when the application
@@ -82,35 +85,31 @@ static int calculateRingBufferSize(final String propertyName) {
     }
 
     static ExceptionHandler&lt;RingBufferLogEvent&gt; getAsyncLoggerExceptionHandler() {
-        final String cls = PropertiesUtil.getProperties().getStringProperty("AsyncLogger.ExceptionHandler");
-        if (cls == null) {
-            return new AsyncLoggerDefaultExceptionHandler();
-        }
         try {
-            @SuppressWarnings("unchecked")
-            final Class&lt;? extends ExceptionHandler&lt;RingBufferLogEvent&gt;&gt; klass =
-                (Class&lt;? extends ExceptionHandler&lt;RingBufferLogEvent&gt;&gt;) Loader.loadClass(cls);
-            return klass.newInstance();
-        } catch (final Exception ignored) {
-            LOGGER.debug("Invalid AsyncLogger.ExceptionHandler value: error creating {}: ", cls, ignored);
-            return new AsyncLoggerDefaultExceptionHandler();
         }
     }
 
     static ExceptionHandler&lt;AsyncLoggerConfigDisruptor.Log4jEventWrapper&gt; getAsyncLoggerConfigExceptionHandler() {
-        final String cls = PropertiesUtil.getProperties().getStringProperty("AsyncLoggerConfig.ExceptionHandler");
-        if (cls == null) {
-            return new AsyncLoggerConfigDefaultExceptionHandler();
-        }
         try {
-            @SuppressWarnings("unchecked")
-            final Class&lt;? extends ExceptionHandler&lt;AsyncLoggerConfigDisruptor.Log4jEventWrapper&gt;&gt; klass =
-                    (Class&lt;? extends ExceptionHandler&lt;AsyncLoggerConfigDisruptor.Log4jEventWrapper&gt;&gt;) Loader.loadClass(cls);
-            return klass.newInstance();
-        } catch (final Exception ignored) {
-            LOGGER.debug("Invalid AsyncLoggerConfig.ExceptionHandler value: error creating {}: ", cls, ignored);
-            return new AsyncLoggerConfigDefaultExceptionHandler();
         }
     }
 
     /**
</code_before><code_after>@@ -26,6 +26,7 @@
 import org.apache.logging.log4j.core.util.Integers;
 import org.apache.logging.log4j.core.util.Loader;
 import org.apache.logging.log4j.status.StatusLogger;
+import org.apache.logging.log4j.util.LoaderUtil;
 import org.apache.logging.log4j.util.PropertiesUtil;
 
 /**
@@ -36,6 +37,8 @@ final class DisruptorUtil {
     private static final int RINGBUFFER_MIN_SIZE = 128;
     private static final int RINGBUFFER_DEFAULT_SIZE = 256 * 1024;
     private static final int RINGBUFFER_NO_GC_DEFAULT_SIZE = 4 * 1024;
+    public static final String LOGGER_EXCEPTION_HANDLER_PROPERTY = "AsyncLogger.ExceptionHandler";
+    public static final String LOGGER_CONFIG_EXCEPTION_HANDLER_PROPERTY = "AsyncLoggerConfig.ExceptionHandler";
 
     /**
      * LOG4J2-2606: Users encountered excessive CPU utilization with Disruptor v3.4.2 when the application
@@ -82,35 +85,31 @@ static int calculateRingBufferSize(final String propertyName) {
     }
 
     static ExceptionHandler&lt;RingBufferLogEvent&gt; getAsyncLoggerExceptionHandler() {
+        ExceptionHandler&lt;RingBufferLogEvent&gt; handler = null;
         try {
+            handler =
+                    LoaderUtil.newCheckedInstanceOfProperty(LOGGER_EXCEPTION_HANDLER_PROPERTY, ExceptionHandler.class);
+        } catch (final ReflectiveOperationException e) {
+            LOGGER.debug("Invalid AsyncLogger.ExceptionHandler value: {}", e.getMessage(), e);
+        }
+        if (handler != null) {
+            return handler;
         }
+        return new AsyncLoggerDefaultExceptionHandler();
     }
 
     static ExceptionHandler&lt;AsyncLoggerConfigDisruptor.Log4jEventWrapper&gt; getAsyncLoggerConfigExceptionHandler() {
+        ExceptionHandler&lt;AsyncLoggerConfigDisruptor.Log4jEventWrapper&gt; handler = null;
         try {
+            handler = LoaderUtil.newCheckedInstanceOfProperty(
+                    LOGGER_CONFIG_EXCEPTION_HANDLER_PROPERTY, ExceptionHandler.class);
+        } catch (final ReflectiveOperationException e) {
+            LOGGER.debug("Invalid AsyncLogger.ExceptionHandler value: {}", e.getMessage(), e);
+        }
+        if (handler != null) {
+            return handler;
         }
+        return new AsyncLoggerConfigDefaultExceptionHandler();
     }
 
     /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>364064</refactoring_id><commit_sha>f21707b94e7980f5f6e8ad968725048c4ea280a1</commit_sha><commit_link>https://github.com/activiti/activiti/commit/f21707b94e7980f5f6e8ad968725048c4ea280a1</commit_link><file_path>activiti-spring-boot/spring-boot-starters/activiti-spring-boot-starter-hal-rest-api/src/test/java/org/activiti/runtime/events/SignalIT.java</file_path><description>Rename Variable signalInfo : SignalInfo to signalProcessInstanceCmd : SignalProcessInstanceCmd in method public processShouldTakeExceptionPathWhenSignalIsSent() : void from class org.activiti.runtime.events.SignalIT</description><code_before>@@ -20,8 +20,8 @@
 import java.util.Map;
 
 import org.activiti.client.model.ProcessInstance;
-import org.activiti.client.model.SignalInfo;
 import org.activiti.client.model.Task;
 import org.activiti.runtime.ProcessInstanceRestTemplate;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,7 +38,7 @@
 import org.springframework.test.context.junit4.SpringRunner;
 
 import static org.activiti.runtime.ProcessInstanceRestTemplate.PROCESS_INSTANCES_RELATIVE_URL;
-import static org.assertj.core.api.Assertions.assertThat;
 
 @RunWith(SpringRunner.class)
 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@@ -48,21 +48,20 @@ public class SignalIT {
     private TestRestTemplate restTemplate;
 
     @Autowired
-    private ProcessInstanceRestTemplate  processInstanceRestTemplate;
 
     @Test
     public void processShouldTakeExceptionPathWhenSignalIsSent() throws Exception {
         //given
         ResponseEntity&lt;ProcessInstance&gt; startProcessEntity = processInstanceRestTemplate.startProcess("ProcessWithBoundarySignal");
-        SignalInfo signalInfo = new SignalInfo();
-        signalInfo.setName("go");
 
         //when
-        ResponseEntity&lt;Void&gt; responseEntity = restTemplate.exchange(PROCESS_INSTANCES_RELATIVE_URL + "/send-signal",
-                                                              HttpMethod.POST,
-                                                              new HttpEntity&lt;&gt;(signalInfo),
-                                                              new ParameterizedTypeReference&lt;Void&gt;() {
-                                                              });
 
         //then
         assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -74,16 +73,16 @@ public void processShouldTakeExceptionPathWhenSignalIsSent() throws Exception {
     public void processShouldHaveVariablesSetWhenSignalCarriesVariables() throws Exception {
         //given
         ResponseEntity&lt;ProcessInstance&gt; startProcessEntity = processInstanceRestTemplate.startProcess("ProcessWithBoundarySignal");
-        SignalInfo signalInfo = new SignalInfo();
-        signalInfo.setName("go");
-        signalInfo.setInputVariables(Collections.singletonMap("myVar", "myContent"));
 
         //when
-        ResponseEntity&lt;Void&gt; responseEntity = restTemplate.exchange(PROCESS_INSTANCES_RELATIVE_URL + "/send-signal",
-                                                              HttpMethod.POST,
-                                                              new HttpEntity&lt;&gt;(signalInfo),
-                                                              new ParameterizedTypeReference&lt;Void&gt;() {
-                                                              });
 
         //then
         assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -92,8 +91,7 @@ public void processShouldHaveVariablesSetWhenSignalCarriesVariables() throws Exc
         assertThat(taskEntity.getBody().getContent()).extracting(Task::getName).containsExactly("Boundary target");
 
         ResponseEntity&lt;Resource&lt;Map&lt;String, Object&gt;&gt;&gt; variablesEntity = processInstanceRestTemplate.getVariables(startProcessEntity);
-        assertThat(variablesEntity.getBody().getContent()).containsEntry("myVar", "myContent");
     }
-
-
 }
</code_before><code_after>@@ -20,8 +20,8 @@
 import java.util.Map;
 
 import org.activiti.client.model.ProcessInstance;
 import org.activiti.client.model.Task;
+import org.activiti.client.model.commands.SignalProcessInstanceCmd;
 import org.activiti.runtime.ProcessInstanceRestTemplate;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,7 +38,7 @@
 import org.springframework.test.context.junit4.SpringRunner;
 
 import static org.activiti.runtime.ProcessInstanceRestTemplate.PROCESS_INSTANCES_RELATIVE_URL;
+import static org.assertj.core.api.Assertions.*;
 
 @RunWith(SpringRunner.class)
 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@@ -48,21 +48,20 @@ public class SignalIT {
     private TestRestTemplate restTemplate;
 
     @Autowired
+    private ProcessInstanceRestTemplate processInstanceRestTemplate;
 
     @Test
     public void processShouldTakeExceptionPathWhenSignalIsSent() throws Exception {
         //given
         ResponseEntity&lt;ProcessInstance&gt; startProcessEntity = processInstanceRestTemplate.startProcess("ProcessWithBoundarySignal");
+        SignalProcessInstanceCmd signalProcessInstanceCmd = new SignalProcessInstanceCmd("gp");
 
         //when
+        ResponseEntity&lt;Void&gt; responseEntity = restTemplate.exchange(PROCESS_INSTANCES_RELATIVE_URL + "/signal",
+                                                                    HttpMethod.POST,
+                                                                    new HttpEntity&lt;&gt;(signalProcessInstanceCmd),
+                                                                    new ParameterizedTypeReference&lt;Void&gt;() {
+                                                                    });
 
         //then
         assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -74,16 +73,16 @@ public void processShouldTakeExceptionPathWhenSignalIsSent() throws Exception {
     public void processShouldHaveVariablesSetWhenSignalCarriesVariables() throws Exception {
         //given
         ResponseEntity&lt;ProcessInstance&gt; startProcessEntity = processInstanceRestTemplate.startProcess("ProcessWithBoundarySignal");
+        SignalProcessInstanceCmd signalProcessInstanceCmd = new SignalProcessInstanceCmd("go",
+                                                                                         Collections.singletonMap("myVar",
+                                                                                                                  "myContent"));
 
         //when
+        ResponseEntity&lt;Void&gt; responseEntity = restTemplate.exchange(PROCESS_INSTANCES_RELATIVE_URL + "/signal",
+                                                                    HttpMethod.POST,
+                                                                    new HttpEntity&lt;&gt;(signalProcessInstanceCmd),
+                                                                    new ParameterizedTypeReference&lt;Void&gt;() {
+                                                                    });
 
         //then
         assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
@@ -92,8 +91,7 @@ public void processShouldHaveVariablesSetWhenSignalCarriesVariables() throws Exc
         assertThat(taskEntity.getBody().getContent()).extracting(Task::getName).containsExactly("Boundary target");
 
         ResponseEntity&lt;Resource&lt;Map&lt;String, Object&gt;&gt;&gt; variablesEntity = processInstanceRestTemplate.getVariables(startProcessEntity);
+        assertThat(variablesEntity.getBody().getContent()).containsEntry("myVar",
+                                                                         "myContent");
     }
 }
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>462046</refactoring_id><commit_sha>c4a7564c5ceb4741be827363aadfcbdbec54fd14</commit_sha><commit_link>https://github.com/oracle/graal/commit/c4a7564c5ceb4741be827363aadfcbdbec54fd14</commit_link><file_path>graal/com.oracle.graal.hotspot/src/com/oracle/graal/hotspot/stubs/Stub.java</file_path><description>Rename Variable cc : CallingConvention to incomingCc : CallingConvention in method public run() : void from class com.oracle.graal.hotspot.stubs.Stub.getCode.sandbox.new Runnable</description><code_before>@@ -154,8 +154,9 @@ public void run() {
                     PhasePlan phasePlan = new PhasePlan();
                     GraphBuilderPhase graphBuilderPhase = new GraphBuilderPhase(runtime, GraphBuilderConfiguration.getDefault(), OptimisticOptimizations.ALL);
                     phasePlan.addPhase(PhasePosition.AFTER_PARSING, graphBuilderPhase);
-                    CallingConvention cc = linkage.getCallingConvention();
-                    final CompilationResult compResult = GraalCompiler.compileGraph(graph, cc, getInstalledCodeOwner(), runtime, replacements, backend, runtime.getTarget(), null, phasePlan,
                                     OptimisticOptimizations.ALL, new SpeculationLog(), runtime.getDefaultSuites(), new CompilationResult());
 
                     assert destroyedRegisters != null;
</code_before><code_after>@@ -154,8 +154,9 @@ public void run() {
                     PhasePlan phasePlan = new PhasePlan();
                     GraphBuilderPhase graphBuilderPhase = new GraphBuilderPhase(runtime, GraphBuilderConfiguration.getDefault(), OptimisticOptimizations.ALL);
                     phasePlan.addPhase(PhasePosition.AFTER_PARSING, graphBuilderPhase);
+                    // The stub itself needs the incoming calling convention.
+                    CallingConvention incomingCc = linkage.getIncomingCallingConvention();
+                    final CompilationResult compResult = GraalCompiler.compileGraph(graph, incomingCc, getInstalledCodeOwner(), runtime, replacements, backend, runtime.getTarget(), null, phasePlan,
                                     OptimisticOptimizations.ALL, new SpeculationLog(), runtime.getDefaultSuites(), new CompilationResult());
 
                     assert destroyedRegisters != null;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>336856</refactoring_id><commit_sha>9f97cd029fd753f0551b056227817fb2b14eff74</commit_sha><commit_link>https://github.com/apache/doris/commit/9f97cd029fd753f0551b056227817fb2b14eff74</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/nereids/rules/analysis/BindExpression.java</file_path><description>Rename Variable project : LogicalProject&lt;Plan&gt; to agg : LogicalAggregate&lt;Plan&gt; in method public buildRules() : List&lt;Rule&gt; from class org.apache.doris.nereids.rules.analysis.BindExpression</description><code_before>@@ -66,6 +66,7 @@
 import org.apache.doris.nereids.trees.plans.logical.LogicalSort;
 import org.apache.doris.nereids.trees.plans.logical.LogicalTVFRelation;
 import org.apache.doris.nereids.trees.plans.logical.UsingJoin;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
@@ -331,6 +332,7 @@ protected boolean condition(Rule rule, Plan plan) {
                     groupBy = groupBy.stream()
                             .map(expr -&gt; bindFunction(expr, ctx.cascadesContext))
                             .collect(ImmutableList.toImmutableList());
                     return agg.withGroupByAndOutput(groupBy, output);
                 })
             ),
@@ -376,6 +378,7 @@ protected boolean condition(Rule rule, Plan plan) {
                                     .collect(ImmutableList.toImmutableList()))
                             .collect(ImmutableList.toImmutableList());
                     List&lt;NamedExpression&gt; newOutput = adjustNullableForRepeat(groupingSets, output);
                     return repeat.withGroupSetsAndOutput(groupingSets, newOutput);
                 })
             ),
@@ -421,16 +424,18 @@ protected boolean condition(Rule rule, Plan plan) {
                 })
             ),
             RuleType.BINDING_HAVING_SLOT.build(
-                logicalHaving(aggregate()).thenApply(ctx -&gt; {
                     LogicalHaving&lt;Aggregate&lt;Plan&gt;&gt; having = ctx.root;
-                    Plan childPlan = having.child();
                     Set&lt;Expression&gt; boundConjuncts = having.getConjuncts().stream()
                             .map(expr -&gt; {
                                 expr = bindSlot(expr, childPlan.children(), ctx.cascadesContext, false);
                                 return bindSlot(expr, childPlan, ctx.cascadesContext, false);
                             })
                             .map(expr -&gt; bindFunction(expr, ctx.cascadesContext))
                             .collect(Collectors.toSet());
                     return new LogicalHaving&lt;&gt;(boundConjuncts, having.child());
                 })
             ),
@@ -445,6 +450,9 @@ protected boolean condition(Rule rule, Plan plan) {
                             })
                             .map(expr -&gt; bindFunction(expr, ctx.cascadesContext))
                             .collect(Collectors.toSet());
                     return new LogicalHaving&lt;&gt;(boundConjuncts, having.child());
                 })
             ),
@@ -668,4 +676,30 @@ private BoundFunction bindTableGeneratingFunction(UnboundFunction unboundFunctio
     public boolean canBind(Plan plan) {
         return !plan.hasUnboundExpression() || plan.canBind();
     }
 }
</code_before><code_after>@@ -66,6 +66,7 @@
 import org.apache.doris.nereids.trees.plans.logical.LogicalSort;
 import org.apache.doris.nereids.trees.plans.logical.LogicalTVFRelation;
 import org.apache.doris.nereids.trees.plans.logical.UsingJoin;
+import org.apache.doris.qe.ConnectContext;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
@@ -331,6 +332,7 @@ protected boolean condition(Rule rule, Plan plan) {
                     groupBy = groupBy.stream()
                             .map(expr -&gt; bindFunction(expr, ctx.cascadesContext))
                             .collect(ImmutableList.toImmutableList());
+                    checkIfOutputAliasNameDuplicatedForGroupBy(groupBy, output);
                     return agg.withGroupByAndOutput(groupBy, output);
                 })
             ),
@@ -376,6 +378,7 @@ protected boolean condition(Rule rule, Plan plan) {
                                     .collect(ImmutableList.toImmutableList()))
                             .collect(ImmutableList.toImmutableList());
                     List&lt;NamedExpression&gt; newOutput = adjustNullableForRepeat(groupingSets, output);
+                    groupingSets.forEach(list -&gt; checkIfOutputAliasNameDuplicatedForGroupBy(list, newOutput));
                     return repeat.withGroupSetsAndOutput(groupingSets, newOutput);
                 })
             ),
@@ -421,16 +424,18 @@ protected boolean condition(Rule rule, Plan plan) {
                 })
             ),
             RuleType.BINDING_HAVING_SLOT.build(
+                logicalHaving(aggregate()).when(Plan::canBind).thenApply(ctx -&gt; {
                     LogicalHaving&lt;Aggregate&lt;Plan&gt;&gt; having = ctx.root;
+                    Aggregate&lt;Plan&gt; childPlan = having.child();
                     Set&lt;Expression&gt; boundConjuncts = having.getConjuncts().stream()
                             .map(expr -&gt; {
                                 expr = bindSlot(expr, childPlan.children(), ctx.cascadesContext, false);
                                 return bindSlot(expr, childPlan, ctx.cascadesContext, false);
                             })
                             .map(expr -&gt; bindFunction(expr, ctx.cascadesContext))
                             .collect(Collectors.toSet());
+                    checkIfOutputAliasNameDuplicatedForGroupBy(ImmutableList.copyOf(boundConjuncts),
+                            childPlan.getOutputExpressions());
                     return new LogicalHaving&lt;&gt;(boundConjuncts, having.child());
                 })
             ),
@@ -445,6 +450,9 @@ protected boolean condition(Rule rule, Plan plan) {
                             })
                             .map(expr -&gt; bindFunction(expr, ctx.cascadesContext))
                             .collect(Collectors.toSet());
+                    checkIfOutputAliasNameDuplicatedForGroupBy(ImmutableList.copyOf(boundConjuncts),
+                            childPlan.getOutput().stream().map(NamedExpression.class::cast)
+                                    .collect(Collectors.toList()));
                     return new LogicalHaving&lt;&gt;(boundConjuncts, having.child());
                 })
             ),
@@ -668,4 +676,30 @@ private BoundFunction bindTableGeneratingFunction(UnboundFunction unboundFunctio
     public boolean canBind(Plan plan) {
         return !plan.hasUnboundExpression() || plan.canBind();
     }
+
+    private void checkIfOutputAliasNameDuplicatedForGroupBy(List&lt;Expression&gt; expressions,
+            List&lt;NamedExpression&gt; output) {
+        // if group_by_and_having_use_alias_first=true, we should fall back to original planner until we
+        // support the session variable.
+        if (output.stream().noneMatch(Alias.class::isInstance)) {
+            return;
+        }
+        List&lt;Alias&gt; aliasList = output.stream().filter(Alias.class::isInstance)
+                .map(Alias.class::cast).collect(Collectors.toList());
+
+        List&lt;NamedExpression&gt; exprAliasList = expressions.stream()
+                .map(expr -&gt; (Set&lt;NamedExpression&gt;) expr.collect(NamedExpression.class::isInstance))
+                .flatMap(Collection::stream)
+                .collect(Collectors.toList());
+
+        boolean isGroupByContainAlias = exprAliasList.stream().anyMatch(ne -&gt;
+                aliasList.stream().anyMatch(alias -&gt; !alias.getExprId().equals(ne.getExprId())
+                        &amp;&amp; alias.getName().equals(ne.getName())));
+
+        if (isGroupByContainAlias
+                &amp;&amp; ConnectContext.get() != null
+                &amp;&amp; ConnectContext.get().getSessionVariable().isGroupByAndHavingUseAliasFirst()) {
+            throw new AnalysisException("group_by_and_having_use_alias=true is unsupported for Nereids");
+        }
+    }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>449691</refactoring_id><commit_sha>1fefc953ede1de2d03da4c839c059d3d07e331ba</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/1fefc953ede1de2d03da4c839c059d3d07e331ba</commit_link><file_path>engine/src/main/java/org/terasology/rendering/nui/layers/mainMenu/TreeViewTestScreen.java</file_path><description>Rename Variable nodes : List&lt;Tree&lt;String&gt;&gt; to treeList : List&lt;Tree&lt;String&gt;&gt; in method public initialise() : void from class org.terasology.rendering.nui.layers.mainMenu.TreeViewTestScreen</description><code_before>@@ -25,10 +25,10 @@
 public class TreeViewTestScreen extends CoreScreenLayer {
     @Override
     public void initialise() {
-        List&lt;Tree&lt;String&gt;&gt; nodes = Lists.newArrayList();
         for (int i = 0; i &lt;= 10; i++) {
-            nodes.add(new Tree&lt;&gt;("Item " + i));
-            nodes.get(i).setExpanded(true);
         }
 
         /**
@@ -46,19 +46,19 @@ public void initialise() {
          * 3  7     10
          */
 
-        nodes.get(0).addChild(nodes.get(1));
-        nodes.get(0).addChild(nodes.get(4));
-        nodes.get(0).addChild(nodes.get(5));
-        nodes.get(1).addChild(nodes.get(2));
-        nodes.get(2).addChild(nodes.get(3));
-        nodes.get(2).addChild(nodes.get(7));
-        nodes.get(4).addChild(nodes.get(8));
-        nodes.get(5).addChild(nodes.get(6));
-        nodes.get(5).addChild(nodes.get(9));
-        nodes.get(9).addChild(nodes.get(10));
 
         for (String id : new String[]{"treeView1", "treeView2", "treeView3", "treeView4"}) {
-            find(id, UITreeView.class).setModel(nodes.get(0).copy());
             find(id, UITreeView.class).setDefaultValue("New Item");
         }
     }
</code_before><code_after>@@ -25,10 +25,10 @@
 public class TreeViewTestScreen extends CoreScreenLayer {
     @Override
     public void initialise() {
+        List&lt;Tree&lt;String&gt;&gt; treeList = Lists.newArrayList();
         for (int i = 0; i &lt;= 10; i++) {
+            treeList.add(new Tree&lt;&gt;("Item " + i));
+            treeList.get(i).setExpanded(true);
         }
 
         /**
@@ -46,19 +46,19 @@ public void initialise() {
          * 3  7     10
          */
 
+        treeList.get(0).addChild(treeList.get(1));
+        treeList.get(0).addChild(treeList.get(4));
+        treeList.get(0).addChild(treeList.get(5));
+        treeList.get(1).addChild(treeList.get(2));
+        treeList.get(2).addChild(treeList.get(3));
+        treeList.get(2).addChild(treeList.get(7));
+        treeList.get(4).addChild(treeList.get(8));
+        treeList.get(5).addChild(treeList.get(6));
+        treeList.get(5).addChild(treeList.get(9));
+        treeList.get(9).addChild(treeList.get(10));
 
         for (String id : new String[]{"treeView1", "treeView2", "treeView3", "treeView4"}) {
+            find(id, UITreeView.class).setModel(treeList.get(0).copy());
             find(id, UITreeView.class).setDefaultValue("New Item");
         }
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>382003</refactoring_id><commit_sha>46ec148ca9ae7ecc668c2c0bb9547140d05d68e2</commit_sha><commit_link>https://github.com/apache/ignite/commit/46ec148ca9ae7ecc668c2c0bb9547140d05d68e2</commit_link><file_path>modules/ml/src/main/java/org/apache/ignite/ml/math/impls/matrix/SparseDistributedMatrix.java</file_path><description>Rename Variable res : Matrix to matrixC : SparseDistributedMatrix in method public times(mtx Matrix) : Matrix from class org.apache.ignite.ml.math.impls.matrix.SparseDistributedMatrix</description><code_before>@@ -17,14 +17,22 @@
 
 package org.apache.ignite.ml.math.impls.matrix;
 
 import org.apache.ignite.lang.IgniteUuid;
 import org.apache.ignite.ml.math.Matrix;
 import org.apache.ignite.ml.math.StorageConstants;
 import org.apache.ignite.ml.math.Vector;
 import org.apache.ignite.ml.math.exceptions.CardinalityException;
 import org.apache.ignite.ml.math.exceptions.UnsupportedOperationException;
 import org.apache.ignite.ml.math.functions.IgniteDoubleFunction;
-import org.apache.ignite.ml.math.impls.CacheUtils;
 import org.apache.ignite.ml.math.impls.storage.matrix.SparseDistributedMatrixStorage;
 
 /**
@@ -93,32 +101,63 @@ private SparseDistributedMatrixStorage storage() {
         return mapOverValues(v -&gt; v * x);
     }
 
-    /**
-     * TODO: IGNITE-5114, tmp naive implementation, WIP.
-     */
     @Override public Matrix times(Matrix mtx) {
-        int cols = columnSize();
 
-        if (cols != mtx.rowSize())
-            throw new CardinalityException(cols, mtx.rowSize());
 
-        int rows = rowSize();
 
-        int mtxCols = mtx.columnSize();
 
-        Matrix res = like(rows, mtxCols);
 
-        for (int x = 0; x &lt; rows; x++)
-            for (int y = 0; y &lt; mtxCols; y++) {
-                double sum = 0.0;
 
-                for (int k = 0; k &lt; cols; k++)
-                    sum += getX(x, k) * mtx.getX(k, y);
 
-                res.setX(x, y, sum);
-            }
 
-        return res;
     }
 
     /** {@inheritDoc} */
@@ -136,24 +175,24 @@ private SparseDistributedMatrixStorage storage() {
      * @return Matrix with mapped values.
      */
     private Matrix mapOverValues(IgniteDoubleFunction&lt;Double&gt; mapper) {
-        CacheUtils.sparseMap(getUUID(), mapper, SparseDistributedMatrixStorage.ML_CACHE_NAME);
 
         return this;
     }
 
     /** {@inheritDoc} */
     @Override public double sum() {
-        return CacheUtils.sparseSum(getUUID(), SparseDistributedMatrixStorage.ML_CACHE_NAME);
     }
 
     /** {@inheritDoc} */
     @Override public double maxValue() {
-        return CacheUtils.sparseMax(getUUID(), SparseDistributedMatrixStorage.ML_CACHE_NAME);
     }
 
     /** {@inheritDoc} */
     @Override public double minValue() {
-        return CacheUtils.sparseMin(getUUID(), SparseDistributedMatrixStorage.ML_CACHE_NAME);
     }
 
     /** {@inheritDoc} */
</code_before><code_after>@@ -17,14 +17,22 @@
 
 package org.apache.ignite.ml.math.impls.matrix;
 
+import java.util.Collection;
+import java.util.Map;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.Ignition;
+import org.apache.ignite.cache.affinity.Affinity;
+import org.apache.ignite.cluster.ClusterNode;
 import org.apache.ignite.lang.IgniteUuid;
 import org.apache.ignite.ml.math.Matrix;
 import org.apache.ignite.ml.math.StorageConstants;
 import org.apache.ignite.ml.math.Vector;
+import org.apache.ignite.ml.math.distributed.CacheUtils;
+import org.apache.ignite.ml.math.distributed.keys.RowColMatrixKey;
 import org.apache.ignite.ml.math.exceptions.CardinalityException;
 import org.apache.ignite.ml.math.exceptions.UnsupportedOperationException;
 import org.apache.ignite.ml.math.functions.IgniteDoubleFunction;
 import org.apache.ignite.ml.math.impls.storage.matrix.SparseDistributedMatrixStorage;
 
 /**
@@ -93,32 +101,63 @@ private SparseDistributedMatrixStorage storage() {
         return mapOverValues(v -&gt; v * x);
     }
 
+
+    /** {@inheritDoc} */
     @Override public Matrix times(Matrix mtx) {
+        if (mtx == null)
+            throw new IllegalArgumentException("The matrix should be not null.");
+
+        if (columnSize() != mtx.rowSize())
+            throw new CardinalityException(columnSize(), mtx.rowSize());
+
+        SparseDistributedMatrix matrixA = this;
+        SparseDistributedMatrix matrixB = (SparseDistributedMatrix)mtx;
+
+        String cacheName = storage().cacheName();
+        SparseDistributedMatrix matrixC = new SparseDistributedMatrix(matrixA.rowSize(), matrixB.columnSize()
+            , getStorage().storageMode(), getStorage().isRandomAccess() ? RANDOM_ACCESS_MODE : SEQUENTIAL_ACCESS_MODE);
+
+        CacheUtils.bcast(cacheName, () -&gt; {
+            Ignite ignite = Ignition.localIgnite();
+            Affinity affinity = ignite.affinity(cacheName);
+
+            IgniteCache&lt;RowColMatrixKey, BlockEntry&gt; cache = ignite.getOrCreateCache(cacheName);
+            ClusterNode locNode = ignite.cluster().localNode();
 
+            SparseDistributedMatrixStorage storageC = matrixC.storage();
 
+            Map&lt;ClusterNode, Collection&lt;RowColMatrixKey&gt;&gt; keysCToNodes = affinity.mapKeysToNodes(storageC.getAllKeys());
+            Collection&lt;RowColMatrixKey&gt; locKeys = keysCToNodes.get(locNode);
 
+            boolean isRowMode = storageC.storageMode() == ROW_STORAGE_MODE;
 
+            if (locKeys == null)
+                return;
 
+            // compute Cij locally on each node
+            // TODO: IGNITE:5114, exec in parallel
+            locKeys.forEach(key -&gt; {
+                int idx = key.index();
+                
+                if (isRowMode){
+                    Vector Aik = matrixA.getCol(idx);
 
+                    for (int i = 0; i &lt; columnSize(); i++) {
+                        Vector Bkj = matrixB.getRow(i);
+                        matrixC.set(idx, i, Aik.times(Bkj).sum());
+                    }
+                } else {
+                    Vector Bkj = matrixB.getRow(idx);
 
+                    for (int i = 0; i &lt; rowSize(); i++) {
+                        Vector Aik = matrixA.getCol(i);
+                        matrixC.set(idx, i, Aik.times(Bkj).sum());
+                    }
+                }
+            });
+        });
 
+        return matrixC;
     }
 
     /** {@inheritDoc} */
@@ -136,24 +175,24 @@ private SparseDistributedMatrixStorage storage() {
      * @return Matrix with mapped values.
      */
     private Matrix mapOverValues(IgniteDoubleFunction&lt;Double&gt; mapper) {
+        CacheUtils.sparseMap(getUUID(), mapper, storage().cacheName());
 
         return this;
     }
 
     /** {@inheritDoc} */
     @Override public double sum() {
+        return CacheUtils.sparseSum(getUUID(), storage().cacheName());
     }
 
     /** {@inheritDoc} */
     @Override public double maxValue() {
+        return CacheUtils.sparseMax(getUUID(), storage().cacheName());
     }
 
     /** {@inheritDoc} */
     @Override public double minValue() {
+        return CacheUtils.sparseMin(getUUID(), storage().cacheName());
     }
 
     /** {@inheritDoc} */
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>386829</refactoring_id><commit_sha>5e853d6297671b61e3927bbf0473ab1f5f210b37</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/5e853d6297671b61e3927bbf0473ab1f5f210b37</commit_link><file_path>servers/src/main/java/tachyon/master/next/filesystem/meta/InodeDirectory.java</file_path><description>Rename Variable inode : Inode to child : Inode in method public getChildrenIds() : List&lt;Long&gt; from class tachyon.master.next.filesystem.meta.InodeDirectory</description><code_before>@@ -133,7 +133,7 @@ public synchronized Inode getChild(String name) {
    * @return an unmodifiable set of the children inodes.
    */
   public synchronized Set&lt;Inode&gt; getChildren() {
-    return ImmutableSet.copyOf(mChildren.all());
   }
 
   /**
@@ -142,10 +142,9 @@ public synchronized Set&lt;Inode&gt; getChildren() {
    * @return the ids of the children
    */
   public synchronized List&lt;Long&gt; getChildrenIds() {
-    Set&lt;Inode&gt; children = mChildren.all();
-    List&lt;Long&gt; ret = new ArrayList&lt;Long&gt;(children.size());
-    for (Inode inode : children) {
-      ret.add(inode.getId());
     }
     return ret;
   }
@@ -182,7 +181,7 @@ public synchronized boolean removeChild(String name) {
   @Override
   public String toString() {
     StringBuilder sb = new StringBuilder("InodeFolder(");
-    sb.append(super.toString()).append(",").append(mChildren.all()).append(")");
     return sb.toString();
   }
 }
</code_before><code_after>@@ -133,7 +133,7 @@ public synchronized Inode getChild(String name) {
    * @return an unmodifiable set of the children inodes.
    */
   public synchronized Set&lt;Inode&gt; getChildren() {
+    return ImmutableSet.copyOf(mChildren.iterator());
   }
 
   /**
@@ -142,10 +142,9 @@ public synchronized Set&lt;Inode&gt; getChildren() {
    * @return the ids of the children
    */
   public synchronized List&lt;Long&gt; getChildrenIds() {
+    List&lt;Long&gt; ret = new ArrayList&lt;Long&gt;(mChildren.size());
+    for (Inode child : mChildren) {
+      ret.add(child.getId());
     }
     return ret;
   }
@@ -182,7 +181,7 @@ public synchronized boolean removeChild(String name) {
   @Override
   public String toString() {
     StringBuilder sb = new StringBuilder("InodeFolder(");
+    sb.append(super.toString()).append(",").append(getChildren()).append(")");
     return sb.toString();
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>398834</refactoring_id><commit_sha>c667f5f115a68dffd4d42e258ad5f5940835a70f</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/c667f5f115a68dffd4d42e258ad5f5940835a70f</commit_link><file_path>flex/tools/flex-ui-designer/idea-plugin/src/com/intellij/flex/uiDesigner/libraries/LibrariesData.java</file_path><description>Rename Variable libraryPathes : String[] to libraryPaths : String[] in method public read(in DataInput) : SortResult from class com.intellij.flex.uiDesigner.libraries.LibrariesData.LibrarySetDataExternalizer</description><code_before>@@ -96,9 +96,9 @@ public boolean execute(CharSequence charSequence) {
     @Override
     public SortResult read(DataInput in) throws IOException {
       int librariesSize = in.readShort();
-      String[] libraryPathes = new String[librariesSize];
       while (librariesSize-- &gt; 0) {
-        libraryPathes[librariesSize] = in.readUTF();
       }
 
       int size = in.readInt();
@@ -113,7 +113,7 @@ public SortResult read(DataInput in) throws IOException {
         map = null;
       }
 
-      return new SortResult(map, libraryPathes);
     }
   }
 }
\ No newline at end of file
</code_before><code_after>@@ -96,9 +96,9 @@ public boolean execute(CharSequence charSequence) {
     @Override
     public SortResult read(DataInput in) throws IOException {
       int librariesSize = in.readShort();
+      String[] libraryPaths = new String[librariesSize];
       while (librariesSize-- &gt; 0) {
+        libraryPaths[librariesSize] = in.readUTF();
       }
 
       int size = in.readInt();
@@ -113,7 +113,7 @@ public SortResult read(DataInput in) throws IOException {
         map = null;
       }
 
+      return new SortResult(map, libraryPaths);
     }
   }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>372263</refactoring_id><commit_sha>2cb67e57d469b30c3e261a42d3917583a78e299d</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/2cb67e57d469b30c3e261a42d3917583a78e299d</commit_link><file_path>server/integration/testsuite/src/test/java/org/infinispan/server/test/util/ProtofileRegistrar.java</file_path><description>Rename Variable PROTOFILE_PATH : String to PROTOFILES_PATH : String in method public main(args String[]) : void from class org.infinispan.server.test.util.ProtofileRegistrar</description><code_before>@@ -1,65 +1,73 @@
 package org.infinispan.server.test.util;
 
-import java.io.IOException;
-import java.io.InputStream;
 import javax.management.MBeanServerConnection;
 import javax.management.ObjectName;
 import javax.management.remote.JMXConnector;
 import javax.management.remote.JMXConnectorFactory;
 import javax.management.remote.JMXServiceURL;
-
-import org.infinispan.commons.util.Util;
 
 /**
- * Utility class for registering arbitrary .protobin file on the server.
  *
  * @author mgencur
  */
 public class ProtofileRegistrar {
 
-    public static void main(String[] args) {
-        if (args.length != 3) {
-            System.err.println("There are 3 parameters required:\n" +
-                    "1) path to a protofile\n" +
-                    "2) server host\n" +
-                    "3) server JMX port");
-            System.exit(1);
-        }
 
-        final String PROTOFILE_PATH = args[0];
-        final String SERVER_HOST = args[1];
-        final int JMX_PORT = Integer.parseInt(args[2]);
 
-        ProtofileRegistrar registrar = new ProtofileRegistrar();
-        try {
-            registrar.registerProtofile(PROTOFILE_PATH, SERVER_HOST, JMX_PORT);
-        } catch (Exception e) {
-            e.printStackTrace();
-            System.exit(1);
-        }
-    }
 
-    private void registerProtofile(String protofilePath, String host, int jmxPort) throws Exception {
-        JMXConnector jmxConnector = JMXConnectorFactory.connect(new JMXServiceURL("service:jmx:http-remoting-jmx://" + host + ":" + jmxPort));
-        MBeanServerConnection jmxConnection = jmxConnector.getMBeanServerConnection();
 
-        ObjectName objName = new ObjectName("jboss.infinispan:type=RemoteQuery,name="
-                + ObjectName.quote("local") + ",component=ProtobufMetadataManager");
 
-        //initialize client-side serialization context via JMX
-        byte[] descriptor = readClasspathResource(protofilePath);
-        jmxConnection.invoke(objName, "registerProtofile", new Object[]{descriptor}, new String[]{byte[].class.getName()});
-        System.out.printf("Successfully registered protofile %s at %s/%d\n", protofilePath, host, jmxPort);
-    }
 
-    private byte[] readClasspathResource(String c) throws IOException {
-        InputStream is = getClass().getResourceAsStream(c);
-        try {
-            return Util.readStream(is);
-        } finally {
-            if (is != null) {
-                is.close();
-            }
-        }
-    }
 }
</code_before><code_after>@@ -1,65 +1,73 @@
 package org.infinispan.server.test.util;
 
+import org.infinispan.commons.util.Util;
+
 import javax.management.MBeanServerConnection;
 import javax.management.ObjectName;
 import javax.management.remote.JMXConnector;
 import javax.management.remote.JMXConnectorFactory;
 import javax.management.remote.JMXServiceURL;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Paths;
+import java.util.LinkedList;
 
 /**
+ * Utility class for registering arbitrary .proto files on the server.
  *
  * @author mgencur
  */
 public class ProtofileRegistrar {
 
+   public static void main(String[] args) {
+      if (args.length != 3) {
+         System.err.println("There are 3 parameters required:\n" +
+                 "1) path to one or more protofiles, comma separated \n" +
+                 "2) server host\n" +
+                 "3) server JMX port");
+         System.exit(1);
+      }
+
+      final String PROTOFILES_PATH = args[0];
+      final String SERVER_HOST = args[1];
+      final int JMX_PORT = Integer.parseInt(args[2]);
+
+      ProtofileRegistrar registrar = new ProtofileRegistrar();
+      try {
+         registrar.registerProtofile(PROTOFILES_PATH, SERVER_HOST, JMX_PORT);
+      } catch (Exception e) {
+         e.printStackTrace();
+         System.exit(1);
+      }
+   }
+
+   private void registerProtofile(String protofilesPath, String host, int jmxPort) throws Exception {
+      JMXConnector jmxConnector = JMXConnectorFactory.connect(new JMXServiceURL("service:jmx:http-remoting-jmx://" + host + ":" + jmxPort));
+      MBeanServerConnection jmxConnection = jmxConnector.getMBeanServerConnection();
 
+      ObjectName objName = new ObjectName("jboss.infinispan:type=RemoteQuery,name="
+              + ObjectName.quote("local") + ",component=ProtobufMetadataManager");
 
+      LinkedList&lt;String&gt; fileNames = new LinkedList&lt;&gt;();
+      LinkedList&lt;String&gt; fileContents = new LinkedList&lt;&gt;();
 
+      //initialize client-side serialization context via JMX
+      for (String protofile : protofilesPath.split(",")) {
+         String descriptor = readClasspathResource(protofile);
+         String name = Paths.get(protofile).getFileName().toString();
+         fileNames.add(name);
+         fileContents.add(descriptor);
+      }
+      String[] names = fileNames.toArray(new String[fileNames.size()]);
+      String[] contents = fileContents.toArray(new String[fileContents.size()]);
 
+      jmxConnection.invoke(objName, "registerProtofiles", new Object[]{names, contents}, new String[]{String[].class.getName(), String[].class.getName()});
 
+      System.out.printf("Successfully registered protofile(s) %s at %s/%d\n", protofilesPath, host, jmxPort);
+   }
 
+   private String readClasspathResource(String c) throws IOException {
+      InputStream is = getClass().getResourceAsStream(c);
+      return Util.read(is);
+   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>391075</refactoring_id><commit_sha>44c5a99954ead02df9d428400ab953d8ae510e78</commit_sha><commit_link>https://github.com/teammates/teammates/commit/44c5a99954ead02df9d428400ab953d8ae510e78</commit_link><file_path>src/main/java/teammates/common/util/FileHelper.java</file_path><description>Rename Variable ans : String to result : String in method public readFile(filePath String) : String from class teammates.test.util.FileHelper</description><code_before>@@ -1,10 +1,5 @@
 package teammates.common.util;
 
-import java.io.BufferedReader;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.IOException;
 import java.io.InputStream;
 import java.util.Scanner;
 
@@ -16,25 +11,6 @@ private FileHelper() {
         // utility class
     }
     
-    /**
-     * Reads a file content and return a String
-     */
-    public static String readFile(String filename) throws FileNotFoundException {
-        Scanner scanner = new Scanner(new BufferedReader(new FileReader(filename)));
-        String ans = scanner.useDelimiter("\\Z").next();
-        scanner.close();
-        return ans;
-    }
-    
-    public static byte[] readFileAsBytes(String fileName) throws FileNotFoundException, IOException {
-        FileInputStream stream = new FileInputStream(fileName);
-        byte[] buffer = new byte[1024 * 300];
-        stream.read(buffer);
-        stream.close();
-        
-        return buffer;
-    }
-
     /**
      * Reads the contents of a file in the {@code resources} folder
      * as an {@link InputStream}.
</code_before><code_after>@@ -1,10 +1,5 @@
 package teammates.common.util;
 
 import java.io.InputStream;
 import java.util.Scanner;
 
@@ -16,25 +11,6 @@ private FileHelper() {
         // utility class
     }
     
     /**
      * Reads the contents of a file in the {@code resources} folder
      * as an {@link InputStream}.
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>347085</refactoring_id><commit_sha>1795c35dfc13866e4234d89f7833e836989ede3b</commit_sha><commit_link>https://github.com/nationalsecurityagency/ghidra/commit/1795c35dfc13866e4234d89f7833e836989ede3b</commit_link><file_path>Ghidra/Debug/Debugger/src/test/java/ghidra/debug/flatapi/FlatDebuggerAPITest.java</file_path><description>Rename Variable tid : UndoableTransaction to tx : Transaction in method protected createMappedTraceAndProgram() : void from class ghidra.debug.flatapi.FlatDebuggerAPITest</description><code_before>@@ -29,6 +29,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
 import generic.Unique;
 import ghidra.app.plugin.assembler.Assembler;
 import ghidra.app.plugin.assembler.Assemblers;
@@ -65,7 +66,6 @@
 import ghidra.trace.model.stack.TraceStack;
 import ghidra.trace.model.thread.TraceThread;
 import ghidra.trace.model.time.schedule.TraceSchedule;
-import ghidra.util.database.UndoableTransaction;
 
 public class FlatDebuggerAPITest extends AbstractGhidraHeadedDebuggerGUITest {
 
@@ -187,7 +187,7 @@ public void testGetCurrentThread() throws Throwable {
 
 		createAndOpenTrace();
 		TraceThread thread;
-		try (UndoableTransaction tid = tb.startTransaction()) {
 			thread = tb.getOrAddThread("Threads[0]", 0);
 		}
 		waitForSwing();
@@ -217,7 +217,7 @@ public void testGetCurrentFrame() throws Throwable {
 
 		createAndOpenTrace();
 		TraceThread thread;
-		try (UndoableTransaction tid = tb.startTransaction()) {
 			thread = tb.getOrAddThread("Threads[0]", 0);
 			TraceStack stack = tb.trace.getStackManager().getStack(thread, 0, true);
 			stack.setDepth(3, true);
@@ -289,7 +289,7 @@ protected TraceThread createTraceWithThreadAndStack(boolean open) throws Throwab
 			createTrace();
 		}
 		TraceThread thread;
-		try (UndoableTransaction tid = tb.startTransaction()) {
 			thread = tb.getOrAddThread("Threads[0]", 0);
 			TraceStack stack = tb.trace.getStackManager().getStack(thread, 0, true);
 			stack.setDepth(3, true);
@@ -354,7 +354,7 @@ public void testActivateSnap() throws Throwable {
 	protected void createTraceWithBinText() throws Throwable {
 		createAndOpenTrace();
 
-		try (UndoableTransaction tid = tb.startTransaction()) {
 			DBTraceMemoryManager mm = tb.trace.getMemoryManager();
 			mm.createRegion("Memory[bin.text]", 0, tb.range(0x00400000, 0x0040ffff),
 				Set.of(TraceMemoryFlag.READ, TraceMemoryFlag.EXECUTE));
@@ -401,14 +401,14 @@ protected void createMappedTraceAndProgram() throws Throwable {
 		programManager.openProgram(program);
 		traceManager.activateTrace(tb.trace);
 
-		try (UndoableTransaction tid = UndoableTransaction.start(program, "add block")) {
 			program.getMemory()
 					.createInitializedBlock(".text", addr(program, 0x00400000), 4096, (byte) 0,
 						monitor, false);
 		}
 
 		CompletableFuture&lt;Void&gt; changesSettled;
-		try (UndoableTransaction tid = tb.startTransaction()) {
 			tb.trace.getMemoryManager()
 					.createRegion("Memory[bin.text]", 0, tb.range(0x00400000, 0x00400fff),
 						Set.of(TraceMemoryFlag.READ, TraceMemoryFlag.EXECUTE));
@@ -463,7 +463,7 @@ protected Address createEmulatableProgram() throws Throwable {
 		programManager.openProgram(program);
 
 		Address entry = addr(program, 0x00400000);
-		try (UndoableTransaction start = UndoableTransaction.start(program, "init")) {
 			program.getMemory()
 					.createInitializedBlock(".text", entry, 4096, (byte) 0,
 						monitor, false);
@@ -1050,7 +1050,7 @@ protected void createProgramWithText() throws Throwable {
 		programManager.openProgram(program);
 		waitForSwing();
 
-		try (UndoableTransaction tid = UndoableTransaction.start(program, "Add block")) {
 			program.getMemory()
 					.createInitializedBlock(
 						".text", addr(program, 0x00400000), 1024, (byte) 0, monitor, false);
</code_before><code_after>@@ -29,6 +29,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import db.Transaction;
 import generic.Unique;
 import ghidra.app.plugin.assembler.Assembler;
 import ghidra.app.plugin.assembler.Assemblers;
@@ -65,7 +66,6 @@
 import ghidra.trace.model.stack.TraceStack;
 import ghidra.trace.model.thread.TraceThread;
 import ghidra.trace.model.time.schedule.TraceSchedule;
 
 public class FlatDebuggerAPITest extends AbstractGhidraHeadedDebuggerGUITest {
 
@@ -187,7 +187,7 @@ public void testGetCurrentThread() throws Throwable {
 
 		createAndOpenTrace();
 		TraceThread thread;
+		try (Transaction tx = tb.startTransaction()) {
 			thread = tb.getOrAddThread("Threads[0]", 0);
 		}
 		waitForSwing();
@@ -217,7 +217,7 @@ public void testGetCurrentFrame() throws Throwable {
 
 		createAndOpenTrace();
 		TraceThread thread;
+		try (Transaction tx = tb.startTransaction()) {
 			thread = tb.getOrAddThread("Threads[0]", 0);
 			TraceStack stack = tb.trace.getStackManager().getStack(thread, 0, true);
 			stack.setDepth(3, true);
@@ -289,7 +289,7 @@ protected TraceThread createTraceWithThreadAndStack(boolean open) throws Throwab
 			createTrace();
 		}
 		TraceThread thread;
+		try (Transaction tx = tb.startTransaction()) {
 			thread = tb.getOrAddThread("Threads[0]", 0);
 			TraceStack stack = tb.trace.getStackManager().getStack(thread, 0, true);
 			stack.setDepth(3, true);
@@ -354,7 +354,7 @@ public void testActivateSnap() throws Throwable {
 	protected void createTraceWithBinText() throws Throwable {
 		createAndOpenTrace();
 
+		try (Transaction tx = tb.startTransaction()) {
 			DBTraceMemoryManager mm = tb.trace.getMemoryManager();
 			mm.createRegion("Memory[bin.text]", 0, tb.range(0x00400000, 0x0040ffff),
 				Set.of(TraceMemoryFlag.READ, TraceMemoryFlag.EXECUTE));
@@ -401,14 +401,14 @@ protected void createMappedTraceAndProgram() throws Throwable {
 		programManager.openProgram(program);
 		traceManager.activateTrace(tb.trace);
 
+		try (Transaction tx = program.openTransaction("add block")) {
 			program.getMemory()
 					.createInitializedBlock(".text", addr(program, 0x00400000), 4096, (byte) 0,
 						monitor, false);
 		}
 
 		CompletableFuture&lt;Void&gt; changesSettled;
+		try (Transaction tx = tb.startTransaction()) {
 			tb.trace.getMemoryManager()
 					.createRegion("Memory[bin.text]", 0, tb.range(0x00400000, 0x00400fff),
 						Set.of(TraceMemoryFlag.READ, TraceMemoryFlag.EXECUTE));
@@ -463,7 +463,7 @@ protected Address createEmulatableProgram() throws Throwable {
 		programManager.openProgram(program);
 
 		Address entry = addr(program, 0x00400000);
+		try (Transaction start = program.openTransaction("init")) {
 			program.getMemory()
 					.createInitializedBlock(".text", entry, 4096, (byte) 0,
 						monitor, false);
@@ -1050,7 +1050,7 @@ protected void createProgramWithText() throws Throwable {
 		programManager.openProgram(program);
 		waitForSwing();
 
+		try (Transaction tx = program.openTransaction("Add block")) {
 			program.getMemory()
 					.createInitializedBlock(
 						".text", addr(program, 0x00400000), 1024, (byte) 0, monitor, false);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>357516</refactoring_id><commit_sha>5795205d1184f5dc8dcc071b17edecb641101aba</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/5795205d1184f5dc8dcc071b17edecb641101aba</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/nioneo/store/AbstractDynamicStore.java</file_path><description>Rename Variable nrOfBytesInt : long to firstInteger : long in method private getRecord(blockId long, window PersistenceWindow, loadData boolean) : DynamicRecord from class org.neo4j.kernel.impl.nioneo.store.AbstractDynamicStore</description><code_before>@@ -265,8 +265,8 @@ public static int getRecordSize( int dataSize )
         return dataSize + BLOCK_HEADER_SIZE;
     }
 
-    // in_use(byte)+nr_of_bytes(int)+next_block(int)
-    protected static final int BLOCK_HEADER_SIZE = 1 + 4 + 4;
 
     public void updateRecord( DynamicRecord record )
     {
@@ -282,20 +282,23 @@ public void updateRecord( DynamicRecord record )
             if ( record.inUse() )
             {
                 long nextProp = record.getNextBlock();
-                int nextModifier = nextProp == Record.NO_NEXT_BLOCK.intValue() ? 0 : (int)((nextProp &amp; 0xF00000000L) &gt;&gt; 8);
-
-                // [    ,   x] in use
-                // [xxxx,    ] high prev block bits
-                short inUseUnsignedByte = ( ( Record.IN_USE.byteValue() /* | prevModifier*/) );
-
-                // [    ,    ][xxxx,xxxx][xxxx,xxxx][xxxx,xxxx] nr of bytes
-                // [    ,xxxx][    ,    ][    ,    ][    ,    ] high next block bits
-                int nrOfBytesInt = record.getLength();
-                nrOfBytesInt |= nextModifier;
-
-                // assert record.getId() != record.getPrevBlock();
-                buffer.put( (byte) inUseUnsignedByte )/*.putInt( (int)prevProp )*/.putInt(
-                        nrOfBytesInt ).putInt( (int)nextProp );
                 if ( !record.isLight() )
                 {
                     if ( !record.isCharData() )
@@ -461,27 +464,28 @@ private DynamicRecord getRecord( long blockId, PersistenceWindow window, boolean
         DynamicRecord record = new DynamicRecord( blockId );
         Buffer buffer = window.getOffsettedBuffer( blockId );
 
-        // [    ,   x] in use
-        // [xxxx,    ] high bits for prev block
-        long inUseByte = buffer.get();
-        boolean inUse = (inUseByte &amp; 0x1) == Record.IN_USE.intValue();
         if ( !inUse )
         {
             throw new InvalidRecordException( "Not in use, blockId[" + blockId + "]" );
         }
-        // long prevBlock = buffer.getUnsignedInt();
-        // long prevModifier = (inUseByte &amp; 0xF0L) &lt;&lt; 28;
-
         int dataSize = getBlockSize() - BLOCK_HEADER_SIZE;
 
-        // [    ,    ][xxxx,xxxx][xxxx,xxxx][xxxx,xxxx] number of bytes
-        // [    ,xxxx][    ,    ][    ,    ][    ,    ] higher bits for next block
-        long nrOfBytesInt = buffer.getInt();
-
-        int nrOfBytes = (int)(nrOfBytesInt &amp; 0xFFFFFF);
 
         long nextBlock = buffer.getUnsignedInt();
-        long nextModifier = (nrOfBytesInt &amp; 0xF000000L) &lt;&lt; 8;
 
         long longNextBlock = longFromIntAndMod( nextBlock, nextModifier );
         if ( longNextBlock != Record.NO_NEXT_BLOCK.intValue()
@@ -493,7 +497,6 @@ private DynamicRecord getRecord( long blockId, PersistenceWindow window, boolean
         }
         record.setInUse( true );
         record.setLength( nrOfBytes );
-        // record.setPrevBlock( longFromIntAndMod( prevBlock, prevModifier ) );
         record.setNextBlock( longNextBlock );
         if ( loadData )
         {
</code_before><code_after>@@ -265,8 +265,8 @@ public static int getRecordSize( int dataSize )
         return dataSize + BLOCK_HEADER_SIZE;
     }
 
+    // (in_use+next high)(1 byte)+nr_of_bytes(3 bytes)+next_block(int)
+    protected static final int BLOCK_HEADER_SIZE = 1 + 3 + 4; // = 8
 
     public void updateRecord( DynamicRecord record )
     {
@@ -282,20 +282,23 @@ public void updateRecord( DynamicRecord record )
             if ( record.inUse() )
             {
                 long nextProp = record.getNextBlock();
+                int nextModifier = nextProp == Record.NO_NEXT_BLOCK.intValue() ? 0
+                        : (int) ( ( nextProp &amp; 0xF00000000L ) &gt;&gt; 8 );
+                nextModifier |= ( Record.IN_USE.byteValue() &lt;&lt; 28 );
+
+                /*
+                 *
+                 * [   x,    ][    ,    ][    ,    ][    ,    ] inUse
+                 * [    ,xxxx][    ,    ][    ,    ][    ,    ] high next block bits
+                 * [    ,    ][xxxx,xxxx][xxxx,xxxx][xxxx,xxxx] nr of bytes
+                 *
+                 */
+                int mostlyNrOfBytesInt = record.getLength();
+                assert mostlyNrOfBytesInt &lt; ( 1 &lt;&lt; 24 ) - 1;
+
+                mostlyNrOfBytesInt |= nextModifier;
+
+                buffer.putInt( mostlyNrOfBytesInt ).putInt( (int) nextProp );
                 if ( !record.isLight() )
                 {
                     if ( !record.isCharData() )
@@ -461,27 +464,28 @@ private DynamicRecord getRecord( long blockId, PersistenceWindow window, boolean
         DynamicRecord record = new DynamicRecord( blockId );
         Buffer buffer = window.getOffsettedBuffer( blockId );
 
+        /*
+         *
+         * [   x,    ][    ,    ][    ,    ][    ,    ] inUse
+         * [    ,xxxx][    ,    ][    ,    ][    ,    ] high next block bits
+         * [    ,    ][xxxx,xxxx][xxxx,xxxx][xxxx,xxxx] nr of bytes
+         *
+         */
+
+        long firstInteger = buffer.getUnsignedInt();
+        // firstInteger &amp;= 0xF0000000;
+        int inUseByte = (int) ( ( firstInteger &amp; 0xF0000000 ) &gt;&gt; 28 );
+        boolean inUse = inUseByte == Record.IN_USE.intValue();
         if ( !inUse )
         {
             throw new InvalidRecordException( "Not in use, blockId[" + blockId + "]" );
         }
         int dataSize = getBlockSize() - BLOCK_HEADER_SIZE;
 
+        int nrOfBytes = (int) ( firstInteger &amp; 0xFFFFFF );
 
         long nextBlock = buffer.getUnsignedInt();
+        long nextModifier = ( firstInteger &amp; 0xF000000L ) &lt;&lt; 8;
 
         long longNextBlock = longFromIntAndMod( nextBlock, nextModifier );
         if ( longNextBlock != Record.NO_NEXT_BLOCK.intValue()
@@ -493,7 +497,6 @@ private DynamicRecord getRecord( long blockId, PersistenceWindow window, boolean
         }
         record.setInUse( true );
         record.setLength( nrOfBytes );
         record.setNextBlock( longNextBlock );
         if ( loadData )
         {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>351514</refactoring_id><commit_sha>0b893869a8f33d50258f44ba24d99f2d7ff859e6</commit_sha><commit_link>https://github.com/pentaho/pentaho-kettle/commit/0b893869a8f33d50258f44ba24d99f2d7ff859e6</commit_link><file_path>src/org/pentaho/di/trans/dialog/TransExecutionConfigurationDialog.java</file_path><description>Rename Variable row : RowMetaAndData to map : Map&lt;String,String&gt; in method private getInfoArguments() : void from class org.pentaho.di.trans.dialog.TransExecutionConfigurationDialog</description><code_before>@@ -1,7 +1,11 @@
 package org.pentaho.di.trans.dialog;
 
 import java.text.SimpleDateFormat;
 import java.util.List;
 
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.custom.CCombo;
@@ -21,9 +25,7 @@
 import org.pentaho.di.cluster.SlaveServer;
 import org.pentaho.di.core.Const;
 import org.pentaho.di.core.Props;
-import org.pentaho.di.core.RowMetaAndData;
 import org.pentaho.di.core.dialog.ErrorDialog;
-import org.pentaho.di.core.exception.KettleValueException;
 import org.pentaho.di.core.gui.GUIResource;
 import org.pentaho.di.core.gui.WindowProperty;
 import org.pentaho.di.core.logging.LogWriter;
@@ -388,22 +390,17 @@ public boolean open()
     private void getVariablesData()
     {
         wVariables.clearAll(false);
-        for (int i=0;i&lt;configuration.getVariables().size();i++)
         {
-            ValueMetaInterface valueMeta = configuration.getVariables().getValueMeta(i);
-            Object valueData = configuration.getVariables().getData()[i];
-            
             TableItem tableItem = new TableItem(wVariables.table, SWT.NONE);
-            tableItem.setText(1, valueMeta.getName());
-            try
-            {
-                tableItem.setText(2, Const.NVL(valueMeta.getString(valueData), ""));;
-            }
-            catch (KettleValueException e)
-            {
-            }
-            
-            
         }
         wVariables.removeEmptyRows();
         wVariables.setRowNums();
@@ -413,20 +410,18 @@ private void getVariablesData()
     private void getArgumentsData()
     {
         wArguments.clearAll(false);
-        for (int i=0;i&lt;configuration.getArguments().size();i++)
         {
-            ValueMetaInterface valueMeta = configuration.getVariables().getValueMeta(i);
-            Object valueData = configuration.getVariables().getData()[i];
-           
             TableItem tableItem = new TableItem(wArguments.table, SWT.NONE);
-            tableItem.setText(1, valueMeta.getName());
-            try
-            {
-                tableItem.setText(2, Const.NVL(valueMeta.getString(valueData), ""));;
-            }
-            catch (KettleValueException e)
-            {
-            }
         }
         wArguments.removeEmptyRows();
         wArguments.setRowNums();
@@ -591,7 +586,7 @@ public void getInfo()
     
     private void getInfoVariables()
     {
-        RowMetaAndData row = new RowMetaAndData();
         for (int i=0;i&lt;wVariables.nrNonEmpty();i++)
         {
             TableItem tableItem = wVariables.getNonEmpty(i);
@@ -600,16 +595,15 @@ private void getInfoVariables()
             
             if (!Const.isEmpty(varName))
             {
-                ValueMeta valueMeta = new ValueMeta(varName, ValueMetaInterface.TYPE_STRING);
-                row.addValue(valueMeta, varValue);
             }
         }
-        configuration.setVariables(row);
     }
     
     private void getInfoArguments()
     {
-        RowMetaAndData row = new RowMetaAndData();
         for (int i=0;i&lt;wArguments.nrNonEmpty();i++)
         {
             TableItem tableItem = wArguments.getNonEmpty(i);
@@ -618,11 +612,10 @@ private void getInfoArguments()
             
             if (!Const.isEmpty(varName))
             {
-                ValueMeta value = new ValueMeta(varName, ValueMetaInterface.TYPE_STRING);
-                row.addValue(value, varValue);
             }
         }
-        configuration.setArguments(row);
     }
 
     
</code_before><code_after>@@ -1,7 +1,11 @@
 package org.pentaho.di.trans.dialog;
 
 import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.custom.CCombo;
@@ -21,9 +25,7 @@
 import org.pentaho.di.cluster.SlaveServer;
 import org.pentaho.di.core.Const;
 import org.pentaho.di.core.Props;
 import org.pentaho.di.core.dialog.ErrorDialog;
 import org.pentaho.di.core.gui.GUIResource;
 import org.pentaho.di.core.gui.WindowProperty;
 import org.pentaho.di.core.logging.LogWriter;
@@ -388,22 +390,17 @@ public boolean open()
     private void getVariablesData()
     {
         wVariables.clearAll(false);
+        List&lt;String&gt; variableNames = new ArrayList&lt;String&gt;( configuration.getVariables().keySet() );
+        Collections.sort(variableNames);
+        
+        for (int i=0;i&lt;variableNames.size();i++)
         {
+        	String variableName = variableNames.get(i);
+        	String variableValue = configuration.getVariables().get(variableName);
+        	
             TableItem tableItem = new TableItem(wVariables.table, SWT.NONE);
+            tableItem.setText(1, variableName);
+            tableItem.setText(2, Const.NVL(variableValue, ""));;
         }
         wVariables.removeEmptyRows();
         wVariables.setRowNums();
@@ -413,20 +410,18 @@ private void getVariablesData()
     private void getArgumentsData()
     {
         wArguments.clearAll(false);
+        
+        List&lt;String&gt; argumentNames = new ArrayList&lt;String&gt;( configuration.getArguments().keySet() );
+        Collections.sort(argumentNames);
+        
+        for (int i=0;i&lt;argumentNames.size();i++)
         {
+        	String argumentName = argumentNames.get(i);
+        	String argumentValue = configuration.getArguments().get(argumentName);
+        	
             TableItem tableItem = new TableItem(wArguments.table, SWT.NONE);
+            tableItem.setText(1, Const.NVL(argumentName, ""));
+            tableItem.setText(2, Const.NVL(argumentValue, ""));
         }
         wArguments.removeEmptyRows();
         wArguments.setRowNums();
@@ -591,7 +586,7 @@ public void getInfo()
     
     private void getInfoVariables()
     {
+        Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();
         for (int i=0;i&lt;wVariables.nrNonEmpty();i++)
         {
             TableItem tableItem = wVariables.getNonEmpty(i);
@@ -600,16 +595,15 @@ private void getInfoVariables()
             
             if (!Const.isEmpty(varName))
             {
+                map.put(varName, varValue);
             }
         }
+        configuration.setVariables(map);
     }
     
     private void getInfoArguments()
     {
+    	Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();
         for (int i=0;i&lt;wArguments.nrNonEmpty();i++)
         {
             TableItem tableItem = wArguments.getNonEmpty(i);
@@ -618,11 +612,10 @@ private void getInfoArguments()
             
             if (!Const.isEmpty(varName))
             {
+                map.put(varName, varValue);
             }
         }
+        configuration.setArguments(map);
     }
 
     
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>433501</refactoring_id><commit_sha>ab98166c36f2955359ccdf31defe0678f66bdd99</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/ab98166c36f2955359ccdf31defe0678f66bdd99</commit_link><file_path>quickstep/recents_ui_overrides/src/com/android/quickstep/views/TaskView.java</file_path><description>Rename Variable dummyInfo : WorkspaceItemInfo to stubInfo : WorkspaceItemInfo in method public getItemInfo() : WorkspaceItemInfo from class com.android.quickstep.views.TaskView</description><code_before>@@ -245,14 +245,14 @@ Touch.TAP, Direction.NONE, getRecentsView().indexOfChild(this),
      */
     public WorkspaceItemInfo getItemInfo() {
         ComponentKey componentKey = TaskUtils.getLaunchComponentKeyForTask(getTask().key);
-        WorkspaceItemInfo dummyInfo = new WorkspaceItemInfo();
-        dummyInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_TASK;
-        dummyInfo.container = LauncherSettings.Favorites.CONTAINER_TASKSWITCHER;
-        dummyInfo.user = componentKey.user;
-        dummyInfo.intent = new Intent().setComponent(componentKey.componentName);
-        dummyInfo.title = TaskUtils.getTitle(getContext(), getTask());
-        dummyInfo.screenId = getRecentsView().indexOfChild(this);
-        return dummyInfo;
     }
 
     @Override
</code_before><code_after>@@ -245,14 +245,14 @@ Touch.TAP, Direction.NONE, getRecentsView().indexOfChild(this),
      */
     public WorkspaceItemInfo getItemInfo() {
         ComponentKey componentKey = TaskUtils.getLaunchComponentKeyForTask(getTask().key);
+        WorkspaceItemInfo stubInfo = new WorkspaceItemInfo();
+        stubInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_TASK;
+        stubInfo.container = LauncherSettings.Favorites.CONTAINER_TASKSWITCHER;
+        stubInfo.user = componentKey.user;
+        stubInfo.intent = new Intent().setComponent(componentKey.componentName);
+        stubInfo.title = TaskUtils.getTitle(getContext(), getTask());
+        stubInfo.screenId = getRecentsView().indexOfChild(this);
+        return stubInfo;
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>384301</refactoring_id><commit_sha>e7e223f7c6b73dc0fa28a545671a528b78a00271</commit_sha><commit_link>https://github.com/apache/ignite/commit/e7e223f7c6b73dc0fa28a545671a528b78a00271</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/binary/BinaryObjectOffheapImpl.java</file_path><description>Rename Variable schemaOffset : int to schemaOff : int in method protected fieldByOrder(order int) : F from class org.apache.ignite.internal.binary.BinaryObjectOffheapImpl</description><code_before>@@ -91,7 +91,17 @@ public BinaryObject heapCopy() {
 
     /** {@inheritDoc} */
     @Override public int typeId() {
-        return BinaryPrimitives.readInt(ptr, start + GridBinaryMarshaller.TYPE_ID_POS);
     }
 
     /** {@inheritDoc} */
@@ -111,7 +121,7 @@ public BinaryObject heapCopy() {
 
     /** {@inheritDoc} */
     @Override protected BinarySchema createSchema() {
-        return reader(null).getOrCreateSchema();
     }
 
     /** {@inheritDoc} */
@@ -145,13 +155,13 @@ public BinaryObject heapCopy() {
     /** {@inheritDoc} */
     @SuppressWarnings("unchecked")
     @Nullable @Override public &lt;F&gt; F field(String fieldName) throws BinaryObjectException {
-        return (F) reader(null).unmarshalField(fieldName);
     }
 
     /** {@inheritDoc} */
     @SuppressWarnings("unchecked")
     @Nullable @Override public &lt;F&gt; F field(int fieldId) throws BinaryObjectException {
-        return (F) reader(null).unmarshalField(fieldId);
     }
 
     /** {@inheritDoc} */
@@ -160,20 +170,20 @@ public BinaryObject heapCopy() {
         Object val;
 
         // Calculate field position.
-        int schemaOffset = BinaryPrimitives.readInt(ptr, start + GridBinaryMarshaller.SCHEMA_OR_RAW_OFF_POS);
 
         short flags = BinaryPrimitives.readShort(ptr, start + GridBinaryMarshaller.FLAGS_POS);
 
         int fieldIdLen = BinaryUtils.isCompactFooter(flags) ? 0 : BinaryUtils.FIELD_ID_LEN;
-        int fieldOffsetLen = BinaryUtils.fieldOffsetLength(flags);
 
-        int fieldOffsetPos = start + schemaOffset + order * (fieldIdLen + fieldOffsetLen) + fieldIdLen;
 
         int fieldPos;
 
-        if (fieldOffsetLen == BinaryUtils.OFFSET_1)
             fieldPos = start + ((int)BinaryPrimitives.readByte(ptr, fieldOffsetPos) &amp; 0xFF);
-        else if (fieldOffsetLen == BinaryUtils.OFFSET_2)
             fieldPos = start + ((int)BinaryPrimitives.readShort(ptr, fieldOffsetPos) &amp; 0xFFFF);
         else
             fieldPos = start + BinaryPrimitives.readInt(ptr, fieldOffsetPos);
@@ -301,12 +311,12 @@ else if (fieldOffsetLen == BinaryUtils.OFFSET_2)
     /** {@inheritDoc} */
     @SuppressWarnings("unchecked")
     @Nullable @Override protected &lt;F&gt; F field(BinaryReaderHandles rCtx, String fieldName) {
-        return (F)reader(rCtx).unmarshalField(fieldName);
     }
 
     /** {@inheritDoc} */
     @Override public boolean hasField(String fieldName) {
-        return reader(null).findFieldByName(fieldName);
     }
 
     /** {@inheritDoc} */
@@ -401,23 +411,25 @@ else if (fieldOffsetLen == BinaryUtils.OFFSET_2)
      * @return Deserialized value.
      */
     private Object deserializeValue() {
-        return reader(null).deserialize();
     }
 
     /**
      * Create new reader for this object.
      *
      * @param rCtx Reader context.
      * @return Reader.
      */
-    private BinaryReaderExImpl reader(@Nullable BinaryReaderHandles rCtx) {
         BinaryOffheapInputStream stream = new BinaryOffheapInputStream(ptr, size, false);
 
         stream.position(start);
 
         return new BinaryReaderExImpl(ctx,
             stream,
             ctx.configuration().getClassLoader(),
-            rCtx);
     }
 }
</code_before><code_after>@@ -91,7 +91,17 @@ public BinaryObject heapCopy() {
 
     /** {@inheritDoc} */
     @Override public int typeId() {
+        int typeId = BinaryPrimitives.readInt(ptr, start + GridBinaryMarshaller.TYPE_ID_POS);
+
+        if (typeId == GridBinaryMarshaller.UNREGISTERED_TYPE_ID) {
+            int off = start + GridBinaryMarshaller.DFLT_HDR_LEN;
+
+            String clsName = BinaryUtils.doReadClassName(new BinaryOffheapInputStream(off, size));
+
+            typeId = ctx.typeId(clsName);
+        }
+
+        return typeId;
     }
 
     /** {@inheritDoc} */
@@ -111,7 +121,7 @@ public BinaryObject heapCopy() {
 
     /** {@inheritDoc} */
     @Override protected BinarySchema createSchema() {
+        return reader(null, false).getOrCreateSchema();
     }
 
     /** {@inheritDoc} */
@@ -145,13 +155,13 @@ public BinaryObject heapCopy() {
     /** {@inheritDoc} */
     @SuppressWarnings("unchecked")
     @Nullable @Override public &lt;F&gt; F field(String fieldName) throws BinaryObjectException {
+        return (F) reader(null, false).unmarshalField(fieldName);
     }
 
     /** {@inheritDoc} */
     @SuppressWarnings("unchecked")
     @Nullable @Override public &lt;F&gt; F field(int fieldId) throws BinaryObjectException {
+        return (F) reader(null, false).unmarshalField(fieldId);
     }
 
     /** {@inheritDoc} */
@@ -160,20 +170,20 @@ public BinaryObject heapCopy() {
         Object val;
 
         // Calculate field position.
+        int schemaOff = BinaryPrimitives.readInt(ptr, start + GridBinaryMarshaller.SCHEMA_OR_RAW_OFF_POS);
 
         short flags = BinaryPrimitives.readShort(ptr, start + GridBinaryMarshaller.FLAGS_POS);
 
         int fieldIdLen = BinaryUtils.isCompactFooter(flags) ? 0 : BinaryUtils.FIELD_ID_LEN;
+        int fieldOffLen = BinaryUtils.fieldOffsetLength(flags);
 
+        int fieldOffsetPos = start + schemaOff + order * (fieldIdLen + fieldOffLen) + fieldIdLen;
 
         int fieldPos;
 
+        if (fieldOffLen == BinaryUtils.OFFSET_1)
             fieldPos = start + ((int)BinaryPrimitives.readByte(ptr, fieldOffsetPos) &amp; 0xFF);
+        else if (fieldOffLen == BinaryUtils.OFFSET_2)
             fieldPos = start + ((int)BinaryPrimitives.readShort(ptr, fieldOffsetPos) &amp; 0xFFFF);
         else
             fieldPos = start + BinaryPrimitives.readInt(ptr, fieldOffsetPos);
@@ -301,12 +311,12 @@ else if (fieldOffsetLen == BinaryUtils.OFFSET_2)
     /** {@inheritDoc} */
     @SuppressWarnings("unchecked")
     @Nullable @Override protected &lt;F&gt; F field(BinaryReaderHandles rCtx, String fieldName) {
+        return (F)reader(rCtx, false).unmarshalField(fieldName);
     }
 
     /** {@inheritDoc} */
     @Override public boolean hasField(String fieldName) {
+        return reader(null, false).findFieldByName(fieldName);
     }
 
     /** {@inheritDoc} */
@@ -401,23 +411,25 @@ else if (fieldOffsetLen == BinaryUtils.OFFSET_2)
      * @return Deserialized value.
      */
     private Object deserializeValue() {
+        return reader(null, true).deserialize();
     }
 
     /**
      * Create new reader for this object.
      *
      * @param rCtx Reader context.
+     * @param forUnmarshal {@code True} if reader is needed to unmarshal object.
      * @return Reader.
      */
+    private BinaryReaderExImpl reader(@Nullable BinaryReaderHandles rCtx, boolean forUnmarshal) {
         BinaryOffheapInputStream stream = new BinaryOffheapInputStream(ptr, size, false);
 
         stream.position(start);
 
         return new BinaryReaderExImpl(ctx,
             stream,
             ctx.configuration().getClassLoader(),
+            rCtx,
+            forUnmarshal);
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>374533</refactoring_id><commit_sha>3e8fde1ed3f626772d055cb53793433d6eebf83e</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/3e8fde1ed3f626772d055cb53793433d6eebf83e</commit_link><file_path>OsmAnd/src/net/osmand/plus/backup/commands/RegisterDeviceCommand.java</file_path><description>Rename Variable serverError : ServerError to backupError : BackupError in method protected doInBackground(objects Object...) : Object from class net.osmand.plus.backup.commands.RegisterDeviceCommand</description><code_before>@@ -7,7 +7,7 @@
 import net.osmand.plus.backup.BackupCommand;
 import net.osmand.plus.backup.BackupHelper;
 import net.osmand.plus.backup.BackupListeners.OnRegisterDeviceListener;
-import net.osmand.plus.backup.ServerError;
 import net.osmand.plus.settings.backend.OsmandSettings;
 import net.osmand.util.Algorithms;
 
@@ -55,10 +55,10 @@ protected Object doInBackground(Object... objects) {
 		AndroidNetworkUtils.sendRequest(getApp(), DEVICE_REGISTER_URL, params, "Register device", false, true, (resultJson, error) -&gt; {
 			int status;
 			String message;
-			ServerError serverError = null;
 			if (!Algorithms.isEmpty(error)) {
-				serverError = new ServerError(error);
-				message = "Device registration error: " + serverError;
 				status = STATUS_SERVER_ERROR;
 			} else if (!Algorithms.isEmpty(resultJson)) {
 				OsmandSettings settings = getApp().getSettings();
@@ -80,7 +80,7 @@ protected Object doInBackground(Object... objects) {
 				message = "Device registration error: empty response";
 				status = STATUS_EMPTY_RESPONSE_ERROR;
 			}
-			publishProgress(status, message, serverError);
 			operationLog.finishOperation(status + " " + message);
 		});
 		return null;
@@ -91,8 +91,8 @@ protected void onProgressUpdate(Object... values) {
 		for (OnRegisterDeviceListener listener : getListeners()) {
 			int status = (Integer) values[0];
 			String message = (String) values[1];
-			ServerError serverError = (ServerError) values[2];
-			listener.onRegisterDevice(status, message, serverError);
 		}
 	}
 }
</code_before><code_after>@@ -7,7 +7,7 @@
 import net.osmand.plus.backup.BackupCommand;
 import net.osmand.plus.backup.BackupHelper;
 import net.osmand.plus.backup.BackupListeners.OnRegisterDeviceListener;
+import net.osmand.plus.backup.BackupError;
 import net.osmand.plus.settings.backend.OsmandSettings;
 import net.osmand.util.Algorithms;
 
@@ -55,10 +55,10 @@ protected Object doInBackground(Object... objects) {
 		AndroidNetworkUtils.sendRequest(getApp(), DEVICE_REGISTER_URL, params, "Register device", false, true, (resultJson, error) -&gt; {
 			int status;
 			String message;
+			BackupError backupError = null;
 			if (!Algorithms.isEmpty(error)) {
+				backupError = new BackupError(error);
+				message = "Device registration error: " + backupError;
 				status = STATUS_SERVER_ERROR;
 			} else if (!Algorithms.isEmpty(resultJson)) {
 				OsmandSettings settings = getApp().getSettings();
@@ -80,7 +80,7 @@ protected Object doInBackground(Object... objects) {
 				message = "Device registration error: empty response";
 				status = STATUS_EMPTY_RESPONSE_ERROR;
 			}
+			publishProgress(status, message, backupError);
 			operationLog.finishOperation(status + " " + message);
 		});
 		return null;
@@ -91,8 +91,8 @@ protected void onProgressUpdate(Object... values) {
 		for (OnRegisterDeviceListener listener : getListeners()) {
 			int status = (Integer) values[0];
 			String message = (String) values[1];
+			BackupError backupError = (BackupError) values[2];
+			listener.onRegisterDevice(status, message, backupError);
 		}
 	}
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>447036</refactoring_id><commit_sha>27c18ef8a39d40fca3750104bf383288c09348fc</commit_sha><commit_link>https://github.com/metersphere/metersphere/commit/27c18ef8a39d40fca3750104bf383288c09348fc</commit_link><file_path>backend/src/main/java/io/metersphere/api/service/ApiModuleService.java</file_path><description>Rename Variable nodes : List&lt;ApiModule&gt; to apiModules : List&lt;ApiModuleDTO&gt; in method public getNodeTreeByProjectId(projectId String, protocol String) : List&lt;ApiModuleDTO&gt; from class io.metersphere.api.service.ApiModuleService</description><code_before>@@ -11,10 +11,12 @@
 import io.metersphere.base.mapper.ApiDefinitionMapper;
 import io.metersphere.base.mapper.ApiModuleMapper;
 import io.metersphere.base.mapper.ext.ExtApiDefinitionMapper;
 import io.metersphere.commons.constants.TestCaseConstants;
 import io.metersphere.commons.exception.MSException;
-import io.metersphere.commons.utils.BeanUtils;
 import io.metersphere.i18n.Translator;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.ibatis.session.ExecutorType;
 import org.apache.ibatis.session.SqlSession;
@@ -28,11 +30,13 @@
 
 @Service
 @Transactional(rollbackFor = Exception.class)
-public class ApiModuleService {
 
     @Resource
     ApiModuleMapper apiModuleMapper;
     @Resource
     private ApiDefinitionMapper apiDefinitionMapper;
     @Resource
     private ExtApiDefinitionMapper extApiDefinitionMapper;
@@ -41,61 +45,10 @@ public class ApiModuleService {
     SqlSessionFactory sqlSessionFactory;
 
     public List&lt;ApiModuleDTO&gt; getNodeTreeByProjectId(String projectId, String protocol) {
-        ApiModuleExample apiDefinitionNodeExample = new ApiModuleExample();
-        apiDefinitionNodeExample.createCriteria().andProjectIdEqualTo(projectId).andProtocolEqualTo(protocol);
-        apiDefinitionNodeExample.setOrderByClause("create_time asc");
-        List&lt;ApiModule&gt; nodes = apiModuleMapper.selectByExample(apiDefinitionNodeExample);
-        return getNodeTrees(nodes);
-    }
-
-    public List&lt;ApiModuleDTO&gt; getNodeTrees(List&lt;ApiModule&gt; nodes) {
-
-        List&lt;ApiModuleDTO&gt; nodeTreeList = new ArrayList&lt;&gt;();
-        Map&lt;Integer, List&lt;ApiModule&gt;&gt; nodeLevelMap = new HashMap&lt;&gt;();
-        nodes.forEach(node -&gt; {
-            Integer level = node.getLevel();
-            if (nodeLevelMap.containsKey(level)) {
-                nodeLevelMap.get(level).add(node);
-            } else {
-                List&lt;ApiModule&gt; apiModules = new ArrayList&lt;&gt;();
-                apiModules.add(node);
-                nodeLevelMap.put(node.getLevel(), apiModules);
-            }
-        });
-        List&lt;ApiModule&gt; rootNodes = Optional.ofNullable(nodeLevelMap.get(1)).orElse(new ArrayList&lt;&gt;());
-        rootNodes.forEach(rootNode -&gt; nodeTreeList.add(buildNodeTree(nodeLevelMap, rootNode)));
-        return nodeTreeList;
     }
 
-    /**
-     * &#x9012;&#x5F52;&#x6784;&#x5EFA;&#x8282;&#x70B9;&#x6811;
-     *
-     * @param nodeLevelMap
-     * @param rootNode
-     * @return
-     */
-    private ApiModuleDTO buildNodeTree(Map&lt;Integer, List&lt;ApiModule&gt;&gt; nodeLevelMap, ApiModule rootNode) {
-
-        ApiModuleDTO nodeTree = new ApiModuleDTO();
-        BeanUtils.copyBean(nodeTree, rootNode);
-        nodeTree.setLabel(rootNode.getName());
-
-        List&lt;ApiModule&gt; lowerNodes = nodeLevelMap.get(rootNode.getLevel() + 1);
-        if (lowerNodes == null) {
-            return nodeTree;
-        }
-        List&lt;ApiModuleDTO&gt; children = Optional.ofNullable(nodeTree.getChildren()).orElse(new ArrayList&lt;&gt;());
-        lowerNodes.forEach(node -&gt; {
-            if (node.getParentId() != null &amp;&amp; node.getParentId().equals(rootNode.getId())) {
-                children.add(buildNodeTree(nodeLevelMap, node));
-                nodeTree.setChildren(children);
-            }
-        });
-
-        return nodeTree;
-    }
-
-
     public String addNode(ApiModule node) {
         validateNode(node);
         return addNodeWithoutValidate(node);
</code_before><code_after>@@ -11,10 +11,12 @@
 import io.metersphere.base.mapper.ApiDefinitionMapper;
 import io.metersphere.base.mapper.ApiModuleMapper;
 import io.metersphere.base.mapper.ext.ExtApiDefinitionMapper;
+import io.metersphere.base.mapper.ext.ExtApiModuleMapper;
 import io.metersphere.commons.constants.TestCaseConstants;
 import io.metersphere.commons.exception.MSException;
+
 import io.metersphere.i18n.Translator;
+import io.metersphere.service.NodeTreeService;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.ibatis.session.ExecutorType;
 import org.apache.ibatis.session.SqlSession;
@@ -28,11 +30,13 @@
 
 @Service
 @Transactional(rollbackFor = Exception.class)
+public class ApiModuleService extends NodeTreeService&lt;ApiModuleDTO&gt; {
 
     @Resource
     ApiModuleMapper apiModuleMapper;
     @Resource
+    ExtApiModuleMapper extApiModuleMapper;
+    @Resource
     private ApiDefinitionMapper apiDefinitionMapper;
     @Resource
     private ExtApiDefinitionMapper extApiDefinitionMapper;
@@ -41,61 +45,10 @@ public class ApiModuleService {
     SqlSessionFactory sqlSessionFactory;
 
     public List&lt;ApiModuleDTO&gt; getNodeTreeByProjectId(String projectId, String protocol) {
+        List&lt;ApiModuleDTO&gt; apiModules = extApiModuleMapper.getNodeTreeByProjectId(projectId, protocol);
+        return getNodeTrees(apiModules);
     }
 
     public String addNode(ApiModule node) {
         validateNode(node);
         return addNodeWithoutValidate(node);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>414465</refactoring_id><commit_sha>65b000598f81a9f7dcaad83ba49cf80ff9a40182</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/65b000598f81a9f7dcaad83ba49cf80ff9a40182</commit_link><file_path>src/edu/stanford/nlp/tagger/maxent/MaxentTagger.java</file_path><description>Rename Variable wordspersec : double to wordsPerSec : double in method private printErrWordsPerSec(milliSec long, numWords int) : void from class edu.stanford.nlp.tagger.maxent.MaxentTagger</description><code_before>@@ -153,7 +153,7 @@
  * &lt;tr&gt;&lt;td&gt;model&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;All&lt;/td&gt;&lt;td&gt;Path and filename where you would like to save the model (training) or where the model should be loaded from (testing, tagging).&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;trainFile&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Train&lt;/td&gt;
      &lt;td&gt;
-       Path to the file holding the training data; specifying this option puts the tagger in training mode.  Only one of 'trainFile','testFile','textFile', and 'convertToSingleFile' may be specified.&lt;br&gt;
        There are three formats possible.  The first is a text file of tagged data, Each line is considered a separate sentence.  In each sentence, words are separated by whitespace.  Each word must have a tag, which is separated using the specified tagSeparator.  This format is the default format.&lt;br&gt;
        Another possible format is a file of Penn Treebank formatted tree files.  Trees are loaded one at a time and the tagged words in the tree are used as the training sentence.  To specify this format, preface the filename with "&lt;code&gt;format=TREES,&lt;/code&gt;".  &lt;br&gt;
        The final possible format is TSV files.  To specify a TSV file, set trainFile to "&lt;code&gt;format=TSV,wordColumn=x,tagColumn=y,filename&lt;/code&gt;".  Column numbers are indexed at 0, and sentences are separated with blank lines.
@@ -164,9 +164,9 @@
        You will note that none of , ; or = can be in filenames.
      &lt;/td&gt;
    &lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;testFile&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Test&lt;/td&gt;&lt;td&gt;Path to the file holding the test data; specifying this option puts the tagger in testing mode.  Only one of 'trainFile','testFile','textFile', and 'convertToSingleFile' may be specified.  The same format as trainFile applies, but only one file can be specified.&lt;/td&gt;&lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;textFile&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Tag&lt;/td&gt;&lt;td&gt;Path to the file holding the text to tag; specifying this option puts the tagger in tagging mode.  Only one of 'trainFile','testFile','textFile', and 'convertToSingleFile' may be specified.  No file reading options may be specified for textFile&lt;/td&gt;&lt;/tr&gt;
- * &lt;tr&gt;&lt;td&gt;convertToSingleFile&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Provided only for backwards compatibility, this option allows you to convert a tagger trained using a previous version of the tagger to the new single-file format.  The value of this flag should be the path for the new model file, 'model' should be the path prefix to the old tagger (up to but not including the ".holder"), and you should supply the properties configuration for the old tagger with -props (before these two arguments).&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;genprops&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Use this option to output a default properties file, containing information about each of the possible configuration options.&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;tagSeparator&lt;/td&gt;&lt;td&gt;char&lt;/td&gt;&lt;td&gt;/&lt;/td&gt;&lt;td&gt;All&lt;/td&gt;&lt;td&gt;Separator character that separates word and part of speech tags, such as out/IN or out_IN.  For training and testing, this is the separator used in the train/test files.  For tagging, this is the character that will be inserted between words and tags in the output.&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;encoding&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;UTF-8&lt;/td&gt;&lt;td&gt;All&lt;/td&gt;&lt;td&gt;Encoding of the read files (training, testing) and the output text files.&lt;/td&gt;&lt;/tr&gt;
@@ -287,6 +287,27 @@ public MaxentTagger(String modelFile, Properties config, boolean printLoading) {
   Dictionary dict = new Dictionary();
   TTags tags;
 
   private LambdaSolveTagger prob;
   // For each extractor index, we have a map from possible extracted
   // features to an array which maps from tag number to feature weight index in the lambdas array.
@@ -799,10 +820,10 @@ protected void readModelAndInit(Properties config, DataInputStream rf, boolean p
       readExtractors(rf);
       dict.setAmbClasses(ambClasses, veryCommonWordThresh, tags);
 
-      int[] numFA = new int[extractors.getSize() + extractorsRare.getSize()];
       int sizeAssoc = rf.readInt();
       fAssociations = new ArrayList&lt;Map&lt;String, int[]&gt;&gt;();
-      for (int i = 0; i &lt; extractors.getSize() + extractorsRare.getSize(); ++i) {
         fAssociations.add(Generics.&lt;String, int[]&gt;newHashMap());
       }
       if (VERBOSE) System.err.printf("Reading %d feature keys...\n",sizeAssoc);
@@ -853,16 +874,20 @@ protected void readModelAndInit(Properties config, DataInputStream rf, boolean p
 
 
   protected void dumpModel(PrintStream out) {
     for (int i = 0; i &lt; fAssociations.size(); ++i) {
       Map&lt;String, int[]&gt; fValueAssociations = fAssociations.get(i);
-      for (Map.Entry&lt;String, int[]&gt; item : fValueAssociations.entrySet()) {
-        String featureValue = item.getKey();
-        int[] fTagAssociations = item.getValue();
         for (int j = 0; j &lt; fTagAssociations.length; ++j) {
           int association = fTagAssociations[j];
           if (association &gt;= 0) {
             FeatureKey fk = new FeatureKey(i, featureValue, tags.getTag(j));
-            out.println(fk + ": " + association);
           }
         }
       }
@@ -935,8 +960,9 @@ public ArrayList&lt;TaggedWord&gt; apply(List&lt;? extends HasWord&gt; in) {
    * it through {@link edu.stanford.nlp.process.WordToSentenceProcessor}.
    *
    * @param sentences A List of Sentence
-   * @return A List of Sentence of TaggedWord (final generification cannot be listed due to lack of complete generification of super classes)
    */
   public List&lt;ArrayList&lt;TaggedWord&gt;&gt; process(List&lt;? extends List&lt;? extends HasWord&gt;&gt; sentences) {
     List&lt;ArrayList&lt;TaggedWord&gt;&gt; taggedSentences = new ArrayList&lt;ArrayList&lt;TaggedWord&gt;&gt;();
 
@@ -1066,7 +1092,7 @@ public static List&lt;List&lt;HasWord&gt;&gt; tokenizeText(Reader r,
 
   private static void dumpModel(TaggerConfig config) {
     try {
-      MaxentTagger tagger = new MaxentTagger(config.getFile(), config, false);
       System.out.println("Serialized tagger built with config:");
       tagger.config.dump(System.out);
       tagger.dumpModel(System.out);
@@ -1188,10 +1214,10 @@ private static void runTraining(TaggerConfig config)
 
 
   private static void printErrWordsPerSec(long milliSec, int numWords) {
-    double wordspersec = numWords / (((double) milliSec) / 1000);
     NumberFormat nf = new DecimalFormat("0.00");
     System.err.println("Tagged " + numWords + " words at " +
-        nf.format(wordspersec) + " words per second.");
   }
 
 
@@ -1807,7 +1833,7 @@ public static void main(String[] args) throws Exception {
     } else if (config.getMode() == TaggerConfig.Mode.DUMP) {
       dumpModel(config);
     } else {
-      System.err.println("Impossible: nothing to do. None of train, tag, test, or convert was specified.");
     }
   } // end main()
 
</code_before><code_after>@@ -153,7 +153,7 @@
  * &lt;tr&gt;&lt;td&gt;model&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;All&lt;/td&gt;&lt;td&gt;Path and filename where you would like to save the model (training) or where the model should be loaded from (testing, tagging).&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;trainFile&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Train&lt;/td&gt;
      &lt;td&gt;
+       Path to the file holding the training data; specifying this option puts the tagger in training mode.  Only one of 'trainFile','testFile','textFile', and 'dump' may be specified.&lt;br&gt;
        There are three formats possible.  The first is a text file of tagged data, Each line is considered a separate sentence.  In each sentence, words are separated by whitespace.  Each word must have a tag, which is separated using the specified tagSeparator.  This format is the default format.&lt;br&gt;
        Another possible format is a file of Penn Treebank formatted tree files.  Trees are loaded one at a time and the tagged words in the tree are used as the training sentence.  To specify this format, preface the filename with "&lt;code&gt;format=TREES,&lt;/code&gt;".  &lt;br&gt;
        The final possible format is TSV files.  To specify a TSV file, set trainFile to "&lt;code&gt;format=TSV,wordColumn=x,tagColumn=y,filename&lt;/code&gt;".  Column numbers are indexed at 0, and sentences are separated with blank lines.
@@ -164,9 +164,9 @@
        You will note that none of , ; or = can be in filenames.
      &lt;/td&gt;
    &lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;testFile&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Test&lt;/td&gt;&lt;td&gt;Path to the file holding the test data; specifying this option puts the tagger in testing mode.  Only one of 'trainFile','testFile','textFile', and 'dump' may be specified.  The same format as trainFile applies, but only one file can be specified.&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;textFile&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Tag&lt;/td&gt;&lt;td&gt;Path to the file holding the text to tag; specifying this option puts the tagger in tagging mode.  Only one of 'trainFile','testFile','textFile', and 'dump' may be specified.  No file reading options may be specified for textFile&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;td&gt;dump&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Dump&lt;/td&gt;&lt;td&gt;Path to the file holding the model to dump; specifying this option puts the tagger in dumping mode.  Only one of 'trainFile','testFile','textFile', and 'dump' may be specified.&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;genprops&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Use this option to output a default properties file, containing information about each of the possible configuration options.&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;tagSeparator&lt;/td&gt;&lt;td&gt;char&lt;/td&gt;&lt;td&gt;/&lt;/td&gt;&lt;td&gt;All&lt;/td&gt;&lt;td&gt;Separator character that separates word and part of speech tags, such as out/IN or out_IN.  For training and testing, this is the separator used in the train/test files.  For tagging, this is the character that will be inserted between words and tags in the output.&lt;/td&gt;&lt;/tr&gt;
  * &lt;tr&gt;&lt;td&gt;encoding&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;UTF-8&lt;/td&gt;&lt;td&gt;All&lt;/td&gt;&lt;td&gt;Encoding of the read files (training, testing) and the output text files.&lt;/td&gt;&lt;/tr&gt;
@@ -287,6 +287,27 @@ public MaxentTagger(String modelFile, Properties config, boolean printLoading) {
   Dictionary dict = new Dictionary();
   TTags tags;
 
+  /**
+   * Will return the index of a tag, adding it if it doesn't already exist
+   */
+  public int addTag(String tag) {
+    return tags.add(tag);
+  }
+  /**
+   * Will return the index of a tag if known, -1 if not already known
+   */
+  public int getTagIndex(String tag) {
+    return tags.getIndex(tag);
+  }
+
+  public int numTags() {
+    return tags.getSize();
+  }
+
+  public String getTag(int index) {
+    return tags.getTag(index);
+  }
+
   private LambdaSolveTagger prob;
   // For each extractor index, we have a map from possible extracted
   // features to an array which maps from tag number to feature weight index in the lambdas array.
@@ -799,10 +820,10 @@ protected void readModelAndInit(Properties config, DataInputStream rf, boolean p
       readExtractors(rf);
       dict.setAmbClasses(ambClasses, veryCommonWordThresh, tags);
 
+      int[] numFA = new int[extractors.size() + extractorsRare.size()];
       int sizeAssoc = rf.readInt();
       fAssociations = new ArrayList&lt;Map&lt;String, int[]&gt;&gt;();
+      for (int i = 0; i &lt; extractors.size() + extractorsRare.size(); ++i) {
         fAssociations.add(Generics.&lt;String, int[]&gt;newHashMap());
       }
       if (VERBOSE) System.err.printf("Reading %d feature keys...\n",sizeAssoc);
@@ -853,16 +874,20 @@ protected void readModelAndInit(Properties config, DataInputStream rf, boolean p
 
 
   protected void dumpModel(PrintStream out) {
+    out.println("Features: template featureValue tag: lambda");
+    NumberFormat nf = new DecimalFormat(" 0.000000;-0.000000");
     for (int i = 0; i &lt; fAssociations.size(); ++i) {
       Map&lt;String, int[]&gt; fValueAssociations = fAssociations.get(i);
+      List&lt;String&gt; features = new ArrayList&lt;String&gt;(fValueAssociations.keySet());
+      Collections.sort(features);
+      for (String featureValue : features) {
+        int[] fTagAssociations = fValueAssociations.get(featureValue);
         for (int j = 0; j &lt; fTagAssociations.length; ++j) {
           int association = fTagAssociations[j];
           if (association &gt;= 0) {
             FeatureKey fk = new FeatureKey(i, featureValue, tags.getTag(j));
+            out.println((fk.num &lt; extractors.size() ? extractors.get(fk.num) : extractorsRare.get(fk.num - extractors.size()))
+                    + " " + fk.val + " " + fk.tag + ": " + nf.format(getLambdaSolve().lambda[association]));
           }
         }
       }
@@ -935,8 +960,9 @@ public ArrayList&lt;TaggedWord&gt; apply(List&lt;? extends HasWord&gt; in) {
    * it through {@link edu.stanford.nlp.process.WordToSentenceProcessor}.
    *
    * @param sentences A List of Sentence
+   * @return A List of Sentence of TaggedWord
    */
+  @Override
   public List&lt;ArrayList&lt;TaggedWord&gt;&gt; process(List&lt;? extends List&lt;? extends HasWord&gt;&gt; sentences) {
     List&lt;ArrayList&lt;TaggedWord&gt;&gt; taggedSentences = new ArrayList&lt;ArrayList&lt;TaggedWord&gt;&gt;();
 
@@ -1066,7 +1092,7 @@ public static List&lt;List&lt;HasWord&gt;&gt; tokenizeText(Reader r,
 
   private static void dumpModel(TaggerConfig config) {
     try {
+      MaxentTagger tagger = new MaxentTagger(config.getModel(), config, false);
       System.out.println("Serialized tagger built with config:");
       tagger.config.dump(System.out);
       tagger.dumpModel(System.out);
@@ -1188,10 +1214,10 @@ private static void runTraining(TaggerConfig config)
 
 
   private static void printErrWordsPerSec(long milliSec, int numWords) {
+    double wordsPerSec = numWords / (((double) milliSec) / 1000);
     NumberFormat nf = new DecimalFormat("0.00");
     System.err.println("Tagged " + numWords + " words at " +
+        nf.format(wordsPerSec) + " words per second.");
   }
 
 
@@ -1807,7 +1833,7 @@ public static void main(String[] args) throws Exception {
     } else if (config.getMode() == TaggerConfig.Mode.DUMP) {
       dumpModel(config);
     } else {
+      System.err.println("Impossible: nothing to do. None of train, tag, test, or dump was specified.");
     }
   } // end main()
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>362545</refactoring_id><commit_sha>bcd7716e90e5ba7e459987e64c1fc6aa17dba1b0</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/bcd7716e90e5ba7e459987e64c1fc6aa17dba1b0</commit_link><file_path>backend/src/main/java/org/camunda/optimize/service/es/reader/ProcessDefinitionReader.java</file_path><description>Rename Variable node : FlowNode to id : String in method public getFlowNodeNames(processDefinitionId String, nodeIds List&lt;String&gt;) : FlowNodeNamesDto from class org.camunda.optimize.service.es.reader.ProcessDefinitionReader</description><code_before>@@ -4,6 +4,7 @@
 import org.camunda.bpm.model.bpmn.Bpmn;
 import org.camunda.bpm.model.bpmn.BpmnModelInstance;
 import org.camunda.bpm.model.bpmn.instance.FlowNode;
 import org.camunda.optimize.dto.optimize.query.ExtendedProcessDefinitionOptimizeDto;
 import org.camunda.optimize.dto.optimize.query.ProcessDefinitionGroupOptimizeDto;
 import org.camunda.optimize.dto.optimize.rest.FlowNodeNamesDto;
@@ -119,21 +120,31 @@ private ExtendedProcessDefinitionOptimizeDto mapSearchToProcessDefinition(Search
   }
 
   public String getProcessDefinitionXml(String processDefinitionId) {
     GetResponse response = esclient.prepareGet(
         configurationService.getOptimizeIndex(configurationService.getProcessDefinitionXmlType()),
         configurationService.getProcessDefinitionXmlType(),
         processDefinitionId)
         .get();
 
-    String xml = null;
     if (response.isExists()) {
-      xml = response.getSource().get(ProcessDefinitionXmlType.BPMN_20_XML).toString();
     } else {
       logger.warn("Could not find process definition xml with id {}", processDefinitionId);
     }
     return xml;
   }
 
   public List&lt;ProcessDefinitionGroupOptimizeDto&gt; getProcessDefinitionsGroupedByKey() {
     Map&lt;String, ProcessDefinitionGroupOptimizeDto&gt; resultMap = new HashMap&lt;&gt;();
     List&lt;ExtendedProcessDefinitionOptimizeDto&gt; allDefinitions = getProcessDefinitions();
@@ -181,19 +192,13 @@ public Map&lt;String, String&gt; getProcessDefinitionsXml(List&lt;String&gt; ids) {
 
   public FlowNodeNamesDto getFlowNodeNames(String processDefinitionId, List&lt;String&gt; nodeIds) {
     FlowNodeNamesDto result = new FlowNodeNamesDto();
-
-    String processDefinitionXml = this.getProcessDefinitionXml(processDefinitionId);
-    if (processDefinitionXml != null) {
-      BpmnModelInstance model = Bpmn.readModelFromStream(new ByteArrayInputStream(processDefinitionXml.getBytes()));
-      for (FlowNode node : model.getModelElementsByType(FlowNode.class)) {
-        if (nodeIds != null &amp;&amp; !nodeIds.isEmpty()) {
-          if (nodeIds.contains(node.getId())) {
-            result.getFlowNodeNames().put(node.getId(), node.getName());
-          }
-        } else {
-          result.getFlowNodeNames().put(node.getId(), node.getName());
-        }
       }
     }
     return result;
   }
</code_before><code_after>@@ -4,6 +4,7 @@
 import org.camunda.bpm.model.bpmn.Bpmn;
 import org.camunda.bpm.model.bpmn.BpmnModelInstance;
 import org.camunda.bpm.model.bpmn.instance.FlowNode;
+import org.camunda.optimize.dto.optimize.importing.ProcessDefinitionXmlOptimizeDto;
 import org.camunda.optimize.dto.optimize.query.ExtendedProcessDefinitionOptimizeDto;
 import org.camunda.optimize.dto.optimize.query.ProcessDefinitionGroupOptimizeDto;
 import org.camunda.optimize.dto.optimize.rest.FlowNodeNamesDto;
@@ -119,21 +120,31 @@ private ExtendedProcessDefinitionOptimizeDto mapSearchToProcessDefinition(Search
   }
 
   public String getProcessDefinitionXml(String processDefinitionId) {
+    return getProcessDefinitionXmlDto(processDefinitionId).getBpmn20Xml();
+  }
+
+  public ProcessDefinitionXmlOptimizeDto getProcessDefinitionXmlDto(String processDefinitionId) {
     GetResponse response = esclient.prepareGet(
         configurationService.getOptimizeIndex(configurationService.getProcessDefinitionXmlType()),
         configurationService.getProcessDefinitionXmlType(),
         processDefinitionId)
         .get();
 
+    ProcessDefinitionXmlOptimizeDto xml = null;
     if (response.isExists()) {
+      xml = new ProcessDefinitionXmlOptimizeDto ();
+
+      xml.setBpmn20Xml(response.getSource().get(ProcessDefinitionXmlType.BPMN_20_XML).toString());
+      xml.setId(response.getSource().get(ProcessDefinitionXmlType.ID).toString());
+      xml.setEngine(response.getSource().get(ProcessDefinitionXmlType.ENGINE).toString());
+      xml.setFlowNodeNames((Map&lt;String, String&gt;) response.getSource().get(ProcessDefinitionXmlType.FLOW_NODE_NAMES));
     } else {
       logger.warn("Could not find process definition xml with id {}", processDefinitionId);
     }
     return xml;
   }
 
+
   public List&lt;ProcessDefinitionGroupOptimizeDto&gt; getProcessDefinitionsGroupedByKey() {
     Map&lt;String, ProcessDefinitionGroupOptimizeDto&gt; resultMap = new HashMap&lt;&gt;();
     List&lt;ExtendedProcessDefinitionOptimizeDto&gt; allDefinitions = getProcessDefinitions();
@@ -181,19 +192,13 @@ public Map&lt;String, String&gt; getProcessDefinitionsXml(List&lt;String&gt; ids) {
 
   public FlowNodeNamesDto getFlowNodeNames(String processDefinitionId, List&lt;String&gt; nodeIds) {
     FlowNodeNamesDto result = new FlowNodeNamesDto();
+    ProcessDefinitionXmlOptimizeDto processDefinitionXmlDto = getProcessDefinitionXmlDto(processDefinitionId);
+    if (nodeIds != null &amp;&amp; !nodeIds.isEmpty()) {
+      for (String id : nodeIds) {
+        result.getFlowNodeNames().put(id, processDefinitionXmlDto.getFlowNodeNames().get(id));
       }
+    } else {
+      result.setFlowNodeNames(processDefinitionXmlDto.getFlowNodeNames());
     }
     return result;
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>381971</refactoring_id><commit_sha>d5cf8087e3348754c28cc40c1b8f724ac4c90b75</commit_sha><commit_link>https://github.com/apache/ignite/commit/d5cf8087e3348754c28cc40c1b8f724ac4c90b75</commit_link><file_path>modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/IgnitePdsDiscoDataHandlingInNewClusterTest.java</file_path><description>Rename Variable mixedCachesGroupFound : boolean to mixedCachesGrpFound : boolean in method private verifyCachesAndGroups(ig IgniteEx) : void from class org.apache.ignite.internal.processors.cache.persistence.IgnitePdsDiscoDataHandlingInNewClusterTest</description><code_before>@@ -170,23 +170,23 @@ private void verifyCachesAndGroups(IgniteEx ig) {
         assertTrue(caches.keySet().contains(STATIC_CACHE_NAME_0));
         assertTrue(caches.keySet().contains(DYNAMIC_CACHE_NAME_0));
 
-        Map&lt;Integer, CacheGroupDescriptor&gt; groups = ig.context().cache().cacheGroupDescriptors();
 
-        assertEquals(2, groups.size());
 
-        boolean dfltGroupFound = false;
-        boolean mixedCachesGroupFound = false;
 
-        for (CacheGroupDescriptor grpDesc : groups.values()) {
             if (grpDesc.cacheOrGroupName().equals(GridCacheUtils.UTILITY_CACHE_NAME))
-                dfltGroupFound = true;
             else if (grpDesc.cacheOrGroupName().equals(MIXED_CACHES_GROUP_NAME_0))
-                mixedCachesGroupFound = true;
         }
 
         assertTrue(String.format("Default group found: %b, mixed group found: %b",
-            dfltGroupFound,
-            mixedCachesGroupFound),
-            dfltGroupFound &amp;&amp; mixedCachesGroupFound);
     }
 }
</code_before><code_after>@@ -170,23 +170,23 @@ private void verifyCachesAndGroups(IgniteEx ig) {
         assertTrue(caches.keySet().contains(STATIC_CACHE_NAME_0));
         assertTrue(caches.keySet().contains(DYNAMIC_CACHE_NAME_0));
 
+        Map&lt;Integer, CacheGroupDescriptor&gt; grps = ig.context().cache().cacheGroupDescriptors();
 
+        assertEquals(2, grps.size());
 
+        boolean dfltGrpFound = false;
+        boolean mixedCachesGrpFound = false;
 
+        for (CacheGroupDescriptor grpDesc : grps.values()) {
             if (grpDesc.cacheOrGroupName().equals(GridCacheUtils.UTILITY_CACHE_NAME))
+                dfltGrpFound = true;
             else if (grpDesc.cacheOrGroupName().equals(MIXED_CACHES_GROUP_NAME_0))
+                mixedCachesGrpFound = true;
         }
 
         assertTrue(String.format("Default group found: %b, mixed group found: %b",
+            dfltGrpFound,
+            mixedCachesGrpFound),
+            dfltGrpFound &amp;&amp; mixedCachesGrpFound);
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>363311</refactoring_id><commit_sha>fdc57c1bf4c3f7cee5cb7e4ab68caa11e6ff20d7</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/fdc57c1bf4c3f7cee5cb7e4ab68caa11e6ff20d7</commit_link><file_path>dmn/src/test/java/io/camunda/zeebe/dmn/DmnEvaluatedDecisionsTest.java</file_path><description>Rename Variable decision_table : var to result : var in method package shouldUseInputExpressionAsInputName() : void from class io.camunda.zeebe.dmn.DmnEvaluatedDecisionsTest.DecisionTableTest</description><code_before>@@ -261,10 +261,11 @@ class DecisionTableTest {
     @Test
     @DisplayName("Should use input label as input name, if label defined")
     void shouldUseInputLabelAsInputName() {
 
-      final var decision_table = evaluateDecision(DRG_DECISION_TABLE, "labeled_input");
-
-      assertThat(decision_table.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::evaluatedInputs)
           .extracting(EvaluatedInput::inputName)
           .containsExactly("input_label_is_used_as_input_name");
@@ -273,10 +274,11 @@ void shouldUseInputLabelAsInputName() {
     @Test
     @DisplayName("Should use input expression as input name, if no label defined")
     void shouldUseInputExpressionAsInputName() {
 
-      final var decision_table = evaluateDecision(DRG_DECISION_TABLE, "unlabeled_input");
-
-      assertThat(decision_table.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::evaluatedInputs)
           .extracting(EvaluatedInput::inputName)
           // the expression is truncated at 30 chars when used as name
@@ -286,10 +288,11 @@ void shouldUseInputExpressionAsInputName() {
     @Test
     @DisplayName("Should use output label as output name, if label defined")
     void shouldUseOutputLabelAsOutputName() {
 
-      final var decision_table = evaluateDecision(DRG_DECISION_TABLE, "labeled_output");
-
-      assertThat(decision_table.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::matchedRules)
           .flatMap(MatchedRule::evaluatedOutputs)
           .extracting(EvaluatedOutput::outputName)
@@ -299,10 +302,11 @@ void shouldUseOutputLabelAsOutputName() {
     @Test
     @DisplayName("Should use output name as output name, if no label defined")
     void shouldUseOutputNameAsOutputName() {
 
-      final var decision_table = evaluateDecision(DRG_DECISION_TABLE, "unlabeled_output");
-
-      assertThat(decision_table.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::matchedRules)
           .flatMap(MatchedRule::evaluatedOutputs)
           .extracting(EvaluatedOutput::outputName)
</code_before><code_after>@@ -261,10 +261,11 @@ class DecisionTableTest {
     @Test
     @DisplayName("Should use input label as input name, if label defined")
     void shouldUseInputLabelAsInputName() {
+      // when
+      final var result = evaluateDecision(DRG_DECISION_TABLE, "labeled_input");
 
+      // then
+      assertThat(result.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::evaluatedInputs)
           .extracting(EvaluatedInput::inputName)
           .containsExactly("input_label_is_used_as_input_name");
@@ -273,10 +274,11 @@ void shouldUseInputLabelAsInputName() {
     @Test
     @DisplayName("Should use input expression as input name, if no label defined")
     void shouldUseInputExpressionAsInputName() {
+      // when
+      final var result = evaluateDecision(DRG_DECISION_TABLE, "unlabeled_input");
 
+      // then
+      assertThat(result.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::evaluatedInputs)
           .extracting(EvaluatedInput::inputName)
           // the expression is truncated at 30 chars when used as name
@@ -286,10 +288,11 @@ void shouldUseInputExpressionAsInputName() {
     @Test
     @DisplayName("Should use output label as output name, if label defined")
     void shouldUseOutputLabelAsOutputName() {
+      // when
+      final var result = evaluateDecision(DRG_DECISION_TABLE, "labeled_output");
 
+      // then
+      assertThat(result.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::matchedRules)
           .flatMap(MatchedRule::evaluatedOutputs)
           .extracting(EvaluatedOutput::outputName)
@@ -299,10 +302,11 @@ void shouldUseOutputLabelAsOutputName() {
     @Test
     @DisplayName("Should use output name as output name, if no label defined")
     void shouldUseOutputNameAsOutputName() {
+      // when
+      final var result = evaluateDecision(DRG_DECISION_TABLE, "unlabeled_output");
 
+      // then
+      assertThat(result.getEvaluatedDecisions())
           .flatMap(EvaluatedDecision::matchedRules)
           .flatMap(MatchedRule::evaluatedOutputs)
           .extracting(EvaluatedOutput::outputName)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>411869</refactoring_id><commit_sha>1e7c3874f9d390b189ef12d4ed454d169cec386d</commit_sha><commit_link>https://github.com/real-logic/aeron/commit/1e7c3874f9d390b189ef12d4ed454d169cec386d</commit_link><file_path>aeron-driver/src/main/java/io/aeron/driver/DriverConductor.java</file_path><description>Rename Variable registrationId : long to subscriberRegistrationId : long in method private linkSpy(publication NetworkPublication, subscription SubscriptionLink) : void from class io.aeron.driver.DriverConductor</description><code_before>@@ -963,23 +963,23 @@ private void linkIpcSubscription(final IpcSubscriptionLink subscription, final I
     private void linkSpy(final NetworkPublication publication, final SubscriptionLink subscription)
     {
         final long joinPosition = publication.consumerPosition();
-        final long registrationId = subscription.registrationId();
         final int streamId = publication.streamId();
         final int sessionId = publication.sessionId();
         final String channel = subscription.uri();
 
         final Position position = SubscriberPos.allocate(
-            countersManager, registrationId, sessionId, streamId, channel, joinPosition);
 
         position.setOrdered(joinPosition);
         publication.addSubscriber(position);
         subscription.link(publication, position);
 
         clientProxy.onAvailableImage(
-            correlationId(publication.rawLog().metaData()),
             streamId,
             sessionId,
-            registrationId,
             position.id(),
             publication.rawLog().fileName(),
             channel);
</code_before><code_after>@@ -963,23 +963,23 @@ private void linkIpcSubscription(final IpcSubscriptionLink subscription, final I
     private void linkSpy(final NetworkPublication publication, final SubscriptionLink subscription)
     {
         final long joinPosition = publication.consumerPosition();
+        final long subscriberRegistrationId = subscription.registrationId();
         final int streamId = publication.streamId();
         final int sessionId = publication.sessionId();
         final String channel = subscription.uri();
 
         final Position position = SubscriberPos.allocate(
+            countersManager, subscriberRegistrationId, sessionId, streamId, channel, joinPosition);
 
         position.setOrdered(joinPosition);
         publication.addSubscriber(position);
         subscription.link(publication, position);
 
         clientProxy.onAvailableImage(
+            publication.registrationId(),
             streamId,
             sessionId,
+            subscriberRegistrationId,
             position.id(),
             publication.rawLog().fileName(),
             channel);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>460653</refactoring_id><commit_sha>3b02e25fc5845a539999c802ce945cdf707a637d</commit_sha><commit_link>https://github.com/oracle/graal/commit/3b02e25fc5845a539999c802ce945cdf707a637d</commit_link><file_path>espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/VM.java</file_path><description>Rename Variable refsArray : Object[] to result : Object in method public getLocalObject(frame Frame, slot int) : StaticObject from class com.oracle.truffle.espresso.nodes.BytecodeNode</description><code_before>@@ -70,8 +70,6 @@
 import com.oracle.truffle.api.frame.Frame;
 import com.oracle.truffle.api.frame.FrameInstance;
 import com.oracle.truffle.api.frame.FrameInstanceVisitor;
-import com.oracle.truffle.api.frame.FrameSlot;
-import com.oracle.truffle.api.frame.FrameSlotTypeException;
 import com.oracle.truffle.api.interop.ArityException;
 import com.oracle.truffle.api.interop.InteropLibrary;
 import com.oracle.truffle.api.interop.InvalidArrayIndexException;
@@ -2764,17 +2762,10 @@ public StaticObject visitFrame(FrameInstance frameInstance) {
                                     m.getName() == Name.executePrivileged) {
                         isPrivileged[0] = true;
                         Frame frame = frameInstance.getFrame(FrameInstance.FrameAccess.READ_ONLY);
-                        FrameSlot refs = frame.getFrameDescriptor().findFrameSlot("refs");
-                        Object[] refsArray = null;
-                        try {
-                            refsArray = (Object[]) frame.getObject(refs);
-                        } catch (FrameSlotTypeException e) {
-                            throw EspressoError.shouldNotReachHere();
-                        }
                         // 2nd argument: `AccessControlContext context`
-                        stackContext = BytecodeNode.getLocalObject(refsArray, 1);
                         // 3rd argument: Class&lt;?&gt; caller
-                        domainKlass = BytecodeNode.getLocalObject(refsArray, 2);
                     } else {
                         domainKlass = m.getDeclaringKlass().mirror();
                     }
</code_before><code_after>@@ -70,8 +70,6 @@
 import com.oracle.truffle.api.frame.Frame;
 import com.oracle.truffle.api.frame.FrameInstance;
 import com.oracle.truffle.api.frame.FrameInstanceVisitor;
 import com.oracle.truffle.api.interop.ArityException;
 import com.oracle.truffle.api.interop.InteropLibrary;
 import com.oracle.truffle.api.interop.InvalidArrayIndexException;
@@ -2764,17 +2762,10 @@ public StaticObject visitFrame(FrameInstance frameInstance) {
                                     m.getName() == Name.executePrivileged) {
                         isPrivileged[0] = true;
                         Frame frame = frameInstance.getFrame(FrameInstance.FrameAccess.READ_ONLY);
                         // 2nd argument: `AccessControlContext context`
+                        stackContext = BytecodeNode.getLocalObject(frame, 1);
                         // 3rd argument: Class&lt;?&gt; caller
+                        domainKlass = BytecodeNode.getLocalObject(frame, 2);
                     } else {
                         domainKlass = m.getDeclaringKlass().mirror();
                     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>382246</refactoring_id><commit_sha>318ffe50fc0edb1d31f05044be8367bd578b6a88</commit_sha><commit_link>https://github.com/apache/ignite/commit/318ffe50fc0edb1d31f05044be8367bd578b6a88</commit_link><file_path>modules/ml/src/test/java/org/apache/ignite/ml/svm/multi/GenericLinearSVMMultiClassClassificationTrainerTest.java</file_path><description>Rename Variable lbs : double[] to vec : double[] in method public testTrainWithTheLinearlySeparableCase() : void from class org.apache.ignite.ml.svm.SVMBinaryTrainerTest</description><code_before>@@ -1,76 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.ignite.ml.svm.multi;
-
-import org.apache.ignite.internal.util.IgniteUtils;
-import org.apache.ignite.ml.TestUtils;
-import org.apache.ignite.ml.Trainer;
-import org.apache.ignite.ml.math.impls.vector.DenseLocalOnHeapVector;
-import org.apache.ignite.ml.structures.LabeledDataset;
-import org.apache.ignite.ml.svm.BaseSVMTest;
-import org.apache.ignite.ml.svm.SVMLinearMultiClassClassificationModel;
-import org.junit.Test;
-
-/**
- * Base class for all linear regression trainers.
- */
-public class GenericLinearSVMMultiClassClassificationTrainerTest extends BaseSVMTest {
-    /** */
-    private final Trainer&lt;SVMLinearMultiClassClassificationModel, LabeledDataset&gt; trainer;
-
-    /** */
-    private boolean isDistributed;
-
-    /** */
-    private final double precision;
-
-    /** */
-    GenericLinearSVMMultiClassClassificationTrainerTest(
-        Trainer&lt;SVMLinearMultiClassClassificationModel, LabeledDataset&gt; trainer,
-        boolean isDistributed,
-        double precision) {
-        super();
-        this.trainer = trainer;
-        this.precision = precision;
-        this.isDistributed = isDistributed;
-    }
-
-    /**
-     * Test trainer on classification model y = x.
-     */
-    @Test
-    public void testTrainWithTheLinearlySeparableCase() {
-        if (isDistributed)
-            IgniteUtils.setCurrentIgniteName(ignite.configuration().getIgniteInstanceName());
-        double[][] mtx =
-            new double[][] {
-                {-10.0, 12.0},
-                {-5.0, 14.0},
-                {-3.0, 18.0},
-                {13.0, -1.0},
-                {10.0, -2.0},
-                {15.0, -3.0}};
-        double[] lbs = new double[] {1.0, 1.0, 1.0, 2.0, 2.0, 2.0};
-        LabeledDataset dataset = new LabeledDataset(mtx, lbs, null, isDistributed);
-
-
-        SVMLinearMultiClassClassificationModel mdl = trainer.train(dataset);
-        TestUtils.assertEquals(1.0, mdl.apply(new DenseLocalOnHeapVector(new double[] {-2.0, 15})), precision);
-        TestUtils.assertEquals(2.0, mdl.apply(new DenseLocalOnHeapVector(new double[] {12, -5})), precision);
-    }
-}
</code_before><code_after>@@ -1,76 +0,0 @@
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>442634</refactoring_id><commit_sha>5718720234f9a3b2246390c9e7a52b03ca351f35</commit_sha><commit_link>https://github.com/confluentinc/schema-registry/commit/5718720234f9a3b2246390c9e7a52b03ca351f35</commit_link><file_path>avro-converter/src/main/java/io/confluent/connect/avro/AvroConverter.java</file_path><description>Rename Variable deserialized : GenericContainer to containerWithVersion : GenericContainerWithVersion in method public toConnectData(topic String, value byte[]) : SchemaAndValue from class io.confluent.connect.avro.AvroConverter</description><code_before>@@ -21,6 +21,7 @@
 import io.confluent.kafka.serializers.AbstractKafkaAvroDeserializer;
 import io.confluent.kafka.serializers.AbstractKafkaAvroSerializer;
 import io.confluent.kafka.serializers.AvroSchemaUtils;
 import io.confluent.kafka.serializers.KafkaAvroDeserializerConfig;
 import io.confluent.kafka.serializers.KafkaAvroSerializerConfig;
 import io.confluent.kafka.serializers.NonRecordContainer;
@@ -82,14 +83,18 @@ public byte[] fromConnectData(String topic, Schema schema, Object value) {
   @Override
   public SchemaAndValue toConnectData(String topic, byte[] value) {
     try {
-      GenericContainer deserialized = deserializer.deserialize(topic, isKey, value);
-      if (deserialized == null) {
         return SchemaAndValue.NULL;
-      } else if (deserialized instanceof IndexedRecord) {
-        return avroData.toConnectData(deserialized.getSchema(), deserialized);
       } else if (deserialized instanceof NonRecordContainer) {
-        return avroData.toConnectData(deserialized.getSchema(), ((NonRecordContainer) deserialized)
-            .getValue());
       }
       throw new DataException("Unsupported type returned during deserialization of topic %s "
                                   .format(topic));
@@ -130,7 +135,7 @@ public Deserializer(Map&lt;String, ?&gt; configs, SchemaRegistryClient client) {
       configure(new KafkaAvroDeserializerConfig(configs));
     }
 
-    public GenericContainer deserialize(String topic, boolean isKey, byte[] payload) {
       return deserializeWithSchemaAndVersion(topic, isKey, payload);
     }
   }
</code_before><code_after>@@ -21,6 +21,7 @@
 import io.confluent.kafka.serializers.AbstractKafkaAvroDeserializer;
 import io.confluent.kafka.serializers.AbstractKafkaAvroSerializer;
 import io.confluent.kafka.serializers.AvroSchemaUtils;
+import io.confluent.kafka.serializers.GenericContainerWithVersion;
 import io.confluent.kafka.serializers.KafkaAvroDeserializerConfig;
 import io.confluent.kafka.serializers.KafkaAvroSerializerConfig;
 import io.confluent.kafka.serializers.NonRecordContainer;
@@ -82,14 +83,18 @@ public byte[] fromConnectData(String topic, Schema schema, Object value) {
   @Override
   public SchemaAndValue toConnectData(String topic, byte[] value) {
     try {
+      GenericContainerWithVersion containerWithVersion =
+          deserializer.deserialize(topic, isKey, value);
+      if (containerWithVersion == null) {
         return SchemaAndValue.NULL;
+      }
+      GenericContainer deserialized = containerWithVersion.getContainer();
+      Integer version = containerWithVersion.getVersion();
+      if (deserialized instanceof IndexedRecord) {
+        return avroData.toConnectData(deserialized.getSchema(), deserialized, version);
       } else if (deserialized instanceof NonRecordContainer) {
+        return avroData.toConnectData(
+            deserialized.getSchema(), ((NonRecordContainer) deserialized).getValue(), version);
       }
       throw new DataException("Unsupported type returned during deserialization of topic %s "
                                   .format(topic));
@@ -130,7 +135,7 @@ public Deserializer(Map&lt;String, ?&gt; configs, SchemaRegistryClient client) {
       configure(new KafkaAvroDeserializerConfig(configs));
     }
 
+    public GenericContainerWithVersion deserialize(String topic, boolean isKey, byte[] payload) {
       return deserializeWithSchemaAndVersion(topic, isKey, payload);
     }
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>426323</refactoring_id><commit_sha>8834ab477c2cf313457accc7992a2df3326796f2</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/8834ab477c2cf313457accc7992a2df3326796f2</commit_link><file_path>src/com/google/javascript/jscomp/JsIterables.java</file_path><description>Rename Variable iterableType : JSTypeNative to templateType : TemplateType in method package maybeBoxIterableOrAsyncIterable(type JSType, typeRegistry JSTypeRegistry) : MaybeBoxedIterableOrAsyncIterable from class com.google.javascript.jscomp.JsIterables</description><code_before>@@ -20,8 +20,8 @@
 import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;
 
 import com.google.javascript.rhino.jstype.JSType;
-import com.google.javascript.rhino.jstype.JSTypeNative;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import com.google.javascript.rhino.jstype.TemplateTypeMap;
 import java.util.ArrayList;
 import java.util.List;
@@ -50,15 +50,15 @@ static final JSType getElementType(JSType iterableOrIterator, JSTypeRegistry typ
     if (templateTypeMap.hasTemplateKey(typeRegistry.getIterableTemplate())) {
       // `Iterable&lt;SomeElementType&gt;` or `Generator&lt;SomeElementType&gt;`
       return templateTypeMap.getResolvedTemplateType(typeRegistry.getIterableTemplate());
-    } else if (templateTypeMap.hasTemplateKey(typeRegistry.getIteratorTemplate())) {
       // `Iterator&lt;SomeElementType&gt;`
-      return templateTypeMap.getResolvedTemplateType(typeRegistry.getIteratorTemplate());
     } else if (templateTypeMap.hasTemplateKey(typeRegistry.getAsyncIterableTemplate())) {
       // `AsyncIterable&lt;SomeElementType&gt;` or `AsyncGenerator&lt;SomeElementType&gt;`
       return templateTypeMap.getResolvedTemplateType(typeRegistry.getAsyncIterableTemplate());
-    } else if (templateTypeMap.hasTemplateKey(typeRegistry.getAsyncIteratorTemplate())) {
       // `AsyncIterator&lt;SomeElementType&gt;`
-      return templateTypeMap.getResolvedTemplateType(typeRegistry.getAsyncIteratorTemplate());
     }
     return typeRegistry.getNativeType(UNKNOWN_TYPE);
   }
@@ -142,9 +142,11 @@ static final MaybeBoxedIterableOrAsyncIterable maybeBoxIterableOrAsyncIterable(
         if (!isIterable &amp;&amp; !isAsyncIterable) {
           return new MaybeBoxedIterableOrAsyncIterable(null, alt);
         }
-        JSTypeNative iterableType = isAsyncIterable ? ASYNC_ITERABLE_TYPE : ITERABLE_TYPE;
-        templatedTypes.add(
-            alt.getInstantiatedTypeArgument(typeRegistry.getNativeType(iterableType)));
       }
     } else {
       JSType autoboxedType = type.isBoxableScalar() ? type.autoboxesTo() : type;
@@ -154,9 +156,11 @@ static final MaybeBoxedIterableOrAsyncIterable maybeBoxIterableOrAsyncIterable(
       if (!isIterable &amp;&amp; !isAsyncIterable) {
         return new MaybeBoxedIterableOrAsyncIterable(null, autoboxedType);
       }
-      JSTypeNative iterableType = isAsyncIterable ? ASYNC_ITERABLE_TYPE : ITERABLE_TYPE;
-      templatedTypes.add(
-          autoboxedType.getInstantiatedTypeArgument(typeRegistry.getNativeType(iterableType)));
     }
     return new MaybeBoxedIterableOrAsyncIterable(
         typeRegistry.createUnionType(templatedTypes), null);
</code_before><code_after>@@ -20,8 +20,8 @@
 import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;
 
 import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
+import com.google.javascript.rhino.jstype.TemplateType;
 import com.google.javascript.rhino.jstype.TemplateTypeMap;
 import java.util.ArrayList;
 import java.util.List;
@@ -50,15 +50,15 @@ static final JSType getElementType(JSType iterableOrIterator, JSTypeRegistry typ
     if (templateTypeMap.hasTemplateKey(typeRegistry.getIterableTemplate())) {
       // `Iterable&lt;SomeElementType&gt;` or `Generator&lt;SomeElementType&gt;`
       return templateTypeMap.getResolvedTemplateType(typeRegistry.getIterableTemplate());
+    } else if (templateTypeMap.hasTemplateKey(typeRegistry.getIteratorValueTemplate())) {
       // `Iterator&lt;SomeElementType&gt;`
+      return templateTypeMap.getResolvedTemplateType(typeRegistry.getIteratorValueTemplate());
     } else if (templateTypeMap.hasTemplateKey(typeRegistry.getAsyncIterableTemplate())) {
       // `AsyncIterable&lt;SomeElementType&gt;` or `AsyncGenerator&lt;SomeElementType&gt;`
       return templateTypeMap.getResolvedTemplateType(typeRegistry.getAsyncIterableTemplate());
+    } else if (templateTypeMap.hasTemplateKey(typeRegistry.getAsyncIteratorValueTemplate())) {
       // `AsyncIterator&lt;SomeElementType&gt;`
+      return templateTypeMap.getResolvedTemplateType(typeRegistry.getAsyncIteratorValueTemplate());
     }
     return typeRegistry.getNativeType(UNKNOWN_TYPE);
   }
@@ -142,9 +142,11 @@ static final MaybeBoxedIterableOrAsyncIterable maybeBoxIterableOrAsyncIterable(
         if (!isIterable &amp;&amp; !isAsyncIterable) {
           return new MaybeBoxedIterableOrAsyncIterable(null, alt);
         }
+        TemplateType valueTemplate =
+            isAsyncIterable
+                ? typeRegistry.getAsyncIterableTemplate()
+                : typeRegistry.getIterableTemplate();
+        templatedTypes.add(alt.getTemplateTypeMap().getResolvedTemplateType(valueTemplate));
       }
     } else {
       JSType autoboxedType = type.isBoxableScalar() ? type.autoboxesTo() : type;
@@ -154,9 +156,11 @@ static final MaybeBoxedIterableOrAsyncIterable maybeBoxIterableOrAsyncIterable(
       if (!isIterable &amp;&amp; !isAsyncIterable) {
         return new MaybeBoxedIterableOrAsyncIterable(null, autoboxedType);
       }
+      TemplateType templateType =
+          isAsyncIterable
+              ? typeRegistry.getAsyncIterableTemplate()
+              : typeRegistry.getIterableTemplate();
+      templatedTypes.add(autoboxedType.getTemplateTypeMap().getResolvedTemplateType(templateType));
     }
     return new MaybeBoxedIterableOrAsyncIterable(
         typeRegistry.createUnionType(templatedTypes), null);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>448654</refactoring_id><commit_sha>a37204079847d5f7aba03f05378a8c6a8a902f5e</commit_sha><commit_link>https://github.com/apache/cloudstack/commit/a37204079847d5f7aba03f05378a8c6a8a902f5e</commit_link><file_path>engine/schema/src/com/cloud/upgrade/dao/Upgrade218to22Premium.java</file_path><description>Rename Variable file : String to script : InputStream in method public getPrepareScripts() : InputStream[] from class com.cloud.upgrade.dao.Upgrade218to22Premium</description><code_before>@@ -16,26 +16,23 @@
 // under the License.
 package com.cloud.upgrade.dao;
 
-import java.io.File;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 
 import com.cloud.utils.exception.CloudRuntimeException;
-import com.cloud.utils.script.Script;
 
 public class Upgrade218to22Premium extends Upgrade218to22 {
     @Override
-    public File[] getPrepareScripts() {
-        File[] scripts = super.getPrepareScripts();
-        File[] newScripts = new File[2];
-        newScripts[0] = scripts[0];
-
-        String file = Script.findScript("", "db/schema-21to22-premium.sql");
-        if (file == null) {
-            throw new CloudRuntimeException("Unable to find the upgrade script, schema-21to22-premium.sql");
         }
-
-        newScripts[1] = new File(file);
 
         return newScripts;
     }
@@ -47,15 +44,6 @@ public void performDataMigration(Connection conn) {
         updateUsageIpAddress(conn);
     }
 
-    @Override
-    public File[] getCleanupScripts() {
-        File[] scripts = super.getCleanupScripts();
-        File[] newScripts = new File[1];
-        // Change the array to 2 when you add in the scripts for premium.
-        newScripts[0] = scripts[0];
-        return newScripts;
-    }
-
     private void updateUserStats(Connection conn) {
         try ( // update device_id information
             PreparedStatement pstmt = conn.prepareStatement(
</code_before><code_after>@@ -16,26 +16,23 @@
 // under the License.
 package com.cloud.upgrade.dao;
 
+import java.io.InputStream;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 
 import com.cloud.utils.exception.CloudRuntimeException;
 
 public class Upgrade218to22Premium extends Upgrade218to22 {
     @Override
+    public InputStream[] getPrepareScripts() {
+        InputStream[] newScripts = new InputStream[2];
+        newScripts[0] = super.getPrepareScripts()[0];
+        final String scriptFile = "META-INF/db/schema-21to22-premium.sql";
+        final InputStream script = Thread.currentThread().getContextClassLoader().getResourceAsStream(scriptFile);
+        if (script == null) {
+            throw new CloudRuntimeException("Unable to find " + scriptFile);
         }
+        newScripts[1] = script;
 
         return newScripts;
     }
@@ -47,15 +44,6 @@ public void performDataMigration(Connection conn) {
         updateUsageIpAddress(conn);
     }
 
     private void updateUserStats(Connection conn) {
         try ( // update device_id information
             PreparedStatement pstmt = conn.prepareStatement(
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>397713</refactoring_id><commit_sha>b04175317bee7a1f9c89498f1cd768d983308ad0</commit_sha><commit_link>https://github.com/zstackio/zstack/commit/b04175317bee7a1f9c89498f1cd768d983308ad0</commit_link><file_path>network/src/main/java/org/zstack/network/l3/L3BasicNetwork.java</file_path><description>Rename Variable used : List&lt;String&gt; to usedIps : List&lt;String&gt; in method public getFreeIp(ipr IpRangeVO, limit int, start String) : List&lt;FreeIpInventory&gt; from class org.zstack.network.l3.IpRangeHelper</description><code_before>@@ -492,38 +492,6 @@ private void handle(APIUpdateIpRangeMsg msg) {
         bus.publish(evt);
     }
 
-    private List&lt;FreeIpInventory&gt; getFreeIp(final IpRangeVO ipr, int limit, String start) {
-        SimpleQuery&lt;UsedIpVO&gt; q = dbf.createQuery(UsedIpVO.class);
-        q.select(UsedIpVO_.ip);
-        q.add(UsedIpVO_.ipRangeUuid, Op.EQ, ipr.getUuid());
-
-        List&lt;String&gt; used = q.listValue();
-        used = used.stream().distinct().collect(Collectors.toList());
-
-        List&lt;String&gt; spareIps = new ArrayList&lt;&gt;();
-        if (ipr.getIpVersion() == IPv6Constants.IPv6) {
-            spareIps.addAll(NetworkUtils.getFreeIpv6InRange(ipr.getStartIp(), ipr.getEndIp(), used, limit, start));
-        } else {
-            IpRangeVO cloneIpr = new IpRangeVO();
-            cloneIpr.setStartIp(ipr.getStartIp());
-            cloneIpr.setEndIp(ipr.getEndIp());
-            cloneIpr.setNetmask(ipr.getNetmask());
-            IpRangeHelper.stripNetworkAndBroadcastAddress(cloneIpr);
-            spareIps.addAll(NetworkUtils.getFreeIpInRange(cloneIpr.getStartIp(), cloneIpr.getEndIp(), used, limit, start));
-        }
-        return CollectionUtils.transformToList(spareIps, new Function&lt;FreeIpInventory, String&gt;() {
-            @Override
-            public FreeIpInventory call(String arg) {
-                FreeIpInventory f = new FreeIpInventory();
-                f.setGateway(ipr.getGateway());
-                f.setIp(arg);
-                f.setNetmask(ipr.getNetmask());
-                f.setIpRangeUuid(ipr.getUuid());
-                return f;
-            }
-        });
-    }
-
     private void handle(APIGetFreeIpMsg msg) {
         APIGetFreeIpReply reply = new APIGetFreeIpReply();
 
@@ -575,7 +543,7 @@ private void handle(APIGetFreeIpMsg msg) {
                     start = "0.0.0.0";
                 }
             }
-            List&lt;FreeIpInventory&gt; tempFreeIpInventorys = getFreeIp(ipRangeVO, limit,start);
             freeIpInventorys.addAll(tempFreeIpInventorys);
             if (freeIpInventorys.size() &gt;= msg.getLimit()) {
                 break;
</code_before><code_after>@@ -492,38 +492,6 @@ private void handle(APIUpdateIpRangeMsg msg) {
         bus.publish(evt);
     }
 
     private void handle(APIGetFreeIpMsg msg) {
         APIGetFreeIpReply reply = new APIGetFreeIpReply();
 
@@ -575,7 +543,7 @@ private void handle(APIGetFreeIpMsg msg) {
                     start = "0.0.0.0";
                 }
             }
+            List&lt;FreeIpInventory&gt; tempFreeIpInventorys = IpRangeHelper.getFreeIp(ipRangeVO, limit,start);
             freeIpInventorys.addAll(tempFreeIpInventorys);
             if (freeIpInventorys.size() &gt;= msg.getLimit()) {
                 break;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>404809</refactoring_id><commit_sha>77ca7601cf46725982db5404204c4dc908fe422b</commit_sha><commit_link>https://github.com/pinpoint-apm/pinpoint/commit/77ca7601cf46725982db5404204c4dc908fe422b</commit_link><file_path>plugins/activemq-client/src/main/java/com/navercorp/pinpoint/plugin/activemq/client/interceptor/ActiveMQMessageConsumerReceiveInterceptor.java</file_path><description>Rename Variable e : JMSException to ignored : JMSException in method private getMessage(result Object) : String from class com.navercorp.pinpoint.plugin.activemq.client.interceptor.ActiveMQMessageConsumerReceiveInterceptor</description><code_before>@@ -88,7 +88,7 @@ private String getMessage(Object result) {
                 sb.append('{').append(text).append('}');
                 return sb.toString();
             }
-        } catch (JMSException e) {
             // ignore
         }
         return simpleClassName;
</code_before><code_after>@@ -88,7 +88,7 @@ private String getMessage(Object result) {
                 sb.append('{').append(text).append('}');
                 return sb.toString();
             }
+        } catch (JMSException ignored) {
             // ignore
         }
         return simpleClassName;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>366326</refactoring_id><commit_sha>089e51f0bc02b63490e1038e0ec23d1d43adf9a8</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/089e51f0bc02b63490e1038e0ec23d1d43adf9a8</commit_link><file_path>jetty-servlet/src/main/java/org/eclipse/jetty/servlet/FilterHolder.java</file_path><description>Rename Variable ignored : AutoLock to l : AutoLock in method protected createInstance() : Filter from class org.eclipse.jetty.servlet.FilterHolder</description><code_before>@@ -103,7 +103,7 @@ public void doStart()
     @Override
     public void initialize() throws Exception
     {
-        try (AutoLock ignored = lock())
         {
             if (_filter != null)
                 return;
@@ -136,7 +136,7 @@ public void initialize() throws Exception
     @Override
     protected Filter createInstance() throws Exception
     {
-        try (AutoLock ignored = lock())
         {
             Filter filter = super.createInstance();
             if (filter == null)
</code_before><code_after>@@ -103,7 +103,7 @@ public void doStart()
     @Override
     public void initialize() throws Exception
     {
+        try (AutoLock l = lock())
         {
             if (_filter != null)
                 return;
@@ -136,7 +136,7 @@ public void initialize() throws Exception
     @Override
     protected Filter createInstance() throws Exception
     {
+        try (AutoLock l = lock())
         {
             Filter filter = super.createInstance();
             if (filter == null)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>356643</refactoring_id><commit_sha>b3080e117fdabb6068913fe431ec49af139ec1b7</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/b3080e117fdabb6068913fe431ec49af139ec1b7</commit_link><file_path>config-model/src/main/java/com/yahoo/vespa/model/content/ClusterControllerConfig.java</file_path><description>Rename Variable minGroupsUpRatio : var to groupsAllowedDownRatio : var in method private maxGroupsAllowedDown(tuning ModelElement, allowMoreThanOneContentGroupDown boolean, numberOfLeafGroups int) : Optional&lt;Integer&gt; from class com.yahoo.vespa.model.content.ClusterControllerConfig.ClusterControllerTuningBuilder</description><code_before>@@ -153,13 +153,13 @@ private static class ClusterControllerTuningBuilder {
 
 
         private static Optional&lt;Integer&gt; maxGroupsAllowedDown(ModelElement tuning, boolean allowMoreThanOneContentGroupDown, int numberOfLeafGroups) {
-            var minGroupsUpRatio = tuning.childAsDouble("min-group-up-ratio");
 
-            if (minGroupsUpRatio != null) {
-                if (minGroupsUpRatio &lt; 0.01 || minGroupsUpRatio &gt; 1)
-                    throw new IllegalArgumentException("min-groups-up-ratio must be between 0.01 and 1, got " + minGroupsUpRatio);
-                double minGroupsUp = minGroupsUpRatio * numberOfLeafGroups;
-                var maxGroupsAllowedDown = Math.max(1, numberOfLeafGroups - (int) Math.ceil(minGroupsUp));
                 return allowMoreThanOneContentGroupDown ? Optional.of(maxGroupsAllowedDown) : Optional.empty();
             }
 
</code_before><code_after>@@ -153,13 +153,13 @@ private static class ClusterControllerTuningBuilder {
 
 
         private static Optional&lt;Integer&gt; maxGroupsAllowedDown(ModelElement tuning, boolean allowMoreThanOneContentGroupDown, int numberOfLeafGroups) {
+            var groupsAllowedDownRatio = tuning.childAsDouble("groups-allowed-down-ratio");
 
+            if (groupsAllowedDownRatio != null) {
+                if (groupsAllowedDownRatio &lt; 0 || groupsAllowedDownRatio &gt; 1)
+                    throw new IllegalArgumentException("groups-allowed-down-ratio must be between 0 and 1, got " + groupsAllowedDownRatio);
+
+                var maxGroupsAllowedDown = Math.max(1, (int) Math.floor(groupsAllowedDownRatio * numberOfLeafGroups));
                 return allowMoreThanOneContentGroupDown ? Optional.of(maxGroupsAllowedDown) : Optional.empty();
             }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>385730</refactoring_id><commit_sha>ae164316a5c17957dd9c77d51b14debe2c773323</commit_sha><commit_link>https://github.com/awsdocs/aws-doc-sdk-examples/commit/ae164316a5c17957dd9c77d51b14debe2c773323</commit_link><file_path>javav2/example_code/pinpoint/src/main/java/com/example/pinpoint/SendMessage.java</file_path><description>Rename Variable USAGE : String to usage : String in method public main(args String[]) : void from class com.example.pinpoint.SendMessage</description><code_before>@@ -3,8 +3,7 @@
 //snippet-keyword:[Code Sample]
 //snippet-keyword:[Amazon Pinpoint]
 //snippet-sourcetype:[full-example]
-//snippet-sourcedate:[09-27-2021]
-//snippet-sourceauthor:[scmacdon-aws]
 
 /*
    Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
@@ -14,6 +13,7 @@
 package com.example.pinpoint;
 
 //snippet-start:[pinpoint.java2.sendmsg.import]
 import software.amazon.awssdk.regions.Region;
 import software.amazon.awssdk.services.pinpoint.PinpointClient;
 import software.amazon.awssdk.services.pinpoint.model.DirectMessageConfiguration;
@@ -30,9 +30,9 @@
 //snippet-end:[pinpoint.java2.sendmsg.import]
 
 /**
- * To run this Java V2 code example, ensure that you have setup your development environment, including your credentials.
  *
- * For information, see this documentation topic:
  *
  * https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
  */
@@ -52,19 +52,20 @@ public class SendMessage {
     public static String senderId = "MySenderID";
 
     public static void main(String[] args) {
-        final String USAGE = "\n" +
                 "Usage: " +
-                "SendMessage &lt;message&gt; &lt;appId&gt; &lt;originationNumber&gt; &lt;destinationNumber&gt; \n\n" +
                 "Where:\n" +
-                "  message - the body of the message to send.\n\n"+
-                "  appId - the Amazon Pinpoint project/application ID to use when you send this message.\n\n" +
-                "  originationNumber - the phone number or short code that you specify has to be associated with your Amazon Pinpoint account. For best results, specify long codes in E.164 format (for example, +1-555-555-5654). "+
-                "  destinationNumber - the recipient's phone number.  For best results, you should specify the phone number in E.164 format (for example, +1-555-555-5654). ";
 
         if (args.length != 4) {
-            System.out.println(USAGE);
             System.exit(1);
-       }
 
         String message = args[0];
         String appId = args[1];
@@ -74,6 +75,7 @@ public static void main(String[] args) {
 
         PinpointClient pinpoint = PinpointClient.builder()
                 .region(Region.US_EAST_1)
                 .build();
 
         sendSMSMessage(pinpoint, message, appId, originationNumber, destinationNumber);
</code_before><code_after>@@ -3,8 +3,7 @@
 //snippet-keyword:[Code Sample]
 //snippet-keyword:[Amazon Pinpoint]
 //snippet-sourcetype:[full-example]
+//snippet-sourcedate:[05/18/2022]
 
 /*
    Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
@@ -14,6 +13,7 @@
 package com.example.pinpoint;
 
 //snippet-start:[pinpoint.java2.sendmsg.import]
+import software.amazon.awssdk.auth.credentials.ProfileCredentialsProvider;
 import software.amazon.awssdk.regions.Region;
 import software.amazon.awssdk.services.pinpoint.PinpointClient;
 import software.amazon.awssdk.services.pinpoint.model.DirectMessageConfiguration;
@@ -30,9 +30,9 @@
 //snippet-end:[pinpoint.java2.sendmsg.import]
 
 /**
+ * Before running this Java V2 code example, set up your development environment, including your credentials.
  *
+ * For more information, see the following documentation topic:
  *
  * https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
  */
@@ -52,19 +52,20 @@ public class SendMessage {
     public static String senderId = "MySenderID";
 
     public static void main(String[] args) {
+
+        final String usage = "\n" +
                 "Usage: " +
+                "  &lt;message&gt; &lt;appId&gt; &lt;originationNumber&gt; &lt;destinationNumber&gt; \n\n" +
                 "Where:\n" +
+                "  message - The body of the message to send.\n\n"+
+                "  appId - The Amazon Pinpoint project/application ID to use when you send this message.\n\n" +
+                "  originationNumber - The phone number or short code that you specify has to be associated with your Amazon Pinpoint account. For best results, specify long codes in E.164 format (for example, +1-555-555-5654). "+
+                "  destinationNumber - The recipient's phone number.  For best results, you should specify the phone number in E.164 format (for example, +1-555-555-5654). ";
 
         if (args.length != 4) {
+            System.out.println(usage);
             System.exit(1);
+        }
 
         String message = args[0];
         String appId = args[1];
@@ -74,6 +75,7 @@ public static void main(String[] args) {
 
         PinpointClient pinpoint = PinpointClient.builder()
                 .region(Region.US_EAST_1)
+                .credentialsProvider(ProfileCredentialsProvider.create())
                 .build();
 
         sendSMSMessage(pinpoint, message, appId, originationNumber, destinationNumber);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>447187</refactoring_id><commit_sha>3f00e665970a7a6aa81ede222c652ca1af0d9848</commit_sha><commit_link>https://github.com/metersphere/metersphere/commit/3f00e665970a7a6aa81ede222c652ca1af0d9848</commit_link><file_path>test-track/backend/src/main/java/io/metersphere/plan/service/remote/api/PlanTestPlanScenarioCaseService.java</file_path><description>Rename Variable projectEnvMap : Map&lt;String,List&lt;String&gt;&gt; to automationsRunInfoDTO : AutomationsRunInfoDTO in method public calculatePlanReport(planId String, report TestPlanSimpleReportDTO) : void from class io.metersphere.plan.service.remote.api.PlanTestPlanScenarioCaseService</description><code_before>@@ -10,11 +10,11 @@
 import io.metersphere.plan.request.api.ApiPlanReportRequest;
 import io.metersphere.plan.request.api.ApiScenarioRequest;
 import io.metersphere.plan.service.TestPlanService;
 import io.metersphere.plan.utils.TestPlanStatusCalculator;
 import io.metersphere.utils.DiscoveryUtil;
 import jakarta.annotation.Resource;
 import org.apache.commons.collections.CollectionUtils;
-import org.apache.commons.collections.MapUtils;
 import org.jetbrains.annotations.NotNull;
 import org.springframework.context.annotation.Lazy;
 import org.springframework.stereotype.Service;
@@ -40,30 +40,10 @@ public void calculatePlanReport(String planId, TestPlanSimpleReportDTO report) {
             calculatePlanReport(report, planReportCaseDTOS);
             //&#x8BB0;&#x5F55;&#x63A5;&#x53E3;&#x7528;&#x4F8B;&#x7684;&#x8FD0;&#x884C;&#x73AF;&#x5883;&#x4FE1;&#x606F;
             List&lt;String&gt; idList = planReportCaseDTOS.stream().map(PlanReportCaseDTO::getId).collect(Collectors.toList());
-            try {
-                if (MapUtils.isEmpty(report.getProjectEnvMap())) {
-                    report.setProjectEnvMap(getPlanProjectEnvMap(idList));
-                } else {
-                    Map&lt;String, List&lt;String&gt;&gt; projectEnvMap = getPlanProjectEnvMap(idList);
-                    if (MapUtils.isNotEmpty(projectEnvMap)) {
-                        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : projectEnvMap.entrySet()) {
-                            String project = entry.getKey();
-                            List&lt;String&gt; envList = entry.getValue();
-                            if (report.getProjectEnvMap().containsKey(project)) {
-                                for (String env : envList) {
-                                    if (!report.getProjectEnvMap().get(project).contains(env)) {
-                                        report.getProjectEnvMap().get(project).add(env);
-                                    }
-                                }
-                            } else {
-                                report.getProjectEnvMap().put(project, envList);
-                            }
-
-                        }
-                    }
-                }
-            } catch (Exception e) {
-                LogUtil.error(e);
             }
         }
     }
@@ -138,8 +118,8 @@ public List&lt;PlanReportCaseDTO&gt; selectStatusForPlanReport(String planId) {
         return microService.getForDataArray(serviceName, BASE_UEL + "/get/report/status/" + planId, PlanReportCaseDTO.class);
     }
 
-    public Map&lt;String, List&lt;String&gt;&gt; getPlanProjectEnvMap(List&lt;String&gt; resourceIds) {
-        return (Map&lt;String, List&lt;String&gt;&gt;) microService.postForData(serviceName, BASE_UEL + "/get/plan/env/map", resourceIds);
     }
 
     public List&lt;String&gt; getExecResultByPlanId(String planId) {
</code_before><code_after>@@ -10,11 +10,11 @@
 import io.metersphere.plan.request.api.ApiPlanReportRequest;
 import io.metersphere.plan.request.api.ApiScenarioRequest;
 import io.metersphere.plan.service.TestPlanService;
+import io.metersphere.plan.utils.TestPlanReportUtil;
 import io.metersphere.plan.utils.TestPlanStatusCalculator;
 import io.metersphere.utils.DiscoveryUtil;
 import jakarta.annotation.Resource;
 import org.apache.commons.collections.CollectionUtils;
 import org.jetbrains.annotations.NotNull;
 import org.springframework.context.annotation.Lazy;
 import org.springframework.stereotype.Service;
@@ -40,30 +40,10 @@ public void calculatePlanReport(String planId, TestPlanSimpleReportDTO report) {
             calculatePlanReport(report, planReportCaseDTOS);
             //&#x8BB0;&#x5F55;&#x63A5;&#x53E3;&#x7528;&#x4F8B;&#x7684;&#x8FD0;&#x884C;&#x73AF;&#x5883;&#x4FE1;&#x606F;
             List&lt;String&gt; idList = planReportCaseDTOS.stream().map(PlanReportCaseDTO::getId).collect(Collectors.toList());
+            AutomationsRunInfoDTO automationsRunInfoDTO = getPlanProjectEnvMap(idList);
+            if (automationsRunInfoDTO != null) {
+                report.setProjectEnvMap(TestPlanReportUtil.mergeProjectEnvMap(report.getProjectEnvMap(), automationsRunInfoDTO.getProjectEnvMap()));
+                report.setResourcePools(TestPlanReportUtil.mergeResourcePools(report.getResourcePools(), automationsRunInfoDTO.getResourcePools()));
             }
         }
     }
@@ -138,8 +118,8 @@ public List&lt;PlanReportCaseDTO&gt; selectStatusForPlanReport(String planId) {
         return microService.getForDataArray(serviceName, BASE_UEL + "/get/report/status/" + planId, PlanReportCaseDTO.class);
     }
 
+    public AutomationsRunInfoDTO getPlanProjectEnvMap(List&lt;String&gt; resourceIds) {
+        return microService.postForData(serviceName, BASE_UEL + "/get/plan/env/map", resourceIds, AutomationsRunInfoDTO.class);
     }
 
     public List&lt;String&gt; getExecResultByPlanId(String planId) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>461849</refactoring_id><commit_sha>b7fa9be6884535191006e982350bb33765906971</commit_sha><commit_link>https://github.com/oracle/graal/commit/b7fa9be6884535191006e982350bb33765906971</commit_link><file_path>graal/com.oracle.max.graal.compiler/src/com/oracle/max/graal/compiler/schedule/IdentifyBlocksPhase.java</file_path><description>Rename Variable counter : LoopCounter to liv : LinearInductionVariable in method private blocksForUsage(node Node, usage Node, closure BlockClosure) : void from class com.oracle.max.graal.compiler.schedule.IdentifyBlocksPhase</description><code_before>@@ -535,10 +535,10 @@ private void blocksForUsage(Node node, Node usage, BlockClosure closure) {
                 block = getCommonDominator(block, nodeToBlock.get(pred));
             }
             closure.apply(block);
-        } else if (usage instanceof LoopCounter) {
-            LoopCounter counter = (LoopCounter) usage;
-            if (node == counter.init() || node == counter.stride()) {
-                LoopBegin loopBegin = counter.loopBegin();
                 Block mergeBlock = nodeToBlock.get(loopBegin);
                 closure.apply(mergeBlock.dominator());
             }
</code_before><code_after>@@ -535,10 +535,10 @@ private void blocksForUsage(Node node, Node usage, BlockClosure closure) {
                 block = getCommonDominator(block, nodeToBlock.get(pred));
             }
             closure.apply(block);
+        } else if (usage instanceof LinearInductionVariable) {
+            LinearInductionVariable liv = (LinearInductionVariable) usage;
+            if (liv.isLinearInductionVariableInput(node)) {
+                LoopBegin loopBegin = liv.loopBegin();
                 Block mergeBlock = nodeToBlock.get(loopBegin);
                 closure.apply(mergeBlock.dominator());
             }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>449002</refactoring_id><commit_sha>324509c9056116881a330b866f3069d06ea59478</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/324509c9056116881a330b866f3069d06ea59478</commit_link><file_path>src/main/java/org/terasology/math/Region3i.java</file_path><description>Rename Variable min : Vector3i to expandedMin : Vector3i in method public expand(amount Vector3i) : Region3i from class org.terasology.math.Region3i</description><code_before>@@ -136,12 +136,12 @@ public Vector3i max() {
      *         do not overlap then the empty region is returned
      */
     public Region3i intersect(Region3i other) {
-        Vector3i min = min();
-        min.max(other.min());
-        Vector3i max = max();
-        max.min(other.max());
 
-        return createFromMinMax(min, max);
     }
 
     /**
@@ -159,27 +159,27 @@ public Iterator&lt;Vector3i&gt; subtract(Region3i other) {
      * @return A new region
      */
     public Region3i expand(int amount) {
-        Vector3i min = min();
-        min.sub(amount, amount, amount);
-        Vector3i max = max();
-        max.add(amount, amount, amount);
-        return createFromMinMax(min, max);
     }
 
     public Region3i expand(Vector3i amount) {
-        Vector3i min = min();
-        min.sub(amount);
-        Vector3i max = max();
-        max.add(amount);
-        return createFromMinMax(min, max);
     }
 
     public Region3i expandToContain(Vector3i adjPos) {
-        Vector3i min = min();
-        min.min(adjPos);
-        Vector3i max = max();
-        max.max(adjPos);
-        return createFromMinMax(min, max);
     }
 
     /**
</code_before><code_after>@@ -136,12 +136,12 @@ public Vector3i max() {
      *         do not overlap then the empty region is returned
      */
     public Region3i intersect(Region3i other) {
+        Vector3i intersectMin = min();
+        intersectMin.max(other.min());
+        Vector3i intersectMax = max();
+        intersectMax.min(other.max());
 
+        return createFromMinMax(intersectMin, intersectMax);
     }
 
     /**
@@ -159,27 +159,27 @@ public Iterator&lt;Vector3i&gt; subtract(Region3i other) {
      * @return A new region
      */
     public Region3i expand(int amount) {
+        Vector3i expandedMin = min();
+        expandedMin.sub(amount, amount, amount);
+        Vector3i expandedMax = max();
+        expandedMax.add(amount, amount, amount);
+        return createFromMinMax(expandedMin, expandedMax);
     }
 
     public Region3i expand(Vector3i amount) {
+        Vector3i expandedMin = min();
+        expandedMin.sub(amount);
+        Vector3i expandedMax = max();
+        expandedMax.add(amount);
+        return createFromMinMax(expandedMin, expandedMax);
     }
 
     public Region3i expandToContain(Vector3i adjPos) {
+        Vector3i expandedMin = min();
+        expandedMin.min(adjPos);
+        Vector3i expandedMax = max();
+        expandedMax.max(adjPos);
+        return createFromMinMax(expandedMin, expandedMax);
     }
 
     /**
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>351585</refactoring_id><commit_sha>c764d569642043237f3b4695833356c6b2d5a4b4</commit_sha><commit_link>https://github.com/pentaho/pentaho-kettle/commit/c764d569642043237f3b4695833356c6b2d5a4b4</commit_link><file_path>ui/src/org/pentaho/di/ui/trans/steps/getvariable/GetVariableDialog.java</file_path><description>Rename Variable FieldsRows : int to fieldsRows : int in method public open() : String from class org.pentaho.di.ui.trans.steps.getvariable.GetVariableDialog</description><code_before>@@ -2,7 +2,7 @@
  *
  * Pentaho Data Integration
  *
- * Copyright (C) 2002-2013 by Pentaho : http://www.pentaho.com
  *
  *******************************************************************************
  *
@@ -50,6 +50,7 @@
 import org.pentaho.di.trans.step.BaseStepMeta;
 import org.pentaho.di.trans.step.StepDialogInterface;
 import org.pentaho.di.trans.steps.getvariable.GetVariableMeta;
 import org.pentaho.di.ui.core.dialog.EnterTextDialog;
 import org.pentaho.di.ui.core.dialog.ErrorDialog;
 import org.pentaho.di.ui.core.dialog.PreviewRowsDialog;
@@ -134,7 +135,7 @@ public void modifyText( ModifyEvent e ) {
     fdlFields.top = new FormAttachment( wStepname, margin );
     wlFields.setLayoutData( fdlFields );
 
-    final int FieldsRows = input.getFieldName().length;
 
     ColumnInfo[] colinf =
       new ColumnInfo[] {
@@ -168,7 +169,7 @@ public void modifyText( ModifyEvent e ) {
 
     wFields =
       new TableView(
-        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );
 
     fdFields = new FormData();
     fdFields.left = new FormAttachment( 0, 0 );
@@ -252,20 +253,21 @@ public void shellClosed( ShellEvent e ) {
   public void getData() {
     wStepname.setText( stepname );
 
-    for ( int i = 0; i &lt; input.getFieldName().length; i++ ) {
       TableItem item = wFields.table.getItem( i );
 
       int index = 1;
-      item.setText( index++, Const.NVL( input.getFieldName()[i], "" ) );
-      item.setText( index++, Const.NVL( input.getVariableString()[i], "" ) );
-      item.setText( index++, ValueMeta.getTypeDesc( input.getFieldType()[i] ) );
-      item.setText( index++, Const.NVL( input.getFieldFormat()[i], "" ) );
-      item.setText( index++, input.getFieldLength()[i] &lt; 0 ? "" : ( "" + input.getFieldLength()[i] ) );
-      item.setText( index++, input.getFieldPrecision()[i] &lt; 0 ? "" : ( "" + input.getFieldPrecision()[i] ) );
-      item.setText( index++, Const.NVL( input.getCurrency()[i], "" ) );
-      item.setText( index++, Const.NVL( input.getDecimal()[i], "" ) );
-      item.setText( index++, Const.NVL( input.getGroup()[i], "" ) );
-      item.setText( index++, ValueMeta.getTrimTypeDesc( input.getTrimType()[i] ) );
     }
 
     wFields.setRowNums();
@@ -293,17 +295,18 @@ private void getInfo( GetVariableMeta input ) throws KettleException {
     for ( int i = 0; i &lt; count; i++ ) {
       TableItem item = wFields.getNonEmpty( i );
 
       int index = 1;
-      input.getFieldName()[i] = item.getText( index++ );
-      input.getVariableString()[i] = item.getText( index++ );
-      input.getFieldType()[i] = ValueMeta.getType( item.getText( index++ ) );
-      input.getFieldFormat()[i] = item.getText( index++ );
-      input.getFieldLength()[i] = Const.toInt( item.getText( index++ ), -1 );
-      input.getFieldPrecision()[i] = Const.toInt( item.getText( index++ ), -1 );
-      input.getCurrency()[i] = item.getText( index++ );
-      input.getDecimal()[i] = item.getText( index++ );
-      input.getGroup()[i] = item.getText( index++ );
-      input.getTrimType()[i] = ValueMeta.getTrimTypeByDesc( item.getText( index++ ) );
     }
   }
 
</code_before><code_after>@@ -2,7 +2,7 @@
  *
  * Pentaho Data Integration
  *
+ * Copyright (C) 2002-2016 by Pentaho : http://www.pentaho.com
  *
  *******************************************************************************
  *
@@ -50,6 +50,7 @@
 import org.pentaho.di.trans.step.BaseStepMeta;
 import org.pentaho.di.trans.step.StepDialogInterface;
 import org.pentaho.di.trans.steps.getvariable.GetVariableMeta;
+import org.pentaho.di.trans.steps.getvariable.GetVariableMeta.FieldDefinition;
 import org.pentaho.di.ui.core.dialog.EnterTextDialog;
 import org.pentaho.di.ui.core.dialog.ErrorDialog;
 import org.pentaho.di.ui.core.dialog.PreviewRowsDialog;
@@ -134,7 +135,7 @@ public void modifyText( ModifyEvent e ) {
     fdlFields.top = new FormAttachment( wStepname, margin );
     wlFields.setLayoutData( fdlFields );
 
+    final int fieldsRows = input.getFieldDefinitions().length;
 
     ColumnInfo[] colinf =
       new ColumnInfo[] {
@@ -168,7 +169,7 @@ public void modifyText( ModifyEvent e ) {
 
     wFields =
       new TableView(
+        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, fieldsRows, lsMod, props );
 
     fdFields = new FormData();
     fdFields.left = new FormAttachment( 0, 0 );
@@ -252,20 +253,21 @@ public void shellClosed( ShellEvent e ) {
   public void getData() {
     wStepname.setText( stepname );
 
+    for ( int i = 0; i &lt; input.getFieldDefinitions().length; i++ ) {
       TableItem item = wFields.table.getItem( i );
 
       int index = 1;
+      FieldDefinition currentField = input.getFieldDefinitions()[i];
+      item.setText( index++, Const.NVL( currentField.getFieldName(), "" ) );
+      item.setText( index++, Const.NVL( currentField.getVariableString(), "" ) );
+      item.setText( index++, ValueMeta.getTypeDesc( currentField.getFieldType() ) );
+      item.setText( index++, Const.NVL( currentField.getFieldFormat(), "" ) );
+      item.setText( index++, currentField.getFieldLength() &lt; 0 ? "" : ( "" + currentField.getFieldLength() ) );
+      item.setText( index++, currentField.getFieldPrecision() &lt; 0 ? "" : ( "" + currentField.getFieldPrecision() ) );
+      item.setText( index++, Const.NVL( currentField.getCurrency(), "" ) );
+      item.setText( index++, Const.NVL( currentField.getDecimal(), "" ) );
+      item.setText( index++, Const.NVL( currentField.getGroup(), "" ) );
+      item.setText( index++, ValueMeta.getTrimTypeDesc( currentField.getTrimType() ) );
     }
 
     wFields.setRowNums();
@@ -293,17 +295,18 @@ private void getInfo( GetVariableMeta input ) throws KettleException {
     for ( int i = 0; i &lt; count; i++ ) {
       TableItem item = wFields.getNonEmpty( i );
 
+      FieldDefinition currentField = input.getFieldDefinitions()[i];
       int index = 1;
+      currentField.setFieldName( item.getText( index++ ) );
+      currentField.setVariableString( item.getText( index++ ) );
+      currentField.setFieldType( ValueMeta.getType( item.getText( index++ ) ) );
+      currentField.setFieldFormat( item.getText( index++ ) );
+      currentField.setFieldLength( Const.toInt( item.getText( index++ ), -1 ) );
+      currentField.setFieldPrecision( Const.toInt( item.getText( index++ ), -1 ) );
+      currentField.setCurrency( item.getText( index++ ) );
+      currentField.setDecimal( item.getText( index++ ) );
+      currentField.setGroup( item.getText( index++ ) );
+      currentField.setTrimType( ValueMeta.getTrimTypeByDesc( item.getText( index++ ) ) );
     }
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>367422</refactoring_id><commit_sha>347551ba20a313f63d858413055643ac4f776a48</commit_sha><commit_link>https://github.com/noear/solon/commit/347551ba20a313f63d858413055643ac4f776a48</commit_link><file_path>_extend/solon.extend.data/src/main/java/org/noear/solon/extend/data/CacheExecutorImp.java</file_path><description>Rename Variable cacheT : Object to result : Object in method public execute(anno XCache, method Method, params Parameter[], values Object[], callable SupplierEx) : Object from class org.noear.solon.extend.data.CacheExecutorImp</description><code_before>@@ -24,77 +24,95 @@ public class CacheExecutorImp implements XCacheExecutor {
     @Override
     public Object execute(XCache anno, Method method, Parameter[] params, Object[] values, SupplierEx callable) throws Throwable {
         CacheService cs = XBridge.cacheServiceGet(anno.service());
-        Map&lt;String,Object&gt; parMap = new HashMap&lt;&gt;();
-        Object cacheT = null;
 
-        //&#x6E05;&#x9664;&#x7F13;&#x5B58;&#x6807;&#x7B7E;
-        //
         if (anno.seconds() != 0 || XUtil.isNotEmpty(anno.tags())) {
-            StringBuilder keyB = new StringBuilder();
-
-            keyB.append(method.getDeclaringClass().getName()).append(":");
-            keyB.append(method.getName()).append(":");
-
-            for (int i = 0, len = params.length; i &lt; len; i++) {
-                keyB.append(params[i].getName()).append("_").append(values[i]);
-                parMap.put(params[i].getName(), values[i]);
-            }
-
-            String key = keyB.toString();
 
             //1.&#x4ECE;&#x7F13;&#x5B58;&#x83B7;&#x53D6;
 
-            cacheT = cs.get(key);
-            if (cacheT == null) {
                 //2.&#x6267;&#x884C;&#x8C03;&#x7528;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;
-                cacheT = callable.get();
-                cs.store(key, cacheT, anno.seconds());
-
-
-                if(XUtil.isNotEmpty(anno.tags())) {
-                    String tags = formatTags(anno.tags(), parMap);
-                    CacheTags ct = new CacheTags(cs);
-
-                    //&#x6DFB;&#x52A0;&#x7F13;&#x5B58;
-                    for (String tag : tags.split(",")) {
-                        ct.add(tag, key);
                     }
                 }
             }
-        }else{
-            cacheT = callable.get();
         }
 
-        //&#x6E05;&#x9664;&#x7F13;&#x5B58;&#x6807;&#x7B7E;
         //
         if (XUtil.isNotEmpty(anno.clearTags())) {
-            if(parMap.size() == 0) {
                 for (int i = 0, len = params.length; i &lt; len; i++) {
                     parMap.put(params[i].getName(), values[i]);
                 }
             }
 
-            String tags = formatTags(anno.clearTags(),parMap);
             CacheTags ct = new CacheTags(cs);
 
-            //&#x6DFB;&#x52A0;&#x7F13;&#x5B58;
-            for(String tag : tags.split(",")) {
                 ct.clear(tag);
             }
         }
 
-        return cacheT;
     }
 
     private String formatTags(String tags, Map map) {
         String tags2 = tags;
 
         Pattern pattern = Pattern.compile("\\$\\{(\\w+)\\}");
         Matcher m = pattern.matcher(tags);
         while (m.find()) {
             String mark = m.group(0);
             String name = m.group(1);
-            if(map.containsKey(name)){
                 String val = String.valueOf(map.get(name));
 
                 tags2 = tags2.replace(mark, val);
</code_before><code_after>@@ -24,77 +24,95 @@ public class CacheExecutorImp implements XCacheExecutor {
     @Override
     public Object execute(XCache anno, Method method, Parameter[] params, Object[] values, SupplierEx callable) throws Throwable {
         CacheService cs = XBridge.cacheServiceGet(anno.service());
+        Map&lt;String, Object&gt; parMap = new HashMap&lt;&gt;();
+        Object result = null;
 
         if (anno.seconds() != 0 || XUtil.isNotEmpty(anno.tags())) {
+            //
+            //&#xFF08;&#x4E00;&#xFF09;&#x6267;&#x884C;&#x7F13;&#x5B58;&#x64CD;&#x4F5C;
+            //
+            String key = buildKey(method, params, values, parMap);
 
             //1.&#x4ECE;&#x7F13;&#x5B58;&#x83B7;&#x53D6;
+            //
+            result = cs.get(key);
 
+            if (result == null) {
                 //2.&#x6267;&#x884C;&#x8C03;&#x7528;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;
+                //
+                result = callable.get();
+
+                if (result != null) {
+                    //3.&#x4E0D;&#x4E3A;null&#xFF0C;&#x5219;&#x8FDB;&#x884C;&#x7F13;&#x5B58;
+                    //
+                    cs.store(key, result, anno.seconds());
+
+                    if (XUtil.isNotEmpty(anno.tags())) {
+                        String tags = formatTags(anno.tags(), parMap);
+                        CacheTags ct = new CacheTags(cs);
+
+                        //4.&#x6DFB;&#x52A0;&#x7F13;&#x5B58;&#x6807;&#x7B7E;
+                        for (String tag : tags.split(",")) {
+                            ct.add(tag, key);
+                        }
                     }
                 }
             }
+        } else {
+            //
+            //&#xFF08;&#x4E00;&#xFF09;&#x65E0;&#x7F13;&#x5B58;&#x64CD;&#x4F5C;
+            //
+            result = callable.get();
         }
 
+        //&#xFF08;&#x4E8C;&#xFF09;&#x6E05;&#x9664;&#x7F13;&#x5B58;&#x6807;&#x7B7E;
         //
         if (XUtil.isNotEmpty(anno.clearTags())) {
+            if (parMap.size() == 0) {
                 for (int i = 0, len = params.length; i &lt; len; i++) {
                     parMap.put(params[i].getName(), values[i]);
                 }
             }
 
+            String tags = formatTags(anno.clearTags(), parMap);
             CacheTags ct = new CacheTags(cs);
 
+            //&#x6E05;&#x9664;&#x7F13;&#x5B58;
+            for (String tag : tags.split(",")) {
                 ct.clear(tag);
             }
         }
 
+        return result;
+    }
+
+    private String buildKey(Method method, Parameter[] params, Object[] values, Map&lt;String, Object&gt; parMap) {
+        StringBuilder keyB = new StringBuilder();
+
+        keyB.append(method.getDeclaringClass().getName()).append(":");
+        keyB.append(method.getName()).append(":");
+
+        for (int i = 0, len = params.length; i &lt; len; i++) {
+            keyB.append(params[i].getName()).append("_").append(values[i]);
+            parMap.put(params[i].getName(), values[i]);
+        }
+
+        return keyB.toString();
     }
 
     private String formatTags(String tags, Map map) {
+        if (tags.indexOf("$") &lt; 0) {
+            return tags;
+        }
+
         String tags2 = tags;
 
         Pattern pattern = Pattern.compile("\\$\\{(\\w+)\\}");
         Matcher m = pattern.matcher(tags);
         while (m.find()) {
             String mark = m.group(0);
             String name = m.group(1);
+            if (map.containsKey(name)) {
                 String val = String.valueOf(map.get(name));
 
                 tags2 = tags2.replace(mark, val);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>424769</refactoring_id><commit_sha>887179f50ae6164ffd527aaae96fdc02ae6dc496</commit_sha><commit_link>https://github.com/androidx/media/commit/887179f50ae6164ffd527aaae96fdc02ae6dc496</commit_link><file_path>libraries/extractor/src/main/java/androidx/media3/extractor/metadata/id3/Id3Decoder.java</file_path><description>Rename Variable value : String to values : ImmutableList&lt;String&gt; in method private decodeTextInformationFrame(id3Data ParsableByteArray, frameSize int, id String) : TextInformationFrame from class androidx.media3.extractor.metadata.id3.Id3Decoder</description><code_before>@@ -26,6 +26,7 @@
 import androidx.media3.extractor.metadata.MetadataInputBuffer;
 import androidx.media3.extractor.metadata.SimpleMetadataDecoder;
 import com.google.common.base.Ascii;
 import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
@@ -457,14 +458,13 @@ private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, i
     byte[] data = new byte[frameSize - 1];
     id3Data.readBytes(data, 0, frameSize - 1);
 
-    int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
-    int valueStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
-    String value = decodeStringIfValid(data, valueStartIndex, valueEndIndex, charset);
-
-    return new TextInformationFrame("TXXX", description, value);
   }
 
   @Nullable
@@ -476,15 +476,34 @@ private static TextInformationFrame decodeTextInformationFrame(
     }
 
     int encoding = id3Data.readUnsignedByte();
-    String charset = getCharsetName(encoding);
 
     byte[] data = new byte[frameSize - 1];
     id3Data.readBytes(data, 0, frameSize - 1);
 
-    int valueEndIndex = indexOfEos(data, 0, encoding);
-    String value = new String(data, 0, valueEndIndex, charset);
 
-    return new TextInformationFrame(id, null, value);
   }
 
   @Nullable
@@ -501,7 +520,7 @@ private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frame
     byte[] data = new byte[frameSize - 1];
     id3Data.readBytes(data, 0, frameSize - 1);
 
-    int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
     int urlStartIndex = descriptionEndIndex + delimiterLength(encoding);
@@ -548,11 +567,11 @@ private static GeobFrame decodeGeobFrame(ParsableByteArray id3Data, int frameSiz
     String mimeType = new String(data, 0, mimeTypeEndIndex, "ISO-8859-1");
 
     int filenameStartIndex = mimeTypeEndIndex + 1;
-    int filenameEndIndex = indexOfEos(data, filenameStartIndex, encoding);
     String filename = decodeStringIfValid(data, filenameStartIndex, filenameEndIndex, charset);
 
     int descriptionStartIndex = filenameEndIndex + delimiterLength(encoding);
-    int descriptionEndIndex = indexOfEos(data, descriptionStartIndex, encoding);
     String description =
         decodeStringIfValid(data, descriptionStartIndex, descriptionEndIndex, charset);
 
@@ -590,7 +609,7 @@ private static ApicFrame decodeApicFrame(
     int pictureType = data[mimeTypeEndIndex + 1] &amp; 0xFF;
 
     int descriptionStartIndex = mimeTypeEndIndex + 2;
-    int descriptionEndIndex = indexOfEos(data, descriptionStartIndex, encoding);
     String description =
         new String(
             data, descriptionStartIndex, descriptionEndIndex - descriptionStartIndex, charset);
@@ -619,11 +638,11 @@ private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int fr
     data = new byte[frameSize - 4];
     id3Data.readBytes(data, 0, frameSize - 4);
 
-    int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
     int textStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    int textEndIndex = indexOfEos(data, textStartIndex, encoding);
     String text = decodeStringIfValid(data, textStartIndex, textEndIndex, charset);
 
     return new CommentFrame(language, description, text);
@@ -800,7 +819,7 @@ private static String getFrameId(
         : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
   }
 
-  private static int indexOfEos(byte[] data, int fromIndex, int encoding) {
     int terminationPos = indexOfZeroByte(data, fromIndex);
 
     // For single byte encoding charsets, we're done.
</code_before><code_after>@@ -26,6 +26,7 @@
 import androidx.media3.extractor.metadata.MetadataInputBuffer;
 import androidx.media3.extractor.metadata.SimpleMetadataDecoder;
 import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableList;
 import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
@@ -457,14 +458,13 @@ private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, i
     byte[] data = new byte[frameSize - 1];
     id3Data.readBytes(data, 0, frameSize - 1);
 
+    int descriptionEndIndex = indexOfTerminator(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
+    ImmutableList&lt;String&gt; values =
+        decodeTextInformationFrameValues(
+            data, encoding, descriptionEndIndex + delimiterLength(encoding));
+    return new TextInformationFrame("TXXX", description, values);
   }
 
   @Nullable
@@ -476,15 +476,34 @@ private static TextInformationFrame decodeTextInformationFrame(
     }
 
     int encoding = id3Data.readUnsignedByte();
 
     byte[] data = new byte[frameSize - 1];
     id3Data.readBytes(data, 0, frameSize - 1);
 
+    ImmutableList&lt;String&gt; values = decodeTextInformationFrameValues(data, encoding, 0);
+    return new TextInformationFrame(id, null, values);
+  }
+
+  private static ImmutableList&lt;String&gt; decodeTextInformationFrameValues(
+      byte[] data, final int encoding, final int index) throws UnsupportedEncodingException {
+    if (index &gt;= data.length) {
+      return ImmutableList.of("");
+    }
+
+    ImmutableList.Builder&lt;String&gt; values = ImmutableList.builder();
+    String charset = getCharsetName(encoding);
+    int valueStartIndex = index;
+    int valueEndIndex = indexOfTerminator(data, valueStartIndex, encoding);
+    while (valueStartIndex &lt; valueEndIndex) {
+      String value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+      values.add(value);
+
+      valueStartIndex = valueEndIndex + delimiterLength(encoding);
+      valueEndIndex = indexOfTerminator(data, valueStartIndex, encoding);
+    }
 
+    ImmutableList&lt;String&gt; result = values.build();
+    return result.isEmpty() ? ImmutableList.of("") : result;
   }
 
   @Nullable
@@ -501,7 +520,7 @@ private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frame
     byte[] data = new byte[frameSize - 1];
     id3Data.readBytes(data, 0, frameSize - 1);
 
+    int descriptionEndIndex = indexOfTerminator(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
     int urlStartIndex = descriptionEndIndex + delimiterLength(encoding);
@@ -548,11 +567,11 @@ private static GeobFrame decodeGeobFrame(ParsableByteArray id3Data, int frameSiz
     String mimeType = new String(data, 0, mimeTypeEndIndex, "ISO-8859-1");
 
     int filenameStartIndex = mimeTypeEndIndex + 1;
+    int filenameEndIndex = indexOfTerminator(data, filenameStartIndex, encoding);
     String filename = decodeStringIfValid(data, filenameStartIndex, filenameEndIndex, charset);
 
     int descriptionStartIndex = filenameEndIndex + delimiterLength(encoding);
+    int descriptionEndIndex = indexOfTerminator(data, descriptionStartIndex, encoding);
     String description =
         decodeStringIfValid(data, descriptionStartIndex, descriptionEndIndex, charset);
 
@@ -590,7 +609,7 @@ private static ApicFrame decodeApicFrame(
     int pictureType = data[mimeTypeEndIndex + 1] &amp; 0xFF;
 
     int descriptionStartIndex = mimeTypeEndIndex + 2;
+    int descriptionEndIndex = indexOfTerminator(data, descriptionStartIndex, encoding);
     String description =
         new String(
             data, descriptionStartIndex, descriptionEndIndex - descriptionStartIndex, charset);
@@ -619,11 +638,11 @@ private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int fr
     data = new byte[frameSize - 4];
     id3Data.readBytes(data, 0, frameSize - 4);
 
+    int descriptionEndIndex = indexOfTerminator(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
     int textStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    int textEndIndex = indexOfTerminator(data, textStartIndex, encoding);
     String text = decodeStringIfValid(data, textStartIndex, textEndIndex, charset);
 
     return new CommentFrame(language, description, text);
@@ -800,7 +819,7 @@ private static String getFrameId(
         : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
   }
 
+  private static int indexOfTerminator(byte[] data, int fromIndex, int encoding) {
     int terminationPos = indexOfZeroByte(data, fromIndex);
 
     // For single byte encoding charsets, we're done.
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>376645</refactoring_id><commit_sha>d169b1ca845a6a72a3d4752438ff9d825c8f6e5e</commit_sha><commit_link>https://github.com/jabref/jabref/commit/d169b1ca845a6a72a3d4752438ff9d825c8f6e5e</commit_link><file_path>src/main/java/net/sf/jabref/gui/preftabs/LabelPatternPrefTab.java</file_path><description>Rename Variable alwaysAddLetter : boolean to prefAlwaysAddLetter : boolean in method public setValues() : void from class net.sf.jabref.gui.preftabs.LabelPatternPrefTab</description><code_before>@@ -1,4 +1,4 @@
-/*  Copyright (C) 2003-2012 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -30,7 +30,6 @@
 import net.sf.jabref.JabRefPreferences;
 import net.sf.jabref.gui.help.HelpDialog;
 import net.sf.jabref.logic.l10n.Localization;
-import net.sf.jabref.logic.labelPattern.AbstractLabelPattern;
 import net.sf.jabref.logic.labelPattern.GlobalLabelPattern;
 import net.sf.jabref.gui.labelPattern.LabelPatternPanel;
 import net.sf.jabref.logic.labelPattern.LabelPatternUtil;
@@ -172,9 +171,9 @@ public void setValues() {
         autoGenerateOnImport.setSelected(Globals.prefs.getBoolean(JabRefPreferences.GENERATE_KEYS_AFTER_INSPECTION));
         warnBeforeOverwriting.setSelected(Globals.prefs.getBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY));
 
-        boolean alwaysAddLetter = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER);
         boolean firstLetterA = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A);
-        if (alwaysAddLetter) {
             this.alwaysAddLetter.setSelected(true);
         } else if (firstLetterA) {
             this.letterStartA.setSelected(true);
</code_before><code_after>@@ -1,4 +1,4 @@
+/*  Copyright (C) 2003-2015 JabRef contributors.
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -30,7 +30,6 @@
 import net.sf.jabref.JabRefPreferences;
 import net.sf.jabref.gui.help.HelpDialog;
 import net.sf.jabref.logic.l10n.Localization;
 import net.sf.jabref.logic.labelPattern.GlobalLabelPattern;
 import net.sf.jabref.gui.labelPattern.LabelPatternPanel;
 import net.sf.jabref.logic.labelPattern.LabelPatternUtil;
@@ -172,9 +171,9 @@ public void setValues() {
         autoGenerateOnImport.setSelected(Globals.prefs.getBoolean(JabRefPreferences.GENERATE_KEYS_AFTER_INSPECTION));
         warnBeforeOverwriting.setSelected(Globals.prefs.getBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY));
 
+        boolean prefAlwaysAddLetter = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER);
         boolean firstLetterA = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A);
+        if (prefAlwaysAddLetter) {
             this.alwaysAddLetter.setSelected(true);
         } else if (firstLetterA) {
             this.letterStartA.setSelected(true);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>381196</refactoring_id><commit_sha>59360400c977f54c12997cc9bc6752e06f83b7b4</commit_sha><commit_link>https://github.com/pmd/pmd/commit/59360400c977f54c12997cc9bc6752e06f83b7b4</commit_link><file_path>pmd-eclipse-test/test/test/net/sourceforge/pmd/core/PMDCorePluginTest.java</file_path><description>Rename Variable registeredRuleSets : Set to defaultRuleSets : Set in method public testDefaultPMDRuleSetsRegistered() : void from class test.net.sourceforge.pmd.core.PMDCorePluginTest</description><code_before>@@ -52,6 +52,9 @@
  * @version $Revision$
  * 
  * $Log$
  * Revision 1.1  2005/06/15 21:14:56  phherlin
  * Create the project for the Eclipse plugin unit tests
  *
@@ -85,6 +88,7 @@ public void testRuleSetManagerNotNull() {
     
     /**
      * Test all the known PMD rulesets has been registered
      *
      */
     public void testStandardPMDRuleSetsRegistered() throws RuleSetNotFoundException {
@@ -94,26 +98,24 @@ public void testStandardPMDRuleSetsRegistered() throws RuleSetNotFoundException
         RuleSetFactory factory = new RuleSetFactory();
         for (int i = 0; i &lt; PluginConstants.PMD_RULESETS.length; i++) {
             RuleSet ruleSet = factory.createRuleSet(PluginConstants.PMD_RULESETS[i]);
-            assertTrue("RuleSet \"" + PluginConstants.PMD_RULESETS[i] + "\" has not been registered", this.ruleSetRegistered(ruleSet, registeredRuleSets));
         }
     }
     
     /**
-     * Tests the additional rulesets has been registered.
-     * For this test to work, the test plugin fragment must have a "additional" file in the "ruleset" package.
-     * The additional file must contain declaration for a "rulesets/extra1.xml" and "rulesets/extra2.xml" rulesets
      *
      */
-    public void testAdditionalRuleSetsRegistered() throws RuleSetNotFoundException {
-        Set registeredRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();
-        assertFalse("No registered rulesets!", registeredRuleSets.isEmpty());
         
         RuleSetFactory factory = new RuleSetFactory();
-        RuleSet ruleSet = factory.createRuleSet("rulesets/extra1.xml");
-        assertTrue("RuleSet \"rulesets/extra1.xml\" has not been registered", this.ruleSetRegistered(ruleSet, registeredRuleSets));
-
-        ruleSet = factory.createRuleSet("rulesets/extra2.xml");
-        assertTrue("RuleSet \"rulesets/extra2.xml\" has not been registered", this.ruleSetRegistered(ruleSet, registeredRuleSets));
     }
     
     /**
</code_before><code_after>@@ -52,6 +52,9 @@
  * @version $Revision$
  * 
  * $Log$
+ * Revision 1.2  2005/07/02 14:32:01  phherlin
+ * Implement the RuleSets extension points new tests
+ *
  * Revision 1.1  2005/06/15 21:14:56  phherlin
  * Create the project for the Eclipse plugin unit tests
  *
@@ -85,6 +88,7 @@ public void testRuleSetManagerNotNull() {
     
     /**
      * Test all the known PMD rulesets has been registered
+     * For this test to work, no fragement or only the test plugin fragment should be installed.
      *
      */
     public void testStandardPMDRuleSetsRegistered() throws RuleSetNotFoundException {
@@ -94,26 +98,24 @@ public void testStandardPMDRuleSetsRegistered() throws RuleSetNotFoundException
         RuleSetFactory factory = new RuleSetFactory();
         for (int i = 0; i &lt; PluginConstants.PMD_RULESETS.length; i++) {
             RuleSet ruleSet = factory.createRuleSet(PluginConstants.PMD_RULESETS[i]);
+            assertTrue("RuleSet \"" + PluginConstants.PMD_RULESETS[i] + "\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));
         }
     }
     
     /**
+     * Test the default rulesets has been registered
+     * For this test to work, no fragement or only the test plugin fragment should be installed.
      *
      */
+    public void testDefaultPMDRuleSetsRegistered() throws RuleSetNotFoundException {
+        Set defaultRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();
+        assertFalse("No registered default rulesets!", defaultRuleSets.isEmpty());
         
         RuleSetFactory factory = new RuleSetFactory();
+        for (int i = 0; i &lt; PluginConstants.PMD_RULESETS.length; i++) {
+            RuleSet ruleSet = factory.createRuleSet(PluginConstants.PMD_RULESETS[i]);
+            assertTrue("RuleSet \"" + PluginConstants.PMD_RULESETS[i] + "\" has not been registered", ruleSetRegistered(ruleSet, defaultRuleSets));
+        }
     }
     
     /**
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>426449</refactoring_id><commit_sha>d5ccde0e398a63496ce9a7a130934ee88307ef78</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/d5ccde0e398a63496ce9a7a130934ee88307ef78</commit_link><file_path>src/com/google/javascript/jscomp/AstValidator.java</file_path><description>Rename Variable calleeFunctionTypeI : FunctionType to calleeFunctionType : FunctionType in method private validateCallType(callNode Node) : void from class com.google.javascript.jscomp.AstValidator</description><code_before>@@ -466,16 +466,17 @@ private void validateNameType(Node nameNode) {
   private void validateCallType(Node callNode) {
     // TODO(b/74537281): Shouldn't CALL nodes always have a type, even if it is unknown?
     Node callee = callNode.getFirstChild();
-    JSType calleeTypeI =
         checkNotNull(callee.getJSType(), "Callee of\n\n%s\nhas no type.", callNode.toStringTree());
 
-    if (calleeTypeI.isFunctionType()) {
-      FunctionType calleeFunctionTypeI = calleeTypeI.toMaybeFunctionType();
-      JSType returnTypeI = calleeFunctionTypeI.getReturnType();
       // Skip this check if the call node was originally in a cast, because the cast type may be
-      // narrower than the return type.
-      if (callNode.getJSTypeBeforeCast() == null) {
-        expectMatchingTypeInformation(callNode, returnTypeI);
       }
     } // TODO(b/74537281): What other cases should be covered?
   }
</code_before><code_after>@@ -466,16 +466,17 @@ private void validateNameType(Node nameNode) {
   private void validateCallType(Node callNode) {
     // TODO(b/74537281): Shouldn't CALL nodes always have a type, even if it is unknown?
     Node callee = callNode.getFirstChild();
+    JSType calleeType =
         checkNotNull(callee.getJSType(), "Callee of\n\n%s\nhas no type.", callNode.toStringTree());
 
+    if (calleeType.isFunctionType()) {
+      FunctionType calleeFunctionType = calleeType.toMaybeFunctionType();
+      JSType returnType = calleeFunctionType.getReturnType();
       // Skip this check if the call node was originally in a cast, because the cast type may be
+      // narrower than the return type. Also skip the check if the function's return type is the
+      // any (formerly unknown) type, since we may have inferred a better type.
+      if (callNode.getJSTypeBeforeCast() == null &amp;&amp; !returnType.isUnknownType()) {
+        expectMatchingTypeInformation(callNode, returnType);
       }
     } // TODO(b/74537281): What other cases should be covered?
   }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>388489</refactoring_id><commit_sha>e185d1bf76b914a841e3fa6f116922334253913d</commit_sha><commit_link>https://github.com/apache/beam/commit/e185d1bf76b914a841e3fa6f116922334253913d</commit_link><file_path>sdks/java/nexmark/src/test/java/org/apache/beam/sdk/nexmark/model/sql/adapter/ModelAdaptersMappingTest.java</file_path><description>Rename Variable auctionRowType : RowType to auctionSchema : Schema in method public testAuctionAdapterRecordType() : void from class org.apache.beam.sdk.nexmark.model.sql.adapter.ModelAdaptersMappingTest</description><code_before>@@ -28,7 +28,7 @@
 import org.apache.beam.sdk.nexmark.model.Auction;
 import org.apache.beam.sdk.nexmark.model.Bid;
 import org.apache.beam.sdk.nexmark.model.Person;
-import org.apache.beam.sdk.values.RowType;
 import org.junit.Test;
 
 /**
@@ -39,7 +39,7 @@ public class ModelAdaptersMappingTest {
   private static final Person PERSON =
       new Person(3L, "name", "email", "cc", "city", "state", 329823L, "extra");
 
-  private static final RowType PERSON_ROW_TYPE = RowSqlType.builder()
       .withBigIntField("id")
       .withVarcharField("name")
       .withVarcharField("emailAddress")
@@ -53,7 +53,7 @@ public class ModelAdaptersMappingTest {
   private static final Bid BID =
       new Bid(5L, 3L, 123123L, 43234234L, "extra2");
 
-  private static final RowType BID_ROW_TYPE = RowSqlType.builder()
       .withBigIntField("auction")
       .withBigIntField("bidder")
       .withBigIntField("price")
@@ -64,7 +64,7 @@ public class ModelAdaptersMappingTest {
   private static final Auction AUCTION =
       new Auction(5L, "item", "desc", 342L, 321L, 3423342L, 2349234L, 3L, 1L, "extra3");
 
-  private static final RowType AUCTION_ROW_TYPE = RowSqlType.builder()
       .withBigIntField("id")
       .withVarcharField("itemName")
       .withVarcharField("description")
@@ -92,27 +92,27 @@ public void hasAdaptersForSupportedModels() throws Exception {
   public void testBidAdapterRecordType() {
     ModelFieldsAdapter&lt;Person&gt; adapter = ModelAdaptersMapping.ADAPTERS.get(Bid.class);
 
-    RowType bidRowType = adapter.getRowType();
 
-    assertEquals(BID_ROW_TYPE, bidRowType);
   }
 
   @Test
   public void testPersonAdapterRecordType() {
     ModelFieldsAdapter&lt;Person&gt; adapter = ModelAdaptersMapping.ADAPTERS.get(Person.class);
 
-    RowType personRowType = adapter.getRowType();
 
-    assertEquals(PERSON_ROW_TYPE, personRowType);
   }
 
   @Test
   public void testAuctionAdapterRecordType() {
     ModelFieldsAdapter&lt;Person&gt; adapter = ModelAdaptersMapping.ADAPTERS.get(Auction.class);
 
-    RowType auctionRowType = adapter.getRowType();
 
-    assertEquals(AUCTION_ROW_TYPE, auctionRowType);
   }
 
   @Test
</code_before><code_after>@@ -28,7 +28,7 @@
 import org.apache.beam.sdk.nexmark.model.Auction;
 import org.apache.beam.sdk.nexmark.model.Bid;
 import org.apache.beam.sdk.nexmark.model.Person;
+import org.apache.beam.sdk.schemas.Schema;
 import org.junit.Test;
 
 /**
@@ -39,7 +39,7 @@ public class ModelAdaptersMappingTest {
   private static final Person PERSON =
       new Person(3L, "name", "email", "cc", "city", "state", 329823L, "extra");
 
+  private static final Schema PERSON_ROW_TYPE = RowSqlType.builder()
       .withBigIntField("id")
       .withVarcharField("name")
       .withVarcharField("emailAddress")
@@ -53,7 +53,7 @@ public class ModelAdaptersMappingTest {
   private static final Bid BID =
       new Bid(5L, 3L, 123123L, 43234234L, "extra2");
 
+  private static final Schema BID_ROW_TYPE = RowSqlType.builder()
       .withBigIntField("auction")
       .withBigIntField("bidder")
       .withBigIntField("price")
@@ -64,7 +64,7 @@ public class ModelAdaptersMappingTest {
   private static final Auction AUCTION =
       new Auction(5L, "item", "desc", 342L, 321L, 3423342L, 2349234L, 3L, 1L, "extra3");
 
+  private static final Schema AUCTION_ROW_TYPE = RowSqlType.builder()
       .withBigIntField("id")
       .withVarcharField("itemName")
       .withVarcharField("description")
@@ -92,27 +92,27 @@ public void hasAdaptersForSupportedModels() throws Exception {
   public void testBidAdapterRecordType() {
     ModelFieldsAdapter&lt;Person&gt; adapter = ModelAdaptersMapping.ADAPTERS.get(Bid.class);
 
+    Schema bidSchema = adapter.getSchema();
 
+    assertEquals(BID_ROW_TYPE, bidSchema);
   }
 
   @Test
   public void testPersonAdapterRecordType() {
     ModelFieldsAdapter&lt;Person&gt; adapter = ModelAdaptersMapping.ADAPTERS.get(Person.class);
 
+    Schema personSchema = adapter.getSchema();
 
+    assertEquals(PERSON_ROW_TYPE, personSchema);
   }
 
   @Test
   public void testAuctionAdapterRecordType() {
     ModelFieldsAdapter&lt;Person&gt; adapter = ModelAdaptersMapping.ADAPTERS.get(Auction.class);
 
+    Schema auctionSchema = adapter.getSchema();
 
+    assertEquals(AUCTION_ROW_TYPE, auctionSchema);
   }
 
   @Test
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>464098</refactoring_id><commit_sha>d5415e4617186e1a46bdcf4b76e304d45634b3b6</commit_sha><commit_link>https://github.com/oracle/graal/commit/d5415e4617186e1a46bdcf4b76e304d45634b3b6</commit_link><file_path>graal/com.oracle.graal.compiler.common/src/com/oracle/graal/compiler/common/type/FloatStamp.java</file_path><description>Rename Variable value : PrimitiveConstant to a : PrimitiveConstant in method public foldConstant(const1 Constant, const2 Constant) : Constant from class com.oracle.graal.compiler.common.type.FloatStamp.OPS.new ArithmeticOpTable.new BinaryOp.Div</description><code_before>@@ -454,6 +454,49 @@ public Stamp foldStamp(Stamp stamp1, Stamp stamp2) {
 
     null, null, null, null,
 
     null, null, null,
 
     new FloatConvertOp(F2I) {
</code_before><code_after>@@ -454,6 +454,49 @@ public Stamp foldStamp(Stamp stamp1, Stamp stamp2) {
 
     null, null, null, null,
 
+    new UnaryOp.Abs() {
+
+        @Override
+        public Constant foldConstant(Constant c) {
+            PrimitiveConstant value = (PrimitiveConstant) c;
+            switch (value.getKind()) {
+                case Float:
+                    return JavaConstant.forFloat(Math.abs(value.asFloat()));
+                case Double:
+                    return JavaConstant.forDouble(Math.abs(value.asDouble()));
+                default:
+                    throw GraalInternalError.shouldNotReachHere();
+            }
+        }
+
+        @Override
+        public Stamp foldStamp(Stamp s) {
+            FloatStamp stamp = (FloatStamp) s;
+            return new FloatStamp(stamp.getBits(), 0, Math.max(-stamp.lowerBound(), stamp.upperBound()), stamp.isNonNaN());
+        }
+    },
+
+    new UnaryOp.Sqrt() {
+
+        @Override
+        public Constant foldConstant(Constant c) {
+            PrimitiveConstant value = (PrimitiveConstant) c;
+            switch (value.getKind()) {
+                case Float:
+                    return JavaConstant.forFloat((float) Math.sqrt(value.asFloat()));
+                case Double:
+                    return JavaConstant.forDouble(Math.sqrt(value.asDouble()));
+                default:
+                    throw GraalInternalError.shouldNotReachHere();
+            }
+        }
+
+        @Override
+        public Stamp foldStamp(Stamp s) {
+            return s.unrestricted();
+        }
+    },
+
     null, null, null,
 
     new FloatConvertOp(F2I) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>462118</refactoring_id><commit_sha>d1b81db0d4e50ad1b972043ef5f3f2efb0758d82</commit_sha><commit_link>https://github.com/oracle/graal/commit/d1b81db0d4e50ad1b972043ef5f3f2efb0758d82</commit_link><file_path>graal/com.oracle.graal.nodes/src/com/oracle/graal/nodes/java/StoreIndexedNode.java</file_path><description>Rename Variable arrayState : State to alias : ValueNode in method public virtualize(tool VirtualizerTool) : void from class com.oracle.graal.nodes.java.StoreIndexedNode</description><code_before>@@ -30,6 +30,7 @@
 import com.oracle.graal.nodes.*;
 import com.oracle.graal.nodes.spi.*;
 import com.oracle.graal.nodes.type.*;
 
 /**
  * The {@code StoreIndexedNode} represents a write to an array element.
@@ -66,15 +67,16 @@ public StoreIndexedNode(ValueNode array, ValueNode index, Kind elementKind, Valu
 
     @Override
     public void virtualize(VirtualizerTool tool) {
-        State arrayState = tool.getObjectState(array());
-        if (arrayState != null &amp;&amp; arrayState.getState() == EscapeState.Virtual) {
-            ValueNode indexValue = tool.getReplacedValue(index());
             int idx = indexValue.isConstant() ? indexValue.asJavaConstant().asInt() : -1;
-            if (idx &gt;= 0 &amp;&amp; idx &lt; arrayState.getVirtualObject().entryCount()) {
-                ResolvedJavaType componentType = arrayState.getVirtualObject().type().getComponentType();
                 if (componentType.isPrimitive() || StampTool.isPointerAlwaysNull(value) || componentType.getSuperclass() == null ||
                                 (StampTool.typeOrNull(value) != null &amp;&amp; componentType.isAssignableFrom(StampTool.typeOrNull(value)))) {
-                    tool.setVirtualEntry(arrayState, idx, value(), false);
                     tool.delete();
                 }
             }
</code_before><code_after>@@ -30,6 +30,7 @@
 import com.oracle.graal.nodes.*;
 import com.oracle.graal.nodes.spi.*;
 import com.oracle.graal.nodes.type.*;
+import com.oracle.graal.nodes.virtual.*;
 
 /**
  * The {@code StoreIndexedNode} represents a write to an array element.
@@ -66,15 +67,16 @@ public StoreIndexedNode(ValueNode array, ValueNode index, Kind elementKind, Valu
 
     @Override
     public void virtualize(VirtualizerTool tool) {
+        ValueNode alias = tool.getAlias(array());
+        if (alias instanceof VirtualObjectNode) {
+            ValueNode indexValue = tool.getAlias(index());
             int idx = indexValue.isConstant() ? indexValue.asJavaConstant().asInt() : -1;
+            VirtualArrayNode virtual = (VirtualArrayNode) alias;
+            if (idx &gt;= 0 &amp;&amp; idx &lt; virtual.entryCount()) {
+                ResolvedJavaType componentType = virtual.type().getComponentType();
                 if (componentType.isPrimitive() || StampTool.isPointerAlwaysNull(value) || componentType.getSuperclass() == null ||
                                 (StampTool.typeOrNull(value) != null &amp;&amp; componentType.isAssignableFrom(StampTool.typeOrNull(value)))) {
+                    tool.setVirtualEntry(virtual, idx, value(), false);
                     tool.delete();
                 }
             }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>391444</refactoring_id><commit_sha>3acd81f1a7ec6ed84879ebbd7c7425fcd188e4db</commit_sha><commit_link>https://github.com/teammates/teammates/commit/3acd81f1a7ec6ed84879ebbd7c7425fcd188e4db</commit_link><file_path>src/main/java/teammates/common/datatransfer/InstructorPrivileges.java</file_path><description>Rename Variable privilege : String to entry : Map.Entry&lt;String,Boolean&gt; in method private setDefaultPrivileges(defaultPrivileges Map&lt;String,Boolean&gt;) : void from class teammates.common.datatransfer.InstructorPrivileges</description><code_before>@@ -179,8 +179,8 @@ public void setDefaultPrivilegesForCustom() {
     }
     
     private void setDefaultPrivileges(Map&lt;String, Boolean&gt; defaultPrivileges) {
-        for (String privilege : defaultPrivileges.keySet()) {
-            courseLevel.put(privilege, defaultPrivileges.get(privilege));
         }
     }
     
@@ -399,8 +399,8 @@ public boolean hasTutorPrivileges() {
 
     private boolean hasSamePrivileges(Map&lt;String, Boolean&gt; defaultPrivileges) {
 
-        for (String privilege : defaultPrivileges.keySet()) {
-            if (isAllowedForPrivilege(privilege) != defaultPrivileges.get(privilege)) {
                 return false;
             }
         }
</code_before><code_after>@@ -179,8 +179,8 @@ public void setDefaultPrivilegesForCustom() {
     }
     
     private void setDefaultPrivileges(Map&lt;String, Boolean&gt; defaultPrivileges) {
+        for (Map.Entry&lt;String, Boolean&gt; entry : defaultPrivileges.entrySet()) {
+            courseLevel.put(entry.getKey(), entry.getValue());
         }
     }
     
@@ -399,8 +399,8 @@ public boolean hasTutorPrivileges() {
 
     private boolean hasSamePrivileges(Map&lt;String, Boolean&gt; defaultPrivileges) {
 
+        for (Map.Entry&lt;String, Boolean&gt; entry : defaultPrivileges.entrySet()) {
+            if (isAllowedForPrivilege(entry.getKey()) != entry.getValue()) {
                 return false;
             }
         }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>362250</refactoring_id><commit_sha>8f50e341559510f633805b7312073bca8f758a32</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/8f50e341559510f633805b7312073bca8f758a32</commit_link><file_path>stream-platform/src/main/java/io/camunda/zeebe/stream/impl/ProcessingStateMachine.java</file_path><description>Rename Variable position : long to writeResult : var in method private writeRecords() : void from class io.camunda.zeebe.stream.impl.ProcessingStateMachine</description><code_before>@@ -455,11 +455,12 @@ private void writeRecords() {
     final ActorFuture&lt;Boolean&gt; retryFuture =
         writeRetryStrategy.runWithRetry(
             () -&gt; {
-              final long position = logStreamWriter.tryWrite(pendingWrites, sourceRecordPosition);
-              if (position &gt; 0) {
-                writtenPosition = position;
               }
-              return position &gt;= 0;
             },
             abortCondition);
 
</code_before><code_after>@@ -455,11 +455,12 @@ private void writeRecords() {
     final ActorFuture&lt;Boolean&gt; retryFuture =
         writeRetryStrategy.runWithRetry(
             () -&gt; {
+              final var writeResult = logStreamWriter.tryWrite(pendingWrites, sourceRecordPosition);
+              if (writeResult.isRight()) {
+                writtenPosition = writeResult.get();
+                return writtenPosition &gt;= 0;
               }
+              return false;
             },
             abortCondition);
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>396343</refactoring_id><commit_sha>36ec1d84a11e74be6590ae1a8dcba4cb2eec5c4a</commit_sha><commit_link>https://github.com/mollyim/mollyim-android/commit/36ec1d84a11e74be6590ae1a8dcba4cb2eec5c4a</commit_link><file_path>src/org/thoughtcrime/securesms/gcm/GcmBroadcastReceiver.java</file_path><description>Rename Variable encryptedMessage : IncomingEncryptedPushMessage to encrypted : IncomingEncryptedPushMessage in method private handleReceivedMessage(context Context, data String) : void from class org.thoughtcrime.securesms.gcm.GcmBroadcastReceiver</description><code_before>@@ -6,7 +6,10 @@
 import android.util.Log;
 
 import com.google.android.gms.gcm.GoogleCloudMessaging;
 
 import org.thoughtcrime.securesms.service.SendReceiveService;
 import org.thoughtcrime.securesms.util.TextSecurePreferences;
 import org.whispersystems.libaxolotl.InvalidVersionException;
@@ -31,38 +34,47 @@ public void onReceive(Context context, Intent intent) {
     if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) {
       Log.w(TAG, "GCM message...");
 
-      try {
-        String data = intent.getStringExtra("message");
-
-        if (Util.isEmpty(data))
-          return;
-
-        if (!TextSecurePreferences.isPushRegistered(context)) {
-          Log.w(TAG, "Not push registered!");
-          return;
-        }
-
-        String                       sessionKey       = TextSecurePreferences.getSignalingKey(context);
-        IncomingEncryptedPushMessage encryptedMessage = new IncomingEncryptedPushMessage(data, sessionKey);
-        IncomingPushMessage          message          = encryptedMessage.getIncomingPushMessage();
-
-        if (!isActiveNumber(context, message.getSource())) {
-          Directory directory           = Directory.getInstance(context);
-          ContactTokenDetails contactTokenDetails = new ContactTokenDetails();
-          contactTokenDetails.setNumber(message.getSource());
-
-          directory.setNumber(contactTokenDetails, true);
-        }
-
-        Intent service = new Intent(context, SendReceiveService.class);
-        service.setAction(SendReceiveService.RECEIVE_PUSH_ACTION);
-        service.putExtra("message", message);
-        context.startService(service);
-      } catch (IOException e) {
-        Log.w(TAG, e);
-      } catch (InvalidVersionException e) {
-        Log.w(TAG, e);
       }
     }
   }
 
</code_before><code_after>@@ -6,7 +6,10 @@
 import android.util.Log;
 
 import com.google.android.gms.gcm.GoogleCloudMessaging;
+import com.path.android.jobqueue.JobManager;
 
+import org.thoughtcrime.securesms.ApplicationContext;
+import org.thoughtcrime.securesms.jobs.DeliveryReceiptJob;
 import org.thoughtcrime.securesms.service.SendReceiveService;
 import org.thoughtcrime.securesms.util.TextSecurePreferences;
 import org.whispersystems.libaxolotl.InvalidVersionException;
@@ -31,38 +34,47 @@ public void onReceive(Context context, Intent intent) {
     if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) {
       Log.w(TAG, "GCM message...");
 
+      if (!TextSecurePreferences.isPushRegistered(context)) {
+        Log.w(TAG, "Not push registered!");
+        return;
       }
+
+      String messageData = intent.getStringExtra("message");
+      String receiptData = intent.getStringExtra("receipt");
+
+      if      (!Util.isEmpty(messageData)) handleReceivedMessage(context, messageData);
+      else if (!Util.isEmpty(receiptData)) handleReceivedMessage(context, receiptData);
+    }
+  }
+
+  private void handleReceivedMessage(Context context, String data) {
+    try {
+      String                       sessionKey = TextSecurePreferences.getSignalingKey(context);
+      IncomingEncryptedPushMessage encrypted  = new IncomingEncryptedPushMessage(data, sessionKey);
+      IncomingPushMessage          message    = encrypted.getIncomingPushMessage();
+
+      if (!isActiveNumber(context, message.getSource())) {
+        Directory           directory           = Directory.getInstance(context);
+        ContactTokenDetails contactTokenDetails = new ContactTokenDetails();
+        contactTokenDetails.setNumber(message.getSource());
+
+        directory.setNumber(contactTokenDetails, true);
+      }
+
+      Intent receiveService = new Intent(context, SendReceiveService.class);
+      receiveService.setAction(SendReceiveService.RECEIVE_PUSH_ACTION);
+      receiveService.putExtra("message", message);
+      context.startService(receiveService);
+
+      if (!message.isReceipt()) {
+        JobManager jobManager = ApplicationContext.getInstance(context).getJobManager();
+        jobManager.addJob(new DeliveryReceiptJob(message.getSource(), message.getTimestampMillis(),
+                                                 message.getRelay()));
+      }
+    } catch (IOException e) {
+      Log.w(TAG, e);
+    } catch (InvalidVersionException e) {
+      Log.w(TAG, e);
     }
   }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>406733</refactoring_id><commit_sha>6a09d6587a2331567f1d092d5e488d7206602cdd</commit_sha><commit_link>https://github.com/rstudio/rstudio/commit/6a09d6587a2331567f1d092d5e488d7206602cdd</commit_link><file_path>src/gwt/src/org/rstudio/core/client/widget/InfoBar.java</file_path><description>Rename Variable anchor : Label to label : Label in method private label(text String, onClick Command) : Label from class org.rstudio.core.client.widget.InfoBar</description><code_before>@@ -23,6 +23,7 @@
 import com.google.gwt.event.dom.client.ClickHandler;
 import com.google.gwt.uibinder.client.UiBinder;
 import com.google.gwt.uibinder.client.UiField;
 import com.google.gwt.user.client.ui.Composite;
 import com.google.gwt.user.client.ui.DockLayoutPanel;
 import com.google.gwt.user.client.ui.HorizontalPanel;
@@ -95,7 +96,8 @@ public int getHeight()
    }
    
    public void showRequiredPackagesMissingWarning(List&lt;String&gt; packages,
-                                                  CommandWithArg&lt;Boolean&gt; onPackageInstallCompleted)
    {
       String message;
       
@@ -121,13 +123,13 @@ else if (n == 3)
       
       if (labelRight_.getWidgetCount() == 0)
       {
-         Label anchor = new Label("Install");
-         anchor.getElement().getStyle().setTextDecoration(TextDecoration.UNDERLINE);
-         anchor.getElement().getStyle().setPaddingLeft(5, Unit.PX);
-         anchor.getElement().getStyle().setCursor(Cursor.POINTER);
-         anchor.getElement().getStyle().setWhiteSpace(WhiteSpace.NOWRAP);
-         anchor.addClickHandler((ClickEvent event) -&gt; { RStudioGinjector.INSTANCE.getDependencyManager().installPackages(packages, onPackageInstallCompleted); });
-         labelRight_.add(anchor);
       }
    }
    
@@ -142,22 +144,28 @@ public void showReadOnlyWarning(List&lt;String&gt; alternatives)
          label_.setText("This document is read only. Generated from:");
          for (String alternative : alternatives)
          {
-            Label anchor = new Label(alternative);
-            anchor.getElement().getStyle().setTextDecoration(TextDecoration.UNDERLINE);
-            anchor.getElement().getStyle().setPaddingLeft(5, Unit.PX);
-            anchor.getElement().getStyle().setCursor(Cursor.POINTER);
-            anchor.getElement().getStyle().setWhiteSpace(WhiteSpace.NOWRAP);
-            anchor.addClickHandler((ClickEvent event) -&gt; {
                Session session = RStudioGinjector.INSTANCE.getSession();
                FileTypeRegistry registry = RStudioGinjector.INSTANCE.getFileTypeRegistry();
                FileSystemItem projDir = session.getSessionInfo().getActiveProjectDir();
                FileSystemItem targetItem = FileSystemItem.createFile(projDir.completePath(alternative));
                registry.editFile(targetItem);
-            });
-            labelRight_.add(anchor);
          }
       }
    }
 
    @UiField
    protected DockLayoutPanel container_;
</code_before><code_after>@@ -23,6 +23,7 @@
 import com.google.gwt.event.dom.client.ClickHandler;
 import com.google.gwt.uibinder.client.UiBinder;
 import com.google.gwt.uibinder.client.UiField;
+import com.google.gwt.user.client.Command;
 import com.google.gwt.user.client.ui.Composite;
 import com.google.gwt.user.client.ui.DockLayoutPanel;
 import com.google.gwt.user.client.ui.HorizontalPanel;
@@ -95,7 +96,8 @@ public int getHeight()
    }
    
    public void showRequiredPackagesMissingWarning(List&lt;String&gt; packages,
+                                                  CommandWithArg&lt;Boolean&gt; onPackageInstallCompleted,
+                                                  Command onDismiss)
    {
       String message;
       
@@ -121,13 +123,13 @@ else if (n == 3)
       
       if (labelRight_.getWidgetCount() == 0)
       {
+         labelRight_.add(label("Install", () -&gt; {
+            RStudioGinjector.INSTANCE.getDependencyManager().installPackages(packages, onPackageInstallCompleted);
+         }));
+         
+         labelRight_.add(label("Don't Show Again", () -&gt; {
+            onDismiss.execute();
+         }));
       }
    }
    
@@ -142,22 +144,28 @@ public void showReadOnlyWarning(List&lt;String&gt; alternatives)
          label_.setText("This document is read only. Generated from:");
          for (String alternative : alternatives)
          {
+            labelRight_.add(label(alternative, () -&gt; {
                Session session = RStudioGinjector.INSTANCE.getSession();
                FileTypeRegistry registry = RStudioGinjector.INSTANCE.getFileTypeRegistry();
                FileSystemItem projDir = session.getSessionInfo().getActiveProjectDir();
                FileSystemItem targetItem = FileSystemItem.createFile(projDir.completePath(alternative));
                registry.editFile(targetItem);
+            }));
          }
       }
    }
+   
+   private Label label(String text, Command onClick)
+   {
+      Label label = new Label(text);
+      label.getElement().getStyle().setTextDecoration(TextDecoration.UNDERLINE);
+      label.getElement().getStyle().setPaddingLeft(5, Unit.PX);
+      label.getElement().getStyle().setCursor(Cursor.POINTER);
+      label.getElement().getStyle().setWhiteSpace(WhiteSpace.NOWRAP);
+      label.addClickHandler((ClickEvent event) -&gt; { onClick.execute(); });
+      return label;
+      
+   }
 
    @UiField
    protected DockLayoutPanel container_;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>448408</refactoring_id><commit_sha>694a8231ef2000ad183555b612d7ec7d1eba1154</commit_sha><commit_link>https://github.com/apache/cloudstack/commit/694a8231ef2000ad183555b612d7ec7d1eba1154</commit_link><file_path>server/src/com/cloud/api/commands/CreateSnapshotCmd.java</file_path><description>Rename Variable response : SnapshotResponse to snapshotResponse : SnapshotResponse in method public createSnapshotResponse(snapshot Snapshot) : SnapshotResponse from class com.cloud.api.ApiResponseHelper</description><code_before>@@ -22,14 +22,14 @@
 
 import com.cloud.api.ApiConstants;
 import com.cloud.api.ApiDBUtils;
 import com.cloud.api.BaseAsyncCreateCmd;
 import com.cloud.api.BaseCmd;
 import com.cloud.api.Implementation;
 import com.cloud.api.Parameter;
 import com.cloud.api.ServerApiException;
 import com.cloud.api.response.SnapshotResponse;
 import com.cloud.event.EventTypes;
-import com.cloud.storage.Snapshot.SnapshotType;
 import com.cloud.storage.SnapshotVO;
 import com.cloud.storage.VolumeVO;
 import com.cloud.storage.snapshot.SnapshotManager;
@@ -108,25 +108,7 @@ public SnapshotResponse getResponse() {
         SnapshotVO snapshot = (SnapshotVO)getResponseObject();
 
         if (snapshot != null) {
-            SnapshotResponse response = new SnapshotResponse();
-            response.setId(snapshot.getId());
-
-            Account account = ApiDBUtils.findAccountById(snapshot.getAccountId());
-            if (account != null) {
-                response.setAccountName(account.getAccountName());
-                response.setDomainId(account.getDomainId());
-                response.setDomainName(ApiDBUtils.findDomainById(account.getDomainId()).getName());
-            }
-
-            VolumeVO volume = ApiDBUtils.findVolumeById(snapshot.getVolumeId());
-            String snapshotTypeStr = SnapshotType.values()[snapshot.getSnapshotType()].name();
-            response.setSnapshotType(snapshotTypeStr);
-            response.setVolumeId(snapshot.getVolumeId());
-            response.setVolumeName(volume.getName());
-            response.setVolumeType(volume.getVolumeType().toString());
-            response.setCreated(snapshot.getCreated());
-            response.setName(snapshot.getName());
-
             response.setResponseName(getName());
             return response;
         }
</code_before><code_after>@@ -22,14 +22,14 @@
 
 import com.cloud.api.ApiConstants;
 import com.cloud.api.ApiDBUtils;
+import com.cloud.api.ApiResponseHelper;
 import com.cloud.api.BaseAsyncCreateCmd;
 import com.cloud.api.BaseCmd;
 import com.cloud.api.Implementation;
 import com.cloud.api.Parameter;
 import com.cloud.api.ServerApiException;
 import com.cloud.api.response.SnapshotResponse;
 import com.cloud.event.EventTypes;
 import com.cloud.storage.SnapshotVO;
 import com.cloud.storage.VolumeVO;
 import com.cloud.storage.snapshot.SnapshotManager;
@@ -108,25 +108,7 @@ public SnapshotResponse getResponse() {
         SnapshotVO snapshot = (SnapshotVO)getResponseObject();
 
         if (snapshot != null) {
+            SnapshotResponse response = ApiResponseHelper.createSnapshotResponse(snapshot);
             response.setResponseName(getName());
             return response;
         }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>361388</refactoring_id><commit_sha>5788b45f979c342a39bc790e0974e8969d31f42a</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/5788b45f979c342a39bc790e0974e8969d31f42a</commit_link><file_path>engine/src/main/java/io/zeebe/engine/state/processing/DbBlackListState.java</file_path><description>Rename Variable workflowInstanceRelatedIntent : WorkflowInstanceRelatedIntent to processInstanceRelatedIntent : ProcessInstanceRelatedIntent in method private shouldBeBlacklisted(intent Intent) : boolean from class io.zeebe.engine.state.processing.DbBlackListState</description><code_before>@@ -18,8 +18,8 @@
 import io.zeebe.engine.state.mutable.MutableBlackListState;
 import io.zeebe.msgpack.UnpackedObject;
 import io.zeebe.protocol.record.intent.Intent;
-import io.zeebe.protocol.record.intent.WorkflowInstanceRelatedIntent;
-import io.zeebe.protocol.record.value.WorkflowInstanceRelated;
 import java.util.function.Consumer;
 import org.slf4j.Logger;
 
@@ -28,40 +28,40 @@ public final class DbBlackListState implements MutableBlackListState {
   private static final Logger LOG = Loggers.STREAM_PROCESSING;
 
   private static final String BLACKLIST_INSTANCE_MESSAGE =
-      "Blacklist workflow instance {}, due to previous errors.";
 
   private final ColumnFamily&lt;DbLong, DbNil&gt; blackListColumnFamily;
-  private final DbLong workflowInstanceKey;
 
   public DbBlackListState(
       final ZeebeDb&lt;ZbColumnFamilies&gt; zeebeDb, final TransactionContext transactionContext) {
-    workflowInstanceKey = new DbLong();
     blackListColumnFamily =
         zeebeDb.createColumnFamily(
-            ZbColumnFamilies.BLACKLIST, transactionContext, workflowInstanceKey, DbNil.INSTANCE);
   }
 
   private void blacklist(final long key) {
     if (key &gt;= 0) {
-      LOG.warn(BLACKLIST_INSTANCE_MESSAGE, workflowInstanceKey);
 
-      workflowInstanceKey.wrapLong(key);
-      blackListColumnFamily.put(workflowInstanceKey, DbNil.INSTANCE);
     }
   }
 
   private boolean isOnBlacklist(final long key) {
-    workflowInstanceKey.wrapLong(key);
-    return blackListColumnFamily.exists(workflowInstanceKey);
   }
 
   @Override
   public boolean isOnBlacklist(final TypedRecord record) {
     final UnpackedObject value = record.getValue();
-    if (value instanceof WorkflowInstanceRelated) {
-      final long workflowInstanceKey = ((WorkflowInstanceRelated) value).getWorkflowInstanceKey();
-      if (workflowInstanceKey &gt;= 0) {
-        return isOnBlacklist(workflowInstanceKey);
       }
     }
     return false;
@@ -73,22 +73,22 @@ public boolean tryToBlacklist(
     final Intent intent = typedRecord.getIntent();
     if (shouldBeBlacklisted(intent)) {
       final UnpackedObject value = typedRecord.getValue();
-      if (value instanceof WorkflowInstanceRelated) {
-        final long workflowInstanceKey = ((WorkflowInstanceRelated) value).getWorkflowInstanceKey();
-        blacklist(workflowInstanceKey);
-        onBlacklistingInstance.accept(workflowInstanceKey);
       }
     }
     return false;
   }
 
   private boolean shouldBeBlacklisted(final Intent intent) {
 
-    if (intent instanceof WorkflowInstanceRelatedIntent) {
-      final WorkflowInstanceRelatedIntent workflowInstanceRelatedIntent =
-          (WorkflowInstanceRelatedIntent) intent;
 
-      return workflowInstanceRelatedIntent.shouldBlacklistInstanceOnError();
     }
 
     return false;
</code_before><code_after>@@ -18,8 +18,8 @@
 import io.zeebe.engine.state.mutable.MutableBlackListState;
 import io.zeebe.msgpack.UnpackedObject;
 import io.zeebe.protocol.record.intent.Intent;
+import io.zeebe.protocol.record.intent.ProcessInstanceRelatedIntent;
+import io.zeebe.protocol.record.value.ProcessInstanceRelated;
 import java.util.function.Consumer;
 import org.slf4j.Logger;
 
@@ -28,40 +28,40 @@ public final class DbBlackListState implements MutableBlackListState {
   private static final Logger LOG = Loggers.STREAM_PROCESSING;
 
   private static final String BLACKLIST_INSTANCE_MESSAGE =
+      "Blacklist process instance {}, due to previous errors.";
 
   private final ColumnFamily&lt;DbLong, DbNil&gt; blackListColumnFamily;
+  private final DbLong processInstanceKey;
 
   public DbBlackListState(
       final ZeebeDb&lt;ZbColumnFamilies&gt; zeebeDb, final TransactionContext transactionContext) {
+    processInstanceKey = new DbLong();
     blackListColumnFamily =
         zeebeDb.createColumnFamily(
+            ZbColumnFamilies.BLACKLIST, transactionContext, processInstanceKey, DbNil.INSTANCE);
   }
 
   private void blacklist(final long key) {
     if (key &gt;= 0) {
+      LOG.warn(BLACKLIST_INSTANCE_MESSAGE, processInstanceKey);
 
+      processInstanceKey.wrapLong(key);
+      blackListColumnFamily.put(processInstanceKey, DbNil.INSTANCE);
     }
   }
 
   private boolean isOnBlacklist(final long key) {
+    processInstanceKey.wrapLong(key);
+    return blackListColumnFamily.exists(processInstanceKey);
   }
 
   @Override
   public boolean isOnBlacklist(final TypedRecord record) {
     final UnpackedObject value = record.getValue();
+    if (value instanceof ProcessInstanceRelated) {
+      final long processInstanceKey = ((ProcessInstanceRelated) value).getProcessInstanceKey();
+      if (processInstanceKey &gt;= 0) {
+        return isOnBlacklist(processInstanceKey);
       }
     }
     return false;
@@ -73,22 +73,22 @@ public boolean tryToBlacklist(
     final Intent intent = typedRecord.getIntent();
     if (shouldBeBlacklisted(intent)) {
       final UnpackedObject value = typedRecord.getValue();
+      if (value instanceof ProcessInstanceRelated) {
+        final long processInstanceKey = ((ProcessInstanceRelated) value).getProcessInstanceKey();
+        blacklist(processInstanceKey);
+        onBlacklistingInstance.accept(processInstanceKey);
       }
     }
     return false;
   }
 
   private boolean shouldBeBlacklisted(final Intent intent) {
 
+    if (intent instanceof ProcessInstanceRelatedIntent) {
+      final ProcessInstanceRelatedIntent processInstanceRelatedIntent =
+          (ProcessInstanceRelatedIntent) intent;
 
+      return processInstanceRelatedIntent.shouldBlacklistInstanceOnError();
     }
 
     return false;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>462009</refactoring_id><commit_sha>c6c956c188b67342a689ddd0742e7c94eede494a</commit_sha><commit_link>https://github.com/oracle/graal/commit/c6c956c188b67342a689ddd0742e7c94eede494a</commit_link><file_path>truffle/src/com.oracle.truffle.dsl.processor/src/com/oracle/truffle/dsl/processor/OptionProcessor.java</file_path><description>Rename Variable unusedType : DeclaredType to suppressedWarnings : DeclaredType in method private generateOptionDescriptor(info OptionsInfo) : void from class com.oracle.truffle.dsl.processor.OptionProcessor</description><code_before>@@ -303,9 +303,9 @@ private void generateOptionDescriptor(OptionsInfo info) {
 
         CodeTypeElement unit = generateDescriptors(context, element, info);
         DeclaredType overrideType = (DeclaredType) context.getType(Override.class);
-        DeclaredType unusedType = (DeclaredType) context.getType(SuppressWarnings.class);
         unit.accept(new GenerateOverrideVisitor(overrideType), null);
-        unit.accept(new FixWarningsVisitor(context.getEnvironment(), unusedType, overrideType), null);
         try {
             unit.accept(new CodeWriter(context.getEnvironment(), element), null);
         } catch (RuntimeException e) {
</code_before><code_after>@@ -303,9 +303,9 @@ private void generateOptionDescriptor(OptionsInfo info) {
 
         CodeTypeElement unit = generateDescriptors(context, element, info);
         DeclaredType overrideType = (DeclaredType) context.getType(Override.class);
+        DeclaredType suppressedWarnings = (DeclaredType) context.getType(SuppressWarnings.class);
         unit.accept(new GenerateOverrideVisitor(overrideType), null);
+        unit.accept(new FixWarningsVisitor(context.getEnvironment(), suppressedWarnings, overrideType), null);
         try {
             unit.accept(new CodeWriter(context.getEnvironment(), element), null);
         } catch (RuntimeException e) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>382234</refactoring_id><commit_sha>d1a039d36787d1920b631d71e8228fa5c47e5d20</commit_sha><commit_link>https://github.com/apache/ignite/commit/d1a039d36787d1920b631d71e8228fa5c47e5d20</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/util/IgniteUtils.java</file_path><description>Rename Variable finalBatchSize : int to batchSizes : int[] in method public doInParallel(parallelismLvl int, executorSvc ExecutorService, srcDatas Collection&lt;T&gt;, operation IgniteThrowableConsumer&lt;T,R&gt;) : Collection&lt;R&gt; from class org.apache.ignite.internal.util.IgniteUtils</description><code_before>@@ -249,7 +249,6 @@
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
-import java.util.stream.IntStream;
 import java.util.zip.Deflater;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -10783,26 +10782,19 @@ public static &lt;T, R&gt; Collection&lt;R&gt; doInParallel(
     ) throws IgniteCheckedException, IgniteInterruptedCheckedException {
         if(srcDatas.isEmpty())
             return Collections.emptyList();
 
-        int batchSize = srcDatas.size() / parallelismLvl;
 
-        final int finalBatchSize = batchSize == 0 ? srcDatas.size() : batchSize;
 
-        List&lt;List&lt;T&gt;&gt; batches = IntStream.range(0, parallelismLvl)
-            .mapToObj(i -&gt; new ArrayList&lt;T&gt;(finalBatchSize))
-            .collect(Collectors.toList());
-
-        int batchIndex = 0;
-
-        final int maxBatchIndex = batches.size() -1;
 
-        List&lt;T&gt; currentBatch = batches.get(batchIndex);
 
-        for (T src : srcDatas) {
-            currentBatch.add(src);
-
-            if(currentBatch.size() &gt;= batchSize &amp;&amp; batchIndex &lt; maxBatchIndex)
-                currentBatch = batches.get(++batchIndex);
         }
 
         List&lt;Future&lt;Collection&lt;R&gt;&gt;&gt; consumerFutures = batches.stream()
@@ -10860,6 +10852,21 @@ public static &lt;T, R&gt; Collection&lt;R&gt; doInParallel(
         return results;
     }
 
     /**
      * @param fut Future to wait for completion.
      * @throws ExecutionException If the future
</code_before><code_after>@@ -249,7 +249,6 @@
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.zip.Deflater;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -10783,26 +10782,19 @@ public static &lt;T, R&gt; Collection&lt;R&gt; doInParallel(
     ) throws IgniteCheckedException, IgniteInterruptedCheckedException {
         if(srcDatas.isEmpty())
             return Collections.emptyList();
+        int[] batchSizes = calculateOptimalBatchSizes(parallelismLvl, srcDatas.size());
 
+        List&lt;List&lt;T&gt;&gt; batches = new ArrayList&lt;&gt;(batchSizes.length);
 
+        Iterator&lt;T&gt; iterator = srcDatas.iterator();
 
+        for (int batchSize : batchSizes) {
+            List&lt;T&gt; batch = new ArrayList&lt;&gt;(batchSize);
 
+            for (int i = 0; i &lt; batchSize; i++)
+                batch.add(iterator.next());
 
+            batches.add(batch);
         }
 
         List&lt;Future&lt;Collection&lt;R&gt;&gt;&gt; consumerFutures = batches.stream()
@@ -10860,6 +10852,21 @@ public static &lt;T, R&gt; Collection&lt;R&gt; doInParallel(
         return results;
     }
 
+    /**
+     * Split number of tasks into optimized batches.
+     * @param parallelismLvl Level of parallelism.
+     * @param size number of tasks to split.
+     * @return array of batch sizes.
+     */
+    public static int[] calculateOptimalBatchSizes(int parallelismLvl, int size) {
+        int[] batcheSizes = new int[Math.min(parallelismLvl, size)];
+
+        for (int i = 0; i &lt; size; i++)
+            batcheSizes[i % batcheSizes.length]++;
+
+        return batcheSizes;
+    }
+
     /**
      * @param fut Future to wait for completion.
      * @throws ExecutionException If the future
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>400427</refactoring_id><commit_sha>8735d023a1405dd071da921d12c14994b9733597</commit_sha><commit_link>https://github.com/apache/druid/commit/8735d023a1405dd071da921d12c14994b9733597</commit_link><file_path>processing/src/main/java/org/apache/druid/query/aggregation/SerializablePairLongStringColumnSerializer.java</file_path><description>Rename Variable pairLongString : SerializablePairLongString to pairLongObject : T in method public serialize(selector ColumnValueSelector&lt;? extends T&gt;) : void from class org.apache.druid.query.aggregation.AbstractSerializablePairLongObjectColumnSerializer</description><code_before>@@ -20,16 +20,10 @@
 package org.apache.druid.query.aggregation;
 
 import com.google.common.base.Preconditions;
-import org.apache.druid.java.util.common.io.smoosh.FileSmoosher;
-import org.apache.druid.segment.ColumnValueSelector;
-import org.apache.druid.segment.GenericColumnSerializer;
 import org.apache.druid.segment.serde.cell.ByteBufferProvider;
-import org.apache.druid.segment.serde.cell.StagedSerde;
 import org.apache.druid.segment.writeout.SegmentWriteOutMedium;
 
-import javax.annotation.Nullable;
 import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
 
 /**
  * valid call sequence
@@ -39,85 +33,27 @@
  * getSerializedSize() / writeTo() effectively function as a close call, but each may be called multiple times and has
  * no effect on one another.
  */
-@SuppressWarnings("NotNullFieldNotInitialized")
-public class SerializablePairLongStringColumnSerializer implements GenericColumnSerializer&lt;SerializablePairLongString&gt;
 {
-  public static final StagedSerde&lt;SerializablePairLongString&gt; STAGED_SERDE =
-      new SerializablePairLongStringSimpleStagedSerde();
-
-  private final SegmentWriteOutMedium segmentWriteOutMedium;
-  private final ByteBufferProvider byteBufferProvider;
-
-  private State state = State.START;
-  private SerializablePairLongStringBufferStore bufferStore;
-  private SerializablePairLongStringBufferStore.TransferredBuffer transferredBuffer;
 
   public SerializablePairLongStringColumnSerializer(
       SegmentWriteOutMedium segmentWriteOutMedium,
       ByteBufferProvider byteBufferProvider
   )
   {
-    this.segmentWriteOutMedium = segmentWriteOutMedium;
-    this.byteBufferProvider = byteBufferProvider;
   }
 
   @Override
   public void open() throws IOException
   {
-    Preconditions.checkState(state == State.START || state == State.OPEN, "open called in invalid state %s", state);
 
-    if (state == State.START) {
       bufferStore = new SerializablePairLongStringBufferStore(
-          new SerializedStorage&lt;&gt;(segmentWriteOutMedium.makeWriteOutBytes(), STAGED_SERDE)
       );
-      state = State.OPEN;
     }
   }
-
-  @Override
-  public void serialize(ColumnValueSelector&lt;? extends SerializablePairLongString&gt; selector) throws IOException
-  {
-    Preconditions.checkState(state == State.OPEN, "serialize called in invalid state %s", state);
-
-    SerializablePairLongString pairLongString = selector.getObject();
-
-    bufferStore.store(pairLongString);
-  }
-
-  @Override
-  public long getSerializedSize() throws IOException
-  {
-    Preconditions.checkState(
-        state != State.START,
-        "getSerializedSize called in invalid state %s (must have opened at least)",
-        state
-    );
-
-    transferToRowWriterIfNecessary();
-
-    return transferredBuffer.getSerializedSize();
-  }
-
-  @Override
-  public void writeTo(WritableByteChannel channel, @Nullable FileSmoosher smoosher) throws IOException
-  {
-    Preconditions.checkState(state != State.START, "writeTo called in invalid state %s", state);
-    transferToRowWriterIfNecessary();
-    transferredBuffer.writeTo(channel, smoosher);
-  }
-
-  private void transferToRowWriterIfNecessary() throws IOException
-  {
-    if (state == State.OPEN) {
-      transferredBuffer = bufferStore.transferToRowWriter(byteBufferProvider, segmentWriteOutMedium);
-      state = State.CLOSED;
-    }
-  }
-
-  private enum State
-  {
-    START,
-    OPEN,
-    CLOSED,
-  }
 }
</code_before><code_after>@@ -20,16 +20,10 @@
 package org.apache.druid.query.aggregation;
 
 import com.google.common.base.Preconditions;
 import org.apache.druid.segment.serde.cell.ByteBufferProvider;
 import org.apache.druid.segment.writeout.SegmentWriteOutMedium;
 
 import java.io.IOException;
 
 /**
  * valid call sequence
@@ -39,85 +33,27 @@
  * getSerializedSize() / writeTo() effectively function as a close call, but each may be called multiple times and has
  * no effect on one another.
  */
+public class SerializablePairLongStringColumnSerializer extends AbstractSerializablePairLongObjectColumnSerializer&lt;SerializablePairLongString&gt;
 {
 
   public SerializablePairLongStringColumnSerializer(
       SegmentWriteOutMedium segmentWriteOutMedium,
       ByteBufferProvider byteBufferProvider
   )
   {
+    super(new SerializablePairLongStringSimpleStagedSerde(), segmentWriteOutMedium, byteBufferProvider);
   }
 
   @Override
   public void open() throws IOException
   {
+    Preconditions.checkState(state == AbstractSerializablePairLongObjectColumnSerializer.State.START || state == AbstractSerializablePairLongObjectColumnSerializer.State.OPEN, "open called in invalid state %s", state);
 
+    if (state == AbstractSerializablePairLongObjectColumnSerializer.State.START) {
       bufferStore = new SerializablePairLongStringBufferStore(
+          new SerializedStorage&lt;&gt;(segmentWriteOutMedium.makeWriteOutBytes(), stagedSerde)
       );
+      state = AbstractSerializablePairLongObjectColumnSerializer.State.OPEN;
     }
   }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>449680</refactoring_id><commit_sha>2d522cfd804b6b9555aeaea24a89914e910387f6</commit_sha><commit_link>https://github.com/movingblocks/terasology/commit/2d522cfd804b6b9555aeaea24a89914e910387f6</commit_link><file_path>src/main/java/org/terasology/persistence/internal/StorageManagerInternal.java</file_path><description>Rename Variable globalStore : GlobalStoreSaver to store : GlobalStore in method private flushGlobalStore() : void from class org.terasology.persistence.internal.StorageManagerInternal</description><code_before>@@ -30,6 +30,7 @@
 import org.terasology.entitySystem.EntityRef;
 import org.terasology.math.Vector3i;
 import org.terasology.persistence.ChunkStore;
 import org.terasology.persistence.PlayerStore;
 import org.terasology.persistence.StorageManager;
 import org.terasology.protobuf.EntityData;
@@ -77,6 +78,8 @@ public final class StorageManagerInternal implements StorageManager, EntityDestr
     private Map&lt;Vector3i, ChunkStoreInternal&gt; pendingProcessingChunkStore = Maps.newConcurrentMap();
     private Map&lt;Vector3i, byte[]&gt; compressedChunkStore = Maps.newConcurrentMap();
 
     public StorageManagerInternal(EngineEntityManager entityManager) {
         this.entityManager = entityManager;
         entityManager.subscribe(this);
@@ -85,7 +88,28 @@ public StorageManagerInternal(EngineEntityManager entityManager) {
     }
 
     @Override
-    public void loadGlobalEntities() throws IOException {
         Path globalDataFile = PathManager.getInstance().getCurrentSavePath().resolve(GLOBAL_ENTITY_STORE);
         if (Files.isRegularFile(globalDataFile)) {
             try (InputStream in = new BufferedInputStream(Files.newInputStream(globalDataFile))) {
@@ -100,32 +124,25 @@ public void loadGlobalEntities() throws IOException {
         }
     }
 
-    @Override
-    public void shutdown() {
-        storageTaskMaster.shutdown(new ShutdownTask(), true);
-    }
-
-    @Override
-    public void flush() throws IOException {
-        flushPlayerStores();
-        flushChunkStores();
-        flushGlobalStore();
     }
 
     private void flushGlobalStore() throws IOException {
-        GlobalStoreSaver globalStore = new GlobalStoreSaver(entityManager);
-        for (EntityRef entity : entityManager.getAllEntities()) {
-            globalStore.store(entity);
-        }
-        for (StoreMetadata table : storeMetadata.values()) {
-            globalStore.addStoreMetadata(table);
         }
-        EntityData.GlobalStore globalStoreData = globalStore.save();
         try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(PathManager.getInstance().getCurrentSavePath().resolve(GLOBAL_ENTITY_STORE)))) {
-            globalStoreData.writeTo(out);
         }
     }
 
     @Override
     public PlayerStore createPlayerStoreForSave(String playerId) {
         return new PlayerStoreInternal(playerId, this, entityManager);
@@ -135,7 +152,7 @@ private void flushPlayerStores() throws IOException {
         Files.createDirectories(playersPath);
         for (Map.Entry&lt;String, EntityData.PlayerStore&gt; playerStoreEntry : playerStores.entrySet()) {
             Path playerFile = playersPath.resolve(playerStoreEntry.getKey() + PLAYER_STORE_EXTENSION);
-            try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(playerFile));) {
                 playerStoreEntry.getValue().writeTo(out);
             }
         }
@@ -226,6 +243,7 @@ private void flushChunkStores() throws IOException {
         } finally {
             storageTaskMaster.restart();
         }
     }
 
     private String getChunkFilename(Vector3i pos) {
@@ -283,4 +301,5 @@ public void onEntityDestroyed(int entityId) {
             }
         }
     }
 }
</code_before><code_after>@@ -30,6 +30,7 @@
 import org.terasology.entitySystem.EntityRef;
 import org.terasology.math.Vector3i;
 import org.terasology.persistence.ChunkStore;
+import org.terasology.persistence.GlobalStore;
 import org.terasology.persistence.PlayerStore;
 import org.terasology.persistence.StorageManager;
 import org.terasology.protobuf.EntityData;
@@ -77,6 +78,8 @@ public final class StorageManagerInternal implements StorageManager, EntityDestr
     private Map&lt;Vector3i, ChunkStoreInternal&gt; pendingProcessingChunkStore = Maps.newConcurrentMap();
     private Map&lt;Vector3i, byte[]&gt; compressedChunkStore = Maps.newConcurrentMap();
 
+    private EntityData.GlobalStore globalStore;
+
     public StorageManagerInternal(EngineEntityManager entityManager) {
         this.entityManager = entityManager;
         entityManager.subscribe(this);
@@ -85,7 +88,28 @@ public StorageManagerInternal(EngineEntityManager entityManager) {
     }
 
     @Override
+    public void shutdown() {
+        storageTaskMaster.shutdown(new ShutdownTask(), true);
+    }
+
+    @Override
+    public void flush() throws IOException {
+        flushPlayerStores();
+        flushChunkStores();
+        flushGlobalStore();
+    }
+
+    @Override
+    public GlobalStore createGlobalStoreForSave() {
+        GlobalStoreSaver globalStore = new GlobalStoreSaver(entityManager);
+        for (StoreMetadata table : storeMetadata.values()) {
+            globalStore.addStoreMetadata(table);
+        }
+        return new GlobalStoreInternal(globalStore, this);
+    }
+
+    @Override
+    public void loadGlobalStore() throws IOException {
         Path globalDataFile = PathManager.getInstance().getCurrentSavePath().resolve(GLOBAL_ENTITY_STORE);
         if (Files.isRegularFile(globalDataFile)) {
             try (InputStream in = new BufferedInputStream(Files.newInputStream(globalDataFile))) {
@@ -100,32 +124,25 @@ public void loadGlobalEntities() throws IOException {
         }
     }
 
+    public void store(EntityData.GlobalStore globalStoreData) {
+        this.globalStore = globalStoreData;
     }
 
     private void flushGlobalStore() throws IOException {
+        if (globalStore == null) {
+            GlobalStore store = createGlobalStoreForSave();
+            for (EntityRef entity : entityManager.getAllEntities()) {
+                store.store(entity);
+            }
+            store.save();
         }
         try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(PathManager.getInstance().getCurrentSavePath().resolve(GLOBAL_ENTITY_STORE)))) {
+            globalStore.writeTo(out);
         }
+        globalStore = null;
     }
 
+
     @Override
     public PlayerStore createPlayerStoreForSave(String playerId) {
         return new PlayerStoreInternal(playerId, this, entityManager);
@@ -135,7 +152,7 @@ private void flushPlayerStores() throws IOException {
         Files.createDirectories(playersPath);
         for (Map.Entry&lt;String, EntityData.PlayerStore&gt; playerStoreEntry : playerStores.entrySet()) {
             Path playerFile = playersPath.resolve(playerStoreEntry.getKey() + PLAYER_STORE_EXTENSION);
+            try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(playerFile))) {
                 playerStoreEntry.getValue().writeTo(out);
             }
         }
@@ -226,6 +243,7 @@ private void flushChunkStores() throws IOException {
         } finally {
             storageTaskMaster.restart();
         }
+        compressedChunkStore.clear();
     }
 
     private String getChunkFilename(Vector3i pos) {
@@ -283,4 +301,5 @@ public void onEntityDestroyed(int entityId) {
             }
         }
     }
+
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>422579</refactoring_id><commit_sha>e104a69f34f446b0916708d7ac6da2d0ffa069b6</commit_sha><commit_link>https://github.com/opentripplanner/opentripplanner/commit/e104a69f34f446b0916708d7ac6da2d0ffa069b6</commit_link><file_path>src/main/java/org/opentripplanner/graph_builder/module/osm/OpenStreetMapModule.java</file_path><description>Rename Variable wheelchairAccessibleCapacity : OptionalInt to wheelchairAccessibleCarCapacity : OptionalInt in method private createVehicleParkingObjectFromOsmEntity(isCarParkAndRide boolean, lon double, lat double, entity OSMWithTags, creativeName I18NString, entrances List&lt;VehicleParking.VehicleParkingEntranceCreator&gt;) : VehicleParking from class org.opentripplanner.graph_builder.module.osm.OpenStreetMapModule.Handler</description><code_before>@@ -62,6 +62,7 @@
 import org.opentripplanner.routing.util.ElevationUtils;
 import org.opentripplanner.routing.vehicle_parking.VehicleParking;
 import org.opentripplanner.routing.vehicle_parking.VehicleParking.VehicleParkingEntranceCreator;
 import org.opentripplanner.routing.vehicle_parking.VehicleParkingHelper;
 import org.opentripplanner.routing.vehicle_parking.VehicleParkingService;
 import org.opentripplanner.routing.vertextype.BarrierVertex;
@@ -529,32 +530,32 @@ private VehicleParking createVehicleParkingObjectFromOsmEntity(
                 I18NString creativeName,
                 List&lt;VehicleParking.VehicleParkingEntranceCreator&gt; entrances
         ) {
-            OptionalInt bicycleCapacity, carCapacity, wheelchairAccessibleCapacity;
             if (isCarParkAndRide) {
                 carCapacity = parseCapacity(entity);
                 bicycleCapacity = parseCapacity(entity, "capacity:bike");
-                wheelchairAccessibleCapacity = parseCapacity(entity, "capacity:disabled");
             } else {
                 bicycleCapacity = parseCapacity(entity);
                 carCapacity = OptionalInt.empty();
-                wheelchairAccessibleCapacity = OptionalInt.empty();
             }
 
-            VehicleParking.VehiclePlaces vehiclePlaces = null;
-            if (bicycleCapacity.isPresent() || carCapacity.isPresent() || wheelchairAccessibleCapacity.isPresent()) {
-                vehiclePlaces = VehicleParking.VehiclePlaces.builder()
                     .bicycleSpaces(bicycleCapacity.isPresent() ? bicycleCapacity.getAsInt() : null)
                     .carSpaces(carCapacity.isPresent() ? carCapacity.getAsInt() : null)
-                    .wheelchairAccessibleCarSpaces(wheelchairAccessibleCapacity.isPresent() ? wheelchairAccessibleCapacity.getAsInt() : null)
                     .build();
             }
 
             var bicyclePlaces = !isCarParkAndRide || bicycleCapacity.orElse(0) &gt; 0;
             var carPlaces = (
                     isCarParkAndRide &amp;&amp;
-                            wheelchairAccessibleCapacity.isEmpty() &amp;&amp; carCapacity.isEmpty()
             ) || carCapacity.orElse(0) &gt; 0;
-            var wheelchairAccessibleCarPlaces = wheelchairAccessibleCapacity.orElse(0) &gt; 0;
 
             var id = new FeedScopedId(
                     VEHICLE_PARKING_OSM_FEED_ID,
@@ -569,7 +570,7 @@ private VehicleParking createVehicleParkingObjectFromOsmEntity(
                     .bicyclePlaces(bicyclePlaces)
                     .carPlaces(carPlaces)
                     .wheelchairAccessibleCarPlaces(wheelchairAccessibleCarPlaces)
-                    .capacity(vehiclePlaces)
                     .entrances(entrances)
                     .build();
         }
</code_before><code_after>@@ -62,6 +62,7 @@
 import org.opentripplanner.routing.util.ElevationUtils;
 import org.opentripplanner.routing.vehicle_parking.VehicleParking;
 import org.opentripplanner.routing.vehicle_parking.VehicleParking.VehicleParkingEntranceCreator;
+import org.opentripplanner.routing.vehicle_parking.VehicleParkingSpaces;
 import org.opentripplanner.routing.vehicle_parking.VehicleParkingHelper;
 import org.opentripplanner.routing.vehicle_parking.VehicleParkingService;
 import org.opentripplanner.routing.vertextype.BarrierVertex;
@@ -529,32 +530,32 @@ private VehicleParking createVehicleParkingObjectFromOsmEntity(
                 I18NString creativeName,
                 List&lt;VehicleParking.VehicleParkingEntranceCreator&gt; entrances
         ) {
+            OptionalInt bicycleCapacity, carCapacity, wheelchairAccessibleCarCapacity;
             if (isCarParkAndRide) {
                 carCapacity = parseCapacity(entity);
                 bicycleCapacity = parseCapacity(entity, "capacity:bike");
+                wheelchairAccessibleCarCapacity = parseCapacity(entity, "capacity:disabled");
             } else {
                 bicycleCapacity = parseCapacity(entity);
                 carCapacity = OptionalInt.empty();
+                wheelchairAccessibleCarCapacity = OptionalInt.empty();
             }
 
+            VehicleParkingSpaces vehicleParkingSpaces = null;
+            if (bicycleCapacity.isPresent() || carCapacity.isPresent() || wheelchairAccessibleCarCapacity.isPresent()) {
+                vehicleParkingSpaces = VehicleParkingSpaces.builder()
                     .bicycleSpaces(bicycleCapacity.isPresent() ? bicycleCapacity.getAsInt() : null)
                     .carSpaces(carCapacity.isPresent() ? carCapacity.getAsInt() : null)
+                    .wheelchairAccessibleCarSpaces(wheelchairAccessibleCarCapacity.isPresent() ? wheelchairAccessibleCarCapacity.getAsInt() : null)
                     .build();
             }
 
             var bicyclePlaces = !isCarParkAndRide || bicycleCapacity.orElse(0) &gt; 0;
             var carPlaces = (
                     isCarParkAndRide &amp;&amp;
+                            wheelchairAccessibleCarCapacity.isEmpty() &amp;&amp; carCapacity.isEmpty()
             ) || carCapacity.orElse(0) &gt; 0;
+            var wheelchairAccessibleCarPlaces = wheelchairAccessibleCarCapacity.orElse(0) &gt; 0;
 
             var id = new FeedScopedId(
                     VEHICLE_PARKING_OSM_FEED_ID,
@@ -569,7 +570,7 @@ private VehicleParking createVehicleParkingObjectFromOsmEntity(
                     .bicyclePlaces(bicyclePlaces)
                     .carPlaces(carPlaces)
                     .wheelchairAccessibleCarPlaces(wheelchairAccessibleCarPlaces)
+                    .capacity(vehicleParkingSpaces)
                     .entrances(entrances)
                     .build();
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>433838</refactoring_id><commit_sha>9af501eb3cc4577296cd43112d638e1e0a6285a0</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/9af501eb3cc4577296cd43112d638e1e0a6285a0</commit_link><file_path>source/ch/cyberduck/core/transfer/move/MoveTransferFilter.java</file_path><description>Rename Variable dest : Path to destination : Path in method public prepare(source Path) : void from class ch.cyberduck.core.transfer.move.MoveTransferFilter</description><code_before>@@ -7,7 +7,7 @@
 import java.util.Map;
 
 /**
- * @version $Id:$
  */
 public class MoveTransferFilter extends TransferPathFilter {
 
@@ -31,18 +31,15 @@ public boolean accept(final Path source) {
 
     @Override
     public void prepare(final Path source) {
-        if(source.attributes().isFile()) {
-            source.status().setResume(false);
-        }
         if(source.attributes().isFile()) {
             final long length = source.attributes().getSize();
             // Download
             source.status().setLength(length);
         }
-        final Path dest = files.get(source);
-        if(dest.attributes().isDirectory()) {
-            if(!dest.exists()) {
-                source.getSession().cache().put(dest.getReference(), AttributedList.&lt;Path&gt;emptyList());
             }
         }
     }
</code_before><code_after>@@ -7,7 +7,7 @@
 import java.util.Map;
 
 /**
+ * @version $Id$
  */
 public class MoveTransferFilter extends TransferPathFilter {
 
@@ -31,18 +31,15 @@ public boolean accept(final Path source) {
 
     @Override
     public void prepare(final Path source) {
         if(source.attributes().isFile()) {
             final long length = source.attributes().getSize();
             // Download
             source.status().setLength(length);
         }
+        final Path destination = files.get(source);
+        if(destination.attributes().isDirectory()) {
+            if(!destination.exists()) {
+                source.getSession().cache().put(destination.getReference(), AttributedList.&lt;Path&gt;emptyList());
             }
         }
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring></Rename_Variable><Remove_Parameter><refactoring><refactoring_id>590881</refactoring_id><commit_sha>7f9865b2a968cd0be6f231b9c17b8f7800c99ba7</commit_sha><commit_link>https://github.com/oracle/graal/commit/7f9865b2a968cd0be6f231b9c17b8f7800c99ba7</commit_link><file_path>substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/OldGeneration.java</file_path><description>Remove Parameter traceHeapChunks : boolean in method public report(log Log, traceHeapChunks boolean) : Log from class com.oracle.svm.core.genscavenge.OldGeneration</description><code_before>@@ -56,8 +56,8 @@ public final class OldGeneration extends Generation {
     OldGeneration(String name) {
         super(name);
         int age = HeapParameters.getMaxSurvivorSpaces() + 1;
-        this.fromSpace = new Space("oldFromSpace", true, age);
-        this.toSpace = new Space("oldToSpace", false, age);
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
@@ -120,12 +120,15 @@ boolean scanGreyObjects() {
     }
 
     @Override
-    public Log report(Log log, boolean traceHeapChunks) {
-        log.string("Old generation: ").indent(true);
-        getFromSpace().report(log, traceHeapChunks).newline();
-        getToSpace().report(log, traceHeapChunks).newline();
-        log.redent(false);
-        return log;
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
</code_before><code_after>@@ -56,8 +56,8 @@ public final class OldGeneration extends Generation {
     OldGeneration(String name) {
         super(name);
         int age = HeapParameters.getMaxSurvivorSpaces() + 1;
+        this.fromSpace = new Space("Old", "O", true, age);
+        this.toSpace = new Space("Old To", "O", false, age);
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
@@ -120,12 +120,15 @@ boolean scanGreyObjects() {
     }
 
     @Override
+    public void logUsage(Log log) {
+        getFromSpace().logUsage(log, true);
+        getToSpace().logUsage(log, false);
+    }
+
+    @Override
+    public void logChunks(Log log) {
+        getFromSpace().logChunks(log);
+        getToSpace().logChunks(log);
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>480653</refactoring_id><commit_sha>45108810dfddaf74c1a759a54b63a74e7bcb509a</commit_sha><commit_link>https://github.com/batfish/batfish/commit/45108810dfddaf74c1a759a54b63a74e7bcb509a</commit_link><file_path>projects/batfish/src/main/java/org/batfish/representation/aws/NetworkAcl.java</file_path><description>Remove Parameter logger : BatfishLogger in method public NetworkAcl(jObj JSONObject, logger BatfishLogger) from class org.batfish.representation.aws.NetworkAcl</description><code_before>@@ -7,7 +7,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
-import org.batfish.common.BatfishLogger;
 import org.batfish.datamodel.HeaderSpace;
 import org.batfish.datamodel.IpAccessList;
 import org.batfish.datamodel.IpAccessListLine;
@@ -35,15 +34,15 @@ public class NetworkAcl implements AwsVpcEntity, Serializable {
 
   private String _vpcId;
 
-  public NetworkAcl(JSONObject jObj, BatfishLogger logger) throws JSONException {
     _networkAclId = jObj.getString(JSON_KEY_NETWORK_ACL_ID);
     _vpcId = jObj.getString(JSON_KEY_VPC_ID);
 
     JSONArray associations = jObj.getJSONArray(JSON_KEY_ASSOCIATIONS);
-    initAssociations(associations, logger);
 
     JSONArray entries = jObj.getJSONArray(JSON_KEY_ENTRIES);
-    initEntries(entries, logger);
   }
 
   private IpAccessList getAcl(boolean isEgress) {
@@ -133,17 +132,17 @@ public String getVpcId() {
     return _vpcId;
   }
 
-  private void initAssociations(JSONArray associations, BatfishLogger logger) throws JSONException {
     for (int index = 0; index &lt; associations.length(); index++) {
       JSONObject childObject = associations.getJSONObject(index);
-      _networkAclAssociations.add(new NetworkAclAssociation(childObject, logger));
     }
   }
 
-  private void initEntries(JSONArray entries, BatfishLogger logger) throws JSONException {
     for (int index = 0; index &lt; entries.length(); index++) {
       JSONObject childObject = entries.getJSONObject(index);
-      _entries.add(new NetworkAclEntry(childObject, logger));
     }
   }
 }
</code_before><code_after>@@ -7,7 +7,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
 import org.batfish.datamodel.HeaderSpace;
 import org.batfish.datamodel.IpAccessList;
 import org.batfish.datamodel.IpAccessListLine;
@@ -35,15 +34,15 @@ public class NetworkAcl implements AwsVpcEntity, Serializable {
 
   private String _vpcId;
 
+  public NetworkAcl(JSONObject jObj) throws JSONException {
     _networkAclId = jObj.getString(JSON_KEY_NETWORK_ACL_ID);
     _vpcId = jObj.getString(JSON_KEY_VPC_ID);
 
     JSONArray associations = jObj.getJSONArray(JSON_KEY_ASSOCIATIONS);
+    initAssociations(associations);
 
     JSONArray entries = jObj.getJSONArray(JSON_KEY_ENTRIES);
+    initEntries(entries);
   }
 
   private IpAccessList getAcl(boolean isEgress) {
@@ -133,17 +132,17 @@ public String getVpcId() {
     return _vpcId;
   }
 
+  private void initAssociations(JSONArray associations) throws JSONException {
     for (int index = 0; index &lt; associations.length(); index++) {
       JSONObject childObject = associations.getJSONObject(index);
+      _networkAclAssociations.add(new NetworkAclAssociation(childObject));
     }
   }
 
+  private void initEntries(JSONArray entries) throws JSONException {
     for (int index = 0; index &lt; entries.length(); index++) {
       JSONObject childObject = entries.getJSONObject(index);
+      _entries.add(new NetworkAclEntry(childObject));
     }
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>465103</refactoring_id><commit_sha>8bf3ff4ea2dace707af3c1f64e42f7df089630c0</commit_sha><commit_link>https://github.com/apache/doris/commit/8bf3ff4ea2dace707af3c1f64e42f7df089630c0</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/load/GroupCommitManager.java</file_path><description>Remove Parameter isCloud : boolean in method public selectBackendForGroupCommit(tableId long, context ConnectContext, isCloud boolean) : Backend from class org.apache.doris.load.GroupCommitManager</description><code_before>@@ -186,26 +186,26 @@ private long getWalQueueSize(Backend backend, PGetWalQueueSizeRequest request) {
         return size;
     }
 
-    public Backend selectBackendForGroupCommit(long tableId, ConnectContext context, boolean isCloud)
             throws LoadException, DdlException {
         // If a group commit request is sent to the follower FE, we will send this request to the master FE. master FE
         // can select a BE and return this BE id to follower FE.
         if (!Env.getCurrentEnv().isMaster()) {
             try {
                 long backendId = new MasterOpExecutor(context)
-                        .getGroupCommitLoadBeId(tableId, context.getCloudCluster(), isCloud);
                 return Env.getCurrentSystemInfo().getBackend(backendId);
             } catch (Exception e) {
                 throw new LoadException(e.getMessage());
             }
         } else {
             // Master FE will select BE by itself.
             return Env.getCurrentSystemInfo()
-                    .getBackend(selectBackendForGroupCommitInternal(tableId, context.getCloudCluster(), isCloud));
         }
     }
 
-    public long selectBackendForGroupCommitInternal(long tableId, String cluster, boolean isCloud)
             throws LoadException, DdlException {
         // Understanding Group Commit and Backend Selection Logic
         //
@@ -237,7 +237,7 @@ public long selectBackendForGroupCommitInternal(long tableId, String cluster, bo
         // a BE is chosen at random. This BE is then recorded along with the mapping of table A and its load level.
         // This approach ensures that group commits can effectively batch data together
         // while managing the load on each BE efficiently.
-        return isCloud ? selectBackendForCloudGroupCommitInternal(tableId, cluster)
                 : selectBackendForLocalGroupCommitInternal(tableId);
     }
 
</code_before><code_after>@@ -186,26 +186,26 @@ private long getWalQueueSize(Backend backend, PGetWalQueueSizeRequest request) {
         return size;
     }
 
+    public Backend selectBackendForGroupCommit(long tableId, ConnectContext context)
             throws LoadException, DdlException {
         // If a group commit request is sent to the follower FE, we will send this request to the master FE. master FE
         // can select a BE and return this BE id to follower FE.
         if (!Env.getCurrentEnv().isMaster()) {
             try {
                 long backendId = new MasterOpExecutor(context)
+                        .getGroupCommitLoadBeId(tableId, context.getCloudCluster());
                 return Env.getCurrentSystemInfo().getBackend(backendId);
             } catch (Exception e) {
                 throw new LoadException(e.getMessage());
             }
         } else {
             // Master FE will select BE by itself.
             return Env.getCurrentSystemInfo()
+                    .getBackend(selectBackendForGroupCommitInternal(tableId, context.getCloudCluster()));
         }
     }
 
+    public long selectBackendForGroupCommitInternal(long tableId, String cluster)
             throws LoadException, DdlException {
         // Understanding Group Commit and Backend Selection Logic
         //
@@ -237,7 +237,7 @@ public long selectBackendForGroupCommitInternal(long tableId, String cluster, bo
         // a BE is chosen at random. This BE is then recorded along with the mapping of table A and its load level.
         // This approach ensures that group commits can effectively batch data together
         // while managing the load on each BE efficiently.
+        return Config.isCloudMode() ? selectBackendForCloudGroupCommitInternal(tableId, cluster)
                 : selectBackendForLocalGroupCommitInternal(tableId);
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>584861</refactoring_id><commit_sha>41e1701bf07736a01f1f55004573211447e94a82</commit_sha><commit_link>https://github.com/oracle/graal/commit/41e1701bf07736a01f1f55004573211447e94a82</commit_link><file_path>truffle/com.oracle.truffle.api.vm/src/com/oracle/truffle/api/vm/PolyglotEngine.java</file_path><description>Remove Parameter chain : InvocationHandler in method package invokeProxy(chain InvocationHandler, wrapper Object, method Method, args Object[]) : Value from class com.oracle.truffle.api.vm.PolyglotEngine.Value</description><code_before>@@ -32,8 +32,6 @@
 import java.io.OutputStream;
 import java.io.Reader;
 import java.io.Writer;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
@@ -60,11 +58,14 @@
 import com.oracle.truffle.api.debug.Debugger;
 import com.oracle.truffle.api.debug.ExecutionEvent;
 import com.oracle.truffle.api.debug.SuspendedEvent;
 import com.oracle.truffle.api.impl.Accessor;
 import com.oracle.truffle.api.instrument.Probe;
 import com.oracle.truffle.api.instrument.ToolSupportProvider;
 import com.oracle.truffle.api.interop.TruffleObject;
 import com.oracle.truffle.api.interop.java.JavaInterop;
 import com.oracle.truffle.api.source.Source;
 
 /**
@@ -530,6 +531,33 @@ private void evalImpl(Debugger[] fillIn, TruffleLanguage&lt;?&gt;[] fillLang, Source s
         }
     }
 
     /**
      * Looks global symbol provided by one of initialized languages up. First of all execute your
      * program via one of your {@link #eval(java.lang.String, java.lang.String)} and then look
@@ -682,7 +710,11 @@ public class Value {
         public Object get() throws IOException {
             waitForSymbol();
             exceptionCheck(result);
-            return result[0];
         }
 
         /**
@@ -702,8 +734,7 @@ public &lt;T&gt; T as(Class&lt;T&gt; representation) throws IOException {
             if (representation.isInstance(obj)) {
                 return representation.cast(obj);
             }
-            T wrapper = JavaInterop.asJavaObject(representation, (TruffleObject) obj);
-            return JavaWrapper.create(representation, wrapper, this);
         }
 
         /**
@@ -734,32 +765,6 @@ public void run() {
             return createValue(language, res, done);
         }
 
-        @SuppressWarnings("try")
-        final Value invokeProxy(final InvocationHandler chain, final Object wrapper, final Method method, final Object[] args) throws IOException {
-            final Debugger[] fillIn = {debugger};
-            final CountDownLatch done = new CountDownLatch(1);
-            final Object[] res = {null, null};
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    try (final Closeable c = SPI.executionStart(PolyglotEngine.this, fillIn, null)) {
-                        if (debugger == null) {
-                            debugger = fillIn[0];
-                        }
-                        res[0] = chain.invoke(wrapper, method, args);
-                    } catch (IOException ex) {
-                        res[1] = ex;
-                    } catch (Throwable ex) {
-                        res[1] = ex;
-                    } finally {
-                        done.countDown();
-                    }
-                }
-            });
-            exceptionCheck(res);
-            return new Value(language, res, done);
-        }
-
         @SuppressWarnings("try")
         private void invokeImpl(Debugger[] fillIn, Object thiz, Object[] args, Object[] res, CountDownLatch done) {
             try (final Closeable c = SPI.executionStart(PolyglotEngine.this, fillIn, null)) {
</code_before><code_after>@@ -32,8 +32,6 @@
 import java.io.OutputStream;
 import java.io.Reader;
 import java.io.Writer;
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
@@ -60,11 +58,14 @@
 import com.oracle.truffle.api.debug.Debugger;
 import com.oracle.truffle.api.debug.ExecutionEvent;
 import com.oracle.truffle.api.debug.SuspendedEvent;
+import com.oracle.truffle.api.frame.VirtualFrame;
 import com.oracle.truffle.api.impl.Accessor;
 import com.oracle.truffle.api.instrument.Probe;
 import com.oracle.truffle.api.instrument.ToolSupportProvider;
+import com.oracle.truffle.api.interop.ForeignAccess;
 import com.oracle.truffle.api.interop.TruffleObject;
 import com.oracle.truffle.api.interop.java.JavaInterop;
+import com.oracle.truffle.api.nodes.Node;
 import com.oracle.truffle.api.source.Source;
 
 /**
@@ -530,6 +531,33 @@ private void evalImpl(Debugger[] fillIn, TruffleLanguage&lt;?&gt;[] fillLang, Source s
         }
     }
 
+    @SuppressWarnings("try")
+    final Object invokeForeign(final Node foreignNode, final VirtualFrame frame, final TruffleObject receiver) throws IOException {
+        final Debugger[] fillIn = {debugger};
+        final Object[] res = {null, null};
+        executor.execute(new Runnable() {
+            @Override
+            public void run() {
+                try (final Closeable c = SPI.executionStart(PolyglotEngine.this, fillIn, null)) {
+                    if (debugger == null) {
+                        debugger = fillIn[0];
+                    }
+                    res[0] = ForeignAccess.execute(foreignNode, frame, receiver, ForeignAccess.getArguments(frame).toArray());
+                } catch (IOException ex) {
+                    res[1] = ex;
+                } catch (Throwable ex) {
+                    res[1] = ex;
+                }
+            }
+        });
+        exceptionCheck(res);
+        if (res[0] instanceof TruffleObject) {
+            return new EngineTruffleObject(this, (TruffleObject) res[0]);
+        } else {
+            return res[0];
+        }
+    }
+
     /**
      * Looks global symbol provided by one of initialized languages up. First of all execute your
      * program via one of your {@link #eval(java.lang.String, java.lang.String)} and then look
@@ -682,7 +710,11 @@ public class Value {
         public Object get() throws IOException {
             waitForSymbol();
             exceptionCheck(result);
+            if (result[0] instanceof TruffleObject) {
+                return new EngineTruffleObject(PolyglotEngine.this, (TruffleObject) result[0]);
+            } else {
+                return result[0];
+            }
         }
 
         /**
@@ -702,8 +734,7 @@ public &lt;T&gt; T as(Class&lt;T&gt; representation) throws IOException {
             if (representation.isInstance(obj)) {
                 return representation.cast(obj);
             }
+            return JavaInterop.asJavaObject(representation, (TruffleObject) obj);
         }
 
         /**
@@ -734,32 +765,6 @@ public void run() {
             return createValue(language, res, done);
         }
 
         @SuppressWarnings("try")
         private void invokeImpl(Debugger[] fillIn, Object thiz, Object[] args, Object[] res, CountDownLatch done) {
             try (final Closeable c = SPI.executionStart(PolyglotEngine.this, fillIn, null)) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>499006</refactoring_id><commit_sha>ee6732955db6f2d31733146b32e0adae559f894b</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/ee6732955db6f2d31733146b32e0adae559f894b</commit_link><file_path>src/main/java/mekanism/common/block/machine/BlockResistiveHeater.java</file_path><description>Remove Parameter hitX : float in method public onBlockActivated(world World, pos BlockPos, state BlockState, player PlayerEntity, hand Hand, side Direction, hitX float, hitY float, hitZ float) : boolean from class mekanism.common.block.machine.BlockResistiveHeater</description><code_before>@@ -38,10 +38,9 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.SoundEvent;
 import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.Explosion;
-import net.minecraft.world.IWorldReader;
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
@@ -73,7 +72,7 @@ public int getMetaFromState(BlockState state) {
     @Nonnull
     @Override
     @Deprecated
-    public BlockState getActualState(@Nonnull BlockState state, IWorldReader world, BlockPos pos) {
         return BlockStateHelper.getActualState(this, state, MekanismUtils.getTileEntitySafe(world, pos));
     }
 
@@ -113,7 +112,7 @@ public void randomDisplayTick(BlockState state, World world, BlockPos pos, Rando
     }
 
     @Override
-    public int getLightValue(BlockState state, IWorldReader world, BlockPos pos) {
         if (MekanismConfig.current().client.enableAmbientLighting.val()) {
             TileEntity tileEntity = MekanismUtils.getTileEntitySafe(world, pos);
             if (tileEntity instanceof IActiveState &amp;&amp; ((IActiveState) tileEntity).lightUpdate() &amp;&amp; ((IActiveState) tileEntity).wasActiveRecently()) {
@@ -124,12 +123,12 @@ public int getLightValue(BlockState state, IWorldReader world, BlockPos pos) {
     }
 
     @Override
-    public boolean onBlockActivated(World world, BlockPos pos, BlockState state, PlayerEntity player, Hand hand, Direction side, float hitX, float hitY, float hitZ) {
         if (world.isRemote) {
             return true;
         }
         TileEntityMekanism tileEntity = (TileEntityMekanism) world.getTileEntity(pos);
-        if (tileEntity.tryWrench(state, player, hand, () -&gt; new RayTraceResult(new Vec3d(hitX, hitY, hitZ), side, pos)) != WrenchResult.PASS) {
             return true;
         }
         if (tileEntity.openGui(player)) {
</code_before><code_after>@@ -38,10 +38,9 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.SoundEvent;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.BlockRayTraceResult;
 import net.minecraft.world.Explosion;
+import net.minecraft.world.IBlockReader;
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
@@ -73,7 +72,7 @@ public int getMetaFromState(BlockState state) {
     @Nonnull
     @Override
     @Deprecated
+    public BlockState getActualState(@Nonnull BlockState state, IBlockReader world, BlockPos pos) {
         return BlockStateHelper.getActualState(this, state, MekanismUtils.getTileEntitySafe(world, pos));
     }
 
@@ -113,7 +112,7 @@ public void randomDisplayTick(BlockState state, World world, BlockPos pos, Rando
     }
 
     @Override
+    public int getLightValue(BlockState state, IBlockReader world, BlockPos pos) {
         if (MekanismConfig.current().client.enableAmbientLighting.val()) {
             TileEntity tileEntity = MekanismUtils.getTileEntitySafe(world, pos);
             if (tileEntity instanceof IActiveState &amp;&amp; ((IActiveState) tileEntity).lightUpdate() &amp;&amp; ((IActiveState) tileEntity).wasActiveRecently()) {
@@ -124,12 +123,12 @@ public int getLightValue(BlockState state, IWorldReader world, BlockPos pos) {
     }
 
     @Override
+    public boolean onBlockActivated(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockRayTraceResult hit) {
         if (world.isRemote) {
             return true;
         }
         TileEntityMekanism tileEntity = (TileEntityMekanism) world.getTileEntity(pos);
+        if (tileEntity.tryWrench(state, player, hand, hit) != WrenchResult.PASS) {
             return true;
         }
         if (tileEntity.openGui(player)) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>491656</refactoring_id><commit_sha>ca0054052dee38c5c79ab853977803ec975cedb3</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/ca0054052dee38c5c79ab853977803ec975cedb3</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/api/txstate/TransactionCountingStateVisitor.java</file_path><description>Remove Parameter statement : StorageStatement in method public TransactionCountingStateVisitor(next TxStateVisitor, storeLayer StoreReadLayer, statement StorageStatement, txState ReadableTransactionState, counts CountsRecordState) from class org.neo4j.kernel.api.txstate.TransactionCountingStateVisitor</description><code_before>@@ -29,7 +29,6 @@
 import org.neo4j.kernel.impl.api.CountsRecordState;
 import org.neo4j.kernel.impl.api.RelationshipDataExtractor;
 import org.neo4j.storageengine.api.NodeItem;
-import org.neo4j.storageengine.api.StorageStatement;
 import org.neo4j.storageengine.api.StoreReadLayer;
 import org.neo4j.storageengine.api.txstate.ReadableTransactionState;
 import org.neo4j.storageengine.api.txstate.TxStateVisitor;
@@ -41,16 +40,14 @@ public class TransactionCountingStateVisitor extends TxStateVisitor.Delegator
 {
     private final RelationshipDataExtractor edge = new RelationshipDataExtractor();
     private final StoreReadLayer storeLayer;
-    private final StorageStatement statement;
     private final CountsRecordState counts;
     private final ReadableTransactionState txState;
 
-    public TransactionCountingStateVisitor( TxStateVisitor next, StoreReadLayer storeLayer, StorageStatement statement,
             ReadableTransactionState txState, CountsRecordState counts )
     {
         super( next );
         this.storeLayer = storeLayer;
-        this.statement = statement;
         this.txState = txState;
         this.counts = counts;
     }
@@ -66,7 +63,7 @@ public void visitCreatedNode( long id )
     public void visitDeletedNode( long id )
     {
         counts.incrementNodeCount( ANY_LABEL, -1 );
-        statement.acquireSingleNodeCursor( id ).forAll( this::decrementCountForLabelsAndRelationships );
         super.visitDeletedNode( id );
     }
 
@@ -78,7 +75,7 @@ private void decrementCountForLabelsAndRelationships( NodeItem node )
             counts.incrementNodeCount( labelId, -1 );
         } );
 
-        storeLayer.degrees( statement, node,
                 ( type, out, in ) -&gt; updateRelationshipsCountsFromDegrees( labelIds, type, -out, -in ) );
     }
 
@@ -116,8 +113,8 @@ public void visitNodeLabelChanges( long id, final LongSet added, final LongSet r
             removed.each( label -&gt; counts.incrementNodeCount( label, -1 ) );
             // get the relationship counts from *before* this transaction,
             // the relationship changes will compensate for what happens during the transaction
-            statement.acquireSingleNodeCursor( id )
-                    .forAll( node -&gt; storeLayer.degrees( statement, node, ( type, out, in ) -&gt;
                     {
                         added.forEach( label -&gt; updateRelationshipsCountsFromDegrees( type, label, out, in ) );
                         removed.forEach( label -&gt; updateRelationshipsCountsFromDegrees( type, label, -out, -in ) );
@@ -151,11 +148,11 @@ private void updateRelationshipCount( long startNode, int type, long endNode, in
 
     private void visitLabels( long nodeId, LongConsumer visitor )
     {
-        nodeCursor( statement, nodeId ).forAll( node -&gt; node.labels().forEach( visitor::accept ) );
     }
 
-    private Cursor&lt;NodeItem&gt; nodeCursor( StorageStatement statement, long nodeId )
     {
-        return txState.augmentSingleNodeCursor( statement.acquireSingleNodeCursor( nodeId ), nodeId );
     }
 }
</code_before><code_after>@@ -29,7 +29,6 @@
 import org.neo4j.kernel.impl.api.CountsRecordState;
 import org.neo4j.kernel.impl.api.RelationshipDataExtractor;
 import org.neo4j.storageengine.api.NodeItem;
 import org.neo4j.storageengine.api.StoreReadLayer;
 import org.neo4j.storageengine.api.txstate.ReadableTransactionState;
 import org.neo4j.storageengine.api.txstate.TxStateVisitor;
@@ -41,16 +40,14 @@ public class TransactionCountingStateVisitor extends TxStateVisitor.Delegator
 {
     private final RelationshipDataExtractor edge = new RelationshipDataExtractor();
     private final StoreReadLayer storeLayer;
     private final CountsRecordState counts;
     private final ReadableTransactionState txState;
 
+    public TransactionCountingStateVisitor( TxStateVisitor next, StoreReadLayer storeLayer,
             ReadableTransactionState txState, CountsRecordState counts )
     {
         super( next );
         this.storeLayer = storeLayer;
         this.txState = txState;
         this.counts = counts;
     }
@@ -66,7 +63,7 @@ public void visitCreatedNode( long id )
     public void visitDeletedNode( long id )
     {
         counts.incrementNodeCount( ANY_LABEL, -1 );
+        storeLayer.acquireSingleNodeCursor( id ).forAll( this::decrementCountForLabelsAndRelationships );
         super.visitDeletedNode( id );
     }
 
@@ -78,7 +75,7 @@ private void decrementCountForLabelsAndRelationships( NodeItem node )
             counts.incrementNodeCount( labelId, -1 );
         } );
 
+        storeLayer.degrees( node,
                 ( type, out, in ) -&gt; updateRelationshipsCountsFromDegrees( labelIds, type, -out, -in ) );
     }
 
@@ -116,8 +113,8 @@ public void visitNodeLabelChanges( long id, final LongSet added, final LongSet r
             removed.each( label -&gt; counts.incrementNodeCount( label, -1 ) );
             // get the relationship counts from *before* this transaction,
             // the relationship changes will compensate for what happens during the transaction
+            storeLayer.acquireSingleNodeCursor( id )
+                    .forAll( node -&gt; storeLayer.degrees( node, ( type, out, in ) -&gt;
                     {
                         added.forEach( label -&gt; updateRelationshipsCountsFromDegrees( type, label, out, in ) );
                         removed.forEach( label -&gt; updateRelationshipsCountsFromDegrees( type, label, -out, -in ) );
@@ -151,11 +148,11 @@ private void updateRelationshipCount( long startNode, int type, long endNode, in
 
     private void visitLabels( long nodeId, LongConsumer visitor )
     {
+        nodeCursor( nodeId ).forAll( node -&gt; node.labels().forEach( visitor::accept ) );
     }
 
+    private Cursor&lt;NodeItem&gt; nodeCursor( long nodeId )
     {
+        return txState.augmentSingleNodeCursor( storeLayer.acquireSingleNodeCursor( nodeId ), nodeId );
     }
 }
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>529549</refactoring_id><commit_sha>9efa6cc9c85aab66b325e9f37f7bad13826aea39</commit_sha><commit_link>https://github.com/apache/druid/commit/9efa6cc9c85aab66b325e9f37f7bad13826aea39</commit_link><file_path>indexing-service/src/test/java/org/apache/druid/indexing/common/task/TestAppenderatorsManager.java</file_path><description>Remove Parameter useLegacyBatchProcessing : boolean in method public createOfflineAppenderatorForTask(taskId String, schema DataSchema, config AppenderatorConfig, metrics FireDepartmentMetrics, dataSegmentPusher DataSegmentPusher, objectMapper ObjectMapper, indexIO IndexIO, indexMerger IndexMerger, rowIngestionMeters RowIngestionMeters, parseExceptionHandler ParseExceptionHandler, useLegacyBatchProcessing boolean) : Appenderator from class org.apache.druid.indexing.common.task.TestAppenderatorsManager</description><code_before>@@ -93,6 +93,62 @@ public Appenderator createRealtimeAppenderatorForTask(
     return realtimeAppenderator;
   }
 
   @Override
   public Appenderator createOfflineAppenderatorForTask(
       String taskId,
@@ -104,8 +160,7 @@ public Appenderator createOfflineAppenderatorForTask(
       IndexIO indexIO,
       IndexMerger indexMerger,
       RowIngestionMeters rowIngestionMeters,
-      ParseExceptionHandler parseExceptionHandler,
-      boolean useLegacyBatchProcessing
   )
   {
     return Appenderators.createOffline(
@@ -118,8 +173,7 @@ public Appenderator createOfflineAppenderatorForTask(
         indexIO,
         indexMerger,
         rowIngestionMeters,
-        parseExceptionHandler,
-        useLegacyBatchProcessing
     );
   }
 
</code_before><code_after>@@ -93,6 +93,62 @@ public Appenderator createRealtimeAppenderatorForTask(
     return realtimeAppenderator;
   }
 
+  @Override
+  public Appenderator createOpenSegmentsOfflineAppenderatorForTask(
+      String taskId,
+      DataSchema schema,
+      AppenderatorConfig config,
+      FireDepartmentMetrics metrics,
+      DataSegmentPusher dataSegmentPusher,
+      ObjectMapper objectMapper,
+      IndexIO indexIO,
+      IndexMerger indexMerger,
+      RowIngestionMeters rowIngestionMeters,
+      ParseExceptionHandler parseExceptionHandler
+  )
+  {
+    return Appenderators.createOpenSegmentsOffline(
+        taskId,
+        schema,
+        config,
+        metrics,
+        dataSegmentPusher,
+        objectMapper,
+        indexIO,
+        indexMerger,
+        rowIngestionMeters,
+        parseExceptionHandler
+    );
+  }
+
+  @Override
+  public Appenderator createClosedSegmentsOfflineAppenderatorForTask(
+      String taskId,
+      DataSchema schema,
+      AppenderatorConfig config,
+      FireDepartmentMetrics metrics,
+      DataSegmentPusher dataSegmentPusher,
+      ObjectMapper objectMapper,
+      IndexIO indexIO,
+      IndexMerger indexMerger,
+      RowIngestionMeters rowIngestionMeters,
+      ParseExceptionHandler parseExceptionHandler
+  )
+  {
+    return Appenderators.createClosedSegmentsOffline(
+        taskId,
+        schema,
+        config,
+        metrics,
+        dataSegmentPusher,
+        objectMapper,
+        indexIO,
+        indexMerger,
+        rowIngestionMeters,
+        parseExceptionHandler
+    );
+  }
+
   @Override
   public Appenderator createOfflineAppenderatorForTask(
       String taskId,
@@ -104,8 +160,7 @@ public Appenderator createOfflineAppenderatorForTask(
       IndexIO indexIO,
       IndexMerger indexMerger,
       RowIngestionMeters rowIngestionMeters,
+      ParseExceptionHandler parseExceptionHandler
   )
   {
     return Appenderators.createOffline(
@@ -118,8 +173,7 @@ public Appenderator createOfflineAppenderatorForTask(
         indexIO,
         indexMerger,
         rowIngestionMeters,
+        parseExceptionHandler
     );
   }
 
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>480769</refactoring_id><commit_sha>82942abfc73c102815ce91a66c083a4ced952828</commit_sha><commit_link>https://github.com/batfish/batfish/commit/82942abfc73c102815ce91a66c083a4ced952828</commit_link><file_path>projects/batfish-client/src/main/java/org/batfish/client/BfCoordWorkHelper.java</file_path><description>Remove Parameter deltaEnvironment : String in method package getAnalysisAnswers(containerName String, baseTestrig String, baseEnvironment String, deltaTestrig String, deltaEnvironment String, analysisName String) : String from class org.batfish.client.BfCoordWorkHelper</description><code_before>@@ -354,12 +354,7 @@ boolean delTestrig(String containerName, String testrigName) {
 
   @Nullable
   String getAnalysisAnswers(
-      String containerName,
-      String baseTestrig,
-      String baseEnvironment,
-      String deltaTestrig,
-      String deltaEnvironment,
-      String analysisName) {
     try {
       WebTarget webTarget = getTarget(CoordConsts.SVC_RSC_GET_ANALYSIS_ANSWERS);
 
@@ -369,10 +364,8 @@ String getAnalysisAnswers(
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_API_KEY, _settings.getApiKey());
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_CONTAINER_NAME, containerName);
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_TESTRIG_NAME, baseTestrig);
-      addTextMultiPart(multiPart, CoordConsts.SVC_KEY_ENV_NAME, baseEnvironment);
       if (deltaTestrig != null) {
         addTextMultiPart(multiPart, CoordConsts.SVC_KEY_DELTA_TESTRIG_NAME, deltaTestrig);
-        addTextMultiPart(multiPart, CoordConsts.SVC_KEY_DELTA_ENV_NAME, deltaEnvironment);
       }
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_ANALYSIS_NAME, analysisName);
 
@@ -398,12 +391,7 @@ String getAnalysisAnswers(
 
   @Nullable
   String getAnswer(
-      String containerName,
-      String baseTestrig,
-      String baseEnv,
-      String deltaTestrig,
-      String deltaEnv,
-      String questionName) {
     try {
       WebTarget webTarget = getTarget(CoordConsts.SVC_RSC_GET_ANSWER);
 
@@ -413,10 +401,8 @@ String getAnswer(
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_API_KEY, _settings.getApiKey());
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_CONTAINER_NAME, containerName);
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_TESTRIG_NAME, baseTestrig);
-      addTextMultiPart(multiPart, CoordConsts.SVC_KEY_ENV_NAME, baseEnv);
       if (deltaTestrig != null) {
         addTextMultiPart(multiPart, CoordConsts.SVC_KEY_DELTA_TESTRIG_NAME, deltaTestrig);
-        addTextMultiPart(multiPart, CoordConsts.SVC_KEY_DELTA_ENV_NAME, deltaEnv);
       }
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_QUESTION_NAME, questionName);
 
@@ -893,44 +879,6 @@ String[] listContainers() {
     }
   }
 
-  @Nullable
-  String[] listEnvironments(String containerName, String testrigName) {
-    try {
-      WebTarget webTarget = getTarget(CoordConsts.SVC_RSC_LIST_ENVIRONMENTS);
-
-      MultiPart multiPart = new MultiPart();
-      multiPart.setMediaType(MediaType.MULTIPART_FORM_DATA_TYPE);
-
-      addTextMultiPart(multiPart, CoordConsts.SVC_KEY_API_KEY, _settings.getApiKey());
-      addTextMultiPart(multiPart, CoordConsts.SVC_KEY_CONTAINER_NAME, containerName);
-      addTextMultiPart(multiPart, CoordConsts.SVC_KEY_TESTRIG_NAME, testrigName);
-
-      JSONObject jObj = postData(webTarget, multiPart);
-      if (jObj == null) {
-        return null;
-      }
-
-      if (!jObj.has(CoordConsts.SVC_KEY_ENVIRONMENT_LIST)) {
-        _logger.errorf("environment list key not found in: %s\n", jObj);
-        return null;
-      }
-
-      JSONArray environmentArray = jObj.getJSONArray(CoordConsts.SVC_KEY_ENVIRONMENT_LIST);
-
-      String[] environmentList = new String[environmentArray.length()];
-
-      for (int index = 0; index &lt; environmentArray.length(); index++) {
-        environmentList[index] = environmentArray.getString(index);
-      }
-
-      return environmentList;
-    } catch (Exception e) {
-      _logger.errorf("exception: ");
-      _logger.error(Throwables.getStackTraceAsString(e) + "\n");
-      return null;
-    }
-  }
-
   @Nullable
   List&lt;WorkStatus&gt; listIncompleteWork(String containerName) {
     try {
</code_before><code_after>@@ -354,12 +354,7 @@ boolean delTestrig(String containerName, String testrigName) {
 
   @Nullable
   String getAnalysisAnswers(
+      String containerName, String baseTestrig, String deltaTestrig, String analysisName) {
     try {
       WebTarget webTarget = getTarget(CoordConsts.SVC_RSC_GET_ANALYSIS_ANSWERS);
 
@@ -369,10 +364,8 @@ String getAnalysisAnswers(
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_API_KEY, _settings.getApiKey());
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_CONTAINER_NAME, containerName);
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_TESTRIG_NAME, baseTestrig);
       if (deltaTestrig != null) {
         addTextMultiPart(multiPart, CoordConsts.SVC_KEY_DELTA_TESTRIG_NAME, deltaTestrig);
       }
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_ANALYSIS_NAME, analysisName);
 
@@ -398,12 +391,7 @@ String getAnalysisAnswers(
 
   @Nullable
   String getAnswer(
+      String containerName, String baseTestrig, String deltaTestrig, String questionName) {
     try {
       WebTarget webTarget = getTarget(CoordConsts.SVC_RSC_GET_ANSWER);
 
@@ -413,10 +401,8 @@ String getAnswer(
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_API_KEY, _settings.getApiKey());
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_CONTAINER_NAME, containerName);
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_TESTRIG_NAME, baseTestrig);
       if (deltaTestrig != null) {
         addTextMultiPart(multiPart, CoordConsts.SVC_KEY_DELTA_TESTRIG_NAME, deltaTestrig);
       }
       addTextMultiPart(multiPart, CoordConsts.SVC_KEY_QUESTION_NAME, questionName);
 
@@ -893,44 +879,6 @@ String[] listContainers() {
     }
   }
 
   @Nullable
   List&lt;WorkStatus&gt; listIncompleteWork(String containerName) {
     try {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>493535</refactoring_id><commit_sha>dd18f5b2f0ff6590d4a23597588ef452f3354d0b</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/dd18f5b2f0ff6590d4a23597588ef452f3354d0b</commit_link><file_path>backend/src/main/java/org/camunda/optimize/service/importing/engine/mediator/RunningProcessInstanceEngineImportMediator.java</file_path><description>Remove Parameter elasticsearchImportJobExecutor : ElasticsearchImportJobExecutor in method public RunningProcessInstanceEngineImportMediator(importIndexHandler RunningProcessInstanceImportIndexHandler, engineEntityFetcher RunningProcessInstanceFetcher, importService RunningProcessInstanceImportService, configurationService ConfigurationService, elasticsearchImportJobExecutor ElasticsearchImportJobExecutor, idleBackoffCalculator BackoffCalculator) from class org.camunda.optimize.service.importing.engine.mediator.RunningProcessInstanceEngineImportMediator</description><code_before>@@ -6,7 +6,6 @@
 package org.camunda.optimize.service.importing.engine.mediator;
 
 import org.camunda.optimize.dto.engine.HistoricProcessInstanceDto;
-import org.camunda.optimize.service.es.ElasticsearchImportJobExecutor;
 import org.camunda.optimize.service.importing.TimestampBasedImportMediator;
 import org.camunda.optimize.service.importing.engine.fetcher.instance.RunningProcessInstanceFetcher;
 import org.camunda.optimize.service.importing.engine.handler.RunningProcessInstanceImportIndexHandler;
@@ -31,16 +30,19 @@ public RunningProcessInstanceEngineImportMediator(final RunningProcessInstanceIm
                                                     final RunningProcessInstanceFetcher engineEntityFetcher,
                                                     final RunningProcessInstanceImportService importService,
                                                     final ConfigurationService configurationService,
-                                                    final ElasticsearchImportJobExecutor elasticsearchImportJobExecutor,
                                                     final BackoffCalculator idleBackoffCalculator) {
     this.importIndexHandler = importIndexHandler;
     this.engineEntityFetcher = engineEntityFetcher;
     this.importService = importService;
     this.configurationService = configurationService;
-    this.elasticsearchImportJobExecutor = elasticsearchImportJobExecutor;
     this.idleBackoffCalculator = idleBackoffCalculator;
   }
 
   @Override
   protected List&lt;HistoricProcessInstanceDto&gt; getEntitiesNextPage() {
     return engineEntityFetcher.fetchRunningProcessInstances(importIndexHandler.getNextPage());
@@ -55,9 +57,4 @@ protected List&lt;HistoricProcessInstanceDto&gt; getEntitiesLastTimestamp() {
   protected int getMaxPageSize() {
     return configurationService.getEngineImportProcessInstanceMaxPageSize();
   }
-
-  @Override
-  protected OffsetDateTime getTimestamp(final HistoricProcessInstanceDto historicProcessInstanceDto) {
-    return historicProcessInstanceDto.getStartTime();
-  }
 }
</code_before><code_after>@@ -6,7 +6,6 @@
 package org.camunda.optimize.service.importing.engine.mediator;
 
 import org.camunda.optimize.dto.engine.HistoricProcessInstanceDto;
 import org.camunda.optimize.service.importing.TimestampBasedImportMediator;
 import org.camunda.optimize.service.importing.engine.fetcher.instance.RunningProcessInstanceFetcher;
 import org.camunda.optimize.service.importing.engine.handler.RunningProcessInstanceImportIndexHandler;
@@ -31,16 +30,19 @@ public RunningProcessInstanceEngineImportMediator(final RunningProcessInstanceIm
                                                     final RunningProcessInstanceFetcher engineEntityFetcher,
                                                     final RunningProcessInstanceImportService importService,
                                                     final ConfigurationService configurationService,
                                                     final BackoffCalculator idleBackoffCalculator) {
     this.importIndexHandler = importIndexHandler;
     this.engineEntityFetcher = engineEntityFetcher;
     this.importService = importService;
     this.configurationService = configurationService;
     this.idleBackoffCalculator = idleBackoffCalculator;
   }
 
+  @Override
+  protected OffsetDateTime getTimestamp(final HistoricProcessInstanceDto historicProcessInstanceDto) {
+    return historicProcessInstanceDto.getStartTime();
+  }
+
   @Override
   protected List&lt;HistoricProcessInstanceDto&gt; getEntitiesNextPage() {
     return engineEntityFetcher.fetchRunningProcessInstances(importIndexHandler.getNextPage());
@@ -55,9 +57,4 @@ protected List&lt;HistoricProcessInstanceDto&gt; getEntitiesLastTimestamp() {
   protected int getMaxPageSize() {
     return configurationService.getEngineImportProcessInstanceMaxPageSize();
   }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>491871</refactoring_id><commit_sha>187c1a2511470a6dbbc3f64e01c776cf61fc33ff</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/187c1a2511470a6dbbc3f64e01c776cf61fc33ff</commit_link><file_path>community/kernel/src/test/java/org/neo4j/kernel/impl/api/KernelTransactionTestBase.java</file_path><description>Remove Parameter txTerminationAwareLocks : boolean in method public newTransaction(accessMode AccessMode, locks Locks.Client, txTerminationAwareLocks boolean) : KernelTransactionImplementation from class org.neo4j.kernel.impl.api.KernelTransactionTestBase</description><code_before>@@ -97,30 +97,29 @@ public KernelTransactionImplementation newTransaction( AccessMode accessMode )
         return newTransaction( 0, accessMode );
     }
 
-    public KernelTransactionImplementation newTransaction( AccessMode accessMode, Locks.Client locks,
-            boolean txTerminationAwareLocks )
     {
-        return newTransaction( 0, accessMode, locks, txTerminationAwareLocks );
     }
 
     public KernelTransactionImplementation newTransaction( long lastTransactionIdWhenStarted, AccessMode accessMode )
     {
-        return newTransaction( lastTransactionIdWhenStarted, accessMode, new NoOpClient(), false );
     }
 
     public KernelTransactionImplementation newTransaction( long lastTransactionIdWhenStarted, AccessMode accessMode,
-            Locks.Client locks, boolean txTerminationAwareLocks )
     {
-        KernelTransactionImplementation tx = newNotInitializedTransaction( txTerminationAwareLocks );
         tx.initialize( lastTransactionIdWhenStarted, BASE_TX_COMMIT_TIMESTAMP,locks, Type.implicit, accessMode );
         return tx;
     }
 
-    public KernelTransactionImplementation newNotInitializedTransaction( boolean txTerminationAwareLocks )
     {
         return new KernelTransactionImplementation( null, schemaWriteGuard, hooks, null, null, headerInformationFactory,
                 commitProcess, transactionMonitor, legacyIndexStateSupplier, txPool, clock, TransactionTracer.NULL,
-                storageEngine, txTerminationAwareLocks );
     }
 
     public class CapturingCommitProcess implements TransactionCommitProcess
</code_before><code_after>@@ -97,30 +97,29 @@ public KernelTransactionImplementation newTransaction( AccessMode accessMode )
         return newTransaction( 0, accessMode );
     }
 
+    public KernelTransactionImplementation newTransaction( AccessMode accessMode, Locks.Client locks )
     {
+        return newTransaction( 0, accessMode, locks );
     }
 
     public KernelTransactionImplementation newTransaction( long lastTransactionIdWhenStarted, AccessMode accessMode )
     {
+        return newTransaction( lastTransactionIdWhenStarted, accessMode, new NoOpClient() );
     }
 
     public KernelTransactionImplementation newTransaction( long lastTransactionIdWhenStarted, AccessMode accessMode,
+            Locks.Client locks )
     {
+        KernelTransactionImplementation tx = newNotInitializedTransaction();
         tx.initialize( lastTransactionIdWhenStarted, BASE_TX_COMMIT_TIMESTAMP,locks, Type.implicit, accessMode );
         return tx;
     }
 
+    public KernelTransactionImplementation newNotInitializedTransaction()
     {
         return new KernelTransactionImplementation( null, schemaWriteGuard, hooks, null, null, headerInformationFactory,
                 commitProcess, transactionMonitor, legacyIndexStateSupplier, txPool, clock, TransactionTracer.NULL,
+                storageEngine );
     }
 
     public class CapturingCommitProcess implements TransactionCommitProcess
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>511843</refactoring_id><commit_sha>796cea3720071dd895bdb32baf7b5c7bdbd2569c</commit_sha><commit_link>https://github.com/jabref/jabref/commit/796cea3720071dd895bdb32baf7b5c7bdbd2569c</commit_link><file_path>src/main/java/net/sf/jabref/bibtex/EntryTypes.java</file_path><description>Remove Parameter database : BibDatabase in method public hasAllRequiredFields(entry BibEntry, database BibDatabase) : boolean from class net.sf.jabref.bibtex.EntryTypes</description><code_before>@@ -112,25 +112,4 @@ public static void removeType(String name) {
             }
         }
     }
-
-    /**
-     * Returns true if this entry contains the fields it needs to be
-     * complete.
-     */
-    public static boolean hasAllRequiredFields(BibEntry entry, BibDatabase database) {
-        EntryType type = getType(entry.getType());
-        return entry.allFieldsPresent(type.getRequiredFields(), database);
-    }
-
-    /**
-     * Gets the display name for the specified type.
-     */
-    public static String getDisplayNameFor(String type) {
-        EntryType entryType = getType(type);
-        if (entryType != null) {
-            return entryType.getName();
-        } else {
-            return EntryUtil.capitalizeFirst(type);
-        }
-    }
 }
</code_before><code_after>@@ -112,25 +112,4 @@ public static void removeType(String name) {
             }
         }
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>529932</refactoring_id><commit_sha>80a2ef7be46c4fc807ac2a74507b8ba8b6a44049</commit_sha><commit_link>https://github.com/apache/druid/commit/80a2ef7be46c4fc807ac2a74507b8ba8b6a44049</commit_link><file_path>extensions-core/kafka-indexing-service/src/main/java/org/apache/druid/indexing/kafka/supervisor/KafkaSupervisorIOConfig.java</file_path><description>Remove Parameter skipOffsetGaps : Boolean in method public KafkaSupervisorIOConfig(topic String, replicas Integer, taskCount Integer, taskDuration Period, consumerProperties Map&lt;String,Object&gt;, pollTimeout Long, startDelay Period, period Period, useEarliestOffset Boolean, completionTimeout Period, lateMessageRejectionPeriod Period, earlyMessageRejectionPeriod Period, skipOffsetGaps Boolean) from class org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorIOConfig</description><code_before>@@ -38,7 +38,7 @@ public class KafkaSupervisorIOConfig extends SeekableStreamSupervisorIOConfig
 
   private final Map&lt;String, Object&gt; consumerProperties;
   private final long pollTimeout;
-  private final boolean skipOffsetGaps;
 
   @JsonCreator
   public KafkaSupervisorIOConfig(
@@ -53,8 +53,7 @@ public KafkaSupervisorIOConfig(
       @JsonProperty("useEarliestOffset") Boolean useEarliestOffset,
       @JsonProperty("completionTimeout") Period completionTimeout,
       @JsonProperty("lateMessageRejectionPeriod") Period lateMessageRejectionPeriod,
-      @JsonProperty("earlyMessageRejectionPeriod") Period earlyMessageRejectionPeriod,
-      @JsonProperty("skipOffsetGaps") Boolean skipOffsetGaps
   )
   {
     super(
@@ -76,7 +75,6 @@ public KafkaSupervisorIOConfig(
         StringUtils.format("consumerProperties must contain entry for [%s]", BOOTSTRAP_SERVERS_KEY)
     );
     this.pollTimeout = pollTimeout != null ? pollTimeout : DEFAULT_POLL_TIMEOUT_MILLIS;
-    this.skipOffsetGaps = skipOffsetGaps != null ? skipOffsetGaps : false;
   }
 
   @JsonProperty
@@ -103,12 +101,6 @@ public boolean isUseEarliestOffset()
     return isUseEarliestSequenceNumber();
   }
 
-  @JsonProperty
-  public boolean isSkipOffsetGaps()
-  {
-    return skipOffsetGaps;
-  }
-
   @Override
   public String toString()
   {
@@ -125,7 +117,6 @@ public String toString()
            ", completionTimeout=" + getCompletionTimeout() +
            ", earlyMessageRejectionPeriod=" + getEarlyMessageRejectionPeriod() +
            ", lateMessageRejectionPeriod=" + getLateMessageRejectionPeriod() +
-           ", skipOffsetGaps=" + skipOffsetGaps +
            '}';
   }
 
</code_before><code_after>@@ -38,7 +38,7 @@ public class KafkaSupervisorIOConfig extends SeekableStreamSupervisorIOConfig
 
   private final Map&lt;String, Object&gt; consumerProperties;
   private final long pollTimeout;
+
 
   @JsonCreator
   public KafkaSupervisorIOConfig(
@@ -53,8 +53,7 @@ public KafkaSupervisorIOConfig(
       @JsonProperty("useEarliestOffset") Boolean useEarliestOffset,
       @JsonProperty("completionTimeout") Period completionTimeout,
       @JsonProperty("lateMessageRejectionPeriod") Period lateMessageRejectionPeriod,
+      @JsonProperty("earlyMessageRejectionPeriod") Period earlyMessageRejectionPeriod
   )
   {
     super(
@@ -76,7 +75,6 @@ public KafkaSupervisorIOConfig(
         StringUtils.format("consumerProperties must contain entry for [%s]", BOOTSTRAP_SERVERS_KEY)
     );
     this.pollTimeout = pollTimeout != null ? pollTimeout : DEFAULT_POLL_TIMEOUT_MILLIS;
   }
 
   @JsonProperty
@@ -103,12 +101,6 @@ public boolean isUseEarliestOffset()
     return isUseEarliestSequenceNumber();
   }
 
   @Override
   public String toString()
   {
@@ -125,7 +117,6 @@ public String toString()
            ", completionTimeout=" + getCompletionTimeout() +
            ", earlyMessageRejectionPeriod=" + getEarlyMessageRejectionPeriod() +
            ", lateMessageRejectionPeriod=" + getLateMessageRejectionPeriod() +
            '}';
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>488098</refactoring_id><commit_sha>abff8bbdb1afcca387436cc2ccec2dd2503a1e17</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/abff8bbdb1afcca387436cc2ccec2dd2503a1e17</commit_link><file_path>community/kernel/src/main/java/org/neo4j/unsafe/impl/batchimport/store/BatchFriendlyWindowPoolFactory.java</file_path><description>Remove Parameter numberOfReservedLowIds : int in method protected createSingleWindow(storageFileName File, recordSize int, channel StoreChannel, numberOfReservedLowIds int) : SingleWindow from class org.neo4j.unsafe.impl.batchimport.store.BatchFriendlyWindowPoolFactory</description><code_before>@@ -24,14 +24,12 @@
 import java.nio.ByteBuffer;
 
 import org.neo4j.io.fs.StoreChannel;
-import org.neo4j.kernel.configuration.Config;
 import org.neo4j.kernel.impl.nioneo.store.Buffer;
 import org.neo4j.kernel.impl.nioneo.store.OperationType;
 import org.neo4j.kernel.impl.nioneo.store.PersistenceWindow;
-import org.neo4j.kernel.impl.nioneo.store.WindowPoolStats;
 import org.neo4j.kernel.impl.nioneo.store.WindowPool;
 import org.neo4j.kernel.impl.nioneo.store.WindowPoolFactory;
-import org.neo4j.kernel.monitoring.Monitors;
 
 import static java.nio.ByteBuffer.allocateDirect;
 
@@ -111,23 +109,21 @@ public BatchFriendlyWindowPoolFactory( int windowTargetSize, Monitor monitor, Mo
     }
 
     @Override
-    public WindowPool create( File storageFileName, int recordSize, StoreChannel fileChannel, Config configuration,
-            int numberOfReservedLowIds, Monitors monitors )
     {
-        return new SingleWindowPool( storageFileName, recordSize, fileChannel, numberOfReservedLowIds );
     }
 
     private class SingleWindowPool implements WindowPool
     {
         private final SingleWindow window;
         private final File storageFileName;
 
-        public SingleWindowPool( File storageFileName, int recordSize, StoreChannel channel,
-                int numberOfReservedLowIds )
         {
             this.storageFileName = storageFileName;
-            this.window = createSingleWindow( storageFileName, recordSize, channel,
-                    numberOfReservedLowIds );
             window.allocateBuffer();
             window.placeWindowFor( 0 );
         }
@@ -169,8 +165,7 @@ public WindowPoolStats getStats()
         }
     }
 
-    protected SingleWindow createSingleWindow( File storageFileName, int recordSize, StoreChannel channel,
-            int numberOfReservedLowIds )
     {
         return new SingleWindow( storageFileName, recordSize, channel );
     }
</code_before><code_after>@@ -24,14 +24,12 @@
 import java.nio.ByteBuffer;
 
 import org.neo4j.io.fs.StoreChannel;
 import org.neo4j.kernel.impl.nioneo.store.Buffer;
 import org.neo4j.kernel.impl.nioneo.store.OperationType;
 import org.neo4j.kernel.impl.nioneo.store.PersistenceWindow;
 import org.neo4j.kernel.impl.nioneo.store.WindowPool;
 import org.neo4j.kernel.impl.nioneo.store.WindowPoolFactory;
+import org.neo4j.kernel.impl.nioneo.store.WindowPoolStats;
 
 import static java.nio.ByteBuffer.allocateDirect;
 
@@ -111,23 +109,21 @@ public BatchFriendlyWindowPoolFactory( int windowTargetSize, Monitor monitor, Mo
     }
 
     @Override
+    public WindowPool create( File storageFileName, int pageSize, StoreChannel fileChannel )
     {
+        return new SingleWindowPool( storageFileName, pageSize, fileChannel );
     }
 
     private class SingleWindowPool implements WindowPool
     {
         private final SingleWindow window;
         private final File storageFileName;
 
+        public SingleWindowPool( File storageFileName, int recordSize, StoreChannel channel )
         {
             this.storageFileName = storageFileName;
+            this.window = createSingleWindow( storageFileName, recordSize, channel
+            );
             window.allocateBuffer();
             window.placeWindowFor( 0 );
         }
@@ -169,8 +165,7 @@ public WindowPoolStats getStats()
         }
     }
 
+    protected SingleWindow createSingleWindow( File storageFileName, int recordSize, StoreChannel channel )
     {
         return new SingleWindow( storageFileName, recordSize, channel );
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>552619</refactoring_id><commit_sha>bcbe3106817360258e30159680cc297e2910a755</commit_sha><commit_link>https://github.com/google/exoplayer/commit/bcbe3106817360258e30159680cc297e2910a755</commit_link><file_path>library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java</file_path><description>Remove Parameter adGroupIndex : int in method public AdPrepareErrorListener(adUri Uri, adGroupIndex int, adIndexInAdGroup int) from class com.google.android.exoplayer2.source.ads.AdsMediaSource.AdPrepareErrorListener</description><code_before>@@ -379,13 +379,9 @@ public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
   private final class AdPrepareErrorListener implements MaskingMediaPeriod.PrepareErrorListener {
 
     private final Uri adUri;
-    private final int adGroupIndex;
-    private final int adIndexInAdGroup;
 
-    public AdPrepareErrorListener(Uri adUri, int adGroupIndex, int adIndexInAdGroup) {
       this.adUri = adUri;
-      this.adGroupIndex = adGroupIndex;
-      this.adIndexInAdGroup = adIndexInAdGroup;
     }
 
     @Override
@@ -400,7 +396,9 @@ public void onPrepareError(MediaPeriodId mediaPeriodId, final IOException except
               AdLoadException.createForAd(exception),
               /* wasCanceled= */ true);
       mainHandler.post(
-          () -&gt; adsLoader.handlePrepareError(adGroupIndex, adIndexInAdGroup, exception));
     }
   }
 
@@ -420,8 +418,7 @@ public MediaPeriod createMediaPeriod(
         Uri adUri, MediaPeriodId id, Allocator allocator, long startPositionUs) {
       MaskingMediaPeriod maskingMediaPeriod =
           new MaskingMediaPeriod(adMediaSource, id, allocator, startPositionUs);
-      maskingMediaPeriod.setPrepareErrorListener(
-          new AdPrepareErrorListener(adUri, id.adGroupIndex, id.adIndexInAdGroup));
       activeMediaPeriods.add(maskingMediaPeriod);
       if (timeline != null) {
         Object periodUid = timeline.getUidOfPeriod(/* periodIndex= */ 0);
</code_before><code_after>@@ -379,13 +379,9 @@ public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
   private final class AdPrepareErrorListener implements MaskingMediaPeriod.PrepareErrorListener {
 
     private final Uri adUri;
 
+    public AdPrepareErrorListener(Uri adUri) {
       this.adUri = adUri;
     }
 
     @Override
@@ -400,7 +396,9 @@ public void onPrepareError(MediaPeriodId mediaPeriodId, final IOException except
               AdLoadException.createForAd(exception),
               /* wasCanceled= */ true);
       mainHandler.post(
+          () -&gt;
+              adsLoader.handlePrepareError(
+                  mediaPeriodId.adGroupIndex, mediaPeriodId.adIndexInAdGroup, exception));
     }
   }
 
@@ -420,8 +418,7 @@ public MediaPeriod createMediaPeriod(
         Uri adUri, MediaPeriodId id, Allocator allocator, long startPositionUs) {
       MaskingMediaPeriod maskingMediaPeriod =
           new MaskingMediaPeriod(adMediaSource, id, allocator, startPositionUs);
+      maskingMediaPeriod.setPrepareErrorListener(new AdPrepareErrorListener(adUri));
       activeMediaPeriods.add(maskingMediaPeriod);
       if (timeline != null) {
         Object periodUid = timeline.getUidOfPeriod(/* periodIndex= */ 0);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>519956</refactoring_id><commit_sha>ede18e9a40976e99761b16861dc5b975b985dcbd</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/ede18e9a40976e99761b16861dc5b975b985dcbd</commit_link><file_path>minicluster/src/main/java/alluxio/underfs/LocalFileSystemCluster.java</file_path><description>Remove Parameter configuration : Configuration in method public LocalFileSystemCluster(baseDir String, configuration Configuration) from class alluxio.underfs.LocalFileSystemCluster</description><code_before>@@ -26,10 +26,9 @@ public final class LocalFileSystemCluster extends UnderFileSystemCluster {
 
   /**
    * @param baseDir the base directory
-   * @param configuration the configuration for Alluxio
    */
-  public LocalFileSystemCluster(String baseDir, Configuration configuration) {
-    super(baseDir, configuration);
   }
 
   @Override
</code_before><code_after>@@ -26,10 +26,9 @@ public final class LocalFileSystemCluster extends UnderFileSystemCluster {
 
   /**
    * @param baseDir the base directory
    */
+  public LocalFileSystemCluster(String baseDir) {
+    super(baseDir);
   }
 
   @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>563806</refactoring_id><commit_sha>aa5762633a06e229cd9122983eec94bdb74fc23a</commit_sha><commit_link>https://github.com/apache/cassandra/commit/aa5762633a06e229cd9122983eec94bdb74fc23a</commit_link><file_path>src/java/org/apache/cassandra/index/transactions/CompactionTransaction.java</file_path><description>Remove Parameter columns : Columns in method public onRowMerge(columns Columns, merged Row, versions Row...) : void from class org.apache.cassandra.index.transactions.CompactionTransaction</description><code_before>@@ -18,7 +18,6 @@
 
 package org.apache.cassandra.index.transactions;
 
-import org.apache.cassandra.db.Columns;
 import org.apache.cassandra.db.rows.Row;
 
 /**
@@ -33,12 +32,12 @@
  */
 public interface CompactionTransaction extends IndexTransaction
 {
-    void onRowMerge(Columns columns, Row merged, Row...versions);
 
     CompactionTransaction NO_OP = new CompactionTransaction()
     {
         public void start(){}
-        public void onRowMerge(Columns columns, Row merged, Row...versions){}
         public void commit(){}
     };
 }
</code_before><code_after>@@ -18,7 +18,6 @@
 
 package org.apache.cassandra.index.transactions;
 
 import org.apache.cassandra.db.rows.Row;
 
 /**
@@ -33,12 +32,12 @@
  */
 public interface CompactionTransaction extends IndexTransaction
 {
+    void onRowMerge(Row merged, Row...versions);
 
     CompactionTransaction NO_OP = new CompactionTransaction()
     {
         public void start(){}
+        public void onRowMerge(Row merged, Row...versions){}
         public void commit(){}
     };
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>549328</refactoring_id><commit_sha>f3e650b8c7173ceb6d28cb9776a153f1536d889f</commit_sha><commit_link>https://github.com/androidx/media/commit/f3e650b8c7173ceb6d28cb9776a153f1536d889f</commit_link><file_path>library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java</file_path><description>Remove Parameter instrumentation : Instrumentation in method private assertData(instrumentation Instrumentation, offset int, length int, pipeMode boolean) : void from class com.google.android.exoplayer2.upstream.ContentDataSourceTest</description><code_before>@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.upstream;
 
 import static com.google.common.truth.Truth.assertThat;
 
-import android.app.Instrumentation;
 import android.content.ContentProvider;
 import android.content.ContentResolver;
 import android.content.ContentValues;
@@ -28,48 +28,58 @@
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Arrays;
 
-/**
- * Unit tests for {@link ContentDataSource}.
- */
-public final class ContentDataSourceTest extends InstrumentationTestCase {
 
   private static final String AUTHORITY = "com.google.android.exoplayer2.core.test";
   private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";
 
   public void testRead() throws Exception {
-    assertData(getInstrumentation(), 0, C.LENGTH_UNSET, false);
   }
 
   public void testReadPipeMode() throws Exception {
-    assertData(getInstrumentation(), 0, C.LENGTH_UNSET, true);
   }
 
   public void testReadFixedLength() throws Exception {
-    assertData(getInstrumentation(), 0, 100, false);
   }
 
   public void testReadFromOffsetToEndOfInput() throws Exception {
-    assertData(getInstrumentation(), 1, C.LENGTH_UNSET, false);
   }
 
   public void testReadFromOffsetToEndOfInputPipeMode() throws Exception {
-    assertData(getInstrumentation(), 1, C.LENGTH_UNSET, true);
   }
 
   public void testReadFromOffsetFixedLength() throws Exception {
-    assertData(getInstrumentation(), 1, 100, false);
   }
 
   public void testReadInvalidUri() throws Exception {
-    ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
     Uri contentUri = TestContentProvider.buildUri("does/not.exist", false);
     DataSpec dataSpec = new DataSpec(contentUri);
     try {
@@ -83,13 +93,14 @@ public void testReadInvalidUri() throws Exception {
     }
   }
 
-  private static void assertData(Instrumentation instrumentation, int offset, int length,
-      boolean pipeMode) throws IOException {
     Uri contentUri = TestContentProvider.buildUri(DATA_PATH, pipeMode);
-    ContentDataSource dataSource = new ContentDataSource(instrumentation.getContext());
     try {
       DataSpec dataSpec = new DataSpec(contentUri, offset, length, null);
-      byte[] completeData = TestUtil.getByteArray(instrumentation.getContext(), DATA_PATH);
       byte[] expectedData = Arrays.copyOfRange(completeData, offset,
           length == C.LENGTH_UNSET ? completeData.length : offset + length);
       TestUtil.assertDataSourceContent(dataSource, dataSpec, expectedData, !pipeMode);
</code_before><code_after>@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.upstream;
 
 import static com.google.common.truth.Truth.assertThat;
+import static junit.framework.Assert.fail;
 
 import android.content.ContentProvider;
 import android.content.ContentResolver;
 import android.content.ContentValues;
@@ -28,48 +28,58 @@
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Arrays;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
+/** Unit tests for {@link ContentDataSource}. */
+@RunWith(AndroidJUnit4.class)
+public final class ContentDataSourceTest {
 
   private static final String AUTHORITY = "com.google.android.exoplayer2.core.test";
   private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";
 
+  @Test
   public void testRead() throws Exception {
+    assertData(0, C.LENGTH_UNSET, false);
   }
 
+  @Test
   public void testReadPipeMode() throws Exception {
+    assertData(0, C.LENGTH_UNSET, true);
   }
 
+  @Test
   public void testReadFixedLength() throws Exception {
+    assertData(0, 100, false);
   }
 
+  @Test
   public void testReadFromOffsetToEndOfInput() throws Exception {
+    assertData(1, C.LENGTH_UNSET, false);
   }
 
+  @Test
   public void testReadFromOffsetToEndOfInputPipeMode() throws Exception {
+    assertData(1, C.LENGTH_UNSET, true);
   }
 
+  @Test
   public void testReadFromOffsetFixedLength() throws Exception {
+    assertData(1, 100, false);
   }
 
+  @Test
   public void testReadInvalidUri() throws Exception {
+    ContentDataSource dataSource =
+        new ContentDataSource(InstrumentationRegistry.getTargetContext());
     Uri contentUri = TestContentProvider.buildUri("does/not.exist", false);
     DataSpec dataSpec = new DataSpec(contentUri);
     try {
@@ -83,13 +93,14 @@ public void testReadInvalidUri() throws Exception {
     }
   }
 
+  private static void assertData(int offset, int length, boolean pipeMode) throws IOException {
     Uri contentUri = TestContentProvider.buildUri(DATA_PATH, pipeMode);
+    ContentDataSource dataSource =
+        new ContentDataSource(InstrumentationRegistry.getTargetContext());
     try {
       DataSpec dataSpec = new DataSpec(contentUri, offset, length, null);
+      byte[] completeData =
+          TestUtil.getByteArray(InstrumentationRegistry.getTargetContext(), DATA_PATH);
       byte[] expectedData = Arrays.copyOfRange(completeData, offset,
           length == C.LENGTH_UNSET ? completeData.length : offset + length);
       TestUtil.assertDataSourceContent(dataSource, dataSpec, expectedData, !pipeMode);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>524337</refactoring_id><commit_sha>3392d4e1abc9c5f61df678437b9cae8577e29bb3</commit_sha><commit_link>https://github.com/spring-projects/spring-integration/commit/3392d4e1abc9c5f61df678437b9cae8577e29bb3</commit_link><file_path>spring-integration-redis/src/main/java/org/springframework/integration/redis/outbound/ExpressionArgumentsStrategy.java</file_path><description>Remove Parameter evaluationContext : EvaluationContext in method public setIntegrationEvaluationContext(evaluationContext EvaluationContext) : void from class org.springframework.integration.redis.outbound.ExpressionArgumentsStrategy</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,19 +23,20 @@
 import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
 import org.springframework.expression.EvaluationContext;
 import org.springframework.expression.Expression;
 import org.springframework.expression.spel.standard.SpelExpressionParser;
 import org.springframework.integration.context.IntegrationContextUtils;
-import org.springframework.integration.expression.IntegrationEvaluationContextAware;
 import org.springframework.messaging.Message;
 import org.springframework.util.Assert;
 
 /**
  * @author Artem Bilan
  * @since 4.0
  */
-public class ExpressionArgumentsStrategy implements ArgumentsStrategy, IntegrationEvaluationContextAware, BeanFactoryAware {
 
 	private static final SpelExpressionParser PARSER = new SpelExpressionParser();
 
@@ -63,14 +64,13 @@ public ExpressionArgumentsStrategy(String[] argumentExpressions, boolean useComm
 	}
 
 	@Override
-	public void setIntegrationEvaluationContext(EvaluationContext evaluationContext) {
-		Assert.notNull(evaluationContext, "'evaluationContext' must not be null");
-		this.evaluationContext = evaluationContext;
 	}
 
 	@Override
-	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
-		this.beanFactory = beanFactory;
 	}
 
 	@Override
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright 2014-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,19 +23,20 @@
 import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
+import org.springframework.beans.factory.InitializingBean;
 import org.springframework.expression.EvaluationContext;
 import org.springframework.expression.Expression;
 import org.springframework.expression.spel.standard.SpelExpressionParser;
 import org.springframework.integration.context.IntegrationContextUtils;
+import org.springframework.integration.expression.ExpressionUtils;
 import org.springframework.messaging.Message;
 import org.springframework.util.Assert;
 
 /**
  * @author Artem Bilan
  * @since 4.0
  */
+public class ExpressionArgumentsStrategy implements ArgumentsStrategy, BeanFactoryAware, InitializingBean {
 
 	private static final SpelExpressionParser PARSER = new SpelExpressionParser();
 
@@ -63,14 +64,13 @@ public ExpressionArgumentsStrategy(String[] argumentExpressions, boolean useComm
 	}
 
 	@Override
+	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
+		this.beanFactory = beanFactory;
 	}
 
 	@Override
+	public void afterPropertiesSet() throws Exception {
+		this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(this.beanFactory);
 	}
 
 	@Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>505215</refactoring_id><commit_sha>e2edf2e141a09c025a958d580c7cac7b57c70d83</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/e2edf2e141a09c025a958d580c7cac7b57c70d83</commit_link><file_path>src/main/java/com/google/devtools/build/lib/rules/android/AndroidLibrary.java</file_path><description>Remove Parameter transitiveAarArtifacts : NestedSetBuilder&lt;Artifact&gt; in method private collectTransitiveAars(ruleContext RuleContext, transitiveAars NestedSetBuilder&lt;Aar&gt;, transitiveAarArtifacts NestedSetBuilder&lt;Artifact&gt;) : void from class com.google.devtools.build.lib.rules.android.AndroidLibrary</description><code_before>@@ -67,9 +67,7 @@ public ConfiguredTarget create(RuleContext ruleContext)
       return null;
     }
     checkResourceInlining(ruleContext);
-    NestedSetBuilder&lt;Aar&gt; transitiveAars = NestedSetBuilder.naiveLinkOrder();
-    NestedSetBuilder&lt;Artifact&gt; transitiveAarArtifacts = NestedSetBuilder.stableOrder();
-    collectTransitiveAars(ruleContext, transitiveAars, transitiveAarArtifacts);
 
     NestedSetBuilder&lt;Artifact&gt; proguardConfigsbuilder = NestedSetBuilder.stableOrder();
     proguardConfigsbuilder.addTransitive(new ProguardLibrary(ruleContext).collectProguardSpecs());
@@ -150,12 +148,12 @@ public ConfiguredTarget create(RuleContext ruleContext)
       // applicationManifest has already been checked for nullness above in this method
       ApplicationManifest applicationManifest = androidSemantics.getManifestForRule(ruleContext);
       aar = Aar.create(aarOut, applicationManifest.getManifest());
-      addAarToProvider(aar, transitiveAars, transitiveAarArtifacts);
     } else if (AndroidCommon.getAndroidResources(ruleContext) != null) {
       primaryResources = Iterables.getOnlyElement(
           AndroidCommon.getAndroidResources(ruleContext).getDirectAndroidResources());
       aar = Aar.create(aarOut, primaryResources.getManifest());
-      addAarToProvider(aar, transitiveAars, transitiveAarArtifacts);
     } else {
       // there are no local resources and resources attribute was not specified either
       aar = null;
@@ -236,26 +234,12 @@ public ConfiguredTarget create(RuleContext ruleContext)
     if (!JavaCommon.isNeverLink(ruleContext)) {
       builder.add(
           AndroidLibraryAarProvider.class,
-          AndroidLibraryAarProvider.create(
-              aar, transitiveAars.build(), transitiveAarArtifacts.build()));
     }
 
     return builder.build();
   }
 
-  private void addAarToProvider(
-      Aar aar,
-      NestedSetBuilder&lt;Aar&gt; transitiveAars,
-      NestedSetBuilder&lt;Artifact&gt; transitiveAarArtifacts) {
-    transitiveAars.add(aar);
-    if (aar.getAar() != null) {
-      transitiveAarArtifacts.add(aar.getAar());
-    }
-    if (aar.getManifest() != null) {
-      transitiveAarArtifacts.add(aar.getManifest());
-    }
-  }
-
   private void checkResourceInlining(RuleContext ruleContext) {
     AndroidResourcesProvider resources = AndroidCommon.getAndroidResources(ruleContext);
     if (resources == null) {
@@ -272,15 +256,13 @@ private void checkResourceInlining(RuleContext ruleContext) {
     }
   }
 
-  private void collectTransitiveAars(
-      RuleContext ruleContext,
-      NestedSetBuilder&lt;Aar&gt; transitiveAars,
-      NestedSetBuilder&lt;Artifact&gt; transitiveAarArtifacts) {
     for (AndroidLibraryAarProvider library : AndroidCommon.getTransitivePrerequisites(
         ruleContext, Mode.TARGET, AndroidLibraryAarProvider.class)) {
-      transitiveAars.addTransitive(library.getTransitiveAars());
-      transitiveAarArtifacts.addTransitive(library.getTransitiveAarArtifacts());
     }
   }
 
   private NestedSetBuilder&lt;Artifact&gt; collectTransitiveResourceJars(RuleContext ruleContext) {
</code_before><code_after>@@ -67,9 +67,7 @@ public ConfiguredTarget create(RuleContext ruleContext)
       return null;
     }
     checkResourceInlining(ruleContext);
+    NestedSetBuilder&lt;Aar&gt; transitiveAars = collectTransitiveAars(ruleContext);
 
     NestedSetBuilder&lt;Artifact&gt; proguardConfigsbuilder = NestedSetBuilder.stableOrder();
     proguardConfigsbuilder.addTransitive(new ProguardLibrary(ruleContext).collectProguardSpecs());
@@ -150,12 +148,12 @@ public ConfiguredTarget create(RuleContext ruleContext)
       // applicationManifest has already been checked for nullness above in this method
       ApplicationManifest applicationManifest = androidSemantics.getManifestForRule(ruleContext);
       aar = Aar.create(aarOut, applicationManifest.getManifest());
+      transitiveAars.add(aar);
     } else if (AndroidCommon.getAndroidResources(ruleContext) != null) {
       primaryResources = Iterables.getOnlyElement(
           AndroidCommon.getAndroidResources(ruleContext).getDirectAndroidResources());
       aar = Aar.create(aarOut, primaryResources.getManifest());
+      transitiveAars.add(aar);
     } else {
       // there are no local resources and resources attribute was not specified either
       aar = null;
@@ -236,26 +234,12 @@ public ConfiguredTarget create(RuleContext ruleContext)
     if (!JavaCommon.isNeverLink(ruleContext)) {
       builder.add(
           AndroidLibraryAarProvider.class,
+          AndroidLibraryAarProvider.create(aar, transitiveAars.build()));
     }
 
     return builder.build();
   }
 
   private void checkResourceInlining(RuleContext ruleContext) {
     AndroidResourcesProvider resources = AndroidCommon.getAndroidResources(ruleContext);
     if (resources == null) {
@@ -272,15 +256,13 @@ private void checkResourceInlining(RuleContext ruleContext) {
     }
   }
 
+  private NestedSetBuilder&lt;Aar&gt; collectTransitiveAars(RuleContext ruleContext) {
+    NestedSetBuilder&lt;Aar&gt; builder = NestedSetBuilder.naiveLinkOrder();
     for (AndroidLibraryAarProvider library : AndroidCommon.getTransitivePrerequisites(
         ruleContext, Mode.TARGET, AndroidLibraryAarProvider.class)) {
+      builder.addTransitive(library.getTransitiveAars());
     }
+    return builder;
   }
 
   private NestedSetBuilder&lt;Artifact&gt; collectTransitiveResourceJars(RuleContext ruleContext) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>480087</refactoring_id><commit_sha>831189459ba51538b239a33b7d632bd2d9e4e8a3</commit_sha><commit_link>https://github.com/runelite/runelite/commit/831189459ba51538b239a33b7d632bd2d9e4e8a3</commit_link><file_path>runelite-client/src/main/java/net/runelite/client/account/SessionManager.java</file_path><description>Remove Parameter configManager : ConfigManager in method private SessionManager(sessionfile File, configManager ConfigManager, eventBus EventBus, accountClient AccountClient, gson Gson, oauthRedirect String, scheduledExecutorService ScheduledExecutorService) from class net.runelite.client.account.SessionManager</description><code_before>@@ -43,7 +43,6 @@
 import javax.inject.Singleton;
 import lombok.Getter;
 import lombok.extern.slf4j.Slf4j;
-import net.runelite.client.config.ConfigManager;
 import net.runelite.client.eventbus.EventBus;
 import net.runelite.client.events.SessionClose;
 import net.runelite.client.events.SessionOpen;
@@ -59,7 +58,6 @@ public class SessionManager
 	private AccountSession accountSession;
 
 	private final EventBus eventBus;
-	private final ConfigManager configManager;
 	private final File sessionFile;
 	private final AccountClient accountClient;
 	private final Gson gson;
@@ -71,15 +69,13 @@ public class SessionManager
 	@Inject
 	private SessionManager(
 		@Named("sessionfile") File sessionfile,
-		ConfigManager configManager,
 		EventBus eventBus,
 		AccountClient accountClient,
 		Gson gson,
 		@Named("runelite.oauth.redirect") String oauthRedirect,
 		ScheduledExecutorService scheduledExecutorService
 	)
 	{
-		this.configManager = configManager;
 		this.eventBus = eventBus;
 		this.sessionFile = sessionfile;
 		this.accountClient = accountClient;
@@ -120,7 +116,7 @@ public void loadSession()
 			return;
 		}
 
-		openSession(session);
 	}
 
 	private void saveSession()
@@ -155,14 +151,6 @@ private void deleteSession()
 	private void openSession(AccountSession session)
 	{
 		accountSession = session;
-
-		if (session.getUsername() != null)
-		{
-			// Initialize config for new session
-			// If the session isn't logged in yet, don't switch to the new config
-			configManager.switchSession(session);
-		}
-
 		eventBus.post(new SessionOpen());
 	}
 
@@ -175,9 +163,6 @@ private void closeSession()
 
 		log.debug("Logging out of account {}", accountSession.getUsername());
 
-		// Restore config prior to deleting session so that pending config changes get saved correctly
-		configManager.switchSession(null);
-
 		// Delete session
 		accountClient.setUuid(accountSession.getUuid());
 		try
@@ -244,7 +229,7 @@ private void startServer() throws IOException
 
 				log.debug("Now signed in as {}", username);
 
-				// open the session, which triggers the sessonopen event
 				AccountSession session = new AccountSession(sessionId, Instant.now(), username);
 				openSession(session);
 
</code_before><code_after>@@ -43,7 +43,6 @@
 import javax.inject.Singleton;
 import lombok.Getter;
 import lombok.extern.slf4j.Slf4j;
 import net.runelite.client.eventbus.EventBus;
 import net.runelite.client.events.SessionClose;
 import net.runelite.client.events.SessionOpen;
@@ -59,7 +58,6 @@ public class SessionManager
 	private AccountSession accountSession;
 
 	private final EventBus eventBus;
 	private final File sessionFile;
 	private final AccountClient accountClient;
 	private final Gson gson;
@@ -71,15 +69,13 @@ public class SessionManager
 	@Inject
 	private SessionManager(
 		@Named("sessionfile") File sessionfile,
 		EventBus eventBus,
 		AccountClient accountClient,
 		Gson gson,
 		@Named("runelite.oauth.redirect") String oauthRedirect,
 		ScheduledExecutorService scheduledExecutorService
 	)
 	{
 		this.eventBus = eventBus;
 		this.sessionFile = sessionfile;
 		this.accountClient = accountClient;
@@ -120,7 +116,7 @@ public void loadSession()
 			return;
 		}
 
+		accountSession = session;
 	}
 
 	private void saveSession()
@@ -155,14 +151,6 @@ private void deleteSession()
 	private void openSession(AccountSession session)
 	{
 		accountSession = session;
 		eventBus.post(new SessionOpen());
 	}
 
@@ -175,9 +163,6 @@ private void closeSession()
 
 		log.debug("Logging out of account {}", accountSession.getUsername());
 
 		// Delete session
 		accountClient.setUuid(accountSession.getUuid());
 		try
@@ -244,7 +229,7 @@ private void startServer() throws IOException
 
 				log.debug("Now signed in as {}", username);
 
+				// open the session, which triggers the sessionopen event
 				AccountSession session = new AccountSession(sessionId, Instant.now(), username);
 				openSession(session);
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>519852</refactoring_id><commit_sha>e2d4f90be1bd523215bcb099361f5305f7d78a0d</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/e2d4f90be1bd523215bcb099361f5305f7d78a0d</commit_link><file_path>underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystem.java</file_path><description>Remove Parameter conf : Configuration in method public connectFromWorker(conf Configuration, hostname String) : void from class alluxio.underfs.swift.SwiftUnderFileSystem</description><code_before>@@ -77,31 +77,30 @@ public class SwiftUnderFileSystem extends UnderFileSystem {
    * Constructs a new Swift {@link UnderFileSystem}.
    *
    * @param uri the {@link AlluxioURI} for this UFS
-   * @param configuration the configuration for Alluxio
    */
-  public SwiftUnderFileSystem(AlluxioURI uri, Configuration configuration) {
-    super(uri, configuration);
     String containerName = uri.getHost();
     LOG.debug("Constructor init: {}", containerName);
     AccountConfig config = new AccountConfig();
-    if (configuration.containsKey(Constants.SWIFT_API_KEY)) {
-      config.setPassword(configuration.get(Constants.SWIFT_API_KEY));
-    } else if (configuration.containsKey(Constants.SWIFT_PASSWORD_KEY)) {
-      config.setPassword(configuration.get(Constants.SWIFT_PASSWORD_KEY));
     }
-    config.setAuthUrl(configuration.get(Constants.SWIFT_AUTH_URL_KEY));
-    String authMethod = configuration.get(Constants.SWIFT_AUTH_METHOD_KEY);
     if (authMethod != null &amp;&amp; authMethod.equals("keystone")) {
       config.setAuthenticationMethod(AuthenticationMethod.KEYSTONE);
-      config.setUsername(configuration.get(Constants.SWIFT_USER_KEY));
-      config.setTenantName(configuration.get(Constants.SWIFT_TENANT_KEY));
     } else {
       config.setAuthenticationMethod(AuthenticationMethod.TEMPAUTH);
       // tempauth requires authentication header to be of the form tenant:user.
       // JOSS however generates header of the form user:tenant.
       // To resolve this, we switch user with tenant
-      config.setTenantName(configuration.get(Constants.SWIFT_USER_KEY));
-      config.setUsername(configuration.get(Constants.SWIFT_TENANT_KEY));
     }
 
     ObjectMapper mapper = new ObjectMapper();
@@ -122,12 +121,12 @@ public void close() throws IOException {
   }
 
   @Override
-  public void connectFromMaster(Configuration conf, String hostname) {
     LOG.debug("connect from master");
   }
 
   @Override
-  public void connectFromWorker(Configuration conf, String hostname) {
     LOG.debug("connect from worker");
   }
 
@@ -211,7 +210,7 @@ public boolean exists(String path) throws IOException {
    */
   @Override
   public long getBlockSizeByte(String path) throws IOException {
-    return mConfiguration.getBytes(Constants.USER_BLOCK_SIZE_BYTES_DEFAULT);
   }
 
   @Override
</code_before><code_after>@@ -77,31 +77,30 @@ public class SwiftUnderFileSystem extends UnderFileSystem {
    * Constructs a new Swift {@link UnderFileSystem}.
    *
    * @param uri the {@link AlluxioURI} for this UFS
    */
+  public SwiftUnderFileSystem(AlluxioURI uri) {
+    super(uri);
     String containerName = uri.getHost();
     LOG.debug("Constructor init: {}", containerName);
     AccountConfig config = new AccountConfig();
+    if (Configuration.containsKey(Constants.SWIFT_API_KEY)) {
+      config.setPassword(Configuration.get(Constants.SWIFT_API_KEY));
+    } else if (Configuration.containsKey(Constants.SWIFT_PASSWORD_KEY)) {
+      config.setPassword(Configuration.get(Constants.SWIFT_PASSWORD_KEY));
     }
+    config.setAuthUrl(Configuration.get(Constants.SWIFT_AUTH_URL_KEY));
+    String authMethod = Configuration.get(Constants.SWIFT_AUTH_METHOD_KEY);
     if (authMethod != null &amp;&amp; authMethod.equals("keystone")) {
       config.setAuthenticationMethod(AuthenticationMethod.KEYSTONE);
+      config.setUsername(Configuration.get(Constants.SWIFT_USER_KEY));
+      config.setTenantName(Configuration.get(Constants.SWIFT_TENANT_KEY));
     } else {
       config.setAuthenticationMethod(AuthenticationMethod.TEMPAUTH);
       // tempauth requires authentication header to be of the form tenant:user.
       // JOSS however generates header of the form user:tenant.
       // To resolve this, we switch user with tenant
+      config.setTenantName(Configuration.get(Constants.SWIFT_USER_KEY));
+      config.setUsername(Configuration.get(Constants.SWIFT_TENANT_KEY));
     }
 
     ObjectMapper mapper = new ObjectMapper();
@@ -122,12 +121,12 @@ public void close() throws IOException {
   }
 
   @Override
+  public void connectFromMaster(String hostname) {
     LOG.debug("connect from master");
   }
 
   @Override
+  public void connectFromWorker(String hostname) {
     LOG.debug("connect from worker");
   }
 
@@ -211,7 +210,7 @@ public boolean exists(String path) throws IOException {
    */
   @Override
   public long getBlockSizeByte(String path) throws IOException {
+    return Configuration.getBytes(Constants.USER_BLOCK_SIZE_BYTES_DEFAULT);
   }
 
   @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>560898</refactoring_id><commit_sha>a01515db8d30f4d64fa6566e37a08df2777c61be</commit_sha><commit_link>https://github.com/broadleafcommerce/broadleafcommerce/commit/a01515db8d30f4d64fa6566e37a08df2777c61be</commit_link><file_path>core/broadleaf-framework-web/src/main/java/org/broadleafcommerce/core/web/api/endpoint/order/CartEndpoint.java</file_path><description>Remove Parameter skuId : Long in method public addSkuToOrder(request HttpServletRequest, uriInfo UriInfo, categoryId Long, productId Long, skuId Long, quantity int, priceOrder boolean) : OrderWrapper from class org.broadleafcommerce.core.web.api.endpoint.order.CartEndpoint</description><code_before>@@ -136,11 +136,10 @@ public OrderWrapper createNewCartForCustomer(HttpServletRequest request) {
      * @param priceOrder
      * @return OrderWrapper
      */
-    public OrderWrapper addSkuToOrder(HttpServletRequest request,
             UriInfo uriInfo,
             Long categoryId,
             Long productId,
-            Long skuId,
             int quantity,
             boolean priceOrder) {
         Customer customer = CustomerState.getCustomer(request);
@@ -170,10 +169,11 @@ public OrderWrapper addSkuToOrder(HttpServletRequest request,
                     productOptions.remove("quantity");
                     productOptions.remove("priceOrder");
 
                     OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
                     orderItemRequestDTO.setCategoryId(categoryId);
                     orderItemRequestDTO.setProductId(productId);
-                    orderItemRequestDTO.setSkuId(skuId);
                     orderItemRequestDTO.setCategoryId(categoryId);
                     orderItemRequestDTO.setQuantity(quantity);
                     
</code_before><code_after>@@ -136,11 +136,10 @@ public OrderWrapper createNewCartForCustomer(HttpServletRequest request) {
      * @param priceOrder
      * @return OrderWrapper
      */
+    public OrderWrapper addProductToOrder(HttpServletRequest request,
             UriInfo uriInfo,
             Long categoryId,
             Long productId,
             int quantity,
             boolean priceOrder) {
         Customer customer = CustomerState.getCustomer(request);
@@ -170,10 +169,11 @@ public OrderWrapper addSkuToOrder(HttpServletRequest request,
                     productOptions.remove("quantity");
                     productOptions.remove("priceOrder");
 
+
+
                     OrderItemRequestDTO orderItemRequestDTO = new OrderItemRequestDTO();
                     orderItemRequestDTO.setCategoryId(categoryId);
                     orderItemRequestDTO.setProductId(productId);
                     orderItemRequestDTO.setCategoryId(categoryId);
                     orderItemRequestDTO.setQuantity(quantity);
                     
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>508917</refactoring_id><commit_sha>914e7a35c1bcd5adbe509954d1b41fe431d4c4f2</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/914e7a35c1bcd5adbe509954d1b41fe431d4c4f2</commit_link><file_path>OsmAnd/src/net/osmand/plus/helpers/AvoidSpecificRoads.java</file_path><description>Remove Parameter a : Activity in method public showOnMap(app OsmandApplication, a Activity, lat double, lon double, name String, dialog DialogInterface) : void from class net.osmand.plus.helpers.AvoidSpecificRoads</description><code_before>@@ -1,13 +1,22 @@
 package net.osmand.plus.helpers;
 
-import java.util.ArrayList;
-import java.util.List;
 
 import net.osmand.CallbackWithObject;
 import net.osmand.Location;
 import net.osmand.ResultMatcher;
 import net.osmand.binary.RouteDataObject;
 import net.osmand.data.LatLon;
 import net.osmand.plus.OsmAndFormatter;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
@@ -17,17 +26,9 @@
 import net.osmand.plus.views.ContextMenuLayer;
 import net.osmand.router.RoutingConfiguration;
 import net.osmand.util.MapUtils;
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.AlertDialog.Builder;
-import android.content.DialogInterface;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.TextView;
-import android.widget.Toast;
 
 public class AvoidSpecificRoads {
 	private List&lt;RouteDataObject&gt; missingRoads;
@@ -114,7 +115,7 @@ public void onClick(DialogInterface dialog, int which) {
 					RouteDataObject obj = getMissingRoads().get(which);
 					double lat = MapUtils.get31LatitudeY(obj.getPoint31YTile(0));
 					double lon = MapUtils.get31LongitudeX(obj.getPoint31XTile(0));
-					showOnMap(app, mapActivity, lat, lon, getText(obj), dialog);
 				}
 
 			});
@@ -172,12 +173,8 @@ public boolean isCancelled() {
 		});
 	}
 	
-	public static void showOnMap(OsmandApplication app, Activity a, double lat, double lon, String name,
 			DialogInterface dialog) {
-		if (!(a instanceof MapActivity)) {
-			return;
-		}
-		MapActivity ctx = (MapActivity) a;
 		AnimateDraggingMapThread thread = ctx.getMapView().getAnimatedDraggingThread();
 		int fZoom = ctx.getMapView().getZoom() &lt; 15 ? 15 : ctx.getMapView().getZoom();
 		if (thread.isAnimating()) {
@@ -186,7 +183,7 @@ public static void showOnMap(OsmandApplication app, Activity a, double lat, doub
 		} else {
 			thread.startMoving(lat, lon, fZoom, true);
 		}
-		ctx.getMapLayers().getContextMenuLayer().showMapContextMenu(new LatLon(lat, lon), name);
 		dialog.dismiss();
 	}
 
</code_before><code_after>@@ -1,13 +1,22 @@
 package net.osmand.plus.helpers;
 
+import android.app.AlertDialog;
+import android.app.AlertDialog.Builder;
+import android.content.DialogInterface;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.TextView;
+import android.widget.Toast;
 
 import net.osmand.CallbackWithObject;
 import net.osmand.Location;
 import net.osmand.ResultMatcher;
 import net.osmand.binary.RouteDataObject;
 import net.osmand.data.LatLon;
+import net.osmand.data.PointDescription;
 import net.osmand.plus.OsmAndFormatter;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
@@ -17,17 +26,9 @@
 import net.osmand.plus.views.ContextMenuLayer;
 import net.osmand.router.RoutingConfiguration;
 import net.osmand.util.MapUtils;
+
+import java.util.ArrayList;
+import java.util.List;
 
 public class AvoidSpecificRoads {
 	private List&lt;RouteDataObject&gt; missingRoads;
@@ -114,7 +115,7 @@ public void onClick(DialogInterface dialog, int which) {
 					RouteDataObject obj = getMissingRoads().get(which);
 					double lat = MapUtils.get31LatitudeY(obj.getPoint31YTile(0));
 					double lon = MapUtils.get31LongitudeX(obj.getPoint31XTile(0));
+					showOnMap(mapActivity, lat, lon, getText(obj), dialog);
 				}
 
 			});
@@ -172,12 +173,8 @@ public boolean isCancelled() {
 		});
 	}
 	
+	private void showOnMap(MapActivity ctx, double lat, double lon, String name,
 			DialogInterface dialog) {
 		AnimateDraggingMapThread thread = ctx.getMapView().getAnimatedDraggingThread();
 		int fZoom = ctx.getMapView().getZoom() &lt; 15 ? 15 : ctx.getMapView().getZoom();
 		if (thread.isAnimating()) {
@@ -186,7 +183,7 @@ public static void showOnMap(OsmandApplication app, Activity a, double lat, doub
 		} else {
 			thread.startMoving(lat, lon, fZoom, true);
 		}
+		ctx.getContextMenu().show(new LatLon(lat, lon), new PointDescription("", name), null);
 		dialog.dismiss();
 	}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>591634</refactoring_id><commit_sha>5be2a40d5a65c033389342f48c6c861db06e946a</commit_sha><commit_link>https://github.com/oracle/graal/commit/5be2a40d5a65c033389342f48c6c861db06e946a</commit_link><file_path>truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/impl/Accessor.java</file_path><description>Remove Parameter threads : Thread[] in method public abstract runThreadLocal(polyglotLanguageContext Object, threads Thread[], action Consumer&lt;ThreadLocalAccess&gt;, async boolean) : Future&lt;Void&gt; from class com.oracle.truffle.api.impl.Accessor.EngineSupport</description><code_before>@@ -58,7 +58,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.Lock;
-import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.logging.Handler;
@@ -80,7 +79,7 @@
 import com.oracle.truffle.api.ContextThreadLocal;
 import com.oracle.truffle.api.InstrumentInfo;
 import com.oracle.truffle.api.RootCallTarget;
-import com.oracle.truffle.api.ThreadLocalAccess;
 import com.oracle.truffle.api.Truffle;
 import com.oracle.truffle.api.TruffleContext;
 import com.oracle.truffle.api.TruffleFile;
@@ -178,6 +177,8 @@ public abstract LanguageInfo createLanguage(Object polyglotLanguage, String id,
         public abstract Object translateStackTraceElement(TruffleStackTraceElement stackTraceLement);
 
         public abstract ExecutionSignature prepareForAOT(RootNode rootNode);
     }
 
     public abstract static class SourceSupport extends Support {
@@ -550,7 +551,9 @@ public abstract &lt;T, G&gt; Iterator&lt;T&gt; mergeHostGuestFrames(StackTraceElement[] host
 
         public abstract long calculateContextHeapSize(Object polyglotContext, long stopAtBytes, AtomicBoolean cancelled);
 
-        public abstract Future&lt;Void&gt; runThreadLocal(Object polyglotLanguageContext, Thread[] threads, Consumer&lt;ThreadLocalAccess&gt; action, boolean async);
     }
 
     public abstract static class LanguageSupport extends Support {
@@ -695,6 +698,11 @@ public abstract Env createEnv(Object polyglotLanguageContext, TruffleLanguage&lt;?&gt;
 
         public abstract Object getScope(Env env);
 
     }
 
     public abstract static class InstrumentSupport extends Support {
@@ -986,8 +994,8 @@ public boolean isNonTruffleClass(Class&lt;?&gt; clazz) {
 
     }
 
-    // A separate class to break the cycle such that Accessor can fully initialize
-    // before ...Accessor classes static initializers run, which call methods from Accessor.
     private static class Constants {
 
         private static final Accessor.LanguageSupport LANGUAGE;
</code_before><code_after>@@ -58,7 +58,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.Lock;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.logging.Handler;
@@ -80,7 +79,7 @@
 import com.oracle.truffle.api.ContextThreadLocal;
 import com.oracle.truffle.api.InstrumentInfo;
 import com.oracle.truffle.api.RootCallTarget;
+import com.oracle.truffle.api.ThreadLocalAction;
 import com.oracle.truffle.api.Truffle;
 import com.oracle.truffle.api.TruffleContext;
 import com.oracle.truffle.api.TruffleFile;
@@ -178,6 +177,8 @@ public abstract LanguageInfo createLanguage(Object polyglotLanguage, String id,
         public abstract Object translateStackTraceElement(TruffleStackTraceElement stackTraceLement);
 
         public abstract ExecutionSignature prepareForAOT(RootNode rootNode);
+
+        public abstract void setPolyglotEngine(RootNode rootNode, Object engine);
     }
 
     public abstract static class SourceSupport extends Support {
@@ -550,7 +551,9 @@ public abstract &lt;T, G&gt; Iterator&lt;T&gt; mergeHostGuestFrames(StackTraceElement[] host
 
         public abstract long calculateContextHeapSize(Object polyglotContext, long stopAtBytes, AtomicBoolean cancelled);
 
+        public abstract Future&lt;Void&gt; submitThreadLocal(Object polyglotLanguageContext, Thread[] threads, ThreadLocalAction action);
+
+        public abstract Object getContext(Object polyglotLanguageContext);
     }
 
     public abstract static class LanguageSupport extends Support {
@@ -695,6 +698,11 @@ public abstract Env createEnv(Object polyglotLanguageContext, TruffleLanguage&lt;?&gt;
 
         public abstract Object getScope(Env env);
 
+        public abstract boolean isSynchronousTLAction(ThreadLocalAction action);
+
+        public abstract boolean isSideEffectingTLAction(ThreadLocalAction action);
+
+        public abstract void performTLAction(ThreadLocalAction action, ThreadLocalAction.Access access);
     }
 
     public abstract static class InstrumentSupport extends Support {
@@ -986,8 +994,8 @@ public boolean isNonTruffleClass(Class&lt;?&gt; clazz) {
 
     }
 
+// A separate class to break the cycle such that Accessor can fully initialize
+// before ...Accessor classes static initializers run, which call methods from Accessor.
     private static class Constants {
 
         private static final Accessor.LanguageSupport LANGUAGE;
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>558841</refactoring_id><commit_sha>b67a15ddd9de4c49432dc4a4ba086e5bb1ef7323</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/b67a15ddd9de4c49432dc4a4ba086e5bb1ef7323</commit_link><file_path>quickstep/recents_ui_overrides/src/com/android/quickstep/TaskViewUtils.java</file_path><description>Remove Parameter wallpaperTargets : RemoteAnimationTargetCompat[] in method public getRecentsWindowAnimator(v TaskView, skipViewChanges boolean, appTargets RemoteAnimationTargetCompat[], wallpaperTargets RemoteAnimationTargetCompat[], inOutHelper AppWindowAnimationHelper) : ValueAnimator from class com.android.quickstep.TaskViewUtils</description><code_before>@@ -17,7 +17,6 @@
 
 import static com.android.launcher3.anim.Interpolators.LINEAR;
 import static com.android.launcher3.anim.Interpolators.TOUCH_RESPONSE_INTERPOLATOR;
-import static com.android.launcher3.config.FeatureFlags.ENABLE_QUICKSTEP_LIVE_TILE;
 import static com.android.systemui.shared.system.RemoteAnimationTargetCompat.MODE_OPENING;
 
 import android.animation.Animator;
@@ -31,18 +30,14 @@
 import com.android.launcher3.BaseDraggingActivity;
 import com.android.launcher3.ItemInfo;
 import com.android.launcher3.Utilities;
-import com.android.quickstep.util.AppWindowAnimationHelper;
 import com.android.quickstep.util.MultiValueUpdateListener;
 import com.android.quickstep.views.RecentsView;
 import com.android.quickstep.views.TaskView;
 import com.android.systemui.shared.recents.model.Task;
 import com.android.systemui.shared.system.RemoteAnimationTargetCompat;
 import com.android.systemui.shared.system.SyncRtSurfaceTransactionApplierCompat;
-import com.android.systemui.shared.system.SyncRtSurfaceTransactionApplierCompat.SurfaceParams;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
 
 /**
  * Utility class for helpful methods related to {@link TaskView} objects and their tasks.
@@ -116,18 +111,15 @@ public static TaskView findTaskViewToLaunch(
      * animation.
      */
     public static ValueAnimator getRecentsWindowAnimator(TaskView v, boolean skipViewChanges,
-            RemoteAnimationTargetCompat[] appTargets,
-            RemoteAnimationTargetCompat[] wallpaperTargets, final AppWindowAnimationHelper inOutHelper) {
         SyncRtSurfaceTransactionApplierCompat applier =
                 new SyncRtSurfaceTransactionApplierCompat(v);
-        final RemoteAnimationTargets targets =
-                new RemoteAnimationTargets(appTargets, wallpaperTargets, MODE_OPENING);
-        targets.addDependentTransactionApplier(applier);
-        AppWindowAnimationHelper.TransformParams params =
-                new AppWindowAnimationHelper.TransformParams()
-                    .setSyncTransactionApplier(applier)
-                    .setTargetSet(targets)
-                    .setLauncherOnTop(true);
 
         final RecentsView recentsView = v.getRecentsView();
         final ValueAnimator appAnimator = ValueAnimator.ofFloat(0, 1);
@@ -148,7 +140,7 @@ public static ValueAnimator getRecentsWindowAnimator(TaskView v, boolean skipVie
                         BaseActivity.fromContext(v.getContext()).getDeviceProfile(),
                         true /* isOpening */);
                 inOutHelper.fromTaskThumbnailView(v.getThumbnail(), (RecentsView) v.getParent(),
-                        targets.apps.length == 0 ? null : targets.apps[0]);
 
                 mThumbnailRect = new RectF(inOutHelper.getTargetRect());
                 mThumbnailRect.offset(-v.getTranslationX(), -v.getTranslationY());
@@ -159,33 +151,7 @@ public static ValueAnimator getRecentsWindowAnimator(TaskView v, boolean skipVie
             public void onUpdate(float percent) {
                 // TODO: Take into account the current fullscreen progress for animating the insets
                 params.setProgress(1 - percent);
-                RectF taskBounds;
-                if (ENABLE_QUICKSTEP_LIVE_TILE.get()) {
-                    List&lt;SurfaceParams&gt; surfaceParamsList = new ArrayList&lt;&gt;();
-                    // Append the surface transform params for the app that's being opened.
-                    Collections.addAll(surfaceParamsList, inOutHelper.getSurfaceParams(params));
-
-                    AppWindowAnimationHelper liveTileAnimationHelper =
-                            v.getRecentsView().getClipAnimationHelper();
-                    if (liveTileAnimationHelper != null) {
-                        // Append the surface transform params for the live tile app.
-                        AppWindowAnimationHelper.TransformParams liveTileParams =
-                                v.getRecentsView().getLiveTileParams(true /* mightNeedToRefill */);
-                        if (liveTileParams != null) {
-                            Collections.addAll(surfaceParamsList,
-                                    liveTileAnimationHelper.getSurfaceParams(liveTileParams));
-                        }
-                    }
-                    // Apply surface transform using the surface params list.
-                    AppWindowAnimationHelper.applySurfaceParams(params.syncTransactionApplier,
-                            surfaceParamsList.toArray(new SurfaceParams[surfaceParamsList.size()]));
-                    // Get the task bounds for the app that's being opened after surface transform
-                    // update.
-                    taskBounds = inOutHelper.updateCurrentRect(params);
-                } else {
-                    taskBounds = inOutHelper.applyTransform(params);
-                }
-
                 int taskIndex = recentsView.indexOfChild(v);
                 int centerTaskIndex = recentsView.getCurrentPage();
                 boolean parallaxCenterAndAdjacentTask = taskIndex != centerTaskIndex;
@@ -202,7 +168,7 @@ public void onUpdate(float percent) {
         appAnimator.addListener(new AnimatorListenerAdapter() {
             @Override
             public void onAnimationEnd(Animator animation) {
-                targets.release();
             }
         });
         return appAnimator;
</code_before><code_after>@@ -17,7 +17,6 @@
 
 import static com.android.launcher3.anim.Interpolators.LINEAR;
 import static com.android.launcher3.anim.Interpolators.TOUCH_RESPONSE_INTERPOLATOR;
 import static com.android.systemui.shared.system.RemoteAnimationTargetCompat.MODE_OPENING;
 
 import android.animation.Animator;
@@ -31,18 +30,14 @@
 import com.android.launcher3.BaseDraggingActivity;
 import com.android.launcher3.ItemInfo;
 import com.android.launcher3.Utilities;
+import com.android.quickstep.util.ClipAnimationHelper;
 import com.android.quickstep.util.MultiValueUpdateListener;
+import com.android.quickstep.util.RemoteAnimationTargetSet;
 import com.android.quickstep.views.RecentsView;
 import com.android.quickstep.views.TaskView;
 import com.android.systemui.shared.recents.model.Task;
 import com.android.systemui.shared.system.RemoteAnimationTargetCompat;
 import com.android.systemui.shared.system.SyncRtSurfaceTransactionApplierCompat;
 
 /**
  * Utility class for helpful methods related to {@link TaskView} objects and their tasks.
@@ -116,18 +111,15 @@ public static TaskView findTaskViewToLaunch(
      * animation.
      */
     public static ValueAnimator getRecentsWindowAnimator(TaskView v, boolean skipViewChanges,
+            RemoteAnimationTargetCompat[] targets, final ClipAnimationHelper inOutHelper) {
         SyncRtSurfaceTransactionApplierCompat applier =
                 new SyncRtSurfaceTransactionApplierCompat(v);
+        ClipAnimationHelper.TransformParams params = new ClipAnimationHelper.TransformParams()
+                .setSyncTransactionApplier(applier);
+
+        final RemoteAnimationTargetSet targetSet =
+                new RemoteAnimationTargetSet(targets, MODE_OPENING);
+        targetSet.addDependentTransactionApplier(applier);
 
         final RecentsView recentsView = v.getRecentsView();
         final ValueAnimator appAnimator = ValueAnimator.ofFloat(0, 1);
@@ -148,7 +140,7 @@ public static ValueAnimator getRecentsWindowAnimator(TaskView v, boolean skipVie
                         BaseActivity.fromContext(v.getContext()).getDeviceProfile(),
                         true /* isOpening */);
                 inOutHelper.fromTaskThumbnailView(v.getThumbnail(), (RecentsView) v.getParent(),
+                        targetSet.apps.length == 0 ? null : targetSet.apps[0]);
 
                 mThumbnailRect = new RectF(inOutHelper.getTargetRect());
                 mThumbnailRect.offset(-v.getTranslationX(), -v.getTranslationY());
@@ -159,33 +151,7 @@ public static ValueAnimator getRecentsWindowAnimator(TaskView v, boolean skipVie
             public void onUpdate(float percent) {
                 // TODO: Take into account the current fullscreen progress for animating the insets
                 params.setProgress(1 - percent);
+                RectF taskBounds = inOutHelper.applyTransform(targetSet, params);
                 int taskIndex = recentsView.indexOfChild(v);
                 int centerTaskIndex = recentsView.getCurrentPage();
                 boolean parallaxCenterAndAdjacentTask = taskIndex != centerTaskIndex;
@@ -202,7 +168,7 @@ public void onUpdate(float percent) {
         appAnimator.addListener(new AnimatorListenerAdapter() {
             @Override
             public void onAnimationEnd(Animator animation) {
+                targetSet.release();
             }
         });
         return appAnimator;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>569041</refactoring_id><commit_sha>54226aa282d9fa2c8a4cb8bad7e0d29e94adb72e</commit_sha><commit_link>https://github.com/freeplane/freeplane/commit/54226aa282d9fa2c8a4cb8bad7e0d29e94adb72e</commit_link><file_path>freeplane/src/org/freeplane/main/applet/AppletResourceController.java</file_path><description>Remove Parameter controller : Controller in method public saveProperties(controller Controller) : void from class org.freeplane.main.applet.AppletResourceController</description><code_before>@@ -29,7 +29,6 @@
 
 import javax.swing.JApplet;
 
-import org.freeplane.core.controller.Controller;
 import org.freeplane.core.resources.ResourceController;
 
 /**
@@ -96,8 +95,8 @@ public URL getResource(final String name) {
 	}
 
 	@Override
-	public void init(final Controller controller) {
-		super.init(controller);
 	}
 
 	@Override
@@ -111,7 +110,7 @@ public void loadPropertiesFromXML(final InputStream in) throws IOException, Inva
 	}
 
 	@Override
-	public void saveProperties(final Controller controller) {
 	}
 
 	@Override
</code_before><code_after>@@ -29,7 +29,6 @@
 
 import javax.swing.JApplet;
 
 import org.freeplane.core.resources.ResourceController;
 
 /**
@@ -96,8 +95,8 @@ public URL getResource(final String name) {
 	}
 
 	@Override
+	public void init() {
+		super.init();
 	}
 
 	@Override
@@ -111,7 +110,7 @@ public void loadPropertiesFromXML(final InputStream in) throws IOException, Inva
 	}
 
 	@Override
+	public void saveProperties() {
 	}
 
 	@Override
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>497512</refactoring_id><commit_sha>251ab596f5d39d804986e7b1dd988bca1772e3e4</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/251ab596f5d39d804986e7b1dd988bca1772e3e4</commit_link><file_path>src/main/java/mekanism/client/render/ctm/ChiselFace.java</file_path><description>Remove Parameter layer : EnumWorldBlockLayer in method public ChiselFace(location ResourceLocation, layer EnumWorldBlockLayer) from class mekanism.client.render.ctm.ChiselFace</description><code_before>@@ -5,7 +5,6 @@
 
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.util.EnumWorldBlockLayer;
-import net.minecraft.util.ResourceLocation;
 
 /**
  * Chisel Face, basically a list of IChiselTexture's
@@ -16,23 +15,20 @@ public final class ChiselFace {
 
     private List&lt;ChiselFace&gt; childFaces;
 
-    private ResourceLocation location;
-
     private EnumWorldBlockLayer layer;
 
-    public ChiselFace(ResourceLocation location) {
-        this(new ArrayList&lt;&gt;(), new ArrayList&lt;&gt;(), location);
     }
 
-    public ChiselFace(ResourceLocation location, EnumWorldBlockLayer layer) {
-        this(location);
         setLayer(layer);
     }
 
-    public ChiselFace(List&lt;ChiselTextureCTM&gt; textureList, List&lt;ChiselFace&gt; childFaces, ResourceLocation location) {
         this.textureList = textureList;
         this.childFaces = childFaces;
-        this.location = location;
     }
 
     public List&lt;ChiselTextureCTM&gt; getTextureList(){
@@ -69,11 +65,6 @@ public TextureAtlasSprite getParticle(){
         }
     }
 
-    public ResourceLocation getLocation(){
-        return this.location;
-    }
-
-
     public void setLayer(EnumWorldBlockLayer layer){
         this.layer = layer;
     }
</code_before><code_after>@@ -5,7 +5,6 @@
 
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.util.EnumWorldBlockLayer;
 
 /**
  * Chisel Face, basically a list of IChiselTexture's
@@ -16,23 +15,20 @@ public final class ChiselFace {
 
     private List&lt;ChiselFace&gt; childFaces;
 
     private EnumWorldBlockLayer layer;
 
+    public ChiselFace() {
+        this(new ArrayList&lt;&gt;(), new ArrayList&lt;&gt;());
     }
 
+    public ChiselFace(EnumWorldBlockLayer layer) {
+        this();
         setLayer(layer);
     }
 
+    public ChiselFace(List&lt;ChiselTextureCTM&gt; textureList, List&lt;ChiselFace&gt; childFaces) {
         this.textureList = textureList;
         this.childFaces = childFaces;
     }
 
     public List&lt;ChiselTextureCTM&gt; getTextureList(){
@@ -69,11 +65,6 @@ public TextureAtlasSprite getParticle(){
         }
     }
 
     public void setLayer(EnumWorldBlockLayer layer){
         this.layer = layer;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>495340</refactoring_id><commit_sha>d8e057e5c52f768494962fbf5527c6840221325c</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/d8e057e5c52f768494962fbf5527c6840221325c</commit_link><file_path>broker/src/main/java/io/camunda/zeebe/broker/bootstrap/BrokerContextImpl.java</file_path><description>Remove Parameter diskSpaceUsageListeners : List&lt;DiskSpaceUsageListener&gt; in method public BrokerContextImpl(clusterServices ClusterServicesImpl, commandApiService CommandApiService, embeddedGatewayService EmbeddedGatewayService, partitionListeners List&lt;PartitionListener&gt;, diskSpaceUsageListeners List&lt;DiskSpaceUsageListener&gt;) from class io.camunda.zeebe.broker.bootstrap.BrokerContextImpl</description><code_before>@@ -14,6 +14,7 @@
 import io.camunda.zeebe.broker.clustering.ClusterServicesImpl;
 import io.camunda.zeebe.broker.system.EmbeddedGatewayService;
 import io.camunda.zeebe.broker.system.monitoring.DiskSpaceUsageListener;
 import io.camunda.zeebe.broker.transport.commandapi.CommandApiService;
 import java.util.Collection;
 import java.util.List;
@@ -23,20 +24,21 @@ public final class BrokerContextImpl implements BrokerContext {
   private final ClusterServicesImpl clusterServices;
   private final CommandApiService commandApiService;
   private final EmbeddedGatewayService embeddedGatewayService;
   private final List&lt;PartitionListener&gt; partitionListeners;
-  private final List&lt;DiskSpaceUsageListener&gt; diskSpaceUsageListeners;
 
   public BrokerContextImpl(
       final ClusterServicesImpl clusterServices,
       final CommandApiService commandApiService,
       final EmbeddedGatewayService embeddedGatewayService,
-      final List&lt;PartitionListener&gt; partitionListeners,
-      final List&lt;DiskSpaceUsageListener&gt; diskSpaceUsageListeners) {
     this.clusterServices = requireNonNull(clusterServices);
     this.commandApiService = requireNonNull(commandApiService);
     this.embeddedGatewayService = embeddedGatewayService;
     this.partitionListeners = unmodifiableList(requireNonNull(partitionListeners));
-    this.diskSpaceUsageListeners = diskSpaceUsageListeners;
   }
 
   @Override
@@ -55,12 +57,19 @@ public CommandApiService getCommandApiService() {
   }
 
   @Override
-  public List&lt;DiskSpaceUsageListener&gt; getDiskSpaceUsageListeners() {
-    return diskSpaceUsageListeners;
   }
 
   @Override
-  public EmbeddedGatewayService getEmbeddedGatewayService() {
-    return embeddedGatewayService;
   }
 }
</code_before><code_after>@@ -14,6 +14,7 @@
 import io.camunda.zeebe.broker.clustering.ClusterServicesImpl;
 import io.camunda.zeebe.broker.system.EmbeddedGatewayService;
 import io.camunda.zeebe.broker.system.monitoring.DiskSpaceUsageListener;
+import io.camunda.zeebe.broker.system.monitoring.DiskSpaceUsageMonitor;
 import io.camunda.zeebe.broker.transport.commandapi.CommandApiService;
 import java.util.Collection;
 import java.util.List;
@@ -23,20 +24,21 @@ public final class BrokerContextImpl implements BrokerContext {
   private final ClusterServicesImpl clusterServices;
   private final CommandApiService commandApiService;
   private final EmbeddedGatewayService embeddedGatewayService;
+  private final DiskSpaceUsageMonitor diskSpaceUsageMonitor;
   private final List&lt;PartitionListener&gt; partitionListeners;
 
   public BrokerContextImpl(
+      final DiskSpaceUsageMonitor diskSpaceUsageMonitor,
       final ClusterServicesImpl clusterServices,
       final CommandApiService commandApiService,
       final EmbeddedGatewayService embeddedGatewayService,
+      final List&lt;PartitionListener&gt; partitionListeners) {
+    this.diskSpaceUsageMonitor = diskSpaceUsageMonitor;
     this.clusterServices = requireNonNull(clusterServices);
     this.commandApiService = requireNonNull(commandApiService);
     this.embeddedGatewayService = embeddedGatewayService;
+
     this.partitionListeners = unmodifiableList(requireNonNull(partitionListeners));
   }
 
   @Override
@@ -55,12 +57,19 @@ public CommandApiService getCommandApiService() {
   }
 
   @Override
+  public EmbeddedGatewayService getEmbeddedGatewayService() {
+    return embeddedGatewayService;
   }
 
   @Override
+  public void addDiskSpaceUsageListener(final DiskSpaceUsageListener diskSpaceUsageListener) {
+    if (diskSpaceUsageMonitor != null) {
+      diskSpaceUsageMonitor.addDiskUsageListener(diskSpaceUsageListener);
+    }
+  }
+
+  @Override
+  public DiskSpaceUsageMonitor getDiskSpaceUsageMonitor() {
+    return diskSpaceUsageMonitor;
   }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>522702</refactoring_id><commit_sha>7889db43a8ec59324bfe980cd309c42e741edf01</commit_sha><commit_link>https://github.com/anuken/mindustry/commit/7889db43a8ec59324bfe980cd309c42e741edf01</commit_link><file_path>core/src/io/anuke/mindustry/maps/generators/RandomGenerator.java</file_path><description>Remove Parameter floor : Block in method public RandomGenerator(width int, height int, floor Block) from class io.anuke.mindustry.maps.generators.RandomGenerator</description><code_before>@@ -9,9 +9,8 @@ public abstract class RandomGenerator extends Generator{
     protected Block floor;
     protected Block block;
 
-    public RandomGenerator(int width, int height, Block floor){
         super(width, height);
-        this.floor = floor;
     }
 
     @Override
</code_before><code_after>@@ -9,9 +9,8 @@ public abstract class RandomGenerator extends Generator{
     protected Block floor;
     protected Block block;
 
+    public RandomGenerator(int width, int height){
         super(width, height);
     }
 
     @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>574026</refactoring_id><commit_sha>50185b7c3a1fd26e9a8635c28cee70fda32d3fc5</commit_sha><commit_link>https://github.com/apache/cloudstack/commit/50185b7c3a1fd26e9a8635c28cee70fda32d3fc5</commit_link><file_path>server/src/org/apache/cloudstack/affinity/AffinityGroupServiceImpl.java</file_path><description>Remove Parameter oldState : State in method public postStateTransitionEvent(oldState State, event Event, newState State, vo VirtualMachine, status boolean, opaque Object) : boolean from class org.apache.cloudstack.affinity.AffinityGroupServiceImpl</description><code_before>@@ -26,6 +26,7 @@
 import javax.inject.Inject;
 import javax.naming.ConfigurationException;
 
 import org.apache.log4j.Logger;
 
 import org.apache.cloudstack.acl.ControlledEntity;
@@ -439,20 +440,21 @@ public boolean preStateTransitionEvent(State oldState, Event event, State newSta
     }
 
     @Override
-    public boolean postStateTransitionEvent(State oldState, Event event, State newState, VirtualMachine vo, boolean status, Object opaque) {
-        if (!status) {
-            return false;
-        }
-        if ((newState == State.Expunging) || (newState == State.Error)) {
-            // cleanup all affinity groups associations of the Expunged VM
-            SearchCriteria&lt;AffinityGroupVMMapVO&gt; sc = _affinityGroupVMMapDao.createSearchCriteria();
-            sc.addAnd("instanceId", SearchCriteria.Op.EQ, vo.getId());
-            _affinityGroupVMMapDao.expunge(sc);
-        }
-        return true;
     }
 
-    @Override
     public UserVm updateVMAffinityGroups(Long vmId, List&lt;Long&gt; affinityGroupIds) {
         // Verify input parameters
         UserVmVO vmInstance = _userVmDao.findById(vmId);
</code_before><code_after>@@ -26,6 +26,7 @@
 import javax.inject.Inject;
 import javax.naming.ConfigurationException;
 
+import com.cloud.utils.fsm.StateMachine2;
 import org.apache.log4j.Logger;
 
 import org.apache.cloudstack.acl.ControlledEntity;
@@ -439,20 +440,21 @@ public boolean preStateTransitionEvent(State oldState, Event event, State newSta
     }
 
     @Override
+    public boolean postStateTransitionEvent(StateMachine2.Transition&lt;State, Event&gt; transition, VirtualMachine vo, boolean status, Object opaque) {
+      if (!status) {
+        return false;
+      }
+      State newState = transition.getToState();
+      if ((newState == State.Expunging) || (newState == State.Error)) {
+        // cleanup all affinity groups associations of the Expunged VM
+        SearchCriteria&lt;AffinityGroupVMMapVO&gt; sc = _affinityGroupVMMapDao.createSearchCriteria();
+        sc.addAnd("instanceId", SearchCriteria.Op.EQ, vo.getId());
+        _affinityGroupVMMapDao.expunge(sc);
+      }
+      return true;
     }
 
+  @Override
     public UserVm updateVMAffinityGroups(Long vmId, List&lt;Long&gt; affinityGroupIds) {
         // Verify input parameters
         UserVmVO vmInstance = _userVmDao.findById(vmId);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>481168</refactoring_id><commit_sha>bff7f7d57f64b4fee25f37a86007b07d3de3388e</commit_sha><commit_link>https://github.com/batfish/batfish/commit/bff7f7d57f64b4fee25f37a86007b07d3de3388e</commit_link><file_path>projects/batfish/src/main/java/org/batfish/main/Batfish.java</file_path><description>Remove Parameter tag : String in method private populateFlowHistory(flowHistory FlowHistory, environmentName String, tag String) : void from class org.batfish.main.Batfish</description><code_before>@@ -136,6 +136,7 @@
 import org.batfish.datamodel.collections.NodeVrfSet;
 import org.batfish.datamodel.collections.RoutesByVrf;
 import org.batfish.datamodel.collections.TreeMultiSet;
 import org.batfish.datamodel.questions.Question;
 import org.batfish.datamodel.questions.Question.InstanceData;
 import org.batfish.datamodel.questions.Question.InstanceData.Variable;
@@ -1680,10 +1681,10 @@ public TestrigSettings getDeltaTestrigSettings() {
   @Override
   public String getDifferentialFlowTag() {
     // return _settings.getQuestionName() + ":" +
-    // _baseTestrigSettings.getName()
-    // + ":" + _baseTestrigSettings.getEnvironmentSettings().getName()
-    // + ":" + _deltaTestrigSettings.getName() + ":"
-    // + _deltaTestrigSettings.getEnvironmentSettings().getName();
     return DIFFERENTIAL_FLOW_TAG;
   }
 
@@ -1704,6 +1705,22 @@ private double getElapsedTime(long beforeTime) {
     return seconds;
   }
 
   private SortedMap&lt;String, BgpAdvertisementsByVrf&gt; getEnvironmentBgpTables(
       Path inputPath, ParseEnvironmentBgpTablesAnswerElement answerElement) {
     if (Files.exists(inputPath.getParent()) &amp;&amp; !Files.exists(inputPath)) {
@@ -1736,9 +1753,9 @@ public String getFlowTag() {
   }
 
   public String getFlowTag(TestrigSettings testrigSettings) {
-    // return _settings.getQuestionName() + ":" + testrigSettings.getName() +
     // ":"
-    // + testrigSettings.getEnvironmentSettings().getName();
     if (testrigSettings == _deltaTestrigSettings) {
       return DELTA_TESTRIG_TAG;
     } else if (testrigSettings == _baseTestrigSettings) {
@@ -1757,25 +1774,28 @@ public GrammarSettings getGrammarSettings() {
   public FlowHistory getHistory() {
     FlowHistory flowHistory = new FlowHistory();
     if (_settings.getDiffQuestion()) {
-      String tag = getDifferentialFlowTag();
-      // String baseName = _baseTestrigSettings.getName() + ":"
-      // + _baseTestrigSettings.getEnvironmentSettings().getName();
-      String baseName = getFlowTag(_baseTestrigSettings);
-      // String deltaName = _deltaTestrigSettings.getName() + ":"
-      // + _deltaTestrigSettings.getEnvironmentSettings().getName();
-      String deltaName = getFlowTag(_deltaTestrigSettings);
       pushBaseEnvironment();
-      populateFlowHistory(flowHistory, baseName, tag);
       popEnvironment();
       pushDeltaEnvironment();
-      populateFlowHistory(flowHistory, deltaName, tag);
       popEnvironment();
     } else {
-      String tag = getFlowTag();
-      // String name = testrigSettings.getName() + ":"
-      // + testrigSettings.getEnvironmentSettings().getName();
-      String envName = tag;
-      populateFlowHistory(flowHistory, envName, tag);
     }
     _logger.debug(flowHistory.toString());
     return flowHistory;
@@ -3236,15 +3256,16 @@ public void popEnvironment() {
     _testrigSettingsStack.remove(lastIndex);
   }
 
-  private void populateFlowHistory(FlowHistory flowHistory, String environmentName, String tag) {
     List&lt;Flow&gt; flows = _dataPlanePlugin.getHistoryFlows();
     List&lt;FlowTrace&gt; flowTraces = _dataPlanePlugin.getHistoryFlowTraces();
     int numEntries = flows.size();
     for (int i = 0; i &lt; numEntries; i++) {
       Flow flow = flows.get(i);
-      if (flow.getTag().equals(tag)) {
         FlowTrace flowTrace = flowTraces.get(i);
-        flowHistory.addFlowTrace(flow, environmentName, flowTrace);
       }
     }
   }
</code_before><code_after>@@ -136,6 +136,7 @@
 import org.batfish.datamodel.collections.NodeVrfSet;
 import org.batfish.datamodel.collections.RoutesByVrf;
 import org.batfish.datamodel.collections.TreeMultiSet;
+import org.batfish.datamodel.pojo.Environment;
 import org.batfish.datamodel.questions.Question;
 import org.batfish.datamodel.questions.Question.InstanceData;
 import org.batfish.datamodel.questions.Question.InstanceData.Variable;
@@ -1680,10 +1681,10 @@ public TestrigSettings getDeltaTestrigSettings() {
   @Override
   public String getDifferentialFlowTag() {
     // return _settings.getQuestionName() + ":" +
+    // _baseTestrigSettings.getEnvName()
+    // + ":" + _baseTestrigSettings.getEnvironmentSettings().getEnvName()
+    // + ":" + _deltaTestrigSettings.getEnvName() + ":"
+    // + _deltaTestrigSettings.getEnvironmentSettings().getEnvName();
     return DIFFERENTIAL_FLOW_TAG;
   }
 
@@ -1704,6 +1705,22 @@ private double getElapsedTime(long beforeTime) {
     return seconds;
   }
 
+  public Environment getEnvironment() {
+    EdgeSet edgeBlackList = getEdgeBlacklist();
+    Set&lt;NodeInterfacePair&gt; interfaceBlackList = getInterfaceBlacklist();
+    NodeSet nodeBlackList = getNodeBlacklist();
+    // TODO: add bgp tables and external announcements as well
+    return new Environment(
+        getEnvironmentName(),
+        getTestrigName(),
+        edgeBlackList,
+        interfaceBlackList,
+        nodeBlackList,
+        null,
+        null,
+        null);
+  }
+
   private SortedMap&lt;String, BgpAdvertisementsByVrf&gt; getEnvironmentBgpTables(
       Path inputPath, ParseEnvironmentBgpTablesAnswerElement answerElement) {
     if (Files.exists(inputPath.getParent()) &amp;&amp; !Files.exists(inputPath)) {
@@ -1736,9 +1753,9 @@ public String getFlowTag() {
   }
 
   public String getFlowTag(TestrigSettings testrigSettings) {
+    // return _settings.getQuestionName() + ":" + testrigSettings.getEnvName() +
     // ":"
+    // + testrigSettings.getEnvironmentSettings().getEnvName();
     if (testrigSettings == _deltaTestrigSettings) {
       return DELTA_TESTRIG_TAG;
     } else if (testrigSettings == _baseTestrigSettings) {
@@ -1757,25 +1774,28 @@ public GrammarSettings getGrammarSettings() {
   public FlowHistory getHistory() {
     FlowHistory flowHistory = new FlowHistory();
     if (_settings.getDiffQuestion()) {
+      String flowTag = getDifferentialFlowTag();
+      // String baseEnvTag = _baseTestrigSettings.getEnvName() + ":"
+      // + _baseTestrigSettings.getEnvironmentSettings().getEnvName();
+      String baseEnvTag = getFlowTag(_baseTestrigSettings);
+      // String deltaName = _deltaTestrigSettings.getEnvName() + ":"
+      // + _deltaTestrigSettings.getEnvironmentSettings().getEnvName();
+      String deltaEnvTag = getFlowTag(_deltaTestrigSettings);
       pushBaseEnvironment();
+      Environment baseEnv = getEnvironment();
+      populateFlowHistory(flowHistory, baseEnvTag, baseEnv, flowTag);
       popEnvironment();
       pushDeltaEnvironment();
+      Environment deltaEnv = getEnvironment();
+      populateFlowHistory(flowHistory, deltaEnvTag, deltaEnv, flowTag);
       popEnvironment();
     } else {
+      String flowTag = getFlowTag();
+      // String name = testrigSettings.getEnvName() + ":"
+      // + testrigSettings.getEnvironmentSettings().getEnvName();
+      String envTag = flowTag;
+      Environment env = getEnvironment();
+      populateFlowHistory(flowHistory, envTag, env, flowTag);
     }
     _logger.debug(flowHistory.toString());
     return flowHistory;
@@ -3236,15 +3256,16 @@ public void popEnvironment() {
     _testrigSettingsStack.remove(lastIndex);
   }
 
+  private void populateFlowHistory(
+      FlowHistory flowHistory, String envTag, Environment environment, String flowTag) {
     List&lt;Flow&gt; flows = _dataPlanePlugin.getHistoryFlows();
     List&lt;FlowTrace&gt; flowTraces = _dataPlanePlugin.getHistoryFlowTraces();
     int numEntries = flows.size();
     for (int i = 0; i &lt; numEntries; i++) {
       Flow flow = flows.get(i);
+      if (flow.getTag().equals(flowTag)) {
         FlowTrace flowTrace = flowTraces.get(i);
+        flowHistory.addFlowTrace(flow, envTag, environment, flowTrace);
       }
     }
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>558272</refactoring_id><commit_sha>bc5bfc11196d40234f077b1e8de07e4d9ad80263</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/bc5bfc11196d40234f077b1e8de07e4d9ad80263</commit_link><file_path>quickstep/src/com/android/quickstep/ActivityControlHelper.java</file_path><description>Remove Parameter assistDataReceiver : AssistDataReceiver in method public startRecents(context Context, intent Intent, assistDataReceiver AssistDataReceiver, remoteAnimationListener RecentsAnimationListener) : void from class com.android.quickstep.ActivityControlHelper.FallbackActivityControllerHelper</description><code_before>@@ -36,8 +36,10 @@
 import com.android.launcher3.DeviceProfile;
 import com.android.launcher3.Launcher;
 import com.android.launcher3.LauncherAppState;
 import com.android.launcher3.LauncherInitListener;
 import com.android.launcher3.LauncherState;
 import com.android.launcher3.allapps.AllAppsTransitionController;
 import com.android.launcher3.anim.AnimatorPlaybackController;
 import com.android.launcher3.util.ViewOnDrawExecutor;
@@ -80,7 +82,10 @@ public interface ActivityControlHelper&lt;T extends BaseDraggingActivity&gt; {
 
     ActivityInitListener createActivityInitListener(BiPredicate&lt;T, Boolean&gt; onInitListener);
 
-    void startRecents(Context context, Intent intent, AssistDataReceiver assistDataReceiver,
             RecentsAnimationListener remoteAnimationListener);
 
     @UiThread
@@ -203,21 +208,44 @@ public ActivityInitListener createActivityInitListener(
         }
 
         @Override
-        public void startRecents(Context context, Intent intent,
-                AssistDataReceiver assistDataReceiver,
-                RecentsAnimationListener remoteAnimationListener) {
             ActivityManagerWrapper.getInstance().startRecentsActivity(
                     intent, assistDataReceiver, remoteAnimationListener, null, null);
         }
 
         @Nullable
         @UiThread
-        private Launcher getVisibleLaucher() {
             LauncherAppState app = LauncherAppState.getInstanceNoCreate();
             if (app == null) {
                 return null;
             }
-            Launcher launcher = (Launcher) app.getModel().getCallback();
             return (launcher != null) &amp;&amp; launcher.isStarted() &amp;&amp; launcher.hasWindowFocus() ?
                     launcher : null;
         }
@@ -325,12 +353,23 @@ public ActivityInitListener createActivityInitListener(
         }
 
         @Override
-        public void startRecents(Context context, Intent intent,
-                AssistDataReceiver assistDataReceiver,
                 final RecentsAnimationListener remoteAnimationListener) {
-            ActivityOptions options =
-                    ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(
-                            new FallbackActivityOptions(remoteAnimationListener), 10000, 10000));
             context.startActivity(intent, options.toBundle());
         }
 
</code_before><code_after>@@ -36,8 +36,10 @@
 import com.android.launcher3.DeviceProfile;
 import com.android.launcher3.Launcher;
 import com.android.launcher3.LauncherAppState;
+import com.android.launcher3.LauncherAppTransitionManagerImpl;
 import com.android.launcher3.LauncherInitListener;
 import com.android.launcher3.LauncherState;
+import com.android.launcher3.MainThreadExecutor;
 import com.android.launcher3.allapps.AllAppsTransitionController;
 import com.android.launcher3.anim.AnimatorPlaybackController;
 import com.android.launcher3.util.ViewOnDrawExecutor;
@@ -80,7 +82,10 @@ public interface ActivityControlHelper&lt;T extends BaseDraggingActivity&gt; {
 
     ActivityInitListener createActivityInitListener(BiPredicate&lt;T, Boolean&gt; onInitListener);
 
+    void startRecentsFromSwipe(Intent intent, AssistDataReceiver assistDataReceiver,
+            final RecentsAnimationListener remoteAnimationListener);
+
+    void startRecentsFromButton(Context context, Intent intent,
             RecentsAnimationListener remoteAnimationListener);
 
     @UiThread
@@ -203,21 +208,44 @@ public ActivityInitListener createActivityInitListener(
         }
 
         @Override
+        public void startRecentsFromSwipe(Intent intent, AssistDataReceiver assistDataReceiver,
+                final RecentsAnimationListener remoteAnimationListener) {
             ActivityManagerWrapper.getInstance().startRecentsActivity(
                     intent, assistDataReceiver, remoteAnimationListener, null, null);
         }
 
+        @Override
+        public void startRecentsFromButton(Context context, Intent intent,
+                RecentsAnimationListener remoteAnimationListener) {
+            // We should use the remove animation for the fallback activity recents button case,
+            // it works better with PiP.  In Launcher, we have already registered the remote
+            // animation definition, which takes priority over explicitly defined remote
+            // animations in the provided activity options when starting the activity, so we
+            // just register a remote animation factory to get a callback to handle this.
+            LauncherAppTransitionManagerImpl appTransitionManager =
+                    (LauncherAppTransitionManagerImpl) getLauncher().getAppTransitionManager();
+            appTransitionManager.setRemoteAnimationOverride(new RecentsAnimationActivityOptions(
+                    remoteAnimationListener, () -&gt; {
+                        // Once the controller is finished, also reset the remote animation override
+                        appTransitionManager.setRemoteAnimationOverride(null);
+                    }));
+            context.startActivity(intent);
+        }
+
         @Nullable
         @UiThread
+        private Launcher getLauncher() {
             LauncherAppState app = LauncherAppState.getInstanceNoCreate();
             if (app == null) {
                 return null;
             }
+            return (Launcher) app.getModel().getCallback();
+        }
+
+        @Nullable
+        @UiThread
+        private Launcher getVisibleLaucher() {
+            Launcher launcher = getLauncher();
             return (launcher != null) &amp;&amp; launcher.isStarted() &amp;&amp; launcher.hasWindowFocus() ?
                     launcher : null;
         }
@@ -325,12 +353,23 @@ public ActivityInitListener createActivityInitListener(
         }
 
         @Override
+        public void startRecentsFromSwipe(Intent intent, AssistDataReceiver assistDataReceiver,
                 final RecentsAnimationListener remoteAnimationListener) {
+            // We can use the normal recents animation for swipe up
+            ActivityManagerWrapper.getInstance().startRecentsActivity(
+                    intent, assistDataReceiver, remoteAnimationListener, null, null);
+        }
+
+        @Override
+        public void startRecentsFromButton(Context context, Intent intent,
+                RecentsAnimationListener remoteAnimationListener) {
+            // We should use the remove animation for the fallback activity recents button case,
+            // it works better with PiP. For the fallback activity, we should not have registered
+            // the launcher app transition manager, so we should just start the remote animation here.
+            ActivityOptions options = ActivityOptionsCompat.makeRemoteAnimation(
+                    new RemoteAnimationAdapterCompat(
+                            new RecentsAnimationActivityOptions(remoteAnimationListener, null),
+                            10000, 10000));
             context.startActivity(intent, options.toBundle());
         }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>587123</refactoring_id><commit_sha>408408ad46ae5c84b6eab38af5020a70490ec3f6</commit_sha><commit_link>https://github.com/oracle/graal/commit/408408ad46ae5c84b6eab38af5020a70490ec3f6</commit_link><file_path>substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/graal/snippets/TypeSnippets.java</file_path><description>Remove Parameter snippetReflection : SnippetReflectionProvider in method public InstanceOfLowering(options OptionValues, factories Iterable&lt;DebugHandlersFactory&gt;, providers Providers, snippetReflection SnippetReflectionProvider, target TargetDescription) from class com.oracle.svm.core.graal.snippets.TypeSnippets.InstanceOfLowering</description><code_before>@@ -30,10 +30,8 @@
 import java.util.Map;
 
 import org.graalvm.compiler.api.replacements.Snippet;
-import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 import org.graalvm.compiler.core.common.calc.UnsignedMath;
 import org.graalvm.compiler.core.common.type.TypeReference;
-import org.graalvm.compiler.debug.DebugHandlersFactory;
 import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 import org.graalvm.compiler.nodes.PiNode;
@@ -51,14 +49,11 @@
 import org.graalvm.compiler.replacements.Snippets;
 
 import com.oracle.svm.core.annotate.DuplicatedInNativeCode;
-import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.graal.meta.RuntimeConfiguration;
 import com.oracle.svm.core.graal.word.DynamicHubAccess;
 import com.oracle.svm.core.hub.DynamicHub;
 import com.oracle.svm.core.meta.SharedType;
 
-import jdk.vm.ci.code.TargetDescription;
-
 public final class TypeSnippets extends SubstrateTemplates implements Snippets {
 
     @Snippet
@@ -151,22 +146,19 @@ private static SubstrateIntrinsics.Any slotTypeCheck(
     }
 
     @SuppressWarnings("unused")
-    public static void registerLowerings(RuntimeConfiguration runtimeConfig, OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers,
-                    SnippetReflectionProvider snippetReflection,
-                    Map&lt;Class&lt;? extends Node&gt;, NodeLoweringProvider&lt;?&gt;&gt; lowerings) {
-        new TypeSnippets(options, runtimeConfig, factories, providers, snippetReflection, lowerings);
     }
 
     final RuntimeConfiguration runtimeConfig;
 
-    private TypeSnippets(OptionValues options, RuntimeConfiguration runtimeConfig, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection,
-                    Map&lt;Class&lt;? extends Node&gt;, NodeLoweringProvider&lt;?&gt;&gt; lowerings) {
-        super(options, factories, providers, snippetReflection);
         this.runtimeConfig = runtimeConfig;
 
-        lowerings.put(InstanceOfNode.class, new InstanceOfLowering(options, factories, providers, snippetReflection, ConfigurationValues.getTarget()));
-        lowerings.put(InstanceOfDynamicNode.class, new InstanceOfDynamicLowering(options, factories, providers, snippetReflection, ConfigurationValues.getTarget()));
-        lowerings.put(ClassIsAssignableFromNode.class, new ClassIsAssignableFromLowering(options, factories, providers, snippetReflection, ConfigurationValues.getTarget()));
     }
 
     final SnippetTemplate.SnippetInfo typeEquality = snippet(TypeSnippets.class, "typeEqualitySnippet");
@@ -175,8 +167,8 @@ protected class InstanceOfLowering extends InstanceOfSnippetsTemplates implement
 
         private final SnippetTemplate.SnippetInfo instanceOf = snippet(TypeSnippets.class, "instanceOfSnippet");
 
-        public InstanceOfLowering(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection, TargetDescription target) {
-            super(options, factories, providers, snippetReflection, target);
         }
 
         @Override
@@ -223,9 +215,8 @@ protected class InstanceOfDynamicLowering extends InstanceOfSnippetsTemplates im
 
         private final SnippetTemplate.SnippetInfo instanceOfDynamic = snippet(TypeSnippets.class, "instanceOfDynamicSnippet");
 
-        public InstanceOfDynamicLowering(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection,
-                        TargetDescription target) {
-            super(options, factories, providers, snippetReflection, target);
         }
 
         @Override
@@ -265,9 +256,8 @@ protected SnippetTemplate.Arguments makeArguments(InstanceOfUsageReplacer replac
     protected class ClassIsAssignableFromLowering extends InstanceOfSnippetsTemplates implements NodeLoweringProvider&lt;FloatingNode&gt; {
         private final SnippetTemplate.SnippetInfo assignableTypeCheck = snippet(TypeSnippets.class, "classIsAssignableFromSnippet");
 
-        public ClassIsAssignableFromLowering(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection,
-                        TargetDescription target) {
-            super(options, factories, providers, snippetReflection, target);
         }
 
         @Override
</code_before><code_after>@@ -30,10 +30,8 @@
 import java.util.Map;
 
 import org.graalvm.compiler.api.replacements.Snippet;
 import org.graalvm.compiler.core.common.calc.UnsignedMath;
 import org.graalvm.compiler.core.common.type.TypeReference;
 import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 import org.graalvm.compiler.nodes.PiNode;
@@ -51,14 +49,11 @@
 import org.graalvm.compiler.replacements.Snippets;
 
 import com.oracle.svm.core.annotate.DuplicatedInNativeCode;
 import com.oracle.svm.core.graal.meta.RuntimeConfiguration;
 import com.oracle.svm.core.graal.word.DynamicHubAccess;
 import com.oracle.svm.core.hub.DynamicHub;
 import com.oracle.svm.core.meta.SharedType;
 
 public final class TypeSnippets extends SubstrateTemplates implements Snippets {
 
     @Snippet
@@ -151,22 +146,19 @@ private static SubstrateIntrinsics.Any slotTypeCheck(
     }
 
     @SuppressWarnings("unused")
+    public static void registerLowerings(RuntimeConfiguration runtimeConfig, OptionValues options, Providers providers, Map&lt;Class&lt;? extends Node&gt;, NodeLoweringProvider&lt;?&gt;&gt; lowerings) {
+        new TypeSnippets(options, runtimeConfig, providers, lowerings);
     }
 
     final RuntimeConfiguration runtimeConfig;
 
+    private TypeSnippets(OptionValues options, RuntimeConfiguration runtimeConfig, Providers providers, Map&lt;Class&lt;? extends Node&gt;, NodeLoweringProvider&lt;?&gt;&gt; lowerings) {
+        super(options, providers);
         this.runtimeConfig = runtimeConfig;
 
+        lowerings.put(InstanceOfNode.class, new InstanceOfLowering(options, providers));
+        lowerings.put(InstanceOfDynamicNode.class, new InstanceOfDynamicLowering(options, providers));
+        lowerings.put(ClassIsAssignableFromNode.class, new ClassIsAssignableFromLowering(options, providers));
     }
 
     final SnippetTemplate.SnippetInfo typeEquality = snippet(TypeSnippets.class, "typeEqualitySnippet");
@@ -175,8 +167,8 @@ protected class InstanceOfLowering extends InstanceOfSnippetsTemplates implement
 
         private final SnippetTemplate.SnippetInfo instanceOf = snippet(TypeSnippets.class, "instanceOfSnippet");
 
+        public InstanceOfLowering(OptionValues options, Providers providers) {
+            super(options, providers);
         }
 
         @Override
@@ -223,9 +215,8 @@ protected class InstanceOfDynamicLowering extends InstanceOfSnippetsTemplates im
 
         private final SnippetTemplate.SnippetInfo instanceOfDynamic = snippet(TypeSnippets.class, "instanceOfDynamicSnippet");
 
+        public InstanceOfDynamicLowering(OptionValues options, Providers providers) {
+            super(options, providers);
         }
 
         @Override
@@ -265,9 +256,8 @@ protected SnippetTemplate.Arguments makeArguments(InstanceOfUsageReplacer replac
     protected class ClassIsAssignableFromLowering extends InstanceOfSnippetsTemplates implements NodeLoweringProvider&lt;FloatingNode&gt; {
         private final SnippetTemplate.SnippetInfo assignableTypeCheck = snippet(TypeSnippets.class, "classIsAssignableFromSnippet");
 
+        public ClassIsAssignableFromLowering(OptionValues options, Providers providers) {
+            super(options, providers);
         }
 
         @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>525413</refactoring_id><commit_sha>0396163fcfc342c0857686e59da92cc433d5a315</commit_sha><commit_link>https://github.com/apache/iotdb/commit/0396163fcfc342c0857686e59da92cc433d5a315</commit_link><file_path>confignode/src/main/java/org/apache/iotdb/confignode/manager/partition/RegionHeartbeatSample.java</file_path><description>Remove Parameter belongedDataNodeId : int in method public RegionHeartbeatSample(sendTimestamp long, receiveTimestamp long, belongedDataNodeId int, isLeader boolean, status RegionStatus) from class org.apache.iotdb.confignode.manager.partition.RegionHeartbeatSample</description><code_before>@@ -26,22 +26,16 @@ public class RegionHeartbeatSample {
   private final long sendTimestamp;
   private final long receiveTimestamp;
 
-  private final int belongedDataNodeId;
   private final boolean isLeader;
   private final RegionStatus status;
 
   // TODO: Add load sample
 
   public RegionHeartbeatSample(
-      long sendTimestamp,
-      long receiveTimestamp,
-      int belongedDataNodeId,
-      boolean isLeader,
-      RegionStatus status) {
     this.sendTimestamp = sendTimestamp;
     this.receiveTimestamp = receiveTimestamp;
 
-    this.belongedDataNodeId = belongedDataNodeId;
     this.isLeader = isLeader;
     this.status = status;
   }
@@ -54,10 +48,6 @@ public long getReceiveTimestamp() {
     return receiveTimestamp;
   }
 
-  public int getBelongedDataNodeId() {
-    return belongedDataNodeId;
-  }
-
   public boolean isLeader() {
     return isLeader;
   }
</code_before><code_after>@@ -26,22 +26,16 @@ public class RegionHeartbeatSample {
   private final long sendTimestamp;
   private final long receiveTimestamp;
 
   private final boolean isLeader;
   private final RegionStatus status;
 
   // TODO: Add load sample
 
   public RegionHeartbeatSample(
+      long sendTimestamp, long receiveTimestamp, boolean isLeader, RegionStatus status) {
     this.sendTimestamp = sendTimestamp;
     this.receiveTimestamp = receiveTimestamp;
 
     this.isLeader = isLeader;
     this.status = status;
   }
@@ -54,10 +48,6 @@ public long getReceiveTimestamp() {
     return receiveTimestamp;
   }
 
   public boolean isLeader() {
     return isLeader;
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>551231</refactoring_id><commit_sha>6b1c6c61ca13d08e8441b1ccb3dc1cbbf2c97bd9</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/6b1c6c61ca13d08e8441b1ccb3dc1cbbf2c97bd9</commit_link><file_path>src/com/google/javascript/rhino/jstype/UnionType.java</file_path><description>Remove Parameter maxUnionSize : int in method private Builder(registry JSTypeRegistry, maxUnionSize int) from class com.google.javascript.rhino.jstype.UnionType.Builder</description><code_before>@@ -82,35 +82,26 @@ public class UnionType extends JSType {
    * Generally, if the best we can do is say "this object is one of thirty things", then we should
    * just give up and admit that we have no clue.
    */
-  private static final int DEFAULT_MAX_UNION_SIZE = 30;
 
   /**
-   * A special case maximum size for use in the type registry.
    *
-   * &lt;p&gt;The registry uses a union type to track all the types that have a given property. In this
-   * scenario, there can be &lt;em&gt;many&lt;/em&gt; alternates but it's still valuable to differentiate them.
-   *
-   * &lt;p&gt;This value was semi-randomly selected based on the Google+ FE project.
    */
-  private static final int PROPERTY_CHECKING_MAX_UNION_SIZE = 3000;
-
-  // NOTE: to avoid allocating iterators, all the loops below iterate over alternates by index
-  // instead of using the for-each loop idiom.
-
-
   private ImmutableList&lt;JSType&gt; alternates;
-  private final int maxUnionSize;
 
   /**
    * Creates a union.
    *
    * &lt;p&gt;This ctor is private because all instances are created using a {@link Builder}. The builder
    * is also responsible for setting the alternates, which is why they aren't passed as a parameter.
    */
-  private UnionType(JSTypeRegistry registry, ImmutableList&lt;JSType&gt; alternates, int maxUnionSize) {
     super(registry);
     this.setAlternates(alternates);
-    this.maxUnionSize = maxUnionSize;
 
     registry.getResolver().resolveIfClosed(this, TYPE_CLASS);
   }
@@ -122,16 +113,7 @@ JSTypeClass getTypeClass() {
 
   /** Creates a {@link Builder} for a new {@link UnionType}. */
   public static Builder builder(JSTypeRegistry registry) {
-    return new Builder(registry, DEFAULT_MAX_UNION_SIZE);
-  }
-
-  /**
-   * Creates a {@link Builder} for a new {@link UnionType}.
-   *
-   * &lt;p&gt;This is only supposed to be used within `JSTypeRegistry`.
-   */
-  static Builder builderForPropertyChecking(JSTypeRegistry registry) {
-    return new Builder(registry, PROPERTY_CHECKING_MAX_UNION_SIZE);
   }
 
   /**
@@ -148,7 +130,7 @@ public ImmutableList&lt;JSType&gt; getAlternates() {
 
   /** Use a {@link Builder} to rebuild the list of alternates. */
   private void rebuildAlternates() {
-    setAlternates(new Builder(this, maxUnionSize).addAlternates(this.alternates).buildInternal());
   }
 
   private UnionType setAlternates(ImmutableList&lt;JSType&gt; alternates) {
@@ -640,7 +622,6 @@ public boolean hasAnyTemplateTypesInternal() {
   public static final class Builder {
     private final UnionType rebuildTarget;
     private final JSTypeRegistry registry;
-    private final int maxUnionSize;
 
     private final List&lt;JSType&gt; alternates = new ArrayList&lt;&gt;();
     // If a union has ? or *, we do not care about any other types, except for undefined (for
@@ -674,17 +655,15 @@ public static final class Builder {
     private boolean hasBuilt = false;
 
     /** Creates a builder for a new union. */
-    private Builder(JSTypeRegistry registry, int maxUnionSize) {
       this.rebuildTarget = null;
       this.registry = registry;
-      this.maxUnionSize = maxUnionSize;
     }
 
     /** Creates a re-builder for an existing union. */
-    private Builder(UnionType rebuildTarget, int maxUnionSize) {
       this.rebuildTarget = rebuildTarget;
       this.registry = rebuildTarget.registry;
-      this.maxUnionSize = maxUnionSize;
     }
 
     private static boolean isSubtype(JSType rightType, JSType leftType) {
@@ -720,7 +699,7 @@ public Builder addAlternate(JSType alternate) {
         return this;
       }
 
-      if (alternates.size() &gt; maxUnionSize) {
         return this;
       }
 
@@ -898,7 +877,7 @@ public JSType build() {
       if (alternates.size() == 1) {
         return alternates.get(0);
       } else {
-        return new UnionType(registry, alternates, maxUnionSize);
       }
     }
 
@@ -920,7 +899,7 @@ private ImmutableList&lt;JSType&gt; buildInternal() {
         // To simplify the typesystem, empty union types are forbidden. Using a single `bottom`
         // makes it essentially a proxy instead.
         return ImmutableList.of(registry.getNativeType(NO_TYPE));
-      } else if (alternates.size() &gt; maxUnionSize) {
         return ImmutableList.of(registry.getNativeType(UNKNOWN_TYPE));
       } else {
         return ImmutableList.copyOf(alternates);
</code_before><code_after>@@ -82,35 +82,26 @@ public class UnionType extends JSType {
    * Generally, if the best we can do is say "this object is one of thirty things", then we should
    * just give up and admit that we have no clue.
    */
+  private static final int MAX_UNION_SIZE = 30;
 
   /**
+   * The types that are unioned.
    *
+   * &lt;p&gt;We use a List rather than a Set so that we can iterate by index. This is substantially more
+   * efficient than using the for-each idiom due to the overhead of allocating iterators. All loops
+   * over this collection should be indexed.
    */
   private ImmutableList&lt;JSType&gt; alternates;
 
   /**
    * Creates a union.
    *
    * &lt;p&gt;This ctor is private because all instances are created using a {@link Builder}. The builder
    * is also responsible for setting the alternates, which is why they aren't passed as a parameter.
    */
+  private UnionType(JSTypeRegistry registry, ImmutableList&lt;JSType&gt; alternates) {
     super(registry);
     this.setAlternates(alternates);
 
     registry.getResolver().resolveIfClosed(this, TYPE_CLASS);
   }
@@ -122,16 +113,7 @@ JSTypeClass getTypeClass() {
 
   /** Creates a {@link Builder} for a new {@link UnionType}. */
   public static Builder builder(JSTypeRegistry registry) {
+    return new Builder(registry);
   }
 
   /**
@@ -148,7 +130,7 @@ public ImmutableList&lt;JSType&gt; getAlternates() {
 
   /** Use a {@link Builder} to rebuild the list of alternates. */
   private void rebuildAlternates() {
+    setAlternates(new Builder(this).addAlternates(this.alternates).buildInternal());
   }
 
   private UnionType setAlternates(ImmutableList&lt;JSType&gt; alternates) {
@@ -640,7 +622,6 @@ public boolean hasAnyTemplateTypesInternal() {
   public static final class Builder {
     private final UnionType rebuildTarget;
     private final JSTypeRegistry registry;
 
     private final List&lt;JSType&gt; alternates = new ArrayList&lt;&gt;();
     // If a union has ? or *, we do not care about any other types, except for undefined (for
@@ -674,17 +655,15 @@ public static final class Builder {
     private boolean hasBuilt = false;
 
     /** Creates a builder for a new union. */
+    private Builder(JSTypeRegistry registry) {
       this.rebuildTarget = null;
       this.registry = registry;
     }
 
     /** Creates a re-builder for an existing union. */
+    private Builder(UnionType rebuildTarget) {
       this.rebuildTarget = rebuildTarget;
       this.registry = rebuildTarget.registry;
     }
 
     private static boolean isSubtype(JSType rightType, JSType leftType) {
@@ -720,7 +699,7 @@ public Builder addAlternate(JSType alternate) {
         return this;
       }
 
+      if (alternates.size() &gt; MAX_UNION_SIZE) {
         return this;
       }
 
@@ -898,7 +877,7 @@ public JSType build() {
       if (alternates.size() == 1) {
         return alternates.get(0);
       } else {
+        return new UnionType(registry, alternates);
       }
     }
 
@@ -920,7 +899,7 @@ private ImmutableList&lt;JSType&gt; buildInternal() {
         // To simplify the typesystem, empty union types are forbidden. Using a single `bottom`
         // makes it essentially a proxy instead.
         return ImmutableList.of(registry.getNativeType(NO_TYPE));
+      } else if (alternates.size() &gt; MAX_UNION_SIZE) {
         return ImmutableList.of(registry.getNativeType(UNKNOWN_TYPE));
       } else {
         return ImmutableList.copyOf(alternates);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>559621</refactoring_id><commit_sha>2bfd04d0e1006a52a7a0c6c241876d06b19ccc52</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/2bfd04d0e1006a52a7a0c6c241876d06b19ccc52</commit_link><file_path>core/src/test/java/ch/cyberduck/core/transfer/upload/SkipFilterTest.java</file_path><description>Remove Parameter listener : ListProgressListener in method public find(file Path, listener ListProgressListener) : boolean from class ch.cyberduck.core.transfer.upload.SkipFilterTest.testAccept.f.new SkipFilter.new NullSession._getFeature.new Find</description><code_before>@@ -33,7 +33,7 @@ public &lt;T&gt; T _getFeature(Class&lt;T&gt; type) {
                 if(type == Find.class) {
                     return (T) new Find() {
                         @Override
-                        public boolean find(Path file, final ListProgressListener listener) throws BackgroundException {
                             return true;
                         }
                     };
@@ -59,7 +59,7 @@ public AttributedList&lt;Path&gt; list(final Path file, final ListProgressListener lis
         });
         f.withAttributes(new AttributesFinder() {
             @Override
-            public PathAttributes find(final Path file, final ListProgressListener listener) throws BackgroundException {
                 return file.attributes();
             }
         });
@@ -81,7 +81,7 @@ public AttributedList&lt;Path&gt; list(final Path file, final ListProgressListener lis
         });
         f.withAttributes(new AttributesFinder() {
             @Override
-            public PathAttributes find(final Path file, final ListProgressListener listener) throws BackgroundException {
                 return file.attributes();
             }
         });
</code_before><code_after>@@ -33,7 +33,7 @@ public &lt;T&gt; T _getFeature(Class&lt;T&gt; type) {
                 if(type == Find.class) {
                     return (T) new Find() {
                         @Override
+                        public boolean find(Path file) throws BackgroundException {
                             return true;
                         }
                     };
@@ -59,7 +59,7 @@ public AttributedList&lt;Path&gt; list(final Path file, final ListProgressListener lis
         });
         f.withAttributes(new AttributesFinder() {
             @Override
+            public PathAttributes find(final Path file) throws BackgroundException {
                 return file.attributes();
             }
         });
@@ -81,7 +81,7 @@ public AttributedList&lt;Path&gt; list(final Path file, final ListProgressListener lis
         });
         f.withAttributes(new AttributesFinder() {
             @Override
+            public PathAttributes find(final Path file) throws BackgroundException {
                 return file.attributes();
             }
         });
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>552402</refactoring_id><commit_sha>c90ca7ba5fb9e83956e9494a584ae6b0620e3b14</commit_sha><commit_link>https://github.com/google/exoplayer/commit/c90ca7ba5fb9e83956e9494a584ae6b0620e3b14</commit_link><file_path>libraries/session/src/main/java/androidx/media3/session/PlayerInfo.java</file_path><description>Remove Parameter excludeMediaItems : boolean in method public toBundle(excludeMediaItems boolean, excludeMediaItemsMetadata boolean, excludeCues boolean, excludeTimeline boolean, excludeTracks boolean) : Bundle from class androidx.media3.session.PlayerInfo</description><code_before>@@ -799,11 +799,7 @@ private boolean isPlaying(
   // Next field key = 31
 
   public Bundle toBundle(
-      boolean excludeMediaItems,
-      boolean excludeMediaItemsMetadata,
-      boolean excludeCues,
-      boolean excludeTimeline,
-      boolean excludeTracks) {
     Bundle bundle = new Bundle();
     if (playerError != null) {
       bundle.putBundle(FIELD_PLAYBACK_ERROR, playerError.toBundle());
@@ -816,16 +812,16 @@ public Bundle toBundle(
     bundle.putBundle(FIELD_PLAYBACK_PARAMETERS, playbackParameters.toBundle());
     bundle.putInt(FIELD_REPEAT_MODE, repeatMode);
     bundle.putBoolean(FIELD_SHUFFLE_MODE_ENABLED, shuffleModeEnabled);
-    if (!excludeTimeline) {
-      bundle.putBundle(FIELD_TIMELINE, timeline.toBundle(excludeMediaItems));
     }
     bundle.putBundle(FIELD_VIDEO_SIZE, videoSize.toBundle());
-    if (!excludeMediaItemsMetadata) {
       bundle.putBundle(FIELD_PLAYLIST_METADATA, playlistMetadata.toBundle());
     }
     bundle.putFloat(FIELD_VOLUME, volume);
     bundle.putBundle(FIELD_AUDIO_ATTRIBUTES, audioAttributes.toBundle());
-    if (!excludeCues) {
       bundle.putBundle(FIELD_CUE_GROUP, cueGroup.toBundle());
     }
     bundle.putBundle(FIELD_DEVICE_INFO, deviceInfo.toBundle());
@@ -836,13 +832,13 @@ public Bundle toBundle(
     bundle.putInt(FIELD_PLAYBACK_STATE, playbackState);
     bundle.putBoolean(FIELD_IS_PLAYING, isPlaying);
     bundle.putBoolean(FIELD_IS_LOADING, isLoading);
-    bundle.putBundle(
-        FIELD_MEDIA_METADATA,
-        excludeMediaItems ? MediaMetadata.EMPTY.toBundle() : mediaMetadata.toBundle());
     bundle.putLong(FIELD_SEEK_BACK_INCREMENT_MS, seekBackIncrementMs);
     bundle.putLong(FIELD_SEEK_FORWARD_INCREMENT_MS, seekForwardIncrementMs);
     bundle.putLong(FIELD_MAX_SEEK_TO_PREVIOUS_POSITION_MS, maxSeekToPreviousPositionMs);
-    if (!excludeTracks) {
       bundle.putBundle(FIELD_CURRENT_TRACKS, currentTracks.toBundle());
     }
     bundle.putBundle(FIELD_TRACK_SELECTION_PARAMETERS, trackSelectionParameters.toBundle());
@@ -853,9 +849,7 @@ public Bundle toBundle(
   @Override
   public Bundle toBundle() {
     return toBundle(
-        /* excludeMediaItems= */ false,
-        /* excludeMediaItemsMetadata= */ false,
-        /* excludeCues= */ false,
         /* excludeTimeline= */ false,
         /* excludeTracks= */ false);
   }
</code_before><code_after>@@ -799,11 +799,7 @@ private boolean isPlaying(
   // Next field key = 31
 
   public Bundle toBundle(
+      Player.Commands availableCommands, boolean excludeTimeline, boolean excludeTracks) {
     Bundle bundle = new Bundle();
     if (playerError != null) {
       bundle.putBundle(FIELD_PLAYBACK_ERROR, playerError.toBundle());
@@ -816,16 +812,16 @@ public Bundle toBundle(
     bundle.putBundle(FIELD_PLAYBACK_PARAMETERS, playbackParameters.toBundle());
     bundle.putInt(FIELD_REPEAT_MODE, repeatMode);
     bundle.putBoolean(FIELD_SHUFFLE_MODE_ENABLED, shuffleModeEnabled);
+    if (!excludeTimeline &amp;&amp; availableCommands.contains(Player.COMMAND_GET_TIMELINE)) {
+      bundle.putBundle(FIELD_TIMELINE, timeline.toBundle());
     }
     bundle.putBundle(FIELD_VIDEO_SIZE, videoSize.toBundle());
+    if (availableCommands.contains(Player.COMMAND_GET_MEDIA_ITEMS_METADATA)) {
       bundle.putBundle(FIELD_PLAYLIST_METADATA, playlistMetadata.toBundle());
     }
     bundle.putFloat(FIELD_VOLUME, volume);
     bundle.putBundle(FIELD_AUDIO_ATTRIBUTES, audioAttributes.toBundle());
+    if (availableCommands.contains(Player.COMMAND_GET_TEXT)) {
       bundle.putBundle(FIELD_CUE_GROUP, cueGroup.toBundle());
     }
     bundle.putBundle(FIELD_DEVICE_INFO, deviceInfo.toBundle());
@@ -836,13 +832,13 @@ public Bundle toBundle(
     bundle.putInt(FIELD_PLAYBACK_STATE, playbackState);
     bundle.putBoolean(FIELD_IS_PLAYING, isPlaying);
     bundle.putBoolean(FIELD_IS_LOADING, isLoading);
+    if (availableCommands.contains(Player.COMMAND_GET_TIMELINE)) {
+      bundle.putBundle(FIELD_MEDIA_METADATA, mediaMetadata.toBundle());
+    }
     bundle.putLong(FIELD_SEEK_BACK_INCREMENT_MS, seekBackIncrementMs);
     bundle.putLong(FIELD_SEEK_FORWARD_INCREMENT_MS, seekForwardIncrementMs);
     bundle.putLong(FIELD_MAX_SEEK_TO_PREVIOUS_POSITION_MS, maxSeekToPreviousPositionMs);
+    if (!excludeTracks &amp;&amp; availableCommands.contains(Player.COMMAND_GET_TRACKS)) {
       bundle.putBundle(FIELD_CURRENT_TRACKS, currentTracks.toBundle());
     }
     bundle.putBundle(FIELD_TRACK_SELECTION_PARAMETERS, trackSelectionParameters.toBundle());
@@ -853,9 +849,7 @@ public Bundle toBundle(
   @Override
   public Bundle toBundle() {
     return toBundle(
+        /* availableCommands= */ new Player.Commands.Builder().addAllCommands().build(),
         /* excludeTimeline= */ false,
         /* excludeTracks= */ false);
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>471517</refactoring_id><commit_sha>920324b13599a46726239361d00f199f3b9b0d70</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/920324b13599a46726239361d00f199f3b9b0d70</commit_link><file_path>src/main/java/vazkii/botania/common/block/decor/stairs/prismarine/BlockPrismarineStairs.java</file_path><description>Remove Parameter z : int in method public getEntry(world World, x int, y int, z int, player EntityPlayer, lexicon ItemStack) : LexiconEntry from class vazkii.botania.common.block.decor.stairs.prismarine.BlockPrismarineStairs</description><code_before>@@ -2,6 +2,7 @@
 
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.item.ItemStack;
 import net.minecraft.world.World;
 import vazkii.botania.api.lexicon.LexiconEntry;
 import vazkii.botania.common.block.ModBlocks;
@@ -19,7 +20,7 @@ public BlockPrismarineStairs(int meta) {
 	}
 
 	@Override
-	public LexiconEntry getEntry(World world, int x, int y, int z,	EntityPlayer player, ItemStack lexicon) {
 		return LexiconData.prismarine;
 	}
 
</code_before><code_after>@@ -2,6 +2,7 @@
 
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.item.ItemStack;
+import net.minecraft.util.BlockPos;
 import net.minecraft.world.World;
 import vazkii.botania.api.lexicon.LexiconEntry;
 import vazkii.botania.common.block.ModBlocks;
@@ -19,7 +20,7 @@ public BlockPrismarineStairs(int meta) {
 	}
 
 	@Override
+	public LexiconEntry getEntry(World world, BlockPos pos, EntityPlayer player, ItemStack lexicon) {
 		return LexiconData.prismarine;
 	}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>560459</refactoring_id><commit_sha>47e3c19885e71f6fc79006da6bc663e573c5560d</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/47e3c19885e71f6fc79006da6bc663e573c5560d</commit_link><file_path>test/ch/cyberduck/core/transfer/DownloadTransferTest.java</file_path><description>Remove Parameter error : TransferErrorCallback in method public transfer(file Path, filter TransferPathFilter, options TransferOptions, error TransferErrorCallback) : void from class ch.cyberduck.core.transfer.DownloadTransferTest.testPrepareOverride.worker.new SingleTransferWorker</description><code_before>@@ -137,12 +137,11 @@ public TransferAction prompt() {
             }
         }, new DisabledTransferErrorCallback(), cache) {
             @Override
-            public void transfer(final Path file, final TransferPathFilter filter,
-                                 final TransferOptions options, final TransferErrorCallback error) throws BackgroundException {
                 if(file.equals(root)) {
                     assertTrue(cache.containsKey(root.getReference()));
                 }
-                super.transfer(file, filter, options, new DisabledTransferErrorCallback());
                 if(file.equals(root)) {
                     assertFalse(cache.containsKey(root.getReference()));
                 }
</code_before><code_after>@@ -137,12 +137,11 @@ public TransferAction prompt() {
             }
         }, new DisabledTransferErrorCallback(), cache) {
             @Override
+            public void transfer(final Path file, final TransferPathFilter filter) throws BackgroundException {
                 if(file.equals(root)) {
                     assertTrue(cache.containsKey(root.getReference()));
                 }
+                super.transfer(file, filter);
                 if(file.equals(root)) {
                     assertFalse(cache.containsKey(root.getReference()));
                 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>506665</refactoring_id><commit_sha>27921e208a1373f4f3d8b1639693510e23cb593b</commit_sha><commit_link>https://github.com/apache/storm/commit/27921e208a1373f4f3d8b1639693510e23cb593b</commit_link><file_path>storm-server/src/main/java/org/apache/storm/nimbus/LeaderListenerCallback.java</file_path><description>Remove Parameter leaderLatch : LeaderLatch in method public LeaderListenerCallback(conf Map, zk CuratorFramework, leaderLatch LeaderLatch, blobStore BlobStore, tc TopoCache, clusterState IStormClusterState, acls List&lt;ACL&gt;, metricsRegistry StormMetricsRegistry) from class org.apache.storm.nimbus.LeaderListenerCallback</description><code_before>@@ -23,6 +23,7 @@
 import com.codahale.metrics.Meter;
 import org.apache.commons.io.IOUtils;
 import org.apache.storm.Config;
 import org.apache.storm.blobstore.BlobStore;
 import org.apache.storm.blobstore.InputStreamWithMeta;
 import org.apache.storm.cluster.ClusterUtils;
@@ -39,6 +40,7 @@
 import org.apache.storm.shade.org.apache.curator.framework.recipes.leader.LeaderLatch;
 import org.apache.storm.shade.org.apache.zookeeper.CreateMode;
 import org.apache.storm.shade.org.apache.zookeeper.data.ACL;
 import org.apache.storm.utils.Utils;
 import org.apache.storm.zookeeper.ClientZookeeper;
 import org.slf4j.Logger;
@@ -60,31 +62,35 @@ public class LeaderListenerCallback {
     private final TopoCache tc;
     private final IStormClusterState clusterState;
     private final CuratorFramework zk;
-    private final LeaderLatch leaderLatch;
     private final Map conf;
     private final List&lt;ACL&gt; acls;
 
     /**
      * Constructor for {@LeaderListenerCallback}.
      * @param conf config
      * @param zk zookeeper CuratorFramework client
-     * @param leaderLatch LeaderLatch
      * @param blobStore BlobStore
      * @param tc TopoCache
      * @param clusterState IStormClusterState
      * @param acls zookeeper acls
      */
-    public LeaderListenerCallback(Map conf, CuratorFramework zk, LeaderLatch leaderLatch, BlobStore blobStore,
                                   TopoCache tc, IStormClusterState clusterState, List&lt;ACL&gt; acls, StormMetricsRegistry metricsRegistry) {
         this.blobStore = blobStore;
         this.tc = tc;
         this.clusterState = clusterState;
         this.zk = zk;
-        this.leaderLatch = leaderLatch;
         this.conf = conf;
         this.acls = acls;
         this.numGainedLeader = metricsRegistry.registerMeter("nimbus:num-gained-leadership");
         this.numLostLeader = metricsRegistry.registerMeter("nimbus:num-lost-leadership");
     }
 
     /**
@@ -129,11 +135,11 @@ public void leaderCallBack() {
             } else {
                 LOG.info("Code for all active topologies is available locally, but some dependencies are not found locally, "
                          + "giving up leadership.");
-                closeLatch();
             }
         } else {
             LOG.info("code for all active topologies not available locally, giving up leadership.");
-            closeLatch();
         }
     }
 
@@ -218,11 +224,11 @@ private Set&lt;String&gt; getTopologyDependencyKeys(Set&lt;String&gt; activeTopologyCodeKeys
         return activeTopologyDependencies;
     }
 
-    private void closeLatch() {
         try {
-            leaderLatch.close();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
         }
     }
 
</code_before><code_after>@@ -23,6 +23,7 @@
 import com.codahale.metrics.Meter;
 import org.apache.commons.io.IOUtils;
 import org.apache.storm.Config;
+import org.apache.storm.DaemonConfig;
 import org.apache.storm.blobstore.BlobStore;
 import org.apache.storm.blobstore.InputStreamWithMeta;
 import org.apache.storm.cluster.ClusterUtils;
@@ -39,6 +40,7 @@
 import org.apache.storm.shade.org.apache.curator.framework.recipes.leader.LeaderLatch;
 import org.apache.storm.shade.org.apache.zookeeper.CreateMode;
 import org.apache.storm.shade.org.apache.zookeeper.data.ACL;
+import org.apache.storm.utils.ObjectReader;
 import org.apache.storm.utils.Utils;
 import org.apache.storm.zookeeper.ClientZookeeper;
 import org.slf4j.Logger;
@@ -60,31 +62,35 @@ public class LeaderListenerCallback {
     private final TopoCache tc;
     private final IStormClusterState clusterState;
     private final CuratorFramework zk;
+    private final ILeaderElector leaderElector;
     private final Map conf;
     private final List&lt;ACL&gt; acls;
+    private final int requeueDelayMs;
 
     /**
      * Constructor for {@LeaderListenerCallback}.
      * @param conf config
      * @param zk zookeeper CuratorFramework client
      * @param blobStore BlobStore
+     * @param leaderElector Leader elector
      * @param tc TopoCache
      * @param clusterState IStormClusterState
      * @param acls zookeeper acls
      */
+    public LeaderListenerCallback(Map conf, CuratorFramework zk, BlobStore blobStore, ILeaderElector leaderElector,
                                   TopoCache tc, IStormClusterState clusterState, List&lt;ACL&gt; acls, StormMetricsRegistry metricsRegistry) {
         this.blobStore = blobStore;
         this.tc = tc;
         this.clusterState = clusterState;
         this.zk = zk;
+        this.leaderElector = leaderElector;
         this.conf = conf;
         this.acls = acls;
         this.numGainedLeader = metricsRegistry.registerMeter("nimbus:num-gained-leadership");
         this.numLostLeader = metricsRegistry.registerMeter("nimbus:num-lost-leadership");
+        //Since we only give up leadership if we're waiting for blobs to sync,
+        //it makes sense to wait a full sync cycle before trying for leadership again.
+        this.requeueDelayMs = ObjectReader.getInt(conf.get(DaemonConfig.NIMBUS_CODE_SYNC_FREQ_SECS))*1000;
     }
 
     /**
@@ -129,11 +135,11 @@ public void leaderCallBack() {
             } else {
                 LOG.info("Code for all active topologies is available locally, but some dependencies are not found locally, "
                          + "giving up leadership.");
+                surrenderLeadership();
             }
         } else {
             LOG.info("code for all active topologies not available locally, giving up leadership.");
+            surrenderLeadership();
         }
     }
 
@@ -218,11 +224,11 @@ private Set&lt;String&gt; getTopologyDependencyKeys(Set&lt;String&gt; activeTopologyCodeKeys
         return activeTopologyDependencies;
     }
 
+    private void surrenderLeadership() {
         try {
+            leaderElector.quitElectionFor(requeueDelayMs);
+        } catch (Exception e) {
+            throw Utils.wrapInRuntime(e);
         }
     }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>510604</refactoring_id><commit_sha>6adbcd5ff6e21f3c5ca1b5a3057e144221f6c6ad</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/6adbcd5ff6e21f3c5ca1b5a3057e144221f6c6ad</commit_link><file_path>OsmAnd/src/net/osmand/plus/monitoring/StopTrackRecordingBottomFragment.java</file_path><description>Remove Parameter saveGpxListener : SaveGpxListener in method public showInstance(gpxFile GPXFile, saveGpxListener SaveGpxListener, fragmentManager FragmentManager, target Fragment) : void from class net.osmand.plus.monitoring.StopTrackRecordingBottomFragment</description><code_before>@@ -1,24 +1,21 @@
 package net.osmand.plus.monitoring;
 
 import android.content.Context;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.LinearLayout;
 
-import net.osmand.GPXUtilities.GPXFile;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.OsmandPlugin;
 import net.osmand.plus.R;
 import net.osmand.plus.UiUtilities;
 import net.osmand.plus.UiUtilities.DialogButtonType;
 import net.osmand.plus.base.MenuBottomSheetDialogFragment;
 import net.osmand.plus.base.bottomsheetmenu.BaseBottomSheetItem;
 import net.osmand.plus.base.bottomsheetmenu.BottomSheetItemWithDescription;
-import net.osmand.plus.myplaces.SaveCurrentTrackTask;
 import net.osmand.plus.settings.backend.OsmandSettings;
-import net.osmand.plus.track.SaveGpxAsyncTask.SaveGpxListener;
 import net.osmand.plus.widgets.TextViewEx;
 
 import androidx.annotation.DimenRes;
@@ -34,17 +31,13 @@ public class StopTrackRecordingBottomFragment extends MenuBottomSheetDialogFragm
 	public static final String TAG = StopTrackRecordingBottomFragment.class.getSimpleName();
 
 	private OsmandApplication app;
 	private OsmandSettings settings;
 	private OsmandMonitoringPlugin plugin;
-	private GPXFile gpxFile;
-	private SaveGpxListener saveGpxListener;
 
-	public void setGpxFile(GPXFile gpxFile) {
-		this.gpxFile = gpxFile;
-	}
-
-	public void setSaveGpxListener(SaveGpxListener saveGpxListener) {
-		this.saveGpxListener = saveGpxListener;
 	}
 
 	@Override
@@ -122,7 +115,7 @@ public void onClick(View v) {
 			return;
 		}
 
-		ButtonType tag = (ButtonType) o;
 		if (tag == ButtonType.STOP_AND_DISCARD) {
 			if (plugin != null &amp;&amp; settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
 				plugin.stopRecording();
@@ -131,8 +124,7 @@ public void onClick(View v) {
 			app.getSavingTrackHelper().clearRecordedData(true);
 		} else if (tag == ButtonType.SAVE_AND_STOP) {
 			if (plugin != null &amp;&amp; settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
-				new SaveCurrentTrackTask(app, gpxFile, saveGpxListener).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-				plugin.stopRecording();
 				app.getNotificationHelper().refreshNotifications();
 			}
 		}
@@ -151,9 +143,11 @@ public void onResume() {
 	@Override
 	public void onPause() {
 		super.onPause();
-		Fragment target = getTargetFragment();
-		if (target instanceof TripRecordingActiveBottomSheet) {
-			((TripRecordingActiveBottomSheet) target).show();
 		}
 	}
 
@@ -183,11 +177,10 @@ protected boolean hideButtonsContainer() {
 		return true;
 	}
 
-	public static void showInstance(GPXFile gpxFile, SaveGpxListener saveGpxListener, @NonNull FragmentManager fragmentManager, @NonNull Fragment target) {
 		if (!fragmentManager.isStateSaved()) {
 			StopTrackRecordingBottomFragment fragment = new StopTrackRecordingBottomFragment();
-			fragment.setGpxFile(gpxFile);
-			fragment.setSaveGpxListener(saveGpxListener);
 			fragment.setTargetFragment(target, 0);
 			fragment.show(fragmentManager, TAG);
 		}
</code_before><code_after>@@ -1,24 +1,21 @@
 package net.osmand.plus.monitoring;
 
 import android.content.Context;
 import android.os.Bundle;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.LinearLayout;
 
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.OsmandPlugin;
 import net.osmand.plus.R;
 import net.osmand.plus.UiUtilities;
 import net.osmand.plus.UiUtilities.DialogButtonType;
+import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.base.MenuBottomSheetDialogFragment;
 import net.osmand.plus.base.bottomsheetmenu.BaseBottomSheetItem;
 import net.osmand.plus.base.bottomsheetmenu.BottomSheetItemWithDescription;
 import net.osmand.plus.settings.backend.OsmandSettings;
 import net.osmand.plus.widgets.TextViewEx;
 
 import androidx.annotation.DimenRes;
@@ -34,17 +31,13 @@ public class StopTrackRecordingBottomFragment extends MenuBottomSheetDialogFragm
 	public static final String TAG = StopTrackRecordingBottomFragment.class.getSimpleName();
 
 	private OsmandApplication app;
+	private MapActivity mapActivity;
 	private OsmandSettings settings;
 	private OsmandMonitoringPlugin plugin;
+	private ButtonType tag = ButtonType.CANCEL;
 
+	public void setMapActivity(MapActivity mapActivity) {
+		this.mapActivity = mapActivity;
 	}
 
 	@Override
@@ -122,7 +115,7 @@ public void onClick(View v) {
 			return;
 		}
 
+		tag = (ButtonType) o;
 		if (tag == ButtonType.STOP_AND_DISCARD) {
 			if (plugin != null &amp;&amp; settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
 				plugin.stopRecording();
@@ -131,8 +124,7 @@ public void onClick(View v) {
 			app.getSavingTrackHelper().clearRecordedData(true);
 		} else if (tag == ButtonType.SAVE_AND_STOP) {
 			if (plugin != null &amp;&amp; settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
+				plugin.saveCurrentTrack(null, mapActivity);
 				app.getNotificationHelper().refreshNotifications();
 			}
 		}
@@ -151,9 +143,11 @@ public void onResume() {
 	@Override
 	public void onPause() {
 		super.onPause();
+		if (tag == ButtonType.CANCEL) {
+			Fragment target = getTargetFragment();
+			if (target instanceof TripRecordingActiveBottomSheet) {
+				((TripRecordingActiveBottomSheet) target).show();
+			}
 		}
 	}
 
@@ -183,11 +177,10 @@ protected boolean hideButtonsContainer() {
 		return true;
 	}
 
+	public static void showInstance(MapActivity mapActivity, @NonNull FragmentManager fragmentManager, @NonNull Fragment target) {
 		if (!fragmentManager.isStateSaved()) {
 			StopTrackRecordingBottomFragment fragment = new StopTrackRecordingBottomFragment();
+			fragment.setMapActivity(mapActivity);
 			fragment.setTargetFragment(target, 0);
 			fragment.show(fragmentManager, TAG);
 		}
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>503102</refactoring_id><commit_sha>c2ccb2827e8f84afb6f76ddad7c29f2d9641d6eb</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/c2ccb2827e8f84afb6f76ddad7c29f2d9641d6eb</commit_link><file_path>src/main/java/com/google/devtools/build/lib/rules/java/JavaToolchainProvider.java</file_path><description>Remove Parameter collection : ProviderCollection in method private from(collection ProviderCollection, errorConsumer RuleErrorConsumer) : JavaToolchainProvider from class com.google.devtools.build.lib.rules.java.JavaToolchainProvider</description><code_before>@@ -17,6 +17,7 @@
 import static com.google.devtools.build.lib.rules.java.JavaStarlarkCommon.checkPrivateAccess;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
@@ -26,7 +27,6 @@
 import com.google.devtools.build.lib.analysis.ProviderCollection;
 import com.google.devtools.build.lib.analysis.RuleContext;
 import com.google.devtools.build.lib.analysis.RuleErrorConsumer;
-import com.google.devtools.build.lib.analysis.TransitiveInfoCollection;
 import com.google.devtools.build.lib.analysis.platform.ToolchainInfo;
 import com.google.devtools.build.lib.cmdline.Label;
 import com.google.devtools.build.lib.collect.nestedset.Depset;
@@ -55,19 +55,25 @@ public final class JavaToolchainProvider extends NativeInfo
 
   /** Returns the Java Toolchain associated with the rule being analyzed or {@code null}. */
   public static JavaToolchainProvider from(RuleContext ruleContext) {
-    TransitiveInfoCollection prerequisite =
-        ruleContext.getPrerequisite(JavaRuleClasses.JAVA_TOOLCHAIN_ATTRIBUTE_NAME);
-    return from(prerequisite, ruleContext);
   }
 
   public static JavaToolchainProvider from(ProviderCollection collection) {
-    return from(collection, null);
   }
 
   @Nullable
   private static JavaToolchainProvider from(
-      ProviderCollection collection, @Nullable RuleErrorConsumer errorConsumer) {
-    ToolchainInfo toolchainInfo = collection.get(ToolchainInfo.PROVIDER);
     if (toolchainInfo != null) {
       try {
         JavaToolchainProvider provider = (JavaToolchainProvider) toolchainInfo.getValue("java");
</code_before><code_after>@@ -17,6 +17,7 @@
 import static com.google.devtools.build.lib.rules.java.JavaStarlarkCommon.checkPrivateAccess;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
@@ -26,7 +27,6 @@
 import com.google.devtools.build.lib.analysis.ProviderCollection;
 import com.google.devtools.build.lib.analysis.RuleContext;
 import com.google.devtools.build.lib.analysis.RuleErrorConsumer;
 import com.google.devtools.build.lib.analysis.platform.ToolchainInfo;
 import com.google.devtools.build.lib.cmdline.Label;
 import com.google.devtools.build.lib.collect.nestedset.Depset;
@@ -55,19 +55,25 @@ public final class JavaToolchainProvider extends NativeInfo
 
   /** Returns the Java Toolchain associated with the rule being analyzed or {@code null}. */
   public static JavaToolchainProvider from(RuleContext ruleContext) {
+    ToolchainInfo toolchainInfo =
+        ruleContext
+            .getToolchainContext()
+            .forToolchainType(
+                ruleContext
+                    .getPrerequisite(JavaRuleClasses.JAVA_TOOLCHAIN_TYPE_ATTRIBUTE_NAME)
+                    .getLabel());
+    return from(toolchainInfo, ruleContext);
   }
 
+  @VisibleForTesting
   public static JavaToolchainProvider from(ProviderCollection collection) {
+    ToolchainInfo toolchainInfo = collection.get(ToolchainInfo.PROVIDER);
+    return from(toolchainInfo, null);
   }
 
   @Nullable
   private static JavaToolchainProvider from(
+      ToolchainInfo toolchainInfo, @Nullable RuleErrorConsumer errorConsumer) {
     if (toolchainInfo != null) {
       try {
         JavaToolchainProvider provider = (JavaToolchainProvider) toolchainInfo.getValue("java");
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>507393</refactoring_id><commit_sha>ad0b1cc84778074769adf9312042fad74169bf2d</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/ad0b1cc84778074769adf9312042fad74169bf2d</commit_link><file_path>core/src/main/java/org/infinispan/statetransfer/StateResponseCommand.java</file_path><description>Remove Parameter ctx : InvocationContext in method public perform(ctx InvocationContext) : Object from class org.infinispan.statetransfer.StateResponseCommand</description><code_before>@@ -5,12 +5,13 @@
 import java.io.ObjectOutput;
 import java.util.ArrayList;
 import java.util.Collection;
 
 import org.infinispan.commands.remote.BaseRpcCommand;
 import org.infinispan.commons.marshall.MarshallUtil;
-import org.infinispan.context.InvocationContext;
 import org.infinispan.remoting.transport.Address;
 import org.infinispan.util.ByteString;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 
@@ -61,12 +62,12 @@ public void init(StateConsumer stateConsumer) {
    }
 
    @Override
-   public Object perform(InvocationContext ctx) throws Throwable {
       final boolean trace = log.isTraceEnabled();
       LogFactory.pushNDC(cacheName, trace);
       try {
          stateConsumer.applyState(getOrigin(), topologyId, stateChunks);
-         return null;
       } finally {
          LogFactory.popNDC(trace);
       }
</code_before><code_after>@@ -5,12 +5,13 @@
 import java.io.ObjectOutput;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.concurrent.CompletableFuture;
 
 import org.infinispan.commands.remote.BaseRpcCommand;
 import org.infinispan.commons.marshall.MarshallUtil;
 import org.infinispan.remoting.transport.Address;
 import org.infinispan.util.ByteString;
+import org.infinispan.util.concurrent.CompletableFutures;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 
@@ -61,12 +62,12 @@ public void init(StateConsumer stateConsumer) {
    }
 
    @Override
+   public CompletableFuture&lt;Object&gt; invokeAsync() throws Throwable {
       final boolean trace = log.isTraceEnabled();
       LogFactory.pushNDC(cacheName, trace);
       try {
          stateConsumer.applyState(getOrigin(), topologyId, stateChunks);
+         return CompletableFutures.completedNull();
       } finally {
          LogFactory.popNDC(trace);
       }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>533139</refactoring_id><commit_sha>292d6a81f7bdfba067836b0b5eb2bf1bdb97bb1f</commit_sha><commit_link>https://github.com/yuliskov/SmartTube/commit/292d6a81f7bdfba067836b0b5eb2bf1bdb97bb1f</commit_link><file_path>common/src/main/java/com/liskovsoft/smartyoutubetv2/common/exoplayer/other/V2/AudioDelayMediaCodecAudioRenderer.java</file_path><description>Remove Parameter drmSessionManager : DrmSessionManager&lt;FrameworkMediaCrypto&gt; in method public AudioDelayMediaCodecAudioRenderer(context Context, mediaCodecSelector MediaCodecSelector, drmSessionManager DrmSessionManager&lt;FrameworkMediaCrypto&gt;, playClearSamplesWithoutKeys boolean, eventHandler Handler, eventListener AudioRendererEventListener, audioCapabilities AudioCapabilities, audioProcessors AudioProcessor...) from class com.liskovsoft.smartyoutubetv2.common.exoplayer.other.V2.AudioDelayMediaCodecAudioRenderer</description><code_before>@@ -1,71 +0,0 @@
-package com.liskovsoft.smartyoutubetv2.common.exoplayer.other.V2;
-
-import android.content.Context;
-import android.os.Handler;
-import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.audio.AudioCapabilities;
-import com.google.android.exoplayer2.audio.AudioProcessor;
-import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioSink;
-import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
-import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
-import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
-
-public class AudioDelayMediaCodecAudioRenderer extends MediaCodecAudioRenderer {
-    private static final String TAG = AudioDelayMediaCodecAudioRenderer.class.getSimpleName();
-    private int mDelayUs;
-
-    public AudioDelayMediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector) {
-        super(context, mediaCodecSelector);
-    }
-
-    public AudioDelayMediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector, @Nullable DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager, boolean playClearSamplesWithoutKeys) {
-        super(context, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
-    }
-
-    public AudioDelayMediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector, @Nullable Handler eventHandler,
-                                             @Nullable AudioRendererEventListener eventListener) {
-        super(context, mediaCodecSelector, eventHandler, eventListener);
-    }
-
-    public AudioDelayMediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-                                             @Nullable DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager,
-                                             boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
-                                             @Nullable AudioRendererEventListener eventListener) {
-        super(context, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener);
-    }
-
-    public AudioDelayMediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-                                             @Nullable DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager,
-                                             boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
-                                             @Nullable AudioRendererEventListener eventListener, @Nullable AudioCapabilities audioCapabilities,
-                                             AudioProcessor... audioProcessors) {
-        super(context, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener, audioCapabilities,
-                audioProcessors);
-    }
-
-    public AudioDelayMediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-                                             @Nullable DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager,
-                                             boolean playClearSamplesWithoutKeys, @Nullable Handler eventHandler,
-                                             @Nullable AudioRendererEventListener eventListener, AudioSink audioSink) {
-        super(context, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener, audioSink);
-    }
-
-    public AudioDelayMediaCodecAudioRenderer(Context context, MediaCodecSelector mediaCodecSelector, @Nullable DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager, boolean playClearSamplesWithoutKeys, boolean enableDecoderFallback, @Nullable Handler eventHandler, @Nullable AudioRendererEventListener eventListener, AudioSink audioSink) {
-        super(context, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, enableDecoderFallback, eventHandler, eventListener, audioSink);
-    }
-
-    @Override
-    public long getPositionUs() {
-        return super.getPositionUs() + mDelayUs;
-    }
-
-    public void setAudioDelayMs(int delayMs) {
-        mDelayUs = delayMs * 1_000;
-    }
-
-    public int getAudioDelayMs() {
-        return mDelayUs / 1_000;
-    }
-}
</code_before><code_after>@@ -1,71 +0,0 @@
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>553873</refactoring_id><commit_sha>5ca84ebfd8bc933c676c3b1c5e8194ab21a95002</commit_sha><commit_link>https://github.com/google/exoplayer/commit/5ca84ebfd8bc933c676c3b1c5e8194ab21a95002</commit_link><file_path>library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java</file_path><description>Remove Parameter childDataHolder : ChildDataHolder in method protected getChildDataByChildUid(childUid Object, childDataHolder ChildDataHolder) : boolean from class com.google.android.exoplayer2.source.DynamicConcatenatingMediaSource.ConcatenatedTimeline</description><code_before>@@ -397,6 +397,7 @@ private static final class ConcatenatedTimeline extends AbstractConcatenatedTime
 
     public ConcatenatedTimeline(Collection&lt;MediaSourceHolder&gt; mediaSourceHolders, int windowCount,
         int periodCount) {
       this.windowCount = windowCount;
       this.periodCount = periodCount;
       int childCount = mediaSourceHolders.size();
@@ -416,28 +417,42 @@ public ConcatenatedTimeline(Collection&lt;MediaSourceHolder&gt; mediaSourceHolders, in
     }
 
     @Override
-    protected void getChildDataByPeriodIndex(int periodIndex, ChildDataHolder childDataHolder) {
-      int index = Util.binarySearchFloor(firstPeriodInChildIndices, periodIndex, true, false);
-      setChildData(index, childDataHolder);
     }
 
     @Override
-    protected void getChildDataByWindowIndex(int windowIndex, ChildDataHolder childDataHolder) {
-      int index = Util.binarySearchFloor(firstWindowInChildIndices, windowIndex, true, false);
-      setChildData(index, childDataHolder);
     }
 
     @Override
-    protected boolean getChildDataByChildUid(Object childUid, ChildDataHolder childDataHolder) {
       if (!(childUid instanceof Integer)) {
-        return false;
       }
       int index = childIndexByUid.get((int) childUid, -1);
-      if (index == -1) {
-        return false;
-      }
-      setChildData(index, childDataHolder);
-      return true;
     }
 
     @Override
@@ -450,10 +465,6 @@ public int getPeriodCount() {
       return periodCount;
     }
 
-    private void setChildData(int srcIndex, ChildDataHolder dest) {
-      dest.setData(timelines[srcIndex], firstPeriodInChildIndices[srcIndex],
-          firstWindowInChildIndices[srcIndex], uids[srcIndex]);
-    }
   }
 
   private static final class DeferredTimeline extends Timeline {
</code_before><code_after>@@ -397,6 +397,7 @@ private static final class ConcatenatedTimeline extends AbstractConcatenatedTime
 
     public ConcatenatedTimeline(Collection&lt;MediaSourceHolder&gt; mediaSourceHolders, int windowCount,
         int periodCount) {
+      super(mediaSourceHolders.size());
       this.windowCount = windowCount;
       this.periodCount = periodCount;
       int childCount = mediaSourceHolders.size();
@@ -416,28 +417,42 @@ public ConcatenatedTimeline(Collection&lt;MediaSourceHolder&gt; mediaSourceHolders, in
     }
 
     @Override
+    protected int getChildIndexByPeriodIndex(int periodIndex) {
+      return Util.binarySearchFloor(firstPeriodInChildIndices, periodIndex, true, false);
     }
 
     @Override
+    protected int getChildIndexByWindowIndex(int windowIndex) {
+      return Util.binarySearchFloor(firstWindowInChildIndices, windowIndex, true, false);
     }
 
     @Override
+    protected int getChildIndexByChildUid(Object childUid) {
       if (!(childUid instanceof Integer)) {
+        return C.INDEX_UNSET;
       }
       int index = childIndexByUid.get((int) childUid, -1);
+      return index == -1 ? C.INDEX_UNSET : index;
+    }
+
+    @Override
+    protected Timeline getTimelineByChildIndex(int childIndex) {
+      return timelines[childIndex];
+    }
+
+    @Override
+    protected int getFirstPeriodIndexByChildIndex(int childIndex) {
+      return firstPeriodInChildIndices[childIndex];
+    }
+
+    @Override
+    protected int getFirstWindowIndexByChildIndex(int childIndex) {
+      return firstWindowInChildIndices[childIndex];
+    }
+
+    @Override
+    protected Object getChildUidByChildIndex(int childIndex) {
+      return uids[childIndex];
     }
 
     @Override
@@ -450,10 +465,6 @@ public int getPeriodCount() {
       return periodCount;
     }
 
   }
 
   private static final class DeferredTimeline extends Timeline {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>478583</refactoring_id><commit_sha>92074f964b82646b6bf20da1ae6d88e2312453c5</commit_sha><commit_link>https://github.com/apache/pinot/commit/92074f964b82646b6bf20da1ae6d88e2312453c5</commit_link><file_path>pinot-core/src/main/java/org/apache/pinot/core/operator/query/AggregationGroupByOperator.java</file_path><description>Remove Parameter numGroupsLimit : int in method public AggregationGroupByOperator(aggregationFunctions AggregationFunction[], groupByExpressions ExpressionContext[], maxInitialResultHolderCapacity int, numGroupsLimit int, transformOperator TransformOperator, numTotalDocs long, useStarTree boolean) from class org.apache.pinot.core.operator.query.AggregationGroupByOperator</description><code_before>@@ -24,37 +24,31 @@
 import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;
 import org.apache.pinot.core.operator.blocks.TransformBlock;
 import org.apache.pinot.core.operator.transform.TransformOperator;
-import org.apache.pinot.core.query.aggregation.function.AggregationFunction;
 import org.apache.pinot.core.query.aggregation.groupby.DefaultGroupByExecutor;
 import org.apache.pinot.core.query.aggregation.groupby.GroupByExecutor;
 import org.apache.pinot.core.startree.executor.StarTreeGroupByExecutor;
 
 
 /**
  * The &lt;code&gt;AggregationGroupByOperator&lt;/code&gt; class provides the operator for aggregation group-by query on a single
  * segment.
  */
-@SuppressWarnings("rawtypes")
 public class AggregationGroupByOperator extends BaseOperator&lt;IntermediateResultsBlock&gt; {
   private static final String OPERATOR_NAME = "AggregationGroupByOperator";
 
-  private final AggregationFunction[] _aggregationFunctions;
   private final ExpressionContext[] _groupByExpressions;
-  private final int _maxInitialResultHolderCapacity;
-  private final int _numGroupsLimit;
   private final TransformOperator _transformOperator;
   private final long _numTotalDocs;
   private final boolean _useStarTree;
 
   private int _numDocsScanned = 0;
 
-  public AggregationGroupByOperator(AggregationFunction[] aggregationFunctions, ExpressionContext[] groupByExpressions,
-      int maxInitialResultHolderCapacity, int numGroupsLimit, TransformOperator transformOperator, long numTotalDocs,
-      boolean useStarTree) {
-    _aggregationFunctions = aggregationFunctions;
     _groupByExpressions = groupByExpressions;
-    _maxInitialResultHolderCapacity = maxInitialResultHolderCapacity;
-    _numGroupsLimit = numGroupsLimit;
     _transformOperator = transformOperator;
     _numTotalDocs = numTotalDocs;
     _useStarTree = useStarTree;
@@ -65,13 +59,9 @@ protected IntermediateResultsBlock getNextBlock() {
     // Perform aggregation group-by on all the blocks
     GroupByExecutor groupByExecutor;
     if (_useStarTree) {
-      groupByExecutor =
-          new StarTreeGroupByExecutor(_aggregationFunctions, _groupByExpressions, _maxInitialResultHolderCapacity,
-              _numGroupsLimit, _transformOperator);
     } else {
-      groupByExecutor =
-          new DefaultGroupByExecutor(_aggregationFunctions, _groupByExpressions, _maxInitialResultHolderCapacity,
-              _numGroupsLimit, _transformOperator);
     }
     TransformBlock transformBlock;
     while ((transformBlock = _transformOperator.nextBlock()) != null) {
@@ -80,7 +70,7 @@ protected IntermediateResultsBlock getNextBlock() {
     }
 
     // Build intermediate result block based on aggregation group-by result from the executor
-    return new IntermediateResultsBlock(_aggregationFunctions, groupByExecutor.getResult());
   }
 
   @Override
</code_before><code_after>@@ -24,37 +24,31 @@
 import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;
 import org.apache.pinot.core.operator.blocks.TransformBlock;
 import org.apache.pinot.core.operator.transform.TransformOperator;
 import org.apache.pinot.core.query.aggregation.groupby.DefaultGroupByExecutor;
 import org.apache.pinot.core.query.aggregation.groupby.GroupByExecutor;
+import org.apache.pinot.core.query.request.context.QueryContext;
 import org.apache.pinot.core.startree.executor.StarTreeGroupByExecutor;
 
 
 /**
  * The &lt;code&gt;AggregationGroupByOperator&lt;/code&gt; class provides the operator for aggregation group-by query on a single
  * segment.
  */
 public class AggregationGroupByOperator extends BaseOperator&lt;IntermediateResultsBlock&gt; {
   private static final String OPERATOR_NAME = "AggregationGroupByOperator";
 
+  private final QueryContext _queryContext;
   private final ExpressionContext[] _groupByExpressions;
   private final TransformOperator _transformOperator;
   private final long _numTotalDocs;
   private final boolean _useStarTree;
 
   private int _numDocsScanned = 0;
 
+  public AggregationGroupByOperator(QueryContext queryContext, ExpressionContext[] groupByExpressions,
+      TransformOperator transformOperator, long numTotalDocs, boolean useStarTree) {
+    _queryContext = queryContext;
     _groupByExpressions = groupByExpressions;
     _transformOperator = transformOperator;
     _numTotalDocs = numTotalDocs;
     _useStarTree = useStarTree;
@@ -65,13 +59,9 @@ protected IntermediateResultsBlock getNextBlock() {
     // Perform aggregation group-by on all the blocks
     GroupByExecutor groupByExecutor;
     if (_useStarTree) {
+      groupByExecutor = new StarTreeGroupByExecutor(_queryContext, _groupByExpressions, _transformOperator);
     } else {
+      groupByExecutor = new DefaultGroupByExecutor(_queryContext, _groupByExpressions, _transformOperator);
     }
     TransformBlock transformBlock;
     while ((transformBlock = _transformOperator.nextBlock()) != null) {
@@ -80,7 +70,7 @@ protected IntermediateResultsBlock getNextBlock() {
     }
 
     // Build intermediate result block based on aggregation group-by result from the executor
+    return new IntermediateResultsBlock(_queryContext.getAggregationFunctions(), groupByExecutor.getResult());
   }
 
   @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>536705</refactoring_id><commit_sha>d33545bdce80934b96a73d541d876bddcbb07439</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/d33545bdce80934b96a73d541d876bddcbb07439</commit_link><file_path>spring-r2dbc/src/main/java/org/springframework/r2dbc/connection/init/ScriptUtils.java</file_path><description>Remove Parameter blockCommentEndDelimiter : String in method private readScript(lineNumberReader LineNumberReader, commentPrefixes String[], separator String, blockCommentEndDelimiter String) : String from class org.springframework.r2dbc.connection.init.ScriptUtils</description><code_before>@@ -242,7 +242,7 @@ static Mono&lt;String&gt; readScript(EncodedResource resource, DataBufferFactory dataB
 						InputStreamReader in = (resource.getCharset() != null ?
 								new InputStreamReader(is, resource.getCharset()) : new InputStreamReader(is));
 						LineNumberReader lnr = new LineNumberReader(in);
-						String script = readScript(lnr, commentPrefixes, separator, blockCommentEndDelimiter);
 						sink.next(script);
 						sink.complete();
 					}
@@ -256,34 +256,22 @@ static Mono&lt;String&gt; readScript(EncodedResource resource, DataBufferFactory dataB
 	}
 
 	/**
-	 * Read a script from the provided {@code LineNumberReader}, using the supplied
-	 * comment prefixes and statement separator, and build a {@code String} containing
-	 * the lines.
-	 * &lt;p&gt;Lines &lt;em&gt;beginning&lt;/em&gt; with one of the comment prefixes are excluded
-	 * from the results; however, line comments anywhere else &amp;mdash; for example,
-	 * within a statement &amp;mdash; will be included in the results.
 	 * @param lineNumberReader the {@code LineNumberReader} containing the script
 	 * to be processed
-	 * @param commentPrefixes the prefixes that identify comments in the SQL script
-	 * (typically "--")
 	 * @param separator the statement separator in the SQL script (typically ";")
-	 * @param blockCommentEndDelimiter the &lt;em&gt;end&lt;/em&gt; block comment delimiter
 	 * @return a {@code String} containing the script lines
 	 * @throws IOException in case of I/O errors
 	 */
-	private static String readScript(LineNumberReader lineNumberReader, @Nullable String[] commentPrefixes,
-			@Nullable String separator, @Nullable String blockCommentEndDelimiter) throws IOException {
-
-		String currentLine = lineNumberReader.readLine();
 		StringBuilder scriptBuilder = new StringBuilder();
 		while (currentLine != null) {
-			if ((blockCommentEndDelimiter != null &amp;&amp; currentLine.contains(blockCommentEndDelimiter)) ||
-				(commentPrefixes != null &amp;&amp; !startsWithAny(currentLine, commentPrefixes, 0))) {
-				if (scriptBuilder.length() &gt; 0) {
-					scriptBuilder.append('\n');
-				}
-				scriptBuilder.append(currentLine);
 			}
 			currentLine = lineNumberReader.readLine();
 		}
 		appendSeparatorToScriptIfNecessary(scriptBuilder, separator);
</code_before><code_after>@@ -242,7 +242,7 @@ static Mono&lt;String&gt; readScript(EncodedResource resource, DataBufferFactory dataB
 						InputStreamReader in = (resource.getCharset() != null ?
 								new InputStreamReader(is, resource.getCharset()) : new InputStreamReader(is));
 						LineNumberReader lnr = new LineNumberReader(in);
+						String script = readScript(lnr, separator);
 						sink.next(script);
 						sink.complete();
 					}
@@ -256,34 +256,22 @@ static Mono&lt;String&gt; readScript(EncodedResource resource, DataBufferFactory dataB
 	}
 
 	/**
+	 * Read a script from the provided {@code LineNumberReader} and build a
+	 * {@code String} containing the lines.
 	 * @param lineNumberReader the {@code LineNumberReader} containing the script
 	 * to be processed
 	 * @param separator the statement separator in the SQL script (typically ";")
 	 * @return a {@code String} containing the script lines
 	 * @throws IOException in case of I/O errors
 	 */
+	private static String readScript(LineNumberReader lineNumberReader, @Nullable String separator) throws IOException {
 		StringBuilder scriptBuilder = new StringBuilder();
+		String currentLine = lineNumberReader.readLine();
 		while (currentLine != null) {
+			if (scriptBuilder.length() &gt; 0) {
+				scriptBuilder.append('\n');
 			}
+			scriptBuilder.append(currentLine);
 			currentLine = lineNumberReader.readLine();
 		}
 		appendSeparatorToScriptIfNecessary(scriptBuilder, separator);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>540871</refactoring_id><commit_sha>9adc5a06a6935e93448eeaffbc5a53ef8bca4ed7</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/9adc5a06a6935e93448eeaffbc5a53ef8bca4ed7</commit_link><file_path>src/edu/stanford/nlp/ie/regexp/RegexNERSequenceClassifier.java</file_path><description>Remove Parameter ignoreCase : boolean in method private findStartIndex(entry Entry, document List&lt;CoreLabel&gt;, searchStart int, myLabels Set&lt;String&gt;, ignoreCase boolean) : int from class edu.stanford.nlp.ie.regexp.RegexNERSequenceClassifier</description><code_before>@@ -14,7 +14,6 @@
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import java.util.regex.PatternSyntaxException;
 
 import edu.stanford.nlp.ie.AbstractSequenceClassifier;
 import edu.stanford.nlp.io.IOUtils;
@@ -91,7 +90,6 @@ public RegexNERSequenceClassifier(String mapping, boolean ignoreCase, boolean ov
 
   private static class Entry implements Comparable&lt;Entry&gt; {
     public List&lt;Pattern&gt; regex; // the regex, tokenized by splitting on white space
-    public List&lt;String&gt; exact = new ArrayList&lt;String&gt;();
     public String type; // the associated type
     public Set&lt;String&gt; overwritableTypes;
     public double priority;
@@ -101,14 +99,6 @@ public Entry(List&lt;Pattern&gt; regex, String type, Set&lt;String&gt; overwritableTypes, do
       this.type = type.intern();
       this.overwritableTypes = overwritableTypes;
       this.priority = priority;
-      // Efficiency shortcut
-      for (Pattern p : regex) {
-        if (p.toString().matches("[a-zA-Z0-9]+")) {
-          exact.add(p.toString());
-        } else {
-          exact.add(null);
-        }
-      }
     }
 
     // if the given priorities are equal, an entry whose regex has more tokens is assigned
@@ -152,7 +142,7 @@ public List&lt;CoreLabel&gt; classify(List&lt;CoreLabel&gt; document) {
       while (true) {
         // only search the part of the document that we haven't yet considered
         // System.err.println("REGEX FIND MATCH FOR " + entry.regex.toString());
-        start = findStartIndex(entry, document, start, myLabels, this.ignoreCase);
         if (start == -1) break; // no match found
 
         // make sure we annotate only valid POS tags
@@ -197,7 +187,7 @@ private List&lt;Entry&gt; readEntries(String mapping, boolean ignoreCase) {
         lineCount ++;
         String[] split = line.split("\t");
         if (split.length &lt; 2 || split.length &gt; 4)
-          throw new RuntimeException("Provided mapping file is in wrong format: " + line);
 
         String[] regexes = split[0].trim().split("\\s+");
         String type = split[1].trim();
@@ -220,9 +210,6 @@ private List&lt;Entry&gt; readEntries(String mapping, boolean ignoreCase) {
         } catch(NumberFormatException e) {
           System.err.println("ERROR: Invalid line " + lineCount + " in regexner file " + mapping + ": \"" + line + "\"!");
           throw e;
-        } catch (PatternSyntaxException e) {
-          System.err.println("ERROR: Invalid line " + lineCount + " in regexner file " + mapping + ": \"" + line + "\"!");
-          throw e;
         }
 
         entries.add(new Entry(tokens, type, overwritableTypes, priority));
@@ -244,25 +231,21 @@ private List&lt;Entry&gt; readEntries(String mapping, boolean ignoreCase) {
    * @param document
    * @return on success, the index of the first token in the matching sequence, otherwise -1
    */
-  private static int findStartIndex(Entry entry, List&lt;CoreLabel&gt; document, int searchStart, Set&lt;String&gt; myLabels, boolean ignoreCase) {
     List&lt;Pattern&gt; regex = entry.regex;
     for (int start = searchStart; start &lt;= document.size() - regex.size(); start++) {
       boolean failed = false;
       for (int i = 0; i &lt; regex.size(); i++) {
         Pattern pattern = regex.get(i);
-        String exact = entry.exact.get(i);
         CoreLabel token = document.get(start + i);
         String NERType = token.get(CoreAnnotations.NamedEntityTagAnnotation.class);
         String currentType = token.get(CoreAnnotations.AnswerAnnotation.class);
 
-        if (
             currentType != null ||
-            (exact != null &amp;&amp; ! (ignoreCase ? exact.equalsIgnoreCase(token.word()) : exact.equals(token.word()))) ||
             ! (entry.overwritableTypes.contains(NERType) ||
-                myLabels.contains(NERType) ||
-                NERType.equals("O"))  ||
-            ! pattern.matcher(token.word()).matches()  // last, as this is likely the expensive operation
-            ) {
           failed = true;
           break;
         }
</code_before><code_after>@@ -14,7 +14,6 @@
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import edu.stanford.nlp.ie.AbstractSequenceClassifier;
 import edu.stanford.nlp.io.IOUtils;
@@ -91,7 +90,6 @@ public RegexNERSequenceClassifier(String mapping, boolean ignoreCase, boolean ov
 
   private static class Entry implements Comparable&lt;Entry&gt; {
     public List&lt;Pattern&gt; regex; // the regex, tokenized by splitting on white space
     public String type; // the associated type
     public Set&lt;String&gt; overwritableTypes;
     public double priority;
@@ -101,14 +99,6 @@ public Entry(List&lt;Pattern&gt; regex, String type, Set&lt;String&gt; overwritableTypes, do
       this.type = type.intern();
       this.overwritableTypes = overwritableTypes;
       this.priority = priority;
     }
 
     // if the given priorities are equal, an entry whose regex has more tokens is assigned
@@ -152,7 +142,7 @@ public List&lt;CoreLabel&gt; classify(List&lt;CoreLabel&gt; document) {
       while (true) {
         // only search the part of the document that we haven't yet considered
         // System.err.println("REGEX FIND MATCH FOR " + entry.regex.toString());
+        start = findStartIndex(entry, document, start, myLabels);
         if (start == -1) break; // no match found
 
         // make sure we annotate only valid POS tags
@@ -197,7 +187,7 @@ private List&lt;Entry&gt; readEntries(String mapping, boolean ignoreCase) {
         lineCount ++;
         String[] split = line.split("\t");
         if (split.length &lt; 2 || split.length &gt; 4)
+          throw new RuntimeException("Provided mapping file is in wrong format");
 
         String[] regexes = split[0].trim().split("\\s+");
         String type = split[1].trim();
@@ -220,9 +210,6 @@ private List&lt;Entry&gt; readEntries(String mapping, boolean ignoreCase) {
         } catch(NumberFormatException e) {
           System.err.println("ERROR: Invalid line " + lineCount + " in regexner file " + mapping + ": \"" + line + "\"!");
           throw e;
         }
 
         entries.add(new Entry(tokens, type, overwritableTypes, priority));
@@ -244,25 +231,21 @@ private List&lt;Entry&gt; readEntries(String mapping, boolean ignoreCase) {
    * @param document
    * @return on success, the index of the first token in the matching sequence, otherwise -1
    */
+  private static int findStartIndex(Entry entry, List&lt;CoreLabel&gt; document, int searchStart, Set&lt;String&gt; myLabels) {
     List&lt;Pattern&gt; regex = entry.regex;
     for (int start = searchStart; start &lt;= document.size() - regex.size(); start++) {
       boolean failed = false;
       for (int i = 0; i &lt; regex.size(); i++) {
         Pattern pattern = regex.get(i);
         CoreLabel token = document.get(start + i);
         String NERType = token.get(CoreAnnotations.NamedEntityTagAnnotation.class);
         String currentType = token.get(CoreAnnotations.AnswerAnnotation.class);
 
+        if (! pattern.matcher(token.word()).matches() ||
             currentType != null ||
             ! (entry.overwritableTypes.contains(NERType) ||
+               myLabels.contains(NERType) ||
+               NERType.equals("O"))) {
           failed = true;
           break;
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>572115</refactoring_id><commit_sha>093aed84401c7f7b33f1bdb3adaea5959b406bbd</commit_sha><commit_link>https://github.com/flowable/flowable-engine/commit/093aed84401c7f7b33f1bdb3adaea5959b406bbd</commit_link><file_path>modules/activiti-engine/src/main/java/org/activiti/engine/impl/persistence/entity/ExecutionEntityManager.java</file_path><description>Remove Parameter page : Page in method public findProcessInstanceAndVariablesByQueryCriteria(executionQuery ProcessInstanceQueryImpl, page Page) : List&lt;ProcessInstance&gt; from class org.activiti.engine.impl.persistence.entity.ExecutionEntityManager</description><code_before>@@ -13,6 +13,7 @@
 
 package org.activiti.engine.impl.persistence.entity;
 
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -108,13 +109,40 @@ public long findProcessInstanceCountByQueryCriteria(ProcessInstanceQueryImpl exe
   }
   
   @SuppressWarnings("unchecked")
-  public List&lt;ProcessInstance&gt; findProcessInstanceByQueryCriteria(ProcessInstanceQueryImpl executionQuery, Page page) {
-    return getDbSqlSession().selectList("selectProcessInstanceByQueryCriteria", executionQuery, page);
   }
   
   @SuppressWarnings("unchecked")
-  public List&lt;ProcessInstance&gt; findProcessInstanceAndVariablesByQueryCriteria(ProcessInstanceQueryImpl executionQuery, Page page) {
-    return getDbSqlSession().selectList("selectProcessInstanceWithVariablesByQueryCriteria", executionQuery, page);
   }
 
   @SuppressWarnings("unchecked")
</code_before><code_after>@@ -13,6 +13,7 @@
 
 package org.activiti.engine.impl.persistence.entity;
 
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -108,13 +109,40 @@ public long findProcessInstanceCountByQueryCriteria(ProcessInstanceQueryImpl exe
   }
   
   @SuppressWarnings("unchecked")
+  public List&lt;ProcessInstance&gt; findProcessInstanceByQueryCriteria(ProcessInstanceQueryImpl executionQuery) {
+    return getDbSqlSession().selectList("selectProcessInstanceByQueryCriteria", executionQuery);
   }
   
   @SuppressWarnings("unchecked")
+  public List&lt;ProcessInstance&gt; findProcessInstanceAndVariablesByQueryCriteria(ProcessInstanceQueryImpl executionQuery) {
+    // paging doesn't work for combining process instances and variables due to an outer join, so doing it in-memory
+    if (executionQuery.getFirstResult() &lt; 0 || executionQuery.getMaxResults() &lt;= 0) {
+      return Collections.EMPTY_LIST;
+    }
+    
+    int firstResult = executionQuery.getFirstResult();
+    int maxResults = executionQuery.getMaxResults();
+    
+    // setting max results, limit to 20000 results for performance reasons
+    executionQuery.setMaxResults(20000);
+    executionQuery.setFirstResult(0);
+    
+    List&lt;ProcessInstance&gt; instanceList = getDbSqlSession().selectList("selectProcessInstanceWithVariablesByQueryCriteria", executionQuery);
+    
+    if (instanceList != null &amp;&amp; instanceList.size() &gt; 0) {
+      if (firstResult &gt; 0) {
+        if (firstResult &lt;= instanceList.size()) {
+          int toIndex = firstResult + Math.min(maxResults, instanceList.size() - firstResult);
+          return instanceList.subList(firstResult, toIndex);
+        } else {
+          return Collections.EMPTY_LIST;
+        }
+      } else {
+        int toIndex = Math.min(maxResults, instanceList.size());
+        return instanceList.subList(0, toIndex);
+      }
+    }
+    return Collections.EMPTY_LIST;
   }
 
   @SuppressWarnings("unchecked")
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>580869</refactoring_id><commit_sha>41ef9e8627c0437a6e7d0a8e7c41027336ff81d5</commit_sha><commit_link>https://github.com/bcgit/bc-java/commit/41ef9e8627c0437a6e7d0a8e7c41027336ff81d5</commit_link><file_path>core/src/main/java/org/bouncycastle/math/ec/custom/sec/SecT283R1Point.java</file_path><description>Remove Parameter withCompression : boolean in method package SecT283R1Point(curve ECCurve, x ECFieldElement, y ECFieldElement, zs ECFieldElement[], withCompression boolean) from class org.bouncycastle.math.ec.custom.sec.SecT283R1Point</description><code_before>@@ -8,34 +8,14 @@
 
 public class SecT283R1Point extends AbstractF2m
 {
-    /**
-     * @deprecated Use ECCurve.createPoint to construct points
-     */
-    public SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y)
-    {
-        this(curve, x, y, false);
-    }
-
-    /**
-     * @deprecated per-point compression property will be removed, refer {@link #getEncoded(boolean)}
-     */
-    public SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, boolean withCompression)
     {
         super(curve, x, y);
-
-        if ((x == null) != (y == null))
-        {
-            throw new IllegalArgumentException("Exactly one of the field elements is null");
-        }
-
-        this.withCompression = withCompression;
     }
 
-    SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, boolean withCompression)
     {
         super(curve, x, y, zs);
-
-        this.withCompression = withCompression;
     }
 
     protected ECPoint detach()
@@ -150,7 +130,7 @@ public ECPoint add(ECPoint b)
             X3 = L.square().add(L).add(X1).addOne();
             if (X3.isZero())
             {
-                return new SecT283R1Point(curve, X3, curve.getB().sqrt(), this.withCompression);
             }
 
             ECFieldElement Y3 = L.multiply(X1.add(X3)).add(X3).add(Y1);
@@ -167,7 +147,7 @@ public ECPoint add(ECPoint b)
             X3 = AU1.multiply(AU2);
             if (X3.isZero())
             {
-                return new SecT283R1Point(curve, X3, curve.getB().sqrt(), this.withCompression);
             }
 
             ECFieldElement ABZ2 = A.multiply(B);
@@ -185,7 +165,7 @@ public ECPoint add(ECPoint b)
             }
         }
 
-        return new SecT283R1Point(curve, X3, L3, new ECFieldElement[]{ Z3 }, this.withCompression);
     }
 
     public ECPoint twice()
@@ -212,7 +192,7 @@ public ECPoint twice()
         ECFieldElement T = L1.square().add(L1Z1).add(Z1Sq);
         if (T.isZero())
         {
-            return new SecT283R1Point(curve, T, curve.getB().sqrt(), withCompression);
         }
 
         ECFieldElement X3 = T.square();
@@ -221,7 +201,7 @@ public ECPoint twice()
         ECFieldElement X1Z1 = Z1IsOne ? X1 : X1.multiply(Z1);
         ECFieldElement L3 = X1Z1.squarePlusProduct(T, L1Z1).add(X3).add(Z3);
 
-        return new SecT283R1Point(curve, X3, L3, new ECFieldElement[]{ Z3 }, this.withCompression);
     }
 
     public ECPoint twicePlus(ECPoint b)
@@ -275,14 +255,14 @@ public ECPoint twicePlus(ECPoint b)
 
         if (A.isZero())
         {
-            return new SecT283R1Point(curve, A, curve.getB().sqrt(), withCompression);
         }
 
         ECFieldElement X3 = A.square().multiply(X2Z1Sq);
         ECFieldElement Z3 = A.multiply(B).multiply(Z1Sq);
         ECFieldElement L3 = A.add(B).square().multiplyPlusProduct(T, L2.addOne(), Z3);
 
-        return new SecT283R1Point(curve, X3, L3, new ECFieldElement[]{ Z3 }, this.withCompression);
     }
 
     public ECPoint negate()
@@ -300,6 +280,6 @@ public ECPoint negate()
 
         // L is actually Lambda (X + Y/X) here
         ECFieldElement L = this.y, Z = this.zs[0];
-        return new SecT283R1Point(curve, X, L.add(Z), new ECFieldElement[]{ Z }, this.withCompression);
     }
 }
</code_before><code_after>@@ -8,34 +8,14 @@
 
 public class SecT283R1Point extends AbstractF2m
 {
+    SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y)
     {
         super(curve, x, y);
     }
 
+    SecT283R1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs)
     {
         super(curve, x, y, zs);
     }
 
     protected ECPoint detach()
@@ -150,7 +130,7 @@ public ECPoint add(ECPoint b)
             X3 = L.square().add(L).add(X1).addOne();
             if (X3.isZero())
             {
+                return new SecT283R1Point(curve, X3, curve.getB().sqrt());
             }
 
             ECFieldElement Y3 = L.multiply(X1.add(X3)).add(X3).add(Y1);
@@ -167,7 +147,7 @@ public ECPoint add(ECPoint b)
             X3 = AU1.multiply(AU2);
             if (X3.isZero())
             {
+                return new SecT283R1Point(curve, X3, curve.getB().sqrt());
             }
 
             ECFieldElement ABZ2 = A.multiply(B);
@@ -185,7 +165,7 @@ public ECPoint add(ECPoint b)
             }
         }
 
+        return new SecT283R1Point(curve, X3, L3, new ECFieldElement[]{ Z3 });
     }
 
     public ECPoint twice()
@@ -212,7 +192,7 @@ public ECPoint twice()
         ECFieldElement T = L1.square().add(L1Z1).add(Z1Sq);
         if (T.isZero())
         {
+            return new SecT283R1Point(curve, T, curve.getB().sqrt());
         }
 
         ECFieldElement X3 = T.square();
@@ -221,7 +201,7 @@ public ECPoint twice()
         ECFieldElement X1Z1 = Z1IsOne ? X1 : X1.multiply(Z1);
         ECFieldElement L3 = X1Z1.squarePlusProduct(T, L1Z1).add(X3).add(Z3);
 
+        return new SecT283R1Point(curve, X3, L3, new ECFieldElement[]{ Z3 });
     }
 
     public ECPoint twicePlus(ECPoint b)
@@ -275,14 +255,14 @@ public ECPoint twicePlus(ECPoint b)
 
         if (A.isZero())
         {
+            return new SecT283R1Point(curve, A, curve.getB().sqrt());
         }
 
         ECFieldElement X3 = A.square().multiply(X2Z1Sq);
         ECFieldElement Z3 = A.multiply(B).multiply(Z1Sq);
         ECFieldElement L3 = A.add(B).square().multiplyPlusProduct(T, L2.addOne(), Z3);
 
+        return new SecT283R1Point(curve, X3, L3, new ECFieldElement[]{ Z3 });
     }
 
     public ECPoint negate()
@@ -300,6 +280,6 @@ public ECPoint negate()
 
         // L is actually Lambda (X + Y/X) here
         ECFieldElement L = this.y, Z = this.zs[0];
+        return new SecT283R1Point(curve, X, L.add(Z), new ECFieldElement[]{ Z });
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>529030</refactoring_id><commit_sha>674bd663a731ea220f27e15bc57e2c4bfeba47a0</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/674bd663a731ea220f27e15bc57e2c4bfeba47a0</commit_link><file_path>flex/src/com/intellij/lang/javascript/flex/actions/airinstaller/AndroidAirPackageParameters.java</file_path><description>Remove Parameter isDebugConnect : boolean in method public AndroidAirPackageParameters(flexSdk Sdk, airDescriptorPath String, installerFileName String, installerFileLocation String, filesToPackage List&lt;FilePathAndPathInPackage&gt;, isDebug boolean, isDebugConnect boolean, debugConnectHost String, isDebugListen boolean, debugListenPort int, airDownloadUrl String, keystorePath String, keystoreType String, keystorePassword String, keyAlias String, keyPassword String, provider String, tsa String) from class com.intellij.lang.javascript.flex.actions.airinstaller.AndroidAirPackageParameters</description><code_before>@@ -1,75 +0,0 @@
-package com.intellij.lang.javascript.flex.actions.airinstaller;
-
-import com.intellij.lang.javascript.flex.run.AirMobileRunnerParameters;
-import com.intellij.openapi.components.PersistentStateComponent;
-import com.intellij.openapi.components.ServiceManager;
-import com.intellij.openapi.components.State;
-import com.intellij.openapi.components.Storage;
-import com.intellij.openapi.project.Project;
-import com.intellij.openapi.projectRoots.Sdk;
-import com.intellij.util.xmlb.XmlSerializerUtil;
-
-import java.util.ArrayList;
-import java.util.List;
-
-@State(
-  name = "AndroidAirPackageParameters",
-  storages = {
-    @Storage(id = "other", file = "$WORKSPACE_FILE$")
-  }
-)
-public class AndroidAirPackageParameters extends AirInstallerParametersBase
-  implements PersistentStateComponent&lt;AndroidAirPackageParameters&gt; {
-
-  public boolean IS_DEBUG;
-  public boolean IS_DEBUG_CONNECT;
-  public String DEBUG_CONNECT_HOST;
-  public boolean IS_DEBUG_LISTEN;
-  public int DEBUG_LISTEN_PORT;
-  public String AIR_DOWNLOAD_URL;
-
-  public static AndroidAirPackageParameters getInstance(final Project project) {
-    return ServiceManager.getService(project, AndroidAirPackageParameters.class);
-  }
-
-  public AndroidAirPackageParameters() {
-    this(null, "", "", "", new ArrayList&lt;FilePathAndPathInPackage&gt;(), false, true, "", false, AirMobileRunnerParameters.DEBUG_PORT_DEFAULT,
-         "", "", "PKCS12", "", "", "", "", "");
-  }
-
-  public AndroidAirPackageParameters(final Sdk flexSdk,
-                                     final String airDescriptorPath,
-                                     final String installerFileName,
-                                     final String installerFileLocation,
-                                     final List&lt;FilePathAndPathInPackage&gt; filesToPackage,
-                                     final boolean isDebug,
-                                     final boolean isDebugConnect,
-                                     final String debugConnectHost,
-                                     final boolean isDebugListen,
-                                     final int debugListenPort,
-                                     final String airDownloadUrl,
-                                     final String keystorePath,
-                                     final String keystoreType,
-                                     final String keystorePassword,
-                                     final String keyAlias,
-                                     final String keyPassword,
-                                     final String provider,
-                                     final String tsa) {
-    super(keyAlias, installerFileName, keystorePath, keyPassword, provider, filesToPackage, tsa, installerFileLocation, keystoreType,
-          keystorePassword, flexSdk, airDescriptorPath);
-    IS_DEBUG = isDebug;
-    IS_DEBUG_CONNECT = isDebugConnect;
-    DEBUG_CONNECT_HOST = debugConnectHost;
-    IS_DEBUG_LISTEN = isDebugListen;
-    DEBUG_LISTEN_PORT = debugListenPort;
-    AIR_DOWNLOAD_URL = airDownloadUrl;
-  }
-
-  public AndroidAirPackageParameters getState() {
-    return this;
-  }
-
-  public void loadState(final AndroidAirPackageParameters state) {
-    XmlSerializerUtil.copyBean(state, this);
-  }
-}
\ No newline at end of file
</code_before><code_after>@@ -1,75 +0,0 @@
\ No newline at end of file
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>566017</refactoring_id><commit_sha>0ff953d1a22a7b98fedbcd4b5e683b39a312ba0b</commit_sha><commit_link>https://github.com/axonframework/axonframework/commit/0ff953d1a22a7b98fedbcd4b5e683b39a312ba0b</commit_link><file_path>core/src/test/java/org/axonframework/eventsourcing/CachingEventSourcingRepositoryTest.java</file_path><description>Remove Parameter firstSequenceNumber : long in method public readEvents(type String, identifier Object, firstSequenceNumber long) : DomainEventStream from class org.axonframework.eventsourcing.CachingEventSourcingRepositoryTest.PartialReadingInMemoryEventStore</description><code_before>@@ -26,7 +26,6 @@
 import org.axonframework.domain.StubAggregate;
 import org.axonframework.eventhandling.EventBus;
 import org.axonframework.eventstore.EventStore;
-import org.axonframework.eventstore.PartialStreamSupport;
 import org.axonframework.repository.AggregateNotFoundException;
 import org.axonframework.unitofwork.CurrentUnitOfWork;
 import org.axonframework.unitofwork.DefaultUnitOfWork;
@@ -56,7 +55,7 @@ public class CachingEventSourcingRepositoryTest {
     @Before
     public void setUp() {
         mockEventStore = spy(new InMemoryEventStore());
-        testSubject = new CachingEventSourcingRepository&lt;StubAggregate&gt;(new StubAggregateFactory(), mockEventStore);
         mockEventBus = mock(EventBus.class);
         testSubject.setEventBus(mockEventBus);
 
@@ -106,7 +105,7 @@ public void describeTo(Description description) {
 
         DefaultUnitOfWork.startAndGet();
         DomainEventStream events = mockEventStore.readEvents("mock", aggregate1.getIdentifier());
-        List&lt;EventMessage&gt; eventList = new ArrayList&lt;EventMessage&gt;();
         while (events.hasNext()) {
             eventList.add(events.next());
         }
@@ -167,11 +166,10 @@ public void describeTo(Description description) {
         }));
     }
 
-    @Test
     public void testLoadAggregateFromCacheWithExpectedVersion_ConcurrentModificationsDetected() {
-        // configure a repository that uses a PartialStreamSupport Event store
-        mockEventStore = spy(new PartialReadingInMemoryEventStore());
-        testSubject = new CachingEventSourcingRepository&lt;StubAggregate&gt;(new StubAggregateFactory(), mockEventStore);
         testSubject.setEventBus(mockEventBus);
         testSubject.setCache(cache);
 
@@ -278,53 +276,37 @@ public Class&lt;StubAggregate&gt; getAggregateType() {
         }
     }
 
-    private class PartialReadingInMemoryEventStore extends InMemoryEventStore implements PartialStreamSupport {
-
-        @Override
-        public DomainEventStream readEvents(String type, Object identifier, long firstSequenceNumber) {
-            return readEvents(type, identifier, firstSequenceNumber, Long.MAX_VALUE);
-        }
-
-        @Override
-        public DomainEventStream readEvents(String type, Object identifier, long firstSequenceNumber,
-                                            long lastSequenceNumber) {
-            if (!store.containsKey(identifier)) {
-                throw new AggregateNotFoundException(identifier, "Aggregate not found");
-            }
-            final List&lt;DomainEventMessage&gt; events = store.get(identifier);
-            List&lt;DomainEventMessage&gt; filteredEvents = new ArrayList&lt;DomainEventMessage&gt;();
-            for (DomainEventMessage message : events) {
-                if (message.getSequenceNumber() &gt;= firstSequenceNumber
-                        &amp;&amp; message.getSequenceNumber() &lt;= lastSequenceNumber) {
-                    filteredEvents.add(message);
-                }
-            }
-            return new SimpleDomainEventStream(filteredEvents);
-        }
-    }
-
     private class InMemoryEventStore implements EventStore {
 
-        protected Map&lt;Object, List&lt;DomainEventMessage&gt;&gt; store = new HashMap&lt;Object, List&lt;DomainEventMessage&gt;&gt;();
 
         @Override
         public void appendEvents(String identifier, DomainEventStream events) {
             while (events.hasNext()) {
                 DomainEventMessage next = events.next();
                 if (!store.containsKey(next.getAggregateIdentifier())) {
-                    store.put(next.getAggregateIdentifier(), new ArrayList&lt;DomainEventMessage&gt;());
                 }
                 List&lt;DomainEventMessage&gt; eventList = store.get(next.getAggregateIdentifier());
                 eventList.add(next);
             }
         }
 
         @Override
-        public DomainEventStream readEvents(String type, Object identifier) {
             if (!store.containsKey(identifier)) {
                 throw new AggregateNotFoundException(identifier, "Aggregate not found");
             }
-            return new SimpleDomainEventStream(store.get(identifier));
         }
 
         public List&lt;DomainEventMessage&gt; readEventsAsList(Object identifier) {
</code_before><code_after>@@ -26,7 +26,6 @@
 import org.axonframework.domain.StubAggregate;
 import org.axonframework.eventhandling.EventBus;
 import org.axonframework.eventstore.EventStore;
 import org.axonframework.repository.AggregateNotFoundException;
 import org.axonframework.unitofwork.CurrentUnitOfWork;
 import org.axonframework.unitofwork.DefaultUnitOfWork;
@@ -56,7 +55,7 @@ public class CachingEventSourcingRepositoryTest {
     @Before
     public void setUp() {
         mockEventStore = spy(new InMemoryEventStore());
+        testSubject = new CachingEventSourcingRepository&lt;&gt;(new StubAggregateFactory(), mockEventStore);
         mockEventBus = mock(EventBus.class);
         testSubject.setEventBus(mockEventBus);
 
@@ -106,7 +105,7 @@ public void describeTo(Description description) {
 
         DefaultUnitOfWork.startAndGet();
         DomainEventStream events = mockEventStore.readEvents("mock", aggregate1.getIdentifier());
+        List&lt;EventMessage&gt; eventList = new ArrayList&lt;&gt;();
         while (events.hasNext()) {
             eventList.add(events.next());
         }
@@ -167,11 +166,10 @@ public void describeTo(Description description) {
         }));
     }
 
+    @Test @Ignore
     public void testLoadAggregateFromCacheWithExpectedVersion_ConcurrentModificationsDetected() {
+        mockEventStore = spy(new InMemoryEventStore());
+        testSubject = new CachingEventSourcingRepository&lt;&gt;(new StubAggregateFactory(), mockEventStore);
         testSubject.setEventBus(mockEventBus);
         testSubject.setCache(cache);
 
@@ -278,53 +276,37 @@ public Class&lt;StubAggregate&gt; getAggregateType() {
         }
     }
 
     private class InMemoryEventStore implements EventStore {
 
+        protected Map&lt;Object, List&lt;DomainEventMessage&gt;&gt; store = new HashMap&lt;&gt;();
 
         @Override
         public void appendEvents(String identifier, DomainEventStream events) {
             while (events.hasNext()) {
                 DomainEventMessage next = events.next();
                 if (!store.containsKey(next.getAggregateIdentifier())) {
+                    store.put(next.getAggregateIdentifier(), new ArrayList&lt;&gt;());
                 }
                 List&lt;DomainEventMessage&gt; eventList = store.get(next.getAggregateIdentifier());
                 eventList.add(next);
             }
         }
 
         @Override
+        public DomainEventStream readEvents(String type, Object identifier, long firstSequenceNumber,
+                                            long lastSequenceNumber) {
             if (!store.containsKey(identifier)) {
                 throw new AggregateNotFoundException(identifier, "Aggregate not found");
             }
+            final List&lt;DomainEventMessage&gt; events = store.get(identifier);
+            List&lt;DomainEventMessage&gt; filteredEvents = new ArrayList&lt;&gt;();
+            for (DomainEventMessage message : events) {
+                if (message.getSequenceNumber() &gt;= firstSequenceNumber
+                        &amp;&amp; message.getSequenceNumber() &lt;= lastSequenceNumber) {
+                    filteredEvents.add(message);
+                }
+            }
+            return new SimpleDomainEventStream(filteredEvents);
         }
 
         public List&lt;DomainEventMessage&gt; readEventsAsList(Object identifier) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>556801</refactoring_id><commit_sha>89469c51979acaa8fff6811ee8d2b3f1a3f64ac9</commit_sha><commit_link>https://github.com/gocd/gocd/commit/89469c51979acaa8fff6811ee8d2b3f1a3f64ac9</commit_link><file_path>server/src/main/java/com/thoughtworks/go/server/service/ValueStreamMapService.java</file_path><description>Remove Parameter result : LocalizedOperationResult in method private removeRevisionsBasedOnPermissionAndCurrentConfig(valueStreamMap ValueStreamMap, username Username, result LocalizedOperationResult) : void from class com.thoughtworks.go.server.service.ValueStreamMapService</description><code_before>@@ -56,7 +56,7 @@ public class ValueStreamMapService {
     private final DownstreamInstancePopulator downstreamInstancePopulator;
     private final RunStagesPopulator runStagesPopulator;
     private final UnrunStagesPopulator unrunStagePopulator;
-    private SecurityService securityService;
     private static final Logger LOGGER = LoggerFactory.getLogger(ValueStreamMapService.class);
 
     @Autowired
@@ -112,7 +112,7 @@ private ValueStreamMap buildValueStreamMap(CaseInsensitiveString pipelineName, i
             return null;
         }
         addInstanceInformationToTheGraph(valueStreamMap);
-        removeRevisionsBasedOnPermissionAndCurrentConfig(valueStreamMap, username, result);
 
         valueStreamMap.addWarningIfBuiltFromInCompatibleRevisions();
 
@@ -168,31 +168,27 @@ public ValueStreamMapPresentationModel getValueStreamMap(String materialFingerpr
                 return null;
             }
 
-            ValueStreamMap valueStreamMap = buildValueStreamMap(material, materialInstance, modification, downstreamPipelines, username, result);
-            if (valueStreamMap == null) {
-                return null;
-            }
-            return valueStreamMap.presentationModel();
         } catch (Exception e) {
             result.internalServerError("Value Stream Map of material with fingerprint '" + materialFingerprint + "' with revision '" + revision + "' can not be rendered. Please check the server log for details.");
             LOGGER.error("[Value Stream Map] Material {} with revision {} could not be rendered.", materialFingerprint, revision, e);
             return null;
         }
     }
 
-    private ValueStreamMap buildValueStreamMap(Material material, MaterialInstance materialInstance, Modification modification, List&lt;PipelineConfig&gt; downstreamPipelines, Username username, LocalizedOperationResult result) {
         CruiseConfig cruiseConfig = goConfigService.currentCruiseConfig();
         ValueStreamMap valueStreamMap = new ValueStreamMap(material, materialInstance, modification);
         Map&lt;CaseInsensitiveString, List&lt;PipelineConfig&gt;&gt; pipelineToDownstreamMap = cruiseConfig.generatePipelineVsDownstreamMap();
 
         traverseDownstream(new CaseInsensitiveString(material.getFingerprint()), downstreamPipelines, pipelineToDownstreamMap, valueStreamMap, new ArrayList&lt;&gt;());
 
         addInstanceInformationToTheGraph(valueStreamMap);
-        removeRevisionsBasedOnPermissionAndCurrentConfig(valueStreamMap, username, result);
         return valueStreamMap;
     }
 
-    private void removeRevisionsBasedOnPermissionAndCurrentConfig(ValueStreamMap valueStreamMap, Username username, LocalizedOperationResult result) {
         for (Node node : valueStreamMap.allNodes()) {
             if (node instanceof PipelineDependencyNode) {
                 String pipelineName = node.getName();
</code_before><code_after>@@ -56,7 +56,7 @@ public class ValueStreamMapService {
     private final DownstreamInstancePopulator downstreamInstancePopulator;
     private final RunStagesPopulator runStagesPopulator;
     private final UnrunStagesPopulator unrunStagePopulator;
+    private final SecurityService securityService;
     private static final Logger LOGGER = LoggerFactory.getLogger(ValueStreamMapService.class);
 
     @Autowired
@@ -112,7 +112,7 @@ private ValueStreamMap buildValueStreamMap(CaseInsensitiveString pipelineName, i
             return null;
         }
         addInstanceInformationToTheGraph(valueStreamMap);
+        removeRevisionsBasedOnPermissionAndCurrentConfig(valueStreamMap, username);
 
         valueStreamMap.addWarningIfBuiltFromInCompatibleRevisions();
 
@@ -168,31 +168,27 @@ public ValueStreamMapPresentationModel getValueStreamMap(String materialFingerpr
                 return null;
             }
 
+            return buildValueStreamMap(material, materialInstance, modification, downstreamPipelines, username).presentationModel();
         } catch (Exception e) {
             result.internalServerError("Value Stream Map of material with fingerprint '" + materialFingerprint + "' with revision '" + revision + "' can not be rendered. Please check the server log for details.");
             LOGGER.error("[Value Stream Map] Material {} with revision {} could not be rendered.", materialFingerprint, revision, e);
             return null;
         }
     }
 
+    private ValueStreamMap buildValueStreamMap(Material material, MaterialInstance materialInstance, Modification modification, List&lt;PipelineConfig&gt; downstreamPipelines, Username username) {
         CruiseConfig cruiseConfig = goConfigService.currentCruiseConfig();
         ValueStreamMap valueStreamMap = new ValueStreamMap(material, materialInstance, modification);
         Map&lt;CaseInsensitiveString, List&lt;PipelineConfig&gt;&gt; pipelineToDownstreamMap = cruiseConfig.generatePipelineVsDownstreamMap();
 
         traverseDownstream(new CaseInsensitiveString(material.getFingerprint()), downstreamPipelines, pipelineToDownstreamMap, valueStreamMap, new ArrayList&lt;&gt;());
 
         addInstanceInformationToTheGraph(valueStreamMap);
+        removeRevisionsBasedOnPermissionAndCurrentConfig(valueStreamMap, username);
         return valueStreamMap;
     }
 
+    private void removeRevisionsBasedOnPermissionAndCurrentConfig(ValueStreamMap valueStreamMap, Username username) {
         for (Node node : valueStreamMap.allNodes()) {
             if (node instanceof PipelineDependencyNode) {
                 String pipelineName = node.getName();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>494642</refactoring_id><commit_sha>8c44bdf718874589c54b04b4744d1fa44efc2129</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/8c44bdf718874589c54b04b4744d1fa44efc2129</commit_link><file_path>engine/src/test/java/io/camunda/zeebe/engine/processing/streamprocessor/StreamProcessorTest.java</file_path><description>Remove Parameter responseWriter : LegacyTypedResponseWriter in method public processRecord(record TypedRecord&lt;UnifiedRecordValue&gt;, responseWriter LegacyTypedResponseWriter, streamWriter LegacyTypedStreamWriter) : void from class io.camunda.zeebe.engine.processing.streamprocessor.StreamProcessorTest.shouldWriteResponse.startTypedStreamProcessor.onCommand.new TypedRecordProcessor&lt;&gt;</description><code_before>@@ -271,11 +271,8 @@ public void shouldWriteFollowUpEvent() {
                     new TypedRecordProcessor&lt;&gt;() {
                       @Override
                       public void processRecord(
-                          final TypedRecord&lt;UnifiedRecordValue&gt; record,
-                          final LegacyTypedResponseWriter responseWriter,
-                          final LegacyTypedStreamWriter streamWriter) {
-
-                        streamWriter.appendFollowUpEvent(
                             record.getKey(),
                             ProcessInstanceIntent.ELEMENT_ACTIVATING,
                             record.getValue());
@@ -491,11 +488,8 @@ public void shouldWriteResponse() {
                 new TypedRecordProcessor&lt;&gt;() {
                   @Override
                   public void processRecord(
-                      final TypedRecord&lt;UnifiedRecordValue&gt; record,
-                      final LegacyTypedResponseWriter responseWriter,
-                      final LegacyTypedStreamWriter streamWriter) {
-
-                    responseWriter.writeEventOnCommand(
                         3, ProcessInstanceIntent.ELEMENT_ACTIVATING, record.getValue(), record);
                   }
                 }));
@@ -530,11 +524,8 @@ public void shouldWriteResponseOnFailedEventProcessing() {
                 new TypedRecordProcessor&lt;&gt;() {
                   @Override
                   public void processRecord(
-                      final TypedRecord&lt;UnifiedRecordValue&gt; record,
-                      final LegacyTypedResponseWriter responseWriter,
-                      final LegacyTypedStreamWriter streamWriter) {
-
-                    responseWriter.writeEventOnCommand(
                         3, ProcessInstanceIntent.ELEMENT_ACTIVATING, record.getValue(), record);
 
                     throw new RuntimeException("expected");
@@ -686,14 +677,14 @@ public void shouldNotOverwriteLastWrittenPositionIfNoFollowUpEvent()
                     new TypedRecordProcessor&lt;&gt;() {
                       @Override
                       public void processRecord(
-                          final TypedRecord&lt;UnifiedRecordValue&gt; record,
-                          final LegacyTypedResponseWriter responseWriter,
-                          final LegacyTypedStreamWriter streamWriter) {
-
-                        streamWriter.appendFollowUpEvent(
-                            record.getKey(),
-                            ProcessInstanceIntent.ELEMENT_ACTIVATING,
-                            record.getValue());
                       }
                     })
                 .onCommand(
</code_before><code_after>@@ -271,11 +271,8 @@ public void shouldWriteFollowUpEvent() {
                     new TypedRecordProcessor&lt;&gt;() {
                       @Override
                       public void processRecord(
+                          final TypedRecord&lt;UnifiedRecordValue&gt; record) {
+                        state.getWriters().state().appendFollowUpEvent(
                             record.getKey(),
                             ProcessInstanceIntent.ELEMENT_ACTIVATING,
                             record.getValue());
@@ -491,11 +488,8 @@ public void shouldWriteResponse() {
                 new TypedRecordProcessor&lt;&gt;() {
                   @Override
                   public void processRecord(
+                      final TypedRecord&lt;UnifiedRecordValue&gt; record) {
+                    context.getWriters().response().writeEventOnCommand(
                         3, ProcessInstanceIntent.ELEMENT_ACTIVATING, record.getValue(), record);
                   }
                 }));
@@ -530,11 +524,8 @@ public void shouldWriteResponseOnFailedEventProcessing() {
                 new TypedRecordProcessor&lt;&gt;() {
                   @Override
                   public void processRecord(
+                      final TypedRecord&lt;UnifiedRecordValue&gt; record) {
+                    context.getWriters().response().writeEventOnCommand(
                         3, ProcessInstanceIntent.ELEMENT_ACTIVATING, record.getValue(), record);
 
                     throw new RuntimeException("expected");
@@ -686,14 +677,14 @@ public void shouldNotOverwriteLastWrittenPositionIfNoFollowUpEvent()
                     new TypedRecordProcessor&lt;&gt;() {
                       @Override
                       public void processRecord(
+                          final TypedRecord&lt;UnifiedRecordValue&gt; record) {
+                        state
+                            .getWriters()
+                            .state()
+                            .appendFollowUpEvent(
+                                record.getKey(),
+                                ProcessInstanceIntent.ELEMENT_ACTIVATING,
+                                record.getValue());
                       }
                     })
                 .onCommand(
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>557417</refactoring_id><commit_sha>e0b340788e20e3b25f5b4a87b901d9a8bc6b1d4b</commit_sha><commit_link>https://github.com/seleniumhq/selenium/commit/e0b340788e20e3b25f5b4a87b901d9a8bc6b1d4b</commit_link><file_path>java/main/com/thoughtworks/selenium/browserlifecycle/session/StoppableBrowserSession.java</file_path><description>Remove Parameter browserExecutable : String in method public run(browserExecutable String, url String, timeout long) : void from class com.thoughtworks.selenium.browserlifecycle.session.StoppableBrowserSession</description><code_before>@@ -19,26 +19,27 @@
 import com.thoughtworks.selenium.browserlifecycle.LifeCycleException;
 import com.thoughtworks.selenium.browserlifecycle.coordinate.Waiter;
 import com.thoughtworks.selenium.browserlifecycle.window.Killable;
-import com.thoughtworks.selenium.browserlifecycle.window.Spawner;
 
-class StoppableBrowserSession implements BrowserSession {
 	
-	private Spawner _windowSpawner;
 	private Waiter _sessionWaiter;
 
-	public StoppableBrowserSession(Spawner windowSpawner, Waiter sessionWaiter) {
 		_windowSpawner = windowSpawner;
 		_sessionWaiter = sessionWaiter;
 	}
 
-	public void run(String browserExecutable, String url, long timeout) throws LifeCycleException {
-		Killable window = startBrowser(browserExecutable, url);
 		waitUntilSessionIsOver(timeout);
 		stopBrowser(window);
 	}
 
-	private Killable startBrowser(String browserExecutable, String url) throws LifeCycleException {
-		return _windowSpawner.spawn(browserExecutable, url);
 	}
 
 	private void waitUntilSessionIsOver(long timeout)
</code_before><code_after>@@ -19,26 +19,27 @@
 import com.thoughtworks.selenium.browserlifecycle.LifeCycleException;
 import com.thoughtworks.selenium.browserlifecycle.coordinate.Waiter;
 import com.thoughtworks.selenium.browserlifecycle.window.Killable;
+import com.thoughtworks.selenium.browserlifecycle.window.BrowserSpawner;
 
+public class StoppableBrowserSession implements BrowserSession {
 	
+	private BrowserSpawner _windowSpawner;
 	private Waiter _sessionWaiter;
 
+	public StoppableBrowserSession(BrowserSpawner windowSpawner, Waiter sessionWaiter) {
 		_windowSpawner = windowSpawner;
 		_sessionWaiter = sessionWaiter;
 	}
 
+	public void run(String url, long timeout) throws LifeCycleException {
+		_sessionWaiter.initialise();
+		Killable window = startBrowser(url);
 		waitUntilSessionIsOver(timeout);
 		stopBrowser(window);
 	}
 
+	private Killable startBrowser(String url) throws LifeCycleException {
+		return _windowSpawner.spawn(url);
 	}
 
 	private void waitUntilSessionIsOver(long timeout)
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>583402</refactoring_id><commit_sha>cf0106ea081d7300b7337b3baeeed0f881dae65d</commit_sha><commit_link>https://github.com/StarRocks/starrocks/commit/cf0106ea081d7300b7337b3baeeed0f881dae65d</commit_link><file_path>fe/fe-core/src/main/java/com/starrocks/persist/EditLog.java</file_path><description>Remove Parameter roleId : long in method public logDropRole(roleId long, privilegeCollection RolePrivilegeCollection, pluginId short, pluginVersion short) : void from class com.starrocks.persist.EditLog</description><code_before>@@ -1426,10 +1426,10 @@ public void logExportCreate(ExportJob job) {
         logEdit(OperationType.OP_EXPORT_CREATE, job);
     }
 
-    public void logExportUpdateState(long jobId, ExportJob.JobState newState, 
-            List&lt;Pair&lt;TNetworkAddress, String&gt;&gt; snapshotPaths, String exportTempPath,
-            Set&lt;String&gt; exportedFiles, ExportFailMsg failMsg) {
-        ExportJob.ExportUpdateInfo updateInfo = new ExportJob.ExportUpdateInfo(jobId, newState, 
                 snapshotPaths, exportTempPath, exportedFiles, failMsg);
         logEdit(OperationType.OP_EXPORT_UPDATE_INFO, updateInfo);
     }
@@ -1743,12 +1743,10 @@ public void logUpdateUserPrivilege(
     }
 
     public void logUpdateRolePrivilege(
-            long roleId,
-            RolePrivilegeCollection privilegeCollection,
             short pluginId,
             short pluginVersion) {
-        RolePrivilegeCollectionInfo info = new RolePrivilegeCollectionInfo(
-                roleId, privilegeCollection, pluginId, pluginVersion);
         logUpdateRolePrivilege(info);
     }
 
@@ -1757,12 +1755,10 @@ public void logUpdateRolePrivilege(RolePrivilegeCollectionInfo info) {
     }
 
     public void logDropRole(
-            long roleId,
-            RolePrivilegeCollection privilegeCollection,
             short pluginId,
             short pluginVersion) {
-        RolePrivilegeCollectionInfo info = new RolePrivilegeCollectionInfo(
-                roleId, privilegeCollection, pluginId, pluginVersion);
         logEdit(OperationType.OP_DROP_ROLE_V2, info);
     }
 
</code_before><code_after>@@ -1426,10 +1426,10 @@ public void logExportCreate(ExportJob job) {
         logEdit(OperationType.OP_EXPORT_CREATE, job);
     }
 
+    public void logExportUpdateState(long jobId, ExportJob.JobState newState,
+                                     List&lt;Pair&lt;TNetworkAddress, String&gt;&gt; snapshotPaths, String exportTempPath,
+                                     Set&lt;String&gt; exportedFiles, ExportFailMsg failMsg) {
+        ExportJob.ExportUpdateInfo updateInfo = new ExportJob.ExportUpdateInfo(jobId, newState,
                 snapshotPaths, exportTempPath, exportedFiles, failMsg);
         logEdit(OperationType.OP_EXPORT_UPDATE_INFO, updateInfo);
     }
@@ -1743,12 +1743,10 @@ public void logUpdateUserPrivilege(
     }
 
     public void logUpdateRolePrivilege(
+            Map&lt;Long, RolePrivilegeCollection&gt; rolePrivCollectionModified,
             short pluginId,
             short pluginVersion) {
+        RolePrivilegeCollectionInfo info = new RolePrivilegeCollectionInfo(rolePrivCollectionModified, pluginId, pluginVersion);
         logUpdateRolePrivilege(info);
     }
 
@@ -1757,12 +1755,10 @@ public void logUpdateRolePrivilege(RolePrivilegeCollectionInfo info) {
     }
 
     public void logDropRole(
+            Map&lt;Long, RolePrivilegeCollection&gt; rolePrivCollectionModified,
             short pluginId,
             short pluginVersion) {
+        RolePrivilegeCollectionInfo info = new RolePrivilegeCollectionInfo(rolePrivCollectionModified, pluginId, pluginVersion);
         logEdit(OperationType.OP_DROP_ROLE_V2, info);
     }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>530105</refactoring_id><commit_sha>c7eeeabf458b9a9afce086f4e5fbc456bf92d8e2</commit_sha><commit_link>https://github.com/apache/druid/commit/c7eeeabf458b9a9afce086f4e5fbc456bf92d8e2</commit_link><file_path>processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java</file_path><description>Remove Parameter numEntries : AtomicInteger in method protected abstract addToFacts(metrics AggregatorFactory[], deserializeComplexMetrics boolean, reportParseExceptions boolean, row InputRow, numEntries AtomicInteger, sizeInBytes AtomicLong, key IncrementalIndexRow, rowContainer ThreadLocal&lt;InputRow&gt;, rowSupplier Supplier&lt;InputRow&gt;, skipMaxRowsInMemoryCheck boolean) : AddToFactsResult from class org.apache.druid.segment.incremental.IncrementalIndex</description><code_before>@@ -97,8 +97,6 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Stream;
 
-/**
- */
 public abstract class IncrementalIndex&lt;AggregatorType&gt; extends AbstractIndex implements Iterable&lt;Row&gt;, Closeable
 {
   private volatile DateTime maxIngestedEventTime;
@@ -250,7 +248,7 @@ public ColumnCapabilities getColumnCapabilities(String columnName)
   /**
    * Setting deserializeComplexMetrics to false is necessary for intermediate aggregation such as groupBy that
    * should not deserialize input columns using ComplexMetricSerde for aggregators that return complex metrics.
-   *
    * Set concurrentEventAdd to true to indicate that adding of input row should be thread-safe (for example, groupBy
    * where the multiple threads can add concurrently to the IncrementalIndex).
    *
@@ -482,12 +480,7 @@ protected abstract AggregatorType[] initAggs(
 
   // Note: This method needs to be thread safe.
   protected abstract AddToFactsResult addToFacts(
-      AggregatorFactory[] metrics,
-      boolean deserializeComplexMetrics,
-      boolean reportParseExceptions,
       InputRow row,
-      AtomicInteger numEntries,
-      AtomicLong sizeInBytes,
       IncrementalIndexRow key,
       ThreadLocal&lt;InputRow&gt; rowContainer,
       Supplier&lt;InputRow&gt; rowSupplier,
@@ -608,12 +601,7 @@ public IncrementalIndexAddResult add(InputRow row, boolean skipMaxRowsInMemoryCh
   {
     IncrementalIndexRowResult incrementalIndexRowResult = toIncrementalIndexRow(row);
     final AddToFactsResult addToFactsResult = addToFacts(
-        metrics,
-        deserializeComplexMetrics,
-        reportParseExceptions,
         row,
-        numEntries,
-        bytesInMemory,
         incrementalIndexRowResult.getIncrementalIndexRow(),
         in,
         rowSupplier,
@@ -625,7 +613,11 @@ public IncrementalIndexAddResult add(InputRow row, boolean skipMaxRowsInMemoryCh
         incrementalIndexRowResult.getParseExceptionMessages(),
         addToFactsResult.getParseExceptionMessages()
     );
-    return new IncrementalIndexAddResult(addToFactsResult.getRowCount(), addToFactsResult.getBytesInMemory(), parseException);
   }
 
   @VisibleForTesting
@@ -785,9 +777,29 @@ public int size()
     return numEntries.get();
   }
 
-  public long getBytesInMemory()
   {
-    return bytesInMemory.get();
   }
 
   private long getMinTimeMillis()
@@ -908,7 +920,10 @@ private ColumnCapabilitiesImpl makeCapabilitiesFromValueType(ValueType type)
    * Index dimension ordering could be changed to initialize from DimensionsSpec after resolution of
    * https://github.com/apache/incubator-druid/issues/2011
    */
-  public void loadDimensionIterable(Iterable&lt;String&gt; oldDimensionOrder, Map&lt;String, ColumnCapabilitiesImpl&gt; oldColumnCapabilities)
   {
     synchronized (dimensionDescs) {
       if (!dimensionDescs.isEmpty()) {
@@ -1289,7 +1304,9 @@ public long getMaxTimeMillis()
     public Iterator&lt;IncrementalIndexRow&gt; iterator(boolean descending)
     {
       if (descending &amp;&amp; sortFacts) {
-        return ((ConcurrentNavigableMap&lt;IncrementalIndexRow, IncrementalIndexRow&gt;) facts).descendingMap().keySet().iterator();
       }
       return keySet().iterator();
     }
@@ -1387,7 +1404,7 @@ public Iterator&lt;IncrementalIndexRow&gt; iterator(boolean descending)
     {
       if (descending &amp;&amp; sortFacts) {
         return timeOrderedConcat(((ConcurrentNavigableMap&lt;Long, Deque&lt;IncrementalIndexRow&gt;&gt;) facts)
-                .descendingMap().values(), true).iterator();
       }
       return timeOrderedConcat(facts.values(), false).iterator();
     }
</code_before><code_after>@@ -97,8 +97,6 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Stream;
 
 public abstract class IncrementalIndex&lt;AggregatorType&gt; extends AbstractIndex implements Iterable&lt;Row&gt;, Closeable
 {
   private volatile DateTime maxIngestedEventTime;
@@ -250,7 +248,7 @@ public ColumnCapabilities getColumnCapabilities(String columnName)
   /**
    * Setting deserializeComplexMetrics to false is necessary for intermediate aggregation such as groupBy that
    * should not deserialize input columns using ComplexMetricSerde for aggregators that return complex metrics.
+   * &lt;p&gt;
    * Set concurrentEventAdd to true to indicate that adding of input row should be thread-safe (for example, groupBy
    * where the multiple threads can add concurrently to the IncrementalIndex).
    *
@@ -482,12 +480,7 @@ protected abstract AggregatorType[] initAggs(
 
   // Note: This method needs to be thread safe.
   protected abstract AddToFactsResult addToFacts(
       InputRow row,
       IncrementalIndexRow key,
       ThreadLocal&lt;InputRow&gt; rowContainer,
       Supplier&lt;InputRow&gt; rowSupplier,
@@ -608,12 +601,7 @@ public IncrementalIndexAddResult add(InputRow row, boolean skipMaxRowsInMemoryCh
   {
     IncrementalIndexRowResult incrementalIndexRowResult = toIncrementalIndexRow(row);
     final AddToFactsResult addToFactsResult = addToFacts(
         row,
         incrementalIndexRowResult.getIncrementalIndexRow(),
         in,
         rowSupplier,
@@ -625,7 +613,11 @@ public IncrementalIndexAddResult add(InputRow row, boolean skipMaxRowsInMemoryCh
         incrementalIndexRowResult.getParseExceptionMessages(),
         addToFactsResult.getParseExceptionMessages()
     );
+    return new IncrementalIndexAddResult(
+        addToFactsResult.getRowCount(),
+        addToFactsResult.getBytesInMemory(),
+        parseException
+    );
   }
 
   @VisibleForTesting
@@ -785,9 +777,29 @@ public int size()
     return numEntries.get();
   }
 
+  boolean getDeserializeComplexMetrics()
+  {
+    return deserializeComplexMetrics;
+  }
+
+  boolean getReportParseExceptions()
+  {
+    return reportParseExceptions;
+  }
+
+  AtomicInteger getNumEntries()
+  {
+    return numEntries;
+  }
+
+  AggregatorFactory[] getMetrics()
   {
+    return metrics;
+  }
+
+  public AtomicLong getBytesInMemory()
+  {
+    return bytesInMemory;
   }
 
   private long getMinTimeMillis()
@@ -908,7 +920,10 @@ private ColumnCapabilitiesImpl makeCapabilitiesFromValueType(ValueType type)
    * Index dimension ordering could be changed to initialize from DimensionsSpec after resolution of
    * https://github.com/apache/incubator-druid/issues/2011
    */
+  public void loadDimensionIterable(
+      Iterable&lt;String&gt; oldDimensionOrder,
+      Map&lt;String, ColumnCapabilitiesImpl&gt; oldColumnCapabilities
+  )
   {
     synchronized (dimensionDescs) {
       if (!dimensionDescs.isEmpty()) {
@@ -1289,7 +1304,9 @@ public long getMaxTimeMillis()
     public Iterator&lt;IncrementalIndexRow&gt; iterator(boolean descending)
     {
       if (descending &amp;&amp; sortFacts) {
+        return ((ConcurrentNavigableMap&lt;IncrementalIndexRow, IncrementalIndexRow&gt;) facts).descendingMap()
+                                                                                         .keySet()
+                                                                                         .iterator();
       }
       return keySet().iterator();
     }
@@ -1387,7 +1404,7 @@ public Iterator&lt;IncrementalIndexRow&gt; iterator(boolean descending)
     {
       if (descending &amp;&amp; sortFacts) {
         return timeOrderedConcat(((ConcurrentNavigableMap&lt;Long, Deque&lt;IncrementalIndexRow&gt;&gt;) facts)
+                                     .descendingMap().values(), true).iterator();
       }
       return timeOrderedConcat(facts.values(), false).iterator();
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>469456</refactoring_id><commit_sha>9d079f4ff5ba12cdba66c15dba15b4bef03eccec</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/9d079f4ff5ba12cdba66c15dba15b4bef03eccec</commit_link><file_path>webapps/webapp/src/main/java/org/camunda/bpm/cockpit/impl/plugin/base/resources/ProcessInstanceRestService.java</file_path><description>Remove Parameter maxResults : Integer in method public queryProcessInstances(queryParameter ProcessInstanceQueryParameter, firstResult Integer, maxResults Integer) : List&lt;ProcessInstanceDto&gt; from class org.camunda.bpm.cockpit.impl.plugin.base.resources.ProcessInstanceRestService</description><code_before>@@ -14,7 +14,7 @@
 import javax.ws.rs.core.UriInfo;
 
 import org.camunda.bpm.cockpit.impl.plugin.base.dto.ProcessInstanceDto;
-import org.camunda.bpm.cockpit.impl.plugin.base.query.parameter.ProcessInstanceQueryParameter;
 import org.camunda.bpm.cockpit.impl.plugin.base.sub.resources.ProcessInstanceResource;
 import org.camunda.bpm.cockpit.plugin.resource.AbstractPluginResource;
 import org.camunda.bpm.engine.impl.ProcessEngineImpl;
@@ -28,55 +28,53 @@ public class ProcessInstanceRestService extends AbstractPluginResource {
   public ProcessInstanceRestService(String engineName) {
     super(engineName);
   }
-  
   @Path("/{id}")
   public ProcessInstanceResource getProcessInstance(@PathParam("id") String id) {
     return new ProcessInstanceResource(getProcessEngine().getName(), id);
   }
- 
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   public List&lt;ProcessInstanceDto&gt; getProcessInstances(@Context UriInfo uriInfo,
       @QueryParam("firstResult") Integer firstResult, @QueryParam("maxResults") Integer maxResults) {
-    ProcessInstanceQueryParameter queryParameter = new ProcessInstanceQueryParameter(uriInfo.getQueryParameters());
     return queryProcessInstances(queryParameter, firstResult, maxResults);
   }
-  
   @POST
   @Produces(MediaType.APPLICATION_JSON)
   @Consumes(MediaType.APPLICATION_JSON)
-  public List&lt;ProcessInstanceDto&gt; queryProcessInstances(ProcessInstanceQueryParameter queryParameter,
       @QueryParam("firstResult") Integer firstResult, @QueryParam("maxResults") Integer maxResults) {
-    ProcessEngineConfigurationImpl processEngineConfiguration = ((ProcessEngineImpl) getProcessEngine()).getProcessEngineConfiguration();
-    if (processEngineConfiguration.getHistoryLevel() == 0) {
-      queryParameter.setHistoryEnabled(false);
-    }
-    paginateQueryParameters(queryParameter, firstResult, maxResults);
     return getQueryService().executeQuery("selectRunningProcessInstancesIncludingIncidents", queryParameter);
   }
-  
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   @Path("/count")
   public CountResultDto getProcessInstancesCount(@Context UriInfo uriInfo) {
-    ProcessInstanceQueryParameter queryParameter = new ProcessInstanceQueryParameter(uriInfo.getQueryParameters());
     return queryProcessInstancesCount(queryParameter);
   }
-  
   @POST
   @Produces(MediaType.APPLICATION_JSON)
   @Consumes(MediaType.APPLICATION_JSON)
   @Path("/count")
-  public CountResultDto queryProcessInstancesCount(ProcessInstanceQueryParameter queryParameter) {
-    ProcessEngineConfigurationImpl processEngineConfiguration = ((ProcessEngineImpl) getProcessEngine()).getProcessEngineConfiguration();
-    if (processEngineConfiguration.getHistoryLevel() == 0) {
-      queryParameter.setHistoryEnabled(false);
-    }
     long result = getQueryService().executeQueryRowCount("selectRunningProcessInstancesCount", queryParameter);
     return new CountResultDto(result);
   }
-  
-  private void paginateQueryParameters(ProcessInstanceQueryParameter queryParameter, Integer firstResult, Integer maxResults) {
     if (firstResult == null) {
       firstResult = 0;
     }
@@ -87,4 +85,13 @@ private void paginateQueryParameters(ProcessInstanceQueryParameter queryParamete
     queryParameter.setMaxResults(maxResults);
   }
 
 }
</code_before><code_after>@@ -14,7 +14,7 @@
 import javax.ws.rs.core.UriInfo;
 
 import org.camunda.bpm.cockpit.impl.plugin.base.dto.ProcessInstanceDto;
+import org.camunda.bpm.cockpit.impl.plugin.base.dto.query.ProcessInstanceQueryDto;
 import org.camunda.bpm.cockpit.impl.plugin.base.sub.resources.ProcessInstanceResource;
 import org.camunda.bpm.cockpit.plugin.resource.AbstractPluginResource;
 import org.camunda.bpm.engine.impl.ProcessEngineImpl;
@@ -28,55 +28,53 @@ public class ProcessInstanceRestService extends AbstractPluginResource {
   public ProcessInstanceRestService(String engineName) {
     super(engineName);
   }
+
   @Path("/{id}")
   public ProcessInstanceResource getProcessInstance(@PathParam("id") String id) {
     return new ProcessInstanceResource(getProcessEngine().getName(), id);
   }
+
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   public List&lt;ProcessInstanceDto&gt; getProcessInstances(@Context UriInfo uriInfo,
       @QueryParam("firstResult") Integer firstResult, @QueryParam("maxResults") Integer maxResults) {
+    ProcessInstanceQueryDto queryParameter = new ProcessInstanceQueryDto(uriInfo.getQueryParameters());
     return queryProcessInstances(queryParameter, firstResult, maxResults);
   }
+
   @POST
   @Produces(MediaType.APPLICATION_JSON)
   @Consumes(MediaType.APPLICATION_JSON)
+  public List&lt;ProcessInstanceDto&gt; queryProcessInstances(ProcessInstanceQueryDto queryParameter,
       @QueryParam("firstResult") Integer firstResult, @QueryParam("maxResults") Integer maxResults) {
+
+    injectEngineConfig(queryParameter);
+    paginate(queryParameter, firstResult, maxResults);
+    
     return getQueryService().executeQuery("selectRunningProcessInstancesIncludingIncidents", queryParameter);
   }
+
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   @Path("/count")
   public CountResultDto getProcessInstancesCount(@Context UriInfo uriInfo) {
+    ProcessInstanceQueryDto queryParameter = new ProcessInstanceQueryDto(uriInfo.getQueryParameters());
     return queryProcessInstancesCount(queryParameter);
   }
+
   @POST
   @Produces(MediaType.APPLICATION_JSON)
   @Consumes(MediaType.APPLICATION_JSON)
   @Path("/count")
+  public CountResultDto queryProcessInstancesCount(ProcessInstanceQueryDto queryParameter) {
+
+    injectEngineConfig(queryParameter);
+
     long result = getQueryService().executeQueryRowCount("selectRunningProcessInstancesCount", queryParameter);
     return new CountResultDto(result);
   }
+
+  private void paginate(ProcessInstanceQueryDto queryParameter, Integer firstResult, Integer maxResults) {
     if (firstResult == null) {
       firstResult = 0;
     }
@@ -87,4 +85,13 @@ private void paginateQueryParameters(ProcessInstanceQueryParameter queryParamete
     queryParameter.setMaxResults(maxResults);
   }
 
+  private void injectEngineConfig(ProcessInstanceQueryDto parameter) {
+
+    ProcessEngineConfigurationImpl processEngineConfiguration = ((ProcessEngineImpl) getProcessEngine()).getProcessEngineConfiguration();
+    if (processEngineConfiguration.getHistoryLevel() == 0) {
+      parameter.setHistoryEnabled(false);
+    }
+
+    parameter.initQueryVariableValues(processEngineConfiguration.getVariableTypes());
+  }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>498913</refactoring_id><commit_sha>ee6732955db6f2d31733146b32e0adae559f894b</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/ee6732955db6f2d31733146b32e0adae559f894b</commit_link><file_path>src/main/java/mekanism/generators/common/block/turbine/BlockTurbineRotor.java</file_path><description>Remove Parameter hitZ : float in method public onBlockActivated(world World, pos BlockPos, state BlockState, entityplayer PlayerEntity, hand Hand, side Direction, hitX float, hitY float, hitZ float) : boolean from class mekanism.generators.common.block.turbine.BlockTurbineRotor</description><code_before>@@ -12,9 +12,8 @@
 import mekanism.generators.common.MekanismGenerators;
 import mekanism.generators.common.tile.turbine.TileEntityTurbineRotor;
 import net.minecraft.block.Block;
-import net.minecraft.block.material.Material;
-import net.minecraft.block.state.BlockFaceShape;
 import net.minecraft.block.BlockState;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.item.ItemStack;
 import net.minecraft.tileentity.TileEntity;
@@ -24,9 +23,10 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
-import net.minecraft.world.IWorldReader;
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
@@ -74,42 +74,42 @@ public void breakBlock(World world, @Nonnull BlockPos pos, @Nonnull BlockState s
     }
 
     @Override
-    public boolean onBlockActivated(World world, BlockPos pos, BlockState state, PlayerEntity entityplayer, Hand hand, Direction side, float hitX, float hitY, float hitZ) {
         if (world.isRemote) {
             return true;
         }
         TileEntityMekanism tileEntity = (TileEntityMekanism) world.getTileEntity(pos);
-        if (tileEntity.tryWrench(state, entityplayer, hand, () -&gt; new RayTraceResult(new Vec3d(hitX, hitY, hitZ), side, pos)) != WrenchResult.PASS) {
             return true;
         }
 
-        ItemStack stack = entityplayer.getHeldItem(hand);
         TileEntityTurbineRotor rod = (TileEntityTurbineRotor) tileEntity;
-        if (!entityplayer.isSneaking()) {
             if (!stack.isEmpty() &amp;&amp; stack.getItem() == GeneratorsItem.TURBINE_BLADE.getItem()) {
                 if (rod.addBlade()) {
-                    if (!entityplayer.isCreative()) {
                         stack.shrink(1);
                         if (stack.getCount() == 0) {
-                            entityplayer.setHeldItem(hand, ItemStack.EMPTY);
                         }
                     }
                 }
                 return true;
             }
         } else if (stack.isEmpty()) {
             if (rod.removeBlade()) {
-                if (!entityplayer.isCreative()) {
-                    entityplayer.setHeldItem(hand, GeneratorsItem.TURBINE_BLADE.getItemStack());
-                    entityplayer.inventory.markDirty();
                 }
             }
         } else if (stack.getItem() == GeneratorsItem.TURBINE_BLADE.getItem()) {
             if (stack.getCount() &lt; stack.getMaxStackSize()) {
                 if (rod.removeBlade()) {
-                    if (!entityplayer.isCreative()) {
                         stack.grow(1);
-                        entityplayer.inventory.markDirty();
                     }
                 }
             }
@@ -132,13 +132,13 @@ public BlockRenderLayer getRenderLayer() {
     @Nonnull
     @Override
     @Deprecated
-    public AxisAlignedBB getBoundingBox(BlockState state, IWorldReader world, BlockPos pos) {
         return ROTOR_BOUNDS;
     }
 
     @Override
     @Deprecated
-    public boolean isSideSolid(BlockState state, @Nonnull IWorldReader world, @Nonnull BlockPos pos, Direction side) {
         //TODO
         return false;
     }
</code_before><code_after>@@ -12,9 +12,8 @@
 import mekanism.generators.common.MekanismGenerators;
 import mekanism.generators.common.tile.turbine.TileEntityTurbineRotor;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockState;
+import net.minecraft.block.material.Material;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.item.ItemStack;
 import net.minecraft.tileentity.TileEntity;
@@ -24,9 +23,10 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.BlockRayTraceResult;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.IBlockReader;
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
@@ -74,42 +74,42 @@ public void breakBlock(World world, @Nonnull BlockPos pos, @Nonnull BlockState s
     }
 
     @Override
+    public boolean onBlockActivated(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockRayTraceResult hit) {
         if (world.isRemote) {
             return true;
         }
         TileEntityMekanism tileEntity = (TileEntityMekanism) world.getTileEntity(pos);
+        if (tileEntity.tryWrench(state, player, hand, hit) != WrenchResult.PASS) {
             return true;
         }
 
+        ItemStack stack = player.getHeldItem(hand);
         TileEntityTurbineRotor rod = (TileEntityTurbineRotor) tileEntity;
+        if (!player.isSneaking()) {
             if (!stack.isEmpty() &amp;&amp; stack.getItem() == GeneratorsItem.TURBINE_BLADE.getItem()) {
                 if (rod.addBlade()) {
+                    if (!player.isCreative()) {
                         stack.shrink(1);
                         if (stack.getCount() == 0) {
+                            player.setHeldItem(hand, ItemStack.EMPTY);
                         }
                     }
                 }
                 return true;
             }
         } else if (stack.isEmpty()) {
             if (rod.removeBlade()) {
+                if (!player.isCreative()) {
+                    player.setHeldItem(hand, GeneratorsItem.TURBINE_BLADE.getItemStack());
+                    player.inventory.markDirty();
                 }
             }
         } else if (stack.getItem() == GeneratorsItem.TURBINE_BLADE.getItem()) {
             if (stack.getCount() &lt; stack.getMaxStackSize()) {
                 if (rod.removeBlade()) {
+                    if (!player.isCreative()) {
                         stack.grow(1);
+                        player.inventory.markDirty();
                     }
                 }
             }
@@ -132,13 +132,13 @@ public BlockRenderLayer getRenderLayer() {
     @Nonnull
     @Override
     @Deprecated
+    public AxisAlignedBB getBoundingBox(BlockState state, IBlockReader world, BlockPos pos) {
         return ROTOR_BOUNDS;
     }
 
     @Override
     @Deprecated
+    public boolean isSideSolid(BlockState state, @Nonnull IBlockReader world, @Nonnull BlockPos pos, Direction side) {
         //TODO
         return false;
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>539626</refactoring_id><commit_sha>7fe2a5603ac0c8eec15384fbc6342b70e5087dc5</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/7fe2a5603ac0c8eec15384fbc6342b70e5087dc5</commit_link><file_path>src/edu/stanford/nlp/ie/crf/NonLinearCliquePotentialFunction.java</file_path><description>Remove Parameter posInSent : int in method public computeCliquePotential(cliqueSize int, labelIndex int, cliqueFeatures int[], featureVal double[], posInSent int) : double from class edu.stanford.nlp.ie.crf.NonLinearCliquePotentialFunction</description><code_before>@@ -60,8 +60,7 @@ public double[] hiddenLayerOutput(double[][] inputLayerWeights, int[] nodeClique
   }
 
   @Override
-  public double computeCliquePotential(int cliqueSize, int labelIndex, 
-      int[] cliqueFeatures, double[] featureVal, int posInSent) {
     double output = 0.0;
     if (cliqueSize &gt; 1) { // linear potential for edge cliques
       for (int m = 0; m &lt; cliqueFeatures.length; m++) {
</code_before><code_after>@@ -60,8 +60,7 @@ public double[] hiddenLayerOutput(double[][] inputLayerWeights, int[] nodeClique
   }
 
   @Override
+  public double computeCliquePotential(int cliqueSize, int labelIndex, int[] cliqueFeatures, double[] featureVal) {
     double output = 0.0;
     if (cliqueSize &gt; 1) { // linear potential for edge cliques
       for (int m = 0; m &lt; cliqueFeatures.length; m++) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>562292</refactoring_id><commit_sha>db1eae0227d3ce20e4bd91d420062dd392e0a1d3</commit_sha><commit_link>https://github.com/yacy/yacy_search_server/commit/db1eae0227d3ce20e4bd91d420062dd392e0a1d3</commit_link><file_path>source/de/anomic/kelondro/kelondroHashtable.java</file_path><description>Remove Parameter exitOnFail : boolean in method public kelondroHashtable(file File, rowdef kelondroRow, offset int, maxsize int, maxrehash int, exitOnFail boolean) from class de.anomic.kelondro.kelondroHashtable</description><code_before>@@ -142,7 +142,7 @@ public class kelondroHashtable {
     
     private   static final byte[] dummyKey = kelondroBase64Order.enhancedCoder.encodeLong(0, 5).getBytes();
 
-    public kelondroHashtable(File file, kelondroRow rowdef, int offset, int maxsize, int maxrehash, boolean exitOnFail) {
         // this creates a new hashtable
         // the key element is not part of the columns array
         // this is unlike the kelondroTree, where the key is part of a row
@@ -152,32 +152,25 @@ public kelondroHashtable(File file, kelondroRow rowdef, int offset, int maxsize,
         // this number is needed to omit grow of the table in case of re-hashing
         // the maxsize is re-computed to a virtual folding height and will result in a tablesize
         // less than the given maxsize. The actual maxsize can be retrieved by maxsize()
-        this.hashArray = new kelondroFixedWidthArray(file, extCol(rowdef), 6, exitOnFail);
-        this.offset = offset;
-        this.maxk = kelondroMSetTools.log2a(maxsize); // equal to |log2(maxsize)| + 1
-        if (this.maxk &gt;= kelondroMSetTools.log2a(maxsize + power2(offset + 1) + 1) - 1) this.maxk--;
-        this.maxrehash = maxrehash;
-        dummyRow = this.hashArray.row().newEntry();
-        dummyRow.setCol(0, dummyKey);
-        for (int i = 0; i &lt; hashArray.row().columns(); i++)
-        try {
             hashArray.seti(0, this.offset);
             hashArray.seti(1, this.maxk);
             hashArray.seti(2, this.maxrehash);
-        } catch (IOException e) {
-            hashArray.logFailure("cannot set properties / " + e.getMessage());
-            if (exitOnFail) System.exit(-1);
-            throw new RuntimeException("cannot set properties / " + e.getMessage());
         }
     }
-
-    public kelondroHashtable(File file, kelondroRow rowdef) throws IOException{
-        // this opens a file with an existing hashtable
-        this.hashArray = new kelondroFixedWidthArray(file, rowdef);
-        this.offset    = hashArray.geti(0);
-        this.maxk      = hashArray.geti(1);
-        this.maxrehash = hashArray.geti(2);
-    }
     
     private kelondroRow extCol(kelondroRow rowdef) {
         kelondroColumn[] newCol = new kelondroColumn[rowdef.columns() + 1];
</code_before><code_after>@@ -142,7 +142,7 @@ public class kelondroHashtable {
     
     private   static final byte[] dummyKey = kelondroBase64Order.enhancedCoder.encodeLong(0, 5).getBytes();
 
+    public kelondroHashtable(File file, kelondroRow rowdef, int offset, int maxsize, int maxrehash) throws IOException {
         // this creates a new hashtable
         // the key element is not part of the columns array
         // this is unlike the kelondroTree, where the key is part of a row
@@ -152,32 +152,25 @@ public kelondroHashtable(File file, kelondroRow rowdef, int offset, int maxsize,
         // this number is needed to omit grow of the table in case of re-hashing
         // the maxsize is re-computed to a virtual folding height and will result in a tablesize
         // less than the given maxsize. The actual maxsize can be retrieved by maxsize()
+        boolean fileExisted = file.exists();
+        this.hashArray = new kelondroFixedWidthArray(file, extCol(rowdef), 6);
+        if (fileExisted) {
+            this.offset    = hashArray.geti(0);
+            this.maxk      = hashArray.geti(1);
+            this.maxrehash = hashArray.geti(2);
+        } else {
+            this.offset = offset;
+            this.maxk = kelondroMSetTools.log2a(maxsize); // equal to |log2(maxsize)| + 1
+            if (this.maxk &gt;= kelondroMSetTools.log2a(maxsize + power2(offset + 1) + 1) - 1) this.maxk--;
+            this.maxrehash = maxrehash;
+            dummyRow = this.hashArray.row().newEntry();
+            dummyRow.setCol(0, dummyKey);
+            //for (int i = 0; i &lt; hashArray.row().columns(); i++)
             hashArray.seti(0, this.offset);
             hashArray.seti(1, this.maxk);
             hashArray.seti(2, this.maxrehash);
         }
     }
     
     private kelondroRow extCol(kelondroRow rowdef) {
         kelondroColumn[] newCol = new kelondroColumn[rowdef.columns() + 1];
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>542406</refactoring_id><commit_sha>689ddcf785f245fddc6af5f9a190889d8e33146b</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/689ddcf785f245fddc6af5f9a190889d8e33146b</commit_link><file_path>src/edu/stanford/nlp/process/stattok/StatTokSent.java</file_path><description>Remove Parameter windowSize : int in method public StatTokSent(modelFile String, windowSize int) from class edu.stanford.nlp.process.stattok.StatTokSent</description><code_before>@@ -54,27 +54,32 @@ public class StatTokSent{
    * 	modelFile: a string containing the path to the model;
    * 	multiWordRulesFile: a string containing the path to the file with multi-word tokens.
    */
-  public StatTokSent(String modelFile, String multiWordRulesFile, int windowSize) throws IOException, ClassNotFoundException{
     logger.info("Loading StatTokSent model from " + modelFile);
     logger.info("Using multi word rules from " + multiWordRulesFile);
 
-    this.windowSize = windowSize;
     ObjectInputStream ois;
 		
     ois = IOUtils.readStreamFromString(modelFile);
     cdc = ColumnDataClassifier.getClassifier(ois);
-	
     multiWordRules = this.readMultiWordRules(multiWordRulesFile);
   }
 
-  public StatTokSent(String modelFile, int windowSize) throws IOException, ClassNotFoundException{
     logger.info("Loading StatTokSent model from " + modelFile);
     logger.info("Using default multi word rules");
     this.windowSize = windowSize;
     ObjectInputStream ois;
 		
     ois = IOUtils.readStreamFromString(modelFile);
     cdc = ColumnDataClassifier.getClassifier(ois);
   }
 
 
@@ -443,7 +448,6 @@ public List&lt;List&lt;CoreLabel&gt;&gt; tokenize(String text){
   public static void main(String[] args) throws Exception{
     Map&lt;String, String[]&gt; arguments = StringUtils.argsToMap(args);
     String textFile = null;
-    String model = null;
     int windowSize = 0;
     String multiWordRulesFile = null;
     try{
@@ -452,11 +456,12 @@ public static void main(String[] args) throws Exception{
       System.out.println("You have not specified a text file.\nUse -textFile option.");
       ex.printStackTrace();
     }
-    try{
-      model = arguments.get("-model")[0];
-    }catch (NullPointerException ex){
       System.out.println("You have not specified a model.\nUse -model option.");
-      ex.printStackTrace();
     }
     try{
       windowSize = Integer.parseInt(arguments.get("-windowSize")[0]);
@@ -483,9 +488,9 @@ public static void main(String[] args) throws Exception{
 
     StatTokSent tokenizer = null;
     if (multiWordRulesFile != null){
-      tokenizer = new StatTokSent(model, multiWordRulesFile, windowSize);
     }else{
-      tokenizer = new StatTokSent(model, windowSize);
     }
 
     List&lt;List&lt;CoreLabel&gt;&gt; sentences = tokenizer.tokenize(text);
</code_before><code_after>@@ -54,27 +54,32 @@ public class StatTokSent{
    * 	modelFile: a string containing the path to the model;
    * 	multiWordRulesFile: a string containing the path to the file with multi-word tokens.
    */
+  public StatTokSent(String modelFile, String multiWordRulesFile) throws IOException, ClassNotFoundException{
     logger.info("Loading StatTokSent model from " + modelFile);
     logger.info("Using multi word rules from " + multiWordRulesFile);
 
     ObjectInputStream ois;
 		
     ois = IOUtils.readStreamFromString(modelFile);
     cdc = ColumnDataClassifier.getClassifier(ois);
+    this.windowSize = ois.readInt();
+
+    logger.info("Found window size of " + this.windowSize);
+
     multiWordRules = this.readMultiWordRules(multiWordRulesFile);
   }
 
+  public StatTokSent(String modelFile) throws IOException, ClassNotFoundException{
     logger.info("Loading StatTokSent model from " + modelFile);
     logger.info("Using default multi word rules");
     this.windowSize = windowSize;
     ObjectInputStream ois;
 		
     ois = IOUtils.readStreamFromString(modelFile);
     cdc = ColumnDataClassifier.getClassifier(ois);
+    this.windowSize = ois.readInt();
+
+    logger.info("Found window size of " + this.windowSize);
   }
 
 
@@ -443,7 +448,6 @@ public List&lt;List&lt;CoreLabel&gt;&gt; tokenize(String text){
   public static void main(String[] args) throws Exception{
     Map&lt;String, String[]&gt; arguments = StringUtils.argsToMap(args);
     String textFile = null;
     int windowSize = 0;
     String multiWordRulesFile = null;
     try{
@@ -452,11 +456,12 @@ public static void main(String[] args) throws Exception{
       System.out.println("You have not specified a text file.\nUse -textFile option.");
       ex.printStackTrace();
     }
+    final String modelFile;
+    try {
+      modelFile = arguments.get("-model")[0];
+    } catch (NullPointerException ex) {
       System.out.println("You have not specified a model.\nUse -model option.");
+      throw ex;
     }
     try{
       windowSize = Integer.parseInt(arguments.get("-windowSize")[0]);
@@ -483,9 +488,9 @@ public static void main(String[] args) throws Exception{
 
     StatTokSent tokenizer = null;
     if (multiWordRulesFile != null){
+      tokenizer = new StatTokSent(modelFile, multiWordRulesFile);
     }else{
+      tokenizer = new StatTokSent(modelFile);
     }
 
     List&lt;List&lt;CoreLabel&gt;&gt; sentences = tokenizer.tokenize(text);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>566986</refactoring_id><commit_sha>0186794104b7106fe426024d65730fec79ad999a</commit_sha><commit_link>https://github.com/AutoMQ/automq/commit/0186794104b7106fe426024d65730fec79ad999a</commit_link><file_path>clients/src/main/java/org/apache/kafka/common/requests/TxnOffsetCommitRequest.java</file_path><description>Remove Parameter retentionTimeMs : long in method public Builder(consumerGroupId String, producerId long, producerEpoch short, retentionTimeMs long, offsets Map&lt;TopicPartition,CommittedOffset&gt;) from class org.apache.kafka.common.requests.TxnOffsetCommitRequest.Builder</description><code_before>@@ -30,7 +30,6 @@ public class TxnOffsetCommitRequest extends AbstractRequest {
     private static final String CONSUMER_GROUP_ID_KEY_NAME = "consumer_group_id";
     private static final String PRODUCER_ID_KEY_NAME = "producer_id";
     private static final String PRODUCER_EPOCH_KEY_NAME = "producer_epoch";
-    private static final String RETENTION_TIME_KEY_NAME = "retention_time";
     private static final String TOPIC_PARTITIONS_KEY_NAME = "topics";
     private static final String TOPIC_KEY_NAME = "topic";
     private static final String PARTITIONS_KEY_NAME = "partitions";
@@ -42,16 +41,14 @@ public static class Builder extends AbstractRequest.Builder&lt;TxnOffsetCommitReque
         private final String consumerGroupId;
         private final long producerId;
         private final short producerEpoch;
-        private final long retentionTimeMs;
         private final Map&lt;TopicPartition, CommittedOffset&gt; offsets;
 
-        public Builder(String consumerGroupId, long producerId, short producerEpoch, long retentionTimeMs,
                        Map&lt;TopicPartition, CommittedOffset&gt; offsets) {
             super(ApiKeys.TXN_OFFSET_COMMIT);
             this.consumerGroupId = consumerGroupId;
             this.producerId = producerId;
             this.producerEpoch = producerEpoch;
-            this.retentionTimeMs = retentionTimeMs;
             this.offsets = offsets;
         }
 
@@ -61,23 +58,21 @@ public String consumerGroupId() {
 
         @Override
         public TxnOffsetCommitRequest build(short version) {
-            return new TxnOffsetCommitRequest(version, consumerGroupId, producerId, producerEpoch, retentionTimeMs, offsets);
         }
     }
 
     private final String consumerGroupId;
     private final long producerId;
     private final short producerEpoch;
-    private final long retentionTimeMs;
     private final Map&lt;TopicPartition, CommittedOffset&gt; offsets;
 
     public TxnOffsetCommitRequest(short version, String consumerGroupId, long producerId, short producerEpoch,
-                                  long retentionTimeMs, Map&lt;TopicPartition, CommittedOffset&gt; offsets) {
         super(version);
         this.consumerGroupId = consumerGroupId;
         this.producerId = producerId;
         this.producerEpoch = producerEpoch;
-        this.retentionTimeMs = retentionTimeMs;
         this.offsets = offsets;
     }
 
@@ -86,7 +81,6 @@ public TxnOffsetCommitRequest(Struct struct, short version) {
         this.consumerGroupId = struct.getString(CONSUMER_GROUP_ID_KEY_NAME);
         this.producerId = struct.getLong(PRODUCER_ID_KEY_NAME);
         this.producerEpoch = struct.getShort(PRODUCER_EPOCH_KEY_NAME);
-        this.retentionTimeMs = struct.getLong(RETENTION_TIME_KEY_NAME);
 
         Map&lt;TopicPartition, CommittedOffset&gt; offsets = new HashMap&lt;&gt;();
         Object[] topicPartitionsArray = struct.getArray(TOPIC_PARTITIONS_KEY_NAME);
@@ -116,10 +110,6 @@ public short producerEpoch() {
         return producerEpoch;
     }
 
-    public long retentionTimeMs() {
-        return retentionTimeMs;
-    }
-
     public Map&lt;TopicPartition, CommittedOffset&gt; offsets() {
         return offsets;
     }
@@ -130,7 +120,6 @@ protected Struct toStruct() {
         struct.set(CONSUMER_GROUP_ID_KEY_NAME, consumerGroupId);
         struct.set(PRODUCER_ID_KEY_NAME, producerId);
         struct.set(PRODUCER_EPOCH_KEY_NAME, producerEpoch);
-        struct.set(RETENTION_TIME_KEY_NAME, retentionTimeMs);
 
         Map&lt;String, Map&lt;Integer, CommittedOffset&gt;&gt; mappedPartitionOffsets = CollectionUtils.groupDataByTopic(offsets);
         Object[] partitionsArray = new Object[mappedPartitionOffsets.size()];
</code_before><code_after>@@ -30,7 +30,6 @@ public class TxnOffsetCommitRequest extends AbstractRequest {
     private static final String CONSUMER_GROUP_ID_KEY_NAME = "consumer_group_id";
     private static final String PRODUCER_ID_KEY_NAME = "producer_id";
     private static final String PRODUCER_EPOCH_KEY_NAME = "producer_epoch";
     private static final String TOPIC_PARTITIONS_KEY_NAME = "topics";
     private static final String TOPIC_KEY_NAME = "topic";
     private static final String PARTITIONS_KEY_NAME = "partitions";
@@ -42,16 +41,14 @@ public static class Builder extends AbstractRequest.Builder&lt;TxnOffsetCommitReque
         private final String consumerGroupId;
         private final long producerId;
         private final short producerEpoch;
         private final Map&lt;TopicPartition, CommittedOffset&gt; offsets;
 
+        public Builder(String consumerGroupId, long producerId, short producerEpoch,
                        Map&lt;TopicPartition, CommittedOffset&gt; offsets) {
             super(ApiKeys.TXN_OFFSET_COMMIT);
             this.consumerGroupId = consumerGroupId;
             this.producerId = producerId;
             this.producerEpoch = producerEpoch;
             this.offsets = offsets;
         }
 
@@ -61,23 +58,21 @@ public String consumerGroupId() {
 
         @Override
         public TxnOffsetCommitRequest build(short version) {
+            return new TxnOffsetCommitRequest(version, consumerGroupId, producerId, producerEpoch, offsets);
         }
     }
 
     private final String consumerGroupId;
     private final long producerId;
     private final short producerEpoch;
     private final Map&lt;TopicPartition, CommittedOffset&gt; offsets;
 
     public TxnOffsetCommitRequest(short version, String consumerGroupId, long producerId, short producerEpoch,
+                                  Map&lt;TopicPartition, CommittedOffset&gt; offsets) {
         super(version);
         this.consumerGroupId = consumerGroupId;
         this.producerId = producerId;
         this.producerEpoch = producerEpoch;
         this.offsets = offsets;
     }
 
@@ -86,7 +81,6 @@ public TxnOffsetCommitRequest(Struct struct, short version) {
         this.consumerGroupId = struct.getString(CONSUMER_GROUP_ID_KEY_NAME);
         this.producerId = struct.getLong(PRODUCER_ID_KEY_NAME);
         this.producerEpoch = struct.getShort(PRODUCER_EPOCH_KEY_NAME);
 
         Map&lt;TopicPartition, CommittedOffset&gt; offsets = new HashMap&lt;&gt;();
         Object[] topicPartitionsArray = struct.getArray(TOPIC_PARTITIONS_KEY_NAME);
@@ -116,10 +110,6 @@ public short producerEpoch() {
         return producerEpoch;
     }
 
     public Map&lt;TopicPartition, CommittedOffset&gt; offsets() {
         return offsets;
     }
@@ -130,7 +120,6 @@ protected Struct toStruct() {
         struct.set(CONSUMER_GROUP_ID_KEY_NAME, consumerGroupId);
         struct.set(PRODUCER_ID_KEY_NAME, producerId);
         struct.set(PRODUCER_EPOCH_KEY_NAME, producerEpoch);
 
         Map&lt;String, Map&lt;Integer, CommittedOffset&gt;&gt; mappedPartitionOffsets = CollectionUtils.groupDataByTopic(offsets);
         Object[] partitionsArray = new Object[mappedPartitionOffsets.size()];
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>509167</refactoring_id><commit_sha>76e1708058899f4e41eda8e4046cc71b94d20ff9</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/76e1708058899f4e41eda8e4046cc71b94d20ff9</commit_link><file_path>OsmAnd/src/net/osmand/plus/wikivoyage/data/TravelDbHelper.java</file_path><description>Remove Parameter articleId : TravelArticleIdentifier in method public checkExistedArticle(article TravelArticle, articleId TravelArticleIdentifier, lang String, readGpx boolean, callback GpxReadCallback) : TravelArticle from class net.osmand.plus.wikivoyage.data.TravelDbHelper</description><code_before>@@ -606,9 +606,8 @@ public TravelArticle getArticleByTitle(@NonNull final String title, @NonNull Qua
 	}
 
 	@Override
-	public TravelArticle checkExistedArticle(@Nullable TravelArticle article, @Nullable TravelArticleIdentifier articleId,
-											 @Nullable String lang, boolean readGpx, @Nullable GpxReadCallback callback) {
-		return article;
 	}
 
 	@Nullable
</code_before><code_after>@@ -606,9 +606,8 @@ public TravelArticle getArticleByTitle(@NonNull final String title, @NonNull Qua
 	}
 
 	@Override
+	public TravelArticle findSavedArticle(@NonNull TravelArticle savedArticle) {
+		return savedArticle;
 	}
 
 	@Nullable
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>554246</refactoring_id><commit_sha>701ef520a30c7b30dcdf2e4a4f06548cc06fbf0b</commit_sha><commit_link>https://github.com/apache/maven/commit/701ef520a30c7b30dcdf2e4a4f06548cc06fbf0b</commit_link><file_path>maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginManager.java</file_path><description>Remove Parameter localRepository : ArtifactRepository in method public getReports(reportPlugin ReportPlugin, reportSet ReportSet, project MavenProject, session MavenSession, localRepository ArtifactRepository) : List from class org.apache.maven.plugin.DefaultPluginManager</description><code_before>@@ -17,6 +17,7 @@
  */
 
 import org.apache.maven.artifact.Artifact;
 import org.apache.maven.artifact.factory.ArtifactFactory;
 import org.apache.maven.artifact.metadata.ArtifactMetadataRetrievalException;
 import org.apache.maven.artifact.metadata.ArtifactMetadataSource;
@@ -112,7 +113,7 @@ public class DefaultPluginManager
 
     protected ArtifactResolver artifactResolver;
 
-    protected ArtifactMetadataSource metadataSource;
 
     protected MavenPluginMappingBuilder pluginMappingBuilder;
 
@@ -172,6 +173,15 @@ public Plugin getPluginDefinitionForPrefix( String prefix, MavenSession session,
     public PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Settings settings,
                                           ArtifactRepository localRepository )
         throws ArtifactResolutionException, PluginManagerException, PluginVersionResolutionException
     {
         // TODO: this should be possibly outside
         // All version-resolution logic has been moved to DefaultPluginVersionManager.
@@ -189,6 +199,7 @@ public PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Setti
             {
                 VersionRange versionRange = VersionRange.createFromVersionSpec( plugin.getVersion() );
 
                 checkRequiredMavenVersion( plugin, localRepository, project.getPluginArtifactRepositories() );
 
                 Artifact pluginArtifact = artifactFactory.createPluginArtifact( plugin.getGroupId(),
@@ -382,17 +393,33 @@ public void executeMojo( MavenProject project, MojoExecution mojoExecution, Mave
         }
     }
 
-    public List getReports( ReportPlugin reportPlugin, ReportSet reportSet, MavenProject project, MavenSession session,
-                            ArtifactRepository localRepository )
         throws PluginManagerException, PluginVersionResolutionException, PluginConfigurationException,
         ArtifactResolutionException
     {
         Plugin forLookup = new Plugin();
-        forLookup.setGroupId( reportPlugin.getGroupId() );
-        forLookup.setArtifactId( reportPlugin.getArtifactId() );
-        forLookup.setVersion( reportPlugin.getVersion() );
-
-        PluginDescriptor pluginDescriptor = verifyPlugin( forLookup, project, session.getSettings(), localRepository );
 
         List reports = new ArrayList();
         for ( Iterator i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )
@@ -516,15 +543,15 @@ private void ensurePluginContainerIsComplete( PluginDescriptor pluginDescriptor,
             {
                 ArtifactRepository localRepository = session.getLocalRepository();
 
-                ResolutionGroup resolutionGroup = metadataSource.retrieve( pluginArtifact, localRepository,
                                                                            project.getPluginArtifactRepositories() );
 
                 Set dependencies = resolutionGroup.getArtifacts();
 
                 ArtifactResolutionResult result = artifactResolver.resolveTransitively( dependencies, pluginArtifact,
                                                                                         localRepository,
                                                                                         resolutionGroup.getResolutionRepositories(),
-                                                                                        metadataSource,
                                                                                         artifactFilter );
 
                 Set resolved = result.getArtifacts();
@@ -1015,7 +1042,7 @@ private void resolveTransitiveDependencies( MavenSession context, ArtifactResolv
         ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getDependencyArtifacts(),
                                                                                 artifact, context.getLocalRepository(),
                                                                                 project.getRemoteArtifactRepositories(),
-                                                                                metadataSource, filter );
 
         project.setArtifacts( result.getArtifacts() );
     }
</code_before><code_after>@@ -17,6 +17,7 @@
  */
 
 import org.apache.maven.artifact.Artifact;
+import org.apache.maven.artifact.ArtifactUtils;
 import org.apache.maven.artifact.factory.ArtifactFactory;
 import org.apache.maven.artifact.metadata.ArtifactMetadataRetrievalException;
 import org.apache.maven.artifact.metadata.ArtifactMetadataSource;
@@ -112,7 +113,7 @@ public class DefaultPluginManager
 
     protected ArtifactResolver artifactResolver;
 
+    protected ArtifactMetadataSource artifactMetadataSource;
 
     protected MavenPluginMappingBuilder pluginMappingBuilder;
 
@@ -172,6 +173,15 @@ public Plugin getPluginDefinitionForPrefix( String prefix, MavenSession session,
     public PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Settings settings,
                                           ArtifactRepository localRepository )
         throws ArtifactResolutionException, PluginManagerException, PluginVersionResolutionException
+    {
+        Artifact existingPluginArtifact = (Artifact) project.getPluginArtifactMap().get( plugin.getKey() );
+        
+        return verifyPlugin( plugin, existingPluginArtifact, project, settings, localRepository );
+    }
+    
+    private PluginDescriptor verifyPlugin( Plugin plugin, Artifact existingArtifact, MavenProject project, Settings settings,
+                                          ArtifactRepository localRepository )
+        throws ArtifactResolutionException, PluginManagerException, PluginVersionResolutionException
     {
         // TODO: this should be possibly outside
         // All version-resolution logic has been moved to DefaultPluginVersionManager.
@@ -189,6 +199,7 @@ public PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Setti
             {
                 VersionRange versionRange = VersionRange.createFromVersionSpec( plugin.getVersion() );
 
+
                 checkRequiredMavenVersion( plugin, localRepository, project.getPluginArtifactRepositories() );
 
                 Artifact pluginArtifact = artifactFactory.createPluginArtifact( plugin.getGroupId(),
@@ -382,17 +393,33 @@ public void executeMojo( MavenProject project, MojoExecution mojoExecution, Mave
         }
     }
 
+    public List getReports( ReportPlugin reportPlugin, ReportSet reportSet, MavenProject project, MavenSession session )
         throws PluginManagerException, PluginVersionResolutionException, PluginConfigurationException,
         ArtifactResolutionException
     {
         Plugin forLookup = new Plugin();
+        
+        String groupId = reportPlugin.getGroupId();
+        String artifactId = reportPlugin.getArtifactId();
+        
+        forLookup.setGroupId( groupId );
+        forLookup.setArtifactId( artifactId );
+
+        String version = reportPlugin.getVersion();
+        
+        Artifact existingPluginArtifact = (Artifact) project.getReportArtifactMap().get( reportPlugin.getKey() );
+        
+        if ( existingPluginArtifact == null
+            || !reportPlugin.getKey().equals( ArtifactUtils.versionlessKey( existingPluginArtifact ) )
+            || version == null )
+        {
+            version = pluginVersionManager.resolvePluginVersion( groupId, artifactId, project, session.getSettings(), session.getLocalRepository(), true );
+        }
+        
+        forLookup.setVersion( version );
+        
+        PluginDescriptor pluginDescriptor = verifyPlugin( forLookup, existingPluginArtifact, project, session
+            .getSettings(), session.getLocalRepository() );
 
         List reports = new ArrayList();
         for ( Iterator i = pluginDescriptor.getMojos().iterator(); i.hasNext(); )
@@ -516,15 +543,15 @@ private void ensurePluginContainerIsComplete( PluginDescriptor pluginDescriptor,
             {
                 ArtifactRepository localRepository = session.getLocalRepository();
 
+                ResolutionGroup resolutionGroup = artifactMetadataSource.retrieve( pluginArtifact, localRepository,
                                                                            project.getPluginArtifactRepositories() );
 
                 Set dependencies = resolutionGroup.getArtifacts();
 
                 ArtifactResolutionResult result = artifactResolver.resolveTransitively( dependencies, pluginArtifact,
                                                                                         localRepository,
                                                                                         resolutionGroup.getResolutionRepositories(),
+                                                                                        artifactMetadataSource,
                                                                                         artifactFilter );
 
                 Set resolved = result.getArtifacts();
@@ -1015,7 +1042,7 @@ private void resolveTransitiveDependencies( MavenSession context, ArtifactResolv
         ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getDependencyArtifacts(),
                                                                                 artifact, context.getLocalRepository(),
                                                                                 project.getRemoteArtifactRepositories(),
+                                                                                artifactMetadataSource, filter );
 
         project.setArtifacts( result.getArtifacts() );
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>536220</refactoring_id><commit_sha>52e87cb425b79f33b2d638a081d66a6a944d8122</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/52e87cb425b79f33b2d638a081d66a6a944d8122</commit_link><file_path>spring-web-reactive/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClientBuilder.java</file_path><description>Remove Parameter filter : ExchangeFilterFunction in method public DefaultWebClient(clientHttpConnector ClientHttpConnector, strategies WebClientStrategies, filter ExchangeFilterFunction) from class org.springframework.web.reactive.function.client.DefaultWebClientBuilder.DefaultWebClient</description><code_before>@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2016 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,101 +16,37 @@
 
 package org.springframework.web.reactive.function.client;
 
-import java.util.logging.Level;
-
-import reactor.core.publisher.Mono;
-
-import org.springframework.http.client.reactive.ClientHttpConnector;
 import org.springframework.util.Assert;
 
 /**
  * Default implementation of {@link WebClient.Builder}.
  *
- * @author Arjen Poutsma
  * @since 5.0
  */
 class DefaultWebClientBuilder implements WebClient.Builder {
 
-	private ClientHttpConnector clientHttpConnector;
-
-	private WebClientStrategies strategies = WebClientStrategies.withDefaults();
 
-	private ExchangeFilterFunction filter = new NoOpFilter();
 
 
-	public DefaultWebClientBuilder(ClientHttpConnector clientHttpConnector) {
-		this.clientHttpConnector = clientHttpConnector;
 	}
 
-	@Override
-	public WebClient.Builder strategies(WebClientStrategies strategies) {
-		Assert.notNull(strategies, "'strategies' must not be null");
-		this.strategies = strategies;
-		return this;
-	}
 
 	@Override
-	public WebClient.Builder filter(ExchangeFilterFunction filter) {
-		Assert.notNull(filter, "'filter' must not be null");
-		this.filter = filter.andThen(this.filter);
 		return this;
 	}
 
 	@Override
 	public WebClient build() {
-		return new DefaultWebClient(this.clientHttpConnector, this.strategies, this.filter);
-	}
-
-	private final static class DefaultWebClient implements WebClient {
-
-		private final ClientHttpConnector clientHttpConnector;
-
-		private final WebClientStrategies strategies;
-
-		private final ExchangeFilterFunction filter;
-
-		public DefaultWebClient(
-				ClientHttpConnector clientHttpConnector,
-				WebClientStrategies strategies,
-				ExchangeFilterFunction filter) {
-			this.clientHttpConnector = clientHttpConnector;
-			this.strategies = strategies;
-			this.filter = filter;
-		}
-
-		@Override
-		public Mono&lt;ClientResponse&gt; exchange(ClientRequest&lt;?&gt; request) {
-			Assert.notNull(request, "'request' must not be null");
-
-			return this.filter.filter(request, this::exchangeInternal);
-		}
-
-		private Mono&lt;ClientResponse&gt; exchangeInternal(ClientRequest&lt;?&gt; request) {
-			return this.clientHttpConnector
-					.connect(request.method(), request.url(),
-							clientHttpRequest -&gt; request
-									.writeTo(clientHttpRequest, this.strategies))
-					.log("org.springframework.web.client.reactive", Level.FINE)
-					.map(clientHttpResponse -&gt; new DefaultClientResponse(clientHttpResponse,
-							this.strategies));
-		}
-
-		@Override
-		public WebClient filter(ExchangeFilterFunction filter) {
-			Assert.notNull(filter, "'filter' must not be null");
-
-			ExchangeFilterFunction composedFilter = filter.andThen(this.filter);
-
-			return new DefaultWebClient(this.clientHttpConnector, this.strategies, composedFilter);
-		}
-	}
-
-	private class NoOpFilter implements ExchangeFilterFunction {
-
-		@Override
-		public Mono&lt;ClientResponse&gt; filter(ClientRequest&lt;?&gt; request, ExchangeFunction next) {
-			return next.exchange(request);
-		}
 	}
 
 }
</code_before><code_after>@@ -1,5 +1,5 @@
 /*
+ * Copyright 2002-2017 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,101 +16,37 @@
 
 package org.springframework.web.reactive.function.client;
 
 import org.springframework.util.Assert;
+import org.springframework.web.util.UriBuilderFactory;
 
 /**
  * Default implementation of {@link WebClient.Builder}.
  *
+ * @author Rossen Stoyanchev
  * @since 5.0
  */
 class DefaultWebClientBuilder implements WebClient.Builder {
 
+	private final ExchangeFunction exchangeFunction;
 
+	private UriBuilderFactory uriBuilderFactory;
 
 
+	public DefaultWebClientBuilder(ExchangeFunction exchangeFunction) {
+		Assert.notNull(exchangeFunction, "'exchangeFunction' must not be null");
+		this.exchangeFunction = exchangeFunction;
 	}
 
 
 	@Override
+	public WebClient.Builder uriBuilderFactory(UriBuilderFactory uriBuilderFactory) {
+		this.uriBuilderFactory = uriBuilderFactory;
 		return this;
 	}
 
 	@Override
 	public WebClient build() {
+		return new DefaultWebClient(this.exchangeFunction, this.uriBuilderFactory);
 	}
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>562030</refactoring_id><commit_sha>6fa439c82b7a9f324fa25da1e57e6b84f81c5974</commit_sha><commit_link>https://github.com/yacy/yacy_search_server/commit/6fa439c82b7a9f324fa25da1e57e6b84f81c5974</commit_link><file_path>source/net/yacy/cora/services/federated/solr/SolrSingleConnector.java</file_path><description>Remove Parameter tempScheme : SolrScheme in method public add(id String, header ResponseHeader, doc Document, tempScheme SolrScheme) : void from class net.yacy.cora.services.federated.solr.SolrSingleConnector</description><code_before>@@ -26,6 +26,7 @@
 
 import java.io.File;
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -41,8 +42,11 @@
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.SolrInputDocument;
 
 import net.yacy.cora.protocol.ResponseHeader;
 import net.yacy.document.Document;
 import net.yacy.kelondro.logging.Log;
 
 
@@ -189,11 +193,10 @@ public void addx(File file, String solrId) throws IOException {
     */
     
     public void add(String id, ResponseHeader header, Document doc) throws IOException {
-        add(id, header, doc, this.scheme);
     }
-    
-    public void add(String id, ResponseHeader header, Document doc, SolrScheme tempScheme) throws IOException {
-        SolrInputDocument solrdoc = tempScheme.yacy2solr(id, header, doc);
         int thisrrc = this.transmissionRoundRobinCounter;
         int nextrrc = thisrrc++;
         if (nextrrc &gt;= transmissionQueueCount) nextrrc = 0;
@@ -223,6 +226,28 @@ protected void addSolr(Collection&lt;SolrInputDocument&gt; docs) throws IOException {
         }
     }
     
     private void flushTransmissionQueue(int idx) throws IOException {
         Collection&lt;SolrInputDocument&gt; c = new ArrayList&lt;SolrInputDocument&gt;();
         while (this.transmissionQueue[idx].size() &gt; 0) {
</code_before><code_after>@@ -26,6 +26,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.net.InetAddress;
 import java.net.MalformedURLException;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -41,8 +42,11 @@
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.SolrInputDocument;
 
+import net.yacy.cora.document.UTF8;
+import net.yacy.cora.protocol.Domains;
 import net.yacy.cora.protocol.ResponseHeader;
 import net.yacy.document.Document;
+import net.yacy.kelondro.data.meta.DigestURI;
 import net.yacy.kelondro.logging.Log;
 
 
@@ -189,11 +193,10 @@ public void addx(File file, String solrId) throws IOException {
     */
     
     public void add(String id, ResponseHeader header, Document doc) throws IOException {
+        add(this.scheme.yacy2solr(id, header, doc));
     }
+
+    private void add(SolrInputDocument solrdoc) throws IOException {
         int thisrrc = this.transmissionRoundRobinCounter;
         int nextrrc = thisrrc++;
         if (nextrrc &gt;= transmissionQueueCount) nextrrc = 0;
@@ -223,6 +226,28 @@ protected void addSolr(Collection&lt;SolrInputDocument&gt; docs) throws IOException {
         }
     }
     
+    public void err(DigestURI digestURI, String failReason, int httpstatus) throws IOException {
+       
+            SolrInputDocument solrdoc = new SolrInputDocument();
+            solrdoc.addField("id", UTF8.String(digestURI.hash()));
+            solrdoc.addField("sku", digestURI.toNormalform(true, false), 3.0f);
+            InetAddress address = Domains.dnsResolve(digestURI.getHost());
+            if (address != null) solrdoc.addField("ip_s", address.getHostAddress());
+            if (digestURI.getHost() != null) solrdoc.addField("host_s", digestURI.getHost());
+
+            // path elements of link
+            String path = digestURI.getPath();
+            if (path != null) {
+                String[] paths = path.split("/");
+                if (paths.length &gt; 0) solrdoc.addField("attr_paths", paths);
+            }
+
+            solrdoc.addField("failreason_t", failReason);
+            solrdoc.addField("httpstatus_i", httpstatus);
+            
+            add(solrdoc);
+    }
+    
     private void flushTransmissionQueue(int idx) throws IOException {
         Collection&lt;SolrInputDocument&gt; c = new ArrayList&lt;SolrInputDocument&gt;();
         while (this.transmissionQueue[idx].size() &gt; 0) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>590442</refactoring_id><commit_sha>efc4209406aa00c588b105e917027358884e7a12</commit_sha><commit_link>https://github.com/oracle/graal/commit/efc4209406aa00c588b105e917027358884e7a12</commit_link><file_path>graal/com.oracle.graal.compiler.amd64/src/com/oracle/graal/compiler/amd64/AMD64LIRGenerator.java</file_path><description>Remove Parameter scale : int in method public emitStore(kind Kind, base Value, displacement long, index Value, scale int, inputVal Value, deopting DeoptimizingNode) : void from class com.oracle.graal.compiler.amd64.AMD64LIRGenerator</description><code_before>@@ -144,7 +144,9 @@ public Variable emitMove(Value input) {
     }
 
     private static AMD64LIRInstruction createMove(AllocatableValue dst, Value src) {
-        if (isRegister(src) || isStackSlot(dst)) {
             return new MoveFromRegOp(dst, src);
         } else {
             return new MoveToRegOp(dst, src);
@@ -156,7 +158,8 @@ public void emitMove(AllocatableValue dst, Value src) {
         append(createMove(dst, src));
     }
 
-    private AMD64AddressValue prepareAddress(Value base, long displacement, Value index, int scale) {
         AllocatableValue baseRegister;
         long finalDisp = displacement;
         if (isConstant(base)) {
@@ -206,17 +209,25 @@ private AMD64AddressValue prepareAddress(Value base, long displacement, Value in
         return new AMD64AddressValue(target().wordKind, baseRegister, indexRegister, scaleEnum, displacementInt);
     }
 
     @Override
-    public Variable emitLoad(Kind kind, Value base, long displacement, Value index, int scale, DeoptimizingNode deopting) {
-        AMD64AddressValue loadAddress = prepareAddress(base, displacement, index, scale);
         Variable result = newVariable(kind);
         append(new LoadOp(kind, result, loadAddress, deopting != null ? state(deopting) : null));
         return result;
     }
 
     @Override
-    public void emitStore(Kind kind, Value base, long displacement, Value index, int scale, Value inputVal, DeoptimizingNode deopting) {
-        AMD64AddressValue storeAddress = prepareAddress(base, displacement, index, scale);
         LIRFrameState state = deopting != null ? state(deopting) : null;
 
         if (isConstant(inputVal)) {
@@ -232,15 +243,7 @@ public void emitStore(Kind kind, Value base, long displacement, Value index, int
     }
 
     @Override
-    public Variable emitLea(Value base, long displacement, Value index, int scale) {
-        Variable result = newVariable(target().wordKind);
-        AMD64AddressValue address = prepareAddress(base, displacement, index, scale);
-        append(new LeaOp(result, address));
-        return result;
-    }
-
-    @Override
-    public Variable emitLea(StackSlot address) {
         Variable result = newVariable(target().wordKind);
         append(new StackLeaOp(result, address));
         return result;
</code_before><code_after>@@ -144,7 +144,9 @@ public Variable emitMove(Value input) {
     }
 
     private static AMD64LIRInstruction createMove(AllocatableValue dst, Value src) {
+        if (src instanceof AMD64AddressValue) {
+            return new LeaOp(dst, (AMD64AddressValue) src);
+        } else if (isRegister(src) || isStackSlot(dst)) {
             return new MoveFromRegOp(dst, src);
         } else {
             return new MoveToRegOp(dst, src);
@@ -156,7 +158,8 @@ public void emitMove(AllocatableValue dst, Value src) {
         append(createMove(dst, src));
     }
 
+    @Override
+    public AMD64AddressValue emitAddress(Value base, long displacement, Value index, int scale) {
         AllocatableValue baseRegister;
         long finalDisp = displacement;
         if (isConstant(base)) {
@@ -206,17 +209,25 @@ private AMD64AddressValue prepareAddress(Value base, long displacement, Value in
         return new AMD64AddressValue(target().wordKind, baseRegister, indexRegister, scaleEnum, displacementInt);
     }
 
+    private AMD64AddressValue asAddress(Value address) {
+        if (address instanceof AMD64AddressValue) {
+            return (AMD64AddressValue) address;
+        } else {
+            return emitAddress(address, 0, Value.ILLEGAL, 0);
+        }
+    }
+
     @Override
+    public Variable emitLoad(Kind kind, Value address, DeoptimizingNode deopting) {
+        AMD64AddressValue loadAddress = asAddress(address);
         Variable result = newVariable(kind);
         append(new LoadOp(kind, result, loadAddress, deopting != null ? state(deopting) : null));
         return result;
     }
 
     @Override
+    public void emitStore(Kind kind, Value address, Value inputVal, DeoptimizingNode deopting) {
+        AMD64AddressValue storeAddress = asAddress(address);
         LIRFrameState state = deopting != null ? state(deopting) : null;
 
         if (isConstant(inputVal)) {
@@ -232,15 +243,7 @@ public void emitStore(Kind kind, Value base, long displacement, Value index, int
     }
 
     @Override
+    public Variable emitAddress(StackSlot address) {
         Variable result = newVariable(target().wordKind);
         append(new StackLeaOp(result, address));
         return result;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>468859</refactoring_id><commit_sha>2e64d0125149634c974fe53fdcd6f08abf963ed5</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/2e64d0125149634c974fe53fdcd6f08abf963ed5</commit_link><file_path>model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RoleAdapter.java</file_path><description>Remove Parameter cache : RealmCache in method public RoleAdapter(cached CachedRole, cache RealmCache, session CacheRealmProvider, realm RealmModel) from class org.keycloak.models.cache.infinispan.RoleAdapter</description><code_before>@@ -21,10 +21,9 @@
 import org.keycloak.models.RoleContainerModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.cache.CacheRealmProvider;
-import org.keycloak.models.cache.RealmCache;
-import org.keycloak.models.cache.entities.CachedClientRole;
-import org.keycloak.models.cache.entities.CachedRealmRole;
-import org.keycloak.models.cache.entities.CachedRole;
 import org.keycloak.models.utils.KeycloakModelUtils;
 
 import java.util.HashSet;
@@ -38,13 +37,11 @@ public class RoleAdapter implements RoleModel {
 
     protected RoleModel updated;
     protected CachedRole cached;
-    protected RealmCache cache;
     protected CacheRealmProvider cacheSession;
     protected RealmModel realm;
 
-    public RoleAdapter(CachedRole cached, RealmCache cache, CacheRealmProvider session, RealmModel realm) {
         this.cached = cached;
-        this.cache = cache;
         this.cacheSession = session;
         this.realm = realm;
     }
</code_before><code_after>@@ -21,10 +21,9 @@
 import org.keycloak.models.RoleContainerModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.cache.CacheRealmProvider;
+import org.keycloak.models.cache.infinispan.entities.CachedClientRole;
+import org.keycloak.models.cache.infinispan.entities.CachedRealmRole;
+import org.keycloak.models.cache.infinispan.entities.CachedRole;
 import org.keycloak.models.utils.KeycloakModelUtils;
 
 import java.util.HashSet;
@@ -38,13 +37,11 @@ public class RoleAdapter implements RoleModel {
 
     protected RoleModel updated;
     protected CachedRole cached;
     protected CacheRealmProvider cacheSession;
     protected RealmModel realm;
 
+    public RoleAdapter(CachedRole cached, CacheRealmProvider session, RealmModel realm) {
         this.cached = cached;
         this.cacheSession = session;
         this.realm = realm;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>479290</refactoring_id><commit_sha>54fe9d9a897afd8ccb23578d156bace9a625d277</commit_sha><commit_link>https://github.com/apache/pinot/commit/54fe9d9a897afd8ccb23578d156bace9a625d277</commit_link><file_path>thirdeye/thirdeye-pinot/src/main/java/com/linkedin/thirdeye/anomaly/detection/DetectionJobScheduler.java</file_path><description>Remove Parameter sessionFactory : SessionFactory in method public DetectionJobScheduler(anomalyJobSpecDAO AnomalyJobSpecDAO, anomalyTaskSpecDAO AnomalyTaskSpecDAO, anomalyFunctionSpecDAO AnomalyFunctionDAO, sessionFactory SessionFactory) from class com.linkedin.thirdeye.anomaly.detection.DetectionJobScheduler</description><code_before>@@ -1,10 +1,12 @@
 package com.linkedin.thirdeye.anomaly.detection;
 
 import com.linkedin.thirdeye.db.dao.AnomalyFunctionDAO;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.hibernate.SessionFactory;
 import org.quartz.CronScheduleBuilder;
 import org.quartz.CronTrigger;
 import org.quartz.JobBuilder;
@@ -22,8 +24,6 @@
 
 import com.linkedin.thirdeye.anomaly.job.JobContext;
 import com.linkedin.thirdeye.db.entity.AnomalyFunctionSpec;
-import com.linkedin.thirdeye.detector.db.dao.AnomalyJobSpecDAO;
-import com.linkedin.thirdeye.detector.db.dao.AnomalyTaskSpecDAO;
 import com.linkedin.thirdeye.detector.function.AnomalyFunctionFactory;
 
 /**
@@ -34,19 +34,16 @@ public class DetectionJobScheduler {
   private static final Logger LOG = LoggerFactory.getLogger(DetectionJobScheduler.class);
   private SchedulerFactory schedulerFactory;
   private Scheduler quartzScheduler;
-  private AnomalyJobSpecDAO anomalyJobSpecDAO;
-  private AnomalyTaskSpecDAO anomalyTaskSpecDAO;
-  private AnomalyFunctionDAO anomalyFunctionSpecDAO;
   private AnomalyFunctionFactory anomalyFunctionFactory;
-  private SessionFactory sessionFactory;
 
-  public DetectionJobScheduler(AnomalyJobSpecDAO anomalyJobSpecDAO, AnomalyTaskSpecDAO anomalyTaskSpecDAO,
-      AnomalyFunctionDAO anomalyFunctionSpecDAO,
-      SessionFactory sessionFactory) {
-    this.anomalyJobSpecDAO = anomalyJobSpecDAO;
-    this.anomalyTaskSpecDAO = anomalyTaskSpecDAO;
-    this.anomalyFunctionSpecDAO = anomalyFunctionSpecDAO;
-    this.sessionFactory = sessionFactory;
 
     schedulerFactory = new StdSchedulerFactory();
     try {
@@ -74,11 +71,10 @@ public void start() throws SchedulerException{
     for (AnomalyFunctionSpec anomalyFunctionSpec : functionSpecs) {
       if (anomalyFunctionSpec.getIsActive()) {
         DetectionJobContext detectionJobContext = new DetectionJobContext();
-        detectionJobContext.setAnomalyFunctionSpecDAO(anomalyFunctionSpecDAO);
-        detectionJobContext.setAnomalyJobSpecDAO(anomalyJobSpecDAO);
-        detectionJobContext.setAnomalyTaskSpecDAO(anomalyTaskSpecDAO);
         detectionJobContext.setAnomalyFunctionFactory(anomalyFunctionFactory);
-        detectionJobContext.setSessionFactory(sessionFactory);
         detectionJobContext.setAnomalyFunctionId(anomalyFunctionSpec.getId());
         String jobKey = getJobKey(anomalyFunctionSpec.getId(), anomalyFunctionSpec.getFunctionName());
         detectionJobContext.setJobName(jobKey);
@@ -93,7 +89,7 @@ public void stop() throws SchedulerException{
   }
 
   public void start(Long id) throws SchedulerException {
-    AnomalyFunctionSpec anomalyFunctionSpec = anomalyFunctionSpecDAO.findById(id);
     if (anomalyFunctionSpec == null) {
       throw new IllegalArgumentException("No function with id " + id);
     }
@@ -106,19 +102,18 @@ public void start(Long id) throws SchedulerException {
     }
 
     DetectionJobContext detectionJobContext = new DetectionJobContext();
-    detectionJobContext.setAnomalyFunctionSpecDAO(anomalyFunctionSpecDAO);
-    detectionJobContext.setAnomalyJobSpecDAO(anomalyJobSpecDAO);
-    detectionJobContext.setAnomalyTaskSpecDAO(anomalyTaskSpecDAO);
     detectionJobContext.setAnomalyFunctionFactory(anomalyFunctionFactory);
-    detectionJobContext.setSessionFactory(sessionFactory);
     detectionJobContext.setAnomalyFunctionId(anomalyFunctionSpec.getId());
     detectionJobContext.setJobName(jobKey);
 
     scheduleJob(detectionJobContext, anomalyFunctionSpec);
   }
 
   public void stop(Long id) throws SchedulerException {
-    AnomalyFunctionSpec anomalyFunctionSpec = anomalyFunctionSpecDAO.findById(id);
     String functionName = anomalyFunctionSpec.getFunctionName();
     String jobKey = getJobKey(id, functionName);
     if (!quartzScheduler.checkExists(JobKey.jobKey(jobKey))) {
@@ -129,7 +124,7 @@ public void stop(Long id) throws SchedulerException {
   }
 
   public void runAdHoc(Long id, String windowStartIso, String windowEndIso) {
-    AnomalyFunctionSpec anomalyFunctionSpec = anomalyFunctionSpecDAO.findById(id);
     if (anomalyFunctionSpec == null) {
       throw new IllegalArgumentException("No function with id " + id);
     }
@@ -140,11 +135,10 @@ public void runAdHoc(Long id, String windowStartIso, String windowEndIso) {
     JobDetail job = JobBuilder.newJob(DetectionJobRunner.class).withIdentity(jobKey).build();
 
     DetectionJobContext detectionJobContext = new DetectionJobContext();
-    detectionJobContext.setAnomalyFunctionSpecDAO(anomalyFunctionSpecDAO);
-    detectionJobContext.setAnomalyJobSpecDAO(anomalyJobSpecDAO);
-    detectionJobContext.setAnomalyTaskSpecDAO(anomalyTaskSpecDAO);
     detectionJobContext.setAnomalyFunctionFactory(anomalyFunctionFactory);
-    detectionJobContext.setSessionFactory(sessionFactory);
     detectionJobContext.setAnomalyFunctionId(anomalyFunctionSpec.getId());
     detectionJobContext.setJobName(jobKey);
     detectionJobContext.setWindowStartIso(windowStartIso);
@@ -184,7 +178,7 @@ private void scheduleJob(JobContext jobContext, AnomalyFunctionSpec anomalyFunct
   }
 
   private List&lt;AnomalyFunctionSpec&gt; readAnomalyFunctionSpecs() {
-    return anomalyFunctionSpecDAO.findAll();
   }
 
   private String getJobKey(Long id, String functionName) {
</code_before><code_after>@@ -1,10 +1,12 @@
 package com.linkedin.thirdeye.anomaly.detection;
 
 import com.linkedin.thirdeye.db.dao.AnomalyFunctionDAO;
+import com.linkedin.thirdeye.db.dao.AnomalyJobDAO;
+import com.linkedin.thirdeye.db.dao.AnomalyTaskDAO;
+
 import java.util.ArrayList;
 import java.util.List;
 
 import org.quartz.CronScheduleBuilder;
 import org.quartz.CronTrigger;
 import org.quartz.JobBuilder;
@@ -22,8 +24,6 @@
 
 import com.linkedin.thirdeye.anomaly.job.JobContext;
 import com.linkedin.thirdeye.db.entity.AnomalyFunctionSpec;
 import com.linkedin.thirdeye.detector.function.AnomalyFunctionFactory;
 
 /**
@@ -34,19 +34,16 @@ public class DetectionJobScheduler {
   private static final Logger LOG = LoggerFactory.getLogger(DetectionJobScheduler.class);
   private SchedulerFactory schedulerFactory;
   private Scheduler quartzScheduler;
+  private AnomalyJobDAO anomalyJobDAO;
+  private AnomalyTaskDAO anomalyTaskDAO;
+  private AnomalyFunctionDAO anomalyFunctionDAO;
   private AnomalyFunctionFactory anomalyFunctionFactory;
 
+  public DetectionJobScheduler(AnomalyJobDAO anomalyJobDAO, AnomalyTaskDAO anomalyTaskDAO,
+      AnomalyFunctionDAO anomalyFunctionDAO) {
+    this.anomalyJobDAO = anomalyJobDAO;
+    this.anomalyTaskDAO = anomalyTaskDAO;
+    this.anomalyFunctionDAO = anomalyFunctionDAO;
 
     schedulerFactory = new StdSchedulerFactory();
     try {
@@ -74,11 +71,10 @@ public void start() throws SchedulerException{
     for (AnomalyFunctionSpec anomalyFunctionSpec : functionSpecs) {
       if (anomalyFunctionSpec.getIsActive()) {
         DetectionJobContext detectionJobContext = new DetectionJobContext();
+        detectionJobContext.setAnomalyFunctionDAO(anomalyFunctionDAO);
+        detectionJobContext.setAnomalyJobDAO(anomalyJobDAO);
+        detectionJobContext.setAnomalyTaskDAO(anomalyTaskDAO);
         detectionJobContext.setAnomalyFunctionFactory(anomalyFunctionFactory);
         detectionJobContext.setAnomalyFunctionId(anomalyFunctionSpec.getId());
         String jobKey = getJobKey(anomalyFunctionSpec.getId(), anomalyFunctionSpec.getFunctionName());
         detectionJobContext.setJobName(jobKey);
@@ -93,7 +89,7 @@ public void stop() throws SchedulerException{
   }
 
   public void start(Long id) throws SchedulerException {
+    AnomalyFunctionSpec anomalyFunctionSpec = anomalyFunctionDAO.findById(id);
     if (anomalyFunctionSpec == null) {
       throw new IllegalArgumentException("No function with id " + id);
     }
@@ -106,19 +102,18 @@ public void start(Long id) throws SchedulerException {
     }
 
     DetectionJobContext detectionJobContext = new DetectionJobContext();
+    detectionJobContext.setAnomalyFunctionDAO(anomalyFunctionDAO);
+    detectionJobContext.setAnomalyJobDAO(anomalyJobDAO);
+    detectionJobContext.setAnomalyTaskDAO(anomalyTaskDAO);
     detectionJobContext.setAnomalyFunctionFactory(anomalyFunctionFactory);
     detectionJobContext.setAnomalyFunctionId(anomalyFunctionSpec.getId());
     detectionJobContext.setJobName(jobKey);
 
     scheduleJob(detectionJobContext, anomalyFunctionSpec);
   }
 
   public void stop(Long id) throws SchedulerException {
+    AnomalyFunctionSpec anomalyFunctionSpec = anomalyFunctionDAO.findById(id);
     String functionName = anomalyFunctionSpec.getFunctionName();
     String jobKey = getJobKey(id, functionName);
     if (!quartzScheduler.checkExists(JobKey.jobKey(jobKey))) {
@@ -129,7 +124,7 @@ public void stop(Long id) throws SchedulerException {
   }
 
   public void runAdHoc(Long id, String windowStartIso, String windowEndIso) {
+    AnomalyFunctionSpec anomalyFunctionSpec = anomalyFunctionDAO.findById(id);
     if (anomalyFunctionSpec == null) {
       throw new IllegalArgumentException("No function with id " + id);
     }
@@ -140,11 +135,10 @@ public void runAdHoc(Long id, String windowStartIso, String windowEndIso) {
     JobDetail job = JobBuilder.newJob(DetectionJobRunner.class).withIdentity(jobKey).build();
 
     DetectionJobContext detectionJobContext = new DetectionJobContext();
+    detectionJobContext.setAnomalyFunctionDAO(anomalyFunctionDAO);
+    detectionJobContext.setAnomalyJobDAO(anomalyJobDAO);
+    detectionJobContext.setAnomalyTaskDAO(anomalyTaskDAO);
     detectionJobContext.setAnomalyFunctionFactory(anomalyFunctionFactory);
     detectionJobContext.setAnomalyFunctionId(anomalyFunctionSpec.getId());
     detectionJobContext.setJobName(jobKey);
     detectionJobContext.setWindowStartIso(windowStartIso);
@@ -184,7 +178,7 @@ private void scheduleJob(JobContext jobContext, AnomalyFunctionSpec anomalyFunct
   }
 
   private List&lt;AnomalyFunctionSpec&gt; readAnomalyFunctionSpecs() {
+    return anomalyFunctionDAO.findAll();
   }
 
   private String getJobKey(Long id, String functionName) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>541637</refactoring_id><commit_sha>6e806177049297d0a678fa1f814afd2de3cf896e</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/6e806177049297d0a678fa1f814afd2de3cf896e</commit_link><file_path>src/edu/stanford/nlp/ling/tokensregex/SequenceMatchRules.java</file_path><description>Remove Parameter env : Env in method public CoreMapExtractRule(env Env, annotationField Class, extractRule ExtractRule&lt;T,O&gt;) from class edu.stanford.nlp.ling.tokensregex.SequenceMatchRules.CoreMapExtractRule</description><code_before>@@ -404,7 +404,7 @@ protected void updateExtractRule(AnnotationExtractRule r,
       MatchedExpression.SingleAnnotationExtractor valueExtractor = createAnnotationExtractor(env, r);
       valueExtractor.valueExtractor =
               new CoreMapFunctionApplier&lt; List&lt;? extends CoreMap&gt;, Value&gt;(
-                      env, r.annotationField,
                       new SequencePatternExtractRule&lt;CoreMap, Value&gt;(
                               pattern,
                               new SequenceMatchResultExtractor&lt;CoreMap&gt;(env, action, result), r.matchFindType, r.matchWithResults));
@@ -461,18 +461,18 @@ protected void updateExtractRule(AnnotationExtractRule r,
       if (r.annotationField != null &amp;&amp; r.annotationField != CoreMap.class) {
         valueExtractor.valueExtractor =
               new CoreMapFunctionApplier&lt; List&lt;? extends CoreMap&gt;, Value &gt;(
-                      env, r.annotationField,
                       new SequencePatternExtractRule&lt;CoreMap, Value&gt;(
                               pattern,
                               new SequenceMatchResultExtractor&lt;CoreMap&gt;(env, action, result), r.matchFindType, r.matchWithResults));
         r.extractRule = new CoreMapExtractRule&lt; List&lt;? extends CoreMap&gt;, MatchedExpression &gt;(
-              env, r.annotationField,
               new SequencePatternExtractRule&lt;CoreMap, MatchedExpression&gt;(pattern,
                       new SequenceMatchedExpressionExtractor( valueExtractor, r.matchedExpressionGroup), r.matchFindType, r.matchWithResults));
       } else {
         valueExtractor.valueExtractor =
                 new CoreMapToListFunctionApplier&lt; Value &gt;(
-                        env, new SequencePatternExtractRule&lt;CoreMap, Value&gt;(
                                 pattern,
                                 new SequenceMatchResultExtractor&lt;CoreMap&gt;(env, action, result), r.matchFindType, r.matchWithResults));
         r.extractRule = new CoreMapToListExtractRule&lt; MatchedExpression &gt;(
@@ -516,12 +516,12 @@ protected void updateExtractRule(AnnotationExtractRule r,
       Pattern pattern = env.getStringPattern(expr);
       valueExtractor.valueExtractor =
               new CoreMapFunctionApplier&lt; String, Value &gt;(
-                      env, r.annotationField,
                       new StringPatternExtractRule&lt;Value&gt;(
                               pattern,
                               new StringMatchResultExtractor(env, action, result)));
       r.extractRule = new CoreMapExtractRule&lt; String, MatchedExpression &gt;(
-              env, r.annotationField,
               new StringPatternExtractRule&lt;MatchedExpression&gt;(pattern,
                       new StringMatchedExpressionExtractor( valueExtractor, r.matchedExpressionGroup)));
       r.filterRule = new AnnotationMatchedFilter(valueExtractor);
@@ -720,22 +720,17 @@ public void addRules(Collection&lt;ExtractRule&lt;I,O&gt;&gt; rules)
    */
   public static class CoreMapExtractRule&lt;T,O&gt; implements ExtractRule&lt;CoreMap, O&gt;
   {
-    Env env;
     Class annotationField;
     ExtractRule&lt;T,O&gt; extractRule;
 
-    public CoreMapExtractRule(Env env, Class annotationField, ExtractRule&lt;T,O&gt; extractRule) {
       this.annotationField = annotationField;
       this.extractRule = extractRule;
-      this.env = env;
     }
 
     public boolean extract(CoreMap cm, List&lt;O&gt; out) {
-      env.push(Expressions.VAR_SELF, cm);
       T field = (T) cm.get(annotationField);
-      boolean res = extractRule.extract(field, out);
-      env.pop(Expressions.VAR_SELF);
-      return res;
     }
 
   }
@@ -913,43 +908,33 @@ public MatchedExpression apply(SequenceMatchResult&lt;CoreMap&gt; matched) {
 
   public static class CoreMapFunctionApplier&lt;T,O&gt; implements Function&lt;CoreMap, O&gt;
   {
-    Env env;
     Class annotationField;
     Function&lt;T,O&gt; func;
 
-    public CoreMapFunctionApplier(Env env, Class annotationField, Function&lt;T,O&gt; func) {
       this.annotationField = annotationField;
       if (annotationField == null) {
         throw new IllegalArgumentException("Annotation field cannot be null");
       }
       this.func = func;
-      this.env = env;
     }
 
     public O apply(CoreMap cm) {
-      if (env != null) { env.push(Expressions.VAR_SELF, cm); }
       T field = (T) cm.get(annotationField);
-      O res = func.apply(field);
-      if (env != null) { env.pop(Expressions.VAR_SELF); }
-      return res;
     }
   }
 
   public static class CoreMapToListFunctionApplier&lt;O&gt; implements Function&lt;CoreMap, O&gt;
   {
-    Env env;
     Function&lt;List&lt;? extends CoreMap&gt;,O&gt; func;
 
-    public CoreMapToListFunctionApplier(Env env, Function&lt;List&lt;? extends CoreMap&gt;,O&gt; func) {
       this.func = func;
-      this.env = env;
     }
 
     public O apply(CoreMap cm) {
-      if (env != null) { env.push(Expressions.VAR_SELF, cm); }
-      O res = func.apply(Arrays.asList(cm));
-      if (env != null) { env.pop(Expressions.VAR_SELF); }
-      return res;
     }
   }
 }
\ No newline at end of file
</code_before><code_after>@@ -404,7 +404,7 @@ protected void updateExtractRule(AnnotationExtractRule r,
       MatchedExpression.SingleAnnotationExtractor valueExtractor = createAnnotationExtractor(env, r);
       valueExtractor.valueExtractor =
               new CoreMapFunctionApplier&lt; List&lt;? extends CoreMap&gt;, Value&gt;(
+                      r.annotationField,
                       new SequencePatternExtractRule&lt;CoreMap, Value&gt;(
                               pattern,
                               new SequenceMatchResultExtractor&lt;CoreMap&gt;(env, action, result), r.matchFindType, r.matchWithResults));
@@ -461,18 +461,18 @@ protected void updateExtractRule(AnnotationExtractRule r,
       if (r.annotationField != null &amp;&amp; r.annotationField != CoreMap.class) {
         valueExtractor.valueExtractor =
               new CoreMapFunctionApplier&lt; List&lt;? extends CoreMap&gt;, Value &gt;(
+                      r.annotationField,
                       new SequencePatternExtractRule&lt;CoreMap, Value&gt;(
                               pattern,
                               new SequenceMatchResultExtractor&lt;CoreMap&gt;(env, action, result), r.matchFindType, r.matchWithResults));
         r.extractRule = new CoreMapExtractRule&lt; List&lt;? extends CoreMap&gt;, MatchedExpression &gt;(
+              r.annotationField,
               new SequencePatternExtractRule&lt;CoreMap, MatchedExpression&gt;(pattern,
                       new SequenceMatchedExpressionExtractor( valueExtractor, r.matchedExpressionGroup), r.matchFindType, r.matchWithResults));
       } else {
         valueExtractor.valueExtractor =
                 new CoreMapToListFunctionApplier&lt; Value &gt;(
+                        new SequencePatternExtractRule&lt;CoreMap, Value&gt;(
                                 pattern,
                                 new SequenceMatchResultExtractor&lt;CoreMap&gt;(env, action, result), r.matchFindType, r.matchWithResults));
         r.extractRule = new CoreMapToListExtractRule&lt; MatchedExpression &gt;(
@@ -516,12 +516,12 @@ protected void updateExtractRule(AnnotationExtractRule r,
       Pattern pattern = env.getStringPattern(expr);
       valueExtractor.valueExtractor =
               new CoreMapFunctionApplier&lt; String, Value &gt;(
+                      r.annotationField,
                       new StringPatternExtractRule&lt;Value&gt;(
                               pattern,
                               new StringMatchResultExtractor(env, action, result)));
       r.extractRule = new CoreMapExtractRule&lt; String, MatchedExpression &gt;(
+              r.annotationField,
               new StringPatternExtractRule&lt;MatchedExpression&gt;(pattern,
                       new StringMatchedExpressionExtractor( valueExtractor, r.matchedExpressionGroup)));
       r.filterRule = new AnnotationMatchedFilter(valueExtractor);
@@ -720,22 +720,17 @@ public void addRules(Collection&lt;ExtractRule&lt;I,O&gt;&gt; rules)
    */
   public static class CoreMapExtractRule&lt;T,O&gt; implements ExtractRule&lt;CoreMap, O&gt;
   {
     Class annotationField;
     ExtractRule&lt;T,O&gt; extractRule;
 
+    public CoreMapExtractRule(Class annotationField, ExtractRule&lt;T,O&gt; extractRule) {
       this.annotationField = annotationField;
       this.extractRule = extractRule;
     }
 
     public boolean extract(CoreMap cm, List&lt;O&gt; out) {
       T field = (T) cm.get(annotationField);
+      return extractRule.extract(field, out);
     }
 
   }
@@ -913,43 +908,33 @@ public MatchedExpression apply(SequenceMatchResult&lt;CoreMap&gt; matched) {
 
   public static class CoreMapFunctionApplier&lt;T,O&gt; implements Function&lt;CoreMap, O&gt;
   {
     Class annotationField;
     Function&lt;T,O&gt; func;
 
+    public CoreMapFunctionApplier(Class annotationField, Function&lt;T,O&gt; func) {
       this.annotationField = annotationField;
       if (annotationField == null) {
         throw new IllegalArgumentException("Annotation field cannot be null");
       }
       this.func = func;
     }
 
     public O apply(CoreMap cm) {
       T field = (T) cm.get(annotationField);
+      return func.apply(field);
     }
   }
 
   public static class CoreMapToListFunctionApplier&lt;O&gt; implements Function&lt;CoreMap, O&gt;
   {
     Function&lt;List&lt;? extends CoreMap&gt;,O&gt; func;
 
+    public CoreMapToListFunctionApplier(Function&lt;List&lt;? extends CoreMap&gt;,O&gt; func) {
       this.func = func;
     }
 
     public O apply(CoreMap cm) {
+      return func.apply(Arrays.asList(cm));
     }
   }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>557227</refactoring_id><commit_sha>00137372e32d812d3671900f218a103403aa70b0</commit_sha><commit_link>https://github.com/seleniumhq/selenium/commit/00137372e32d812d3671900f218a103403aa70b0</commit_link><file_path>server-coreless/src/main/java/org/openqa/selenium/server/browserlaunchers/MockBrowserLauncher.java</file_path><description>Remove Parameter defaultLogLevel : String in method public launchHTMLSuite(startURL String, suiteUrl String, multiWindow boolean, defaultLogLevel String) : void from class org.openqa.selenium.server.browserlaunchers.MockBrowserLauncher</description><code_before>@@ -33,30 +33,15 @@ public class MockBrowserLauncher implements BrowserLauncher, Runnable {
     private String uniqueId;
     private int sequenceNumber = 0;
     private final RemoteControlConfiguration configuration;
-    
-    public MockBrowserLauncher(RemoteControlConfiguration configuration, String sessionId) {
         this.sessionId = sessionId;
         this.uniqueId = "mock";
         this.configuration = configuration;
     }
     
-    public MockBrowserLauncher(RemoteControlConfiguration configuration, String sessionId, String command) {
-        this.sessionId = sessionId;
-        this.configuration = configuration;
-    }
-    
-    public void launchRemoteSession(String url, boolean multiWindow) {
-      browser = new Thread(this);
-      browser.setName("mockbrowser");
-      if (null != url) {
-        browser.start();
-      } else {
-        log.info("launching a mock unresponsive browser");
-      }
-    }
-
     public void launchHTMLSuite(String startURL, String suiteUrl,
-            boolean multiWindow, String defaultLogLevel) {
 
     }
 
@@ -183,7 +168,13 @@ private String doBrowserRequest(String url, String body) throws IOException {
      */
     public void launchRemoteSession(String url, boolean multiWindow,
             BrowserConfigurationOptions browserConfigurationOptions) {
-        launchRemoteSession(url, multiWindow);
     }
 
 }
</code_before><code_after>@@ -33,30 +33,15 @@ public class MockBrowserLauncher implements BrowserLauncher, Runnable {
     private String uniqueId;
     private int sequenceNumber = 0;
     private final RemoteControlConfiguration configuration;
+        
+    public MockBrowserLauncher(BrowserConfigurationOptions browserOptions, RemoteControlConfiguration configuration, String sessionId, String command) {
         this.sessionId = sessionId;
         this.uniqueId = "mock";
         this.configuration = configuration;
     }
     
     public void launchHTMLSuite(String startURL, String suiteUrl,
+            boolean multiWindow) {
 
     }
 
@@ -183,7 +168,13 @@ private String doBrowserRequest(String url, String body) throws IOException {
      */
     public void launchRemoteSession(String url, boolean multiWindow,
             BrowserConfigurationOptions browserConfigurationOptions) {
+        browser = new Thread(this);
+          browser.setName("mockbrowser");
+          if (null != url) {
+            browser.start();
+          } else {
+            log.info("launching a mock unresponsive browser");
+          }
     }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>530062</refactoring_id><commit_sha>b6eeef31e586c62853c69ade67848d31f0af18cd</commit_sha><commit_link>https://github.com/apache/druid/commit/b6eeef31e586c62853c69ade67848d31f0af18cd</commit_link><file_path>server/src/main/java/org/apache/druid/segment/realtime/appenderator/AppenderatorImpl.java</file_path><description>Remove Parameter sink : Sink in method private calculateSinkMemoryInUsed(sink Sink) : int from class org.apache.druid.segment.realtime.appenderator.AppenderatorImpl</description><code_before>@@ -175,6 +175,7 @@ public class AppenderatorImpl implements Appenderator
 
   private final boolean isOpenSegments;
   private final boolean useMaxMemoryEstimates;
   /**
    * Use next Map to store metadata (File, SegmentId) for a hydrant for batch appenderator
    * in order to facilitate the mapping of the QueryableIndex associated with a given hydrant
@@ -242,11 +243,10 @@ public class AppenderatorImpl implements Appenderator
     skipBytesInMemoryOverheadCheck = tuningConfig.isSkipBytesInMemoryOverheadCheck();
 
     if (isOpenSegments) {
-      log.info("Running open segments appenderator");
     } else {
-      log.info("Running closed segments appenderator");
     }
-
   }
 
   @Override
@@ -503,7 +503,7 @@ private Sink getOrCreateSink(final SegmentIdWithShardSpec identifier)
           useMaxMemoryEstimates,
           null
       );
-      bytesCurrentlyInMemory.addAndGet(calculateSinkMemoryInUsed(retVal));
 
       try {
         segmentAnnouncer.announceSegment(retVal.getSegment());
@@ -1351,7 +1351,7 @@ private ListenableFuture&lt;?&gt; abandonSegment(
       // i.e. those that haven't been persisted for *InMemory counters, or pushed to deep storage for the total counter.
       rowsCurrentlyInMemory.addAndGet(-sink.getNumRowsInMemory());
       bytesCurrentlyInMemory.addAndGet(-sink.getBytesInMemory());
-      bytesCurrentlyInMemory.addAndGet(-calculateSinkMemoryInUsed(sink));
       for (FireHydrant hydrant : sink) {
         // Decrement memory used by all Memory Mapped Hydrant
         if (!hydrant.equals(sink.getCurrHydrant())) {
@@ -1595,7 +1595,7 @@ private int calculateMMappedHydrantMemoryInUsed(FireHydrant hydrant)
     return total;
   }
 
-  private int calculateSinkMemoryInUsed(Sink sink)
   {
     if (skipBytesInMemoryOverheadCheck) {
       return 0;
</code_before><code_after>@@ -175,6 +175,7 @@ public class AppenderatorImpl implements Appenderator
 
   private final boolean isOpenSegments;
   private final boolean useMaxMemoryEstimates;
+
   /**
    * Use next Map to store metadata (File, SegmentId) for a hydrant for batch appenderator
    * in order to facilitate the mapping of the QueryableIndex associated with a given hydrant
@@ -242,11 +243,10 @@ public class AppenderatorImpl implements Appenderator
     skipBytesInMemoryOverheadCheck = tuningConfig.isSkipBytesInMemoryOverheadCheck();
 
     if (isOpenSegments) {
+      log.debug("Running open segments appenderator");
     } else {
+      log.debug("Running closed segments appenderator");
     }
   }
 
   @Override
@@ -503,7 +503,7 @@ private Sink getOrCreateSink(final SegmentIdWithShardSpec identifier)
           useMaxMemoryEstimates,
           null
       );
+      bytesCurrentlyInMemory.addAndGet(calculateSinkMemoryInUsed());
 
       try {
         segmentAnnouncer.announceSegment(retVal.getSegment());
@@ -1351,7 +1351,7 @@ private ListenableFuture&lt;?&gt; abandonSegment(
       // i.e. those that haven't been persisted for *InMemory counters, or pushed to deep storage for the total counter.
       rowsCurrentlyInMemory.addAndGet(-sink.getNumRowsInMemory());
       bytesCurrentlyInMemory.addAndGet(-sink.getBytesInMemory());
+      bytesCurrentlyInMemory.addAndGet(-calculateSinkMemoryInUsed());
       for (FireHydrant hydrant : sink) {
         // Decrement memory used by all Memory Mapped Hydrant
         if (!hydrant.equals(sink.getCurrHydrant())) {
@@ -1595,7 +1595,7 @@ private int calculateMMappedHydrantMemoryInUsed(FireHydrant hydrant)
     return total;
   }
 
+  private int calculateSinkMemoryInUsed()
   {
     if (skipBytesInMemoryOverheadCheck) {
       return 0;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>548884</refactoring_id><commit_sha>ff77d1e72cc3836abf0a724b1791fa39176b7472</commit_sha><commit_link>https://github.com/androidx/media/commit/ff77d1e72cc3836abf0a724b1791fa39176b7472</commit_link><file_path>library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java</file_path><description>Remove Parameter isCached : boolean in method package CacheSpan(key String, position long, length long, isCached boolean, lastAccessTimestamp long, file File) from class com.google.android.exoplayer2.upstream.cache.CacheSpan</description><code_before>@@ -16,21 +16,12 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Util;
 import java.io.File;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * Defines a span of data that may or may not be cached (as indicated by {@link #isCached}).
  */
-public final class CacheSpan implements Comparable&lt;CacheSpan&gt; {
-
-  private static final String SUFFIX = ".v2.exo";
-  private static final Pattern CACHE_FILE_PATTERN_V1 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
-  private static final Pattern CACHE_FILE_PATTERN_V2 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
 
   /**
    * The cache key that uniquely identifies the original stream.
@@ -57,64 +48,34 @@ public final class CacheSpan implements Comparable&lt;CacheSpan&gt; {
    */
   public final long lastAccessTimestamp;
 
-  public static File getCacheFileName(File cacheDir, String key, long offset,
-      long lastAccessTimestamp) {
-    return new File(cacheDir,
-        Util.escapeFileName(key) + "." + offset + "." + lastAccessTimestamp + SUFFIX);
-  }
-
-  public static CacheSpan createLookup(String key, long position) {
-    return new CacheSpan(key, position, C.LENGTH_UNSET, false, C.TIME_UNSET, null);
-  }
-
-  public static CacheSpan createOpenHole(String key, long position) {
-    return new CacheSpan(key, position, C.LENGTH_UNSET, false, C.TIME_UNSET, null);
-  }
-
-  public static CacheSpan createClosedHole(String key, long position, long length) {
-    return new CacheSpan(key, position, length, false, C.TIME_UNSET, null);
-  }
-
   /**
-   * Creates a cache span from an underlying cache file.
    *
-   * @param file The cache file.
-   * @return The span, or null if the file name is not correctly formatted.
    */
-  public static CacheSpan createCacheEntry(File file) {
-    Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(file.getName());
-    if (!matcher.matches()) {
-      return null;
-    }
-    String key = Util.unescapeFileName(matcher.group(1));
-    return key == null ? null : createCacheEntry(
-        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)), file);
   }
 
-  static File upgradeIfNeeded(File file) {
-    Matcher matcher = CACHE_FILE_PATTERN_V1.matcher(file.getName());
-    if (!matcher.matches()) {
-      return file;
-    }
-    String key = matcher.group(1); // Keys were not escaped in version 1.
-    File newCacheFile = getCacheFileName(file.getParentFile(), key,
-        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
-    file.renameTo(newCacheFile);
-    return newCacheFile;
-  }
-
-  private static CacheSpan createCacheEntry(String key, long position, long lastAccessTimestamp,
-      File file) {
-    return new CacheSpan(key, position, file.length(), true, lastAccessTimestamp, file);
-  }
-
-  // Visible for testing.
-  CacheSpan(String key, long position, long length, boolean isCached,
-      long lastAccessTimestamp, File file) {
     this.key = key;
     this.position = position;
     this.length = length;
-    this.isCached = isCached;
     this.file = file;
     this.lastAccessTimestamp = lastAccessTimestamp;
   }
@@ -127,15 +88,10 @@ public boolean isOpenEnded() {
   }
 
   /**
-   * Renames the file underlying this cache span to update its last access time.
-   *
-   * @return A {@link CacheSpan} representing the updated cache file.
    */
-  public CacheSpan touch() {
-    long now = System.currentTimeMillis();
-    File newCacheFile = getCacheFileName(file.getParentFile(), key, position, now);
-    file.renameTo(newCacheFile);
-    return createCacheEntry(key, position, now, newCacheFile);
   }
 
   @Override
</code_before><code_after>@@ -16,21 +16,12 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import com.google.android.exoplayer2.C;
 import java.io.File;
 
 /**
  * Defines a span of data that may or may not be cached (as indicated by {@link #isCached}).
  */
+public class CacheSpan implements Comparable&lt;CacheSpan&gt; {
 
   /**
    * The cache key that uniquely identifies the original stream.
@@ -57,64 +48,34 @@ public final class CacheSpan implements Comparable&lt;CacheSpan&gt; {
    */
   public final long lastAccessTimestamp;
 
   /**
+   * Creates a hole CacheSpan which isn't cached, has no last access time and no file associated.
    *
+   * @param key The cache key that uniquely identifies the original stream.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
+   *     open-ended hole.
    */
+  public CacheSpan(String key, long position, long length) {
+    this(key, position, length, C.TIME_UNSET, null);
   }
 
+  /**
+   * Creates a CacheSpan.
+   *
+   * @param key The cache key that uniquely identifies the original stream.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
+   *     open-ended hole.
+   * @param lastAccessTimestamp The last access timestamp, or {@link C#TIME_UNSET} if
+   *     {@link #isCached} is false.
+   * @param file The file corresponding to this {@link CacheSpan}, or null if it's a hole.
+   */
+  public CacheSpan(String key, long position, long length, long lastAccessTimestamp, File file) {
     this.key = key;
     this.position = position;
     this.length = length;
+    this.isCached = file != null;
     this.file = file;
     this.lastAccessTimestamp = lastAccessTimestamp;
   }
@@ -127,15 +88,10 @@ public boolean isOpenEnded() {
   }
 
   /**
+   * Returns whether this is a hole {@link CacheSpan}.
    */
+  public boolean isHoleSpan() {
+    return !isCached;
   }
 
   @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>534929</refactoring_id><commit_sha>13de448867b66773886b019f540e67c198d87a6c</commit_sha><commit_link>https://github.com/rstudio/rstudio/commit/13de448867b66773886b019f540e67c198d87a6c</commit_link><file_path>src/gwt/src/org/rstudio/studio/client/workbench/views/vcs/git/GitPresenter.java</file_path><description>Remove Parameter session : Session in method public GitPresenter(gitCore GitPresenterCore, vcsFileOpener VCSFileOpener, view Display, server GitServerOperations, session Session, commands Commands, commandBinder Binder, gitState GitState, globalDisplay GlobalDisplay, satelliteManager SatelliteManager) from class org.rstudio.studio.client.workbench.views.vcs.git.GitPresenter</description><code_before>@@ -40,8 +40,6 @@
 import org.rstudio.studio.client.vcs.VCSApplicationParams;
 import org.rstudio.studio.client.workbench.WorkbenchView;
 import org.rstudio.studio.client.workbench.commands.Commands;
-import org.rstudio.studio.client.workbench.model.Session;
-import org.rstudio.studio.client.workbench.model.SessionInfo;
 import org.rstudio.studio.client.workbench.views.vcs.BaseVcsPresenter;
 import org.rstudio.studio.client.workbench.views.vcs.common.VCSFileOpener;
 import org.rstudio.studio.client.workbench.views.vcs.common.events.VcsRefreshEvent;
@@ -77,7 +75,6 @@ public GitPresenter(GitPresenterCore gitCore,
                        VCSFileOpener vcsFileOpener,
                        Display view,
                        GitServerOperations server,
-                       Session session,
                        final Commands commands,
                        Binder commandBinder,
                        GitState gitState,
@@ -89,7 +86,6 @@ public GitPresenter(GitPresenterCore gitCore,
       vcsFileOpener_  = vcsFileOpener;
       view_ = view;
       server_ = server;
-      session_ = session;
       commands_ = commands;
       gitState_ = gitState;
       globalDisplay_ = globalDisplay;
@@ -358,42 +354,39 @@ public void execute()
    @Override
    public void viewOnGitHub(final GitHubViewRequest viewRequest)
    {
-      Command viewOnGithub = new Command()
-      {
          @Override
-         public void execute()
-         {           
-            // determine the branch (use master if there is no remote)
-            String branch = null;
-            if (gitState_.hasRemote())
-               branch = gitState_.getBranchInfo().getActiveBranch();
             else
-               branch = "master";
-            
-            // form the github url
-            SessionInfo si = session_.getSessionInfo();
-            FileSystemItem file = viewRequest.getFile();
-            String url = si.getGithubBaseUrl();
-            url += viewRequest.getViewType() == GitHubViewRequest.ViewType.View 
-                                 ? "/blob/" : "/blame/";                             
-            url += branch + "/";
-            url += file.getPathRelativeTo(si.getActiveProjectDir());    
-            if (viewRequest.getStartLine() != -1)
-               url += "#L" + viewRequest.getStartLine();
-            if (viewRequest.getEndLine() != viewRequest.getStartLine())
-               url += "-L" + viewRequest.getEndLine();
-            
-            globalDisplay_.openWindow(url);
          }
-      
-      };
-      
-      // if we don't have branch info then perform a refresh
-      // before interrogating the git state
-      if (gitState_.getBranchInfo() == null)
-         gitState_.refresh(false, viewOnGithub);
-      else
-         viewOnGithub.execute();
    }
    
    @Override
@@ -407,7 +400,6 @@ public void onVcsCleanup()
    private final GitPresenterCore gitPresenterCore_;
    private final GitServerOperations server_;
    private final Commands commands_;
-   private final Session session_;
    private final GitState gitState_;
    private final GlobalDisplay globalDisplay_;
    private final SatelliteManager satelliteManager_;
</code_before><code_after>@@ -40,8 +40,6 @@
 import org.rstudio.studio.client.vcs.VCSApplicationParams;
 import org.rstudio.studio.client.workbench.WorkbenchView;
 import org.rstudio.studio.client.workbench.commands.Commands;
 import org.rstudio.studio.client.workbench.views.vcs.BaseVcsPresenter;
 import org.rstudio.studio.client.workbench.views.vcs.common.VCSFileOpener;
 import org.rstudio.studio.client.workbench.views.vcs.common.events.VcsRefreshEvent;
@@ -77,7 +75,6 @@ public GitPresenter(GitPresenterCore gitCore,
                        VCSFileOpener vcsFileOpener,
                        Display view,
                        GitServerOperations server,
                        final Commands commands,
                        Binder commandBinder,
                        GitState gitState,
@@ -89,7 +86,6 @@ public GitPresenter(GitPresenterCore gitCore,
       vcsFileOpener_  = vcsFileOpener;
       view_ = view;
       server_ = server;
       commands_ = commands;
       gitState_ = gitState;
       globalDisplay_ = globalDisplay;
@@ -358,42 +354,39 @@ public void execute()
    @Override
    public void viewOnGitHub(final GitHubViewRequest viewRequest)
    {
+      String view = null;
+      if (viewRequest.getViewType() == GitHubViewRequest.ViewType.View)
+         view = "blob";
+      else if (viewRequest.getViewType() == GitHubViewRequest.ViewType.Blame)
+         view = "blame";
+      
+      final String path = viewRequest.getFile().getPath();
+      server_.gitGithubRemoteUrl(view, 
+                                 path, 
+                                 new SimpleRequestCallback&lt;String&gt;() {
+         
          @Override
+         public void onResponseReceived(String url)
+         {
+            if (url.length() == 0)
+            {
+               globalDisplay_.showErrorMessage(
+                     "Error", 
+                     "Unable to view " + path + " on GitHub.\n\n" +
+                     "Are you sure that this file is on GithHub and is " + 
+                     "contained in the currently active project?");
+            }
             else
+            {
+               if (viewRequest.getStartLine() != -1)
+                  url += "#L" + viewRequest.getStartLine();
+               if (viewRequest.getEndLine() != viewRequest.getStartLine())
+                  url += "-L" + viewRequest.getEndLine();
+               
+               globalDisplay_.openWindow(url);
+            }
          }
+      });
    }
    
    @Override
@@ -407,7 +400,6 @@ public void onVcsCleanup()
    private final GitPresenterCore gitPresenterCore_;
    private final GitServerOperations server_;
    private final Commands commands_;
    private final GitState gitState_;
    private final GlobalDisplay globalDisplay_;
    private final SatelliteManager satelliteManager_;
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>571798</refactoring_id><commit_sha>bcd49a1579b4bf53e4dbf24358b030c061ad5eb6</commit_sha><commit_link>https://github.com/flowable/flowable-engine/commit/bcd49a1579b4bf53e4dbf24358b030c061ad5eb6</commit_link><file_path>modules/flowable-rest/src/main/java/org/flowable/rest/service/api/runtime/process/ProcessInstanceVariableDataResource.java</file_path><description>Remove Parameter request : HttpServletRequest in method public getVariableData(processInstanceId String, variableName String, scope String, request HttpServletRequest, response HttpServletResponse) : byte[] from class org.flowable.rest.service.api.runtime.process.ProcessInstanceVariableDataResource</description><code_before>@@ -13,7 +13,6 @@
 
 package org.flowable.rest.service.api.runtime.process;
 
-import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
 
 import org.flowable.engine.runtime.Execution;
@@ -51,7 +50,7 @@ public ProcessInstanceVariableDataResource() {
     @GetMapping(value = "/runtime/process-instances/{processInstanceId}/variables/{variableName}/data")
     public byte[] getVariableData(@ApiParam(name = "processInstanceId") @PathVariable("processInstanceId") String processInstanceId, @ApiParam(name = "variableName") @PathVariable("variableName") String variableName,
             @RequestParam(value = "scope", required = false) String scope,
-            HttpServletRequest request, HttpServletResponse response) {
 
         Execution execution = getExecutionFromRequestWithoutAccessCheck(processInstanceId);
         return getVariableDataByteArray(execution, variableName, scope, response);
</code_before><code_after>@@ -13,7 +13,6 @@
 
 package org.flowable.rest.service.api.runtime.process;
 
 import jakarta.servlet.http.HttpServletResponse;
 
 import org.flowable.engine.runtime.Execution;
@@ -51,7 +50,7 @@ public ProcessInstanceVariableDataResource() {
     @GetMapping(value = "/runtime/process-instances/{processInstanceId}/variables/{variableName}/data")
     public byte[] getVariableData(@ApiParam(name = "processInstanceId") @PathVariable("processInstanceId") String processInstanceId, @ApiParam(name = "variableName") @PathVariable("variableName") String variableName,
             @RequestParam(value = "scope", required = false) String scope,
+            HttpServletResponse response) {
 
         Execution execution = getExecutionFromRequestWithoutAccessCheck(processInstanceId);
         return getVariableDataByteArray(execution, variableName, scope, response);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>557337</refactoring_id><commit_sha>ca05f4beee4d74cfb5eda90e7502c524580253bc</commit_sha><commit_link>https://github.com/seleniumhq/selenium/commit/ca05f4beee4d74cfb5eda90e7502c524580253bc</commit_link><file_path>java/main/com/thoughtworks/selenium/browserlifecycle/session/SequentialMultipleBrowserSession.java</file_path><description>Remove Parameter browserExecutables : String[] in method public run(browserExecutables String[], url String, individualBrowserTimeout long) : void from class com.thoughtworks.selenium.browserlifecycle.session.SequentialMultipleBrowserSession</description><code_before>@@ -18,21 +18,18 @@
 
 import com.thoughtworks.selenium.browserlifecycle.LifeCycleException;
 
-public class SequentialMultipleBrowserSession implements MultipleBrowserSession {
 
-	SessionFactory _browserSessionFactory;
 
-	public SequentialMultipleBrowserSession(SessionFactory browserSessionFactory) {
-		_browserSessionFactory = browserSessionFactory;
 	}
 
-	public void run(String[] browserExecutables, String url,
-			long individualBrowserTimeout) throws LifeCycleException {
-		for (int i = 0; i &lt; browserExecutables.length; i++) {
-			BrowserSession browserSession = (BrowserSession) _browserSessionFactory
-					.buildSingleBrowserSession();
-			browserSession.run(browserExecutables[i], url,
-					individualBrowserTimeout);
 		}
 
 	}
</code_before><code_after>@@ -18,21 +18,18 @@
 
 import com.thoughtworks.selenium.browserlifecycle.LifeCycleException;
 
+public class SequentialMultipleBrowserSession implements BrowserSession {
 
+	BrowserSession[] _browserSessions;
 
+	public SequentialMultipleBrowserSession(BrowserSession[] browserSessions) {
+		_browserSessions = browserSessions;
 	}
 
+	public void run(String url, long individualBrowserTimeout)
+			throws LifeCycleException {
+		for (int i = 0; i &lt; _browserSessions.length; i++) {
+			_browserSessions[i].run(url, individualBrowserTimeout);
 		}
 
 	}
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>548825</refactoring_id><commit_sha>006986cc58bae6758cd75ea7bc21a0da4eae9646</commit_sha><commit_link>https://github.com/androidx/media/commit/006986cc58bae6758cd75ea7bc21a0da4eae9646</commit_link><file_path>library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java</file_path><description>Remove Parameter inputEncoding : String in method public parse(connectionUrl String, inputStream InputStream, inputEncoding String) : SmoothStreamingManifest from class com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifestParser</description><code_before>@@ -19,10 +19,10 @@
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.ProtectionElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.MimeTypes;
-import com.google.android.exoplayer.util.NetworkLoadable;
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
@@ -60,11 +60,11 @@ public SmoothStreamingManifestParser() {
   }
 
   @Override
-  public SmoothStreamingManifest parse(String connectionUrl, InputStream inputStream,
-      String inputEncoding) throws IOException, ParserException {
     try {
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
-      xmlParser.setInput(inputStream, inputEncoding);
       SmoothStreamMediaParser smoothStreamMediaParser = new SmoothStreamMediaParser(null,
           Util.parseBaseUri(connectionUrl));
       return (SmoothStreamingManifest) smoothStreamMediaParser.parse(xmlParser);
</code_before><code_after>@@ -19,10 +19,10 @@
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.ProtectionElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
+import com.google.android.exoplayer.upstream.NetworkLoadable;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
@@ -60,11 +60,11 @@ public SmoothStreamingManifestParser() {
   }
 
   @Override
+  public SmoothStreamingManifest parse(String connectionUrl, InputStream inputStream)
+      throws IOException, ParserException {
     try {
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
+      xmlParser.setInput(inputStream, null);
       SmoothStreamMediaParser smoothStreamMediaParser = new SmoothStreamMediaParser(null,
           Util.parseBaseUri(connectionUrl));
       return (SmoothStreamingManifest) smoothStreamMediaParser.parse(xmlParser);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>516034</refactoring_id><commit_sha>7d05c09a4928fd9094c0bcf8b1689e8c1dab7e98</commit_sha><commit_link>https://github.com/apache/ignite/commit/7d05c09a4928fd9094c0bcf8b1689e8c1dab7e98</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/processors/cache/database/tree/util/PageHandler.java</file_path><description>Remove Parameter pageId : long in method public writePage(pageId long, page Page, lockListener PageLockListener, h PageHandler&lt;X,R&gt;, arg X, intArg int) : R from class org.apache.ignite.internal.processors.cache.database.tree.util.PageHandler</description><code_before>@@ -35,14 +35,13 @@
 public abstract class PageHandler&lt;X, R&gt; {
     /** */
     private static final PageHandler&lt;Void, Void&gt; NOOP = new PageHandler&lt;Void, Void&gt;() {
-        @Override public Void run(long pageId, Page page, PageIO io, ByteBuffer buf, Void arg, int intArg)
             throws IgniteCheckedException {
             return null;
         }
     };
 
     /**
-     * @param pageId Page ID.
      * @param page Page.
      * @param io IO.
      * @param buf Page buffer.
@@ -51,22 +50,20 @@ public abstract class PageHandler&lt;X, R&gt; {
      * @return Result.
      * @throws IgniteCheckedException If failed.
      */
-    public abstract R run(long pageId, Page page, PageIO io, ByteBuffer buf, X arg, int intArg)
         throws IgniteCheckedException;
 
     /**
-     * @param pageId Page ID.
      * @param page Page.
      * @param arg Argument.
      * @param intArg Argument of type {@code int}.
      * @return {@code true} If release.
      */
-    public boolean releaseAfterWrite(long pageId, Page page, X arg, int intArg) {
         return true;
     }
 
     /**
-     * @param pageId Page ID.
      * @param page Page.
      * @param h Handler.
      * @param arg Argument.
@@ -75,14 +72,13 @@ public boolean releaseAfterWrite(long pageId, Page page, X arg, int intArg) {
      * @throws IgniteCheckedException If failed.
      */
     public static &lt;X, R&gt; R readPage(
-        long pageId,
         Page page,
         PageLockListener lockListener,
         PageHandler&lt;X, R&gt; h,
         X arg,
         int intArg
     ) throws IgniteCheckedException {
-        lockListener.onBeforeReadLock(pageId, page);
 
         ByteBuffer buf = page.getForRead();
 
@@ -91,7 +87,7 @@ public static &lt;X, R&gt; R readPage(
 
             PageIO io = PageIO.getPageIO(buf);
 
-            return h.run(pageId, page, io, buf, arg, intArg);
         }
         finally {
             lockListener.onReadUnlock(page, buf);
@@ -101,7 +97,6 @@ public static &lt;X, R&gt; R readPage(
     }
 
     /**
-     * @param pageId Page ID.
      * @param page Page.
      * @param h Handler.
      * @param arg Argument.
@@ -110,35 +105,31 @@ public static &lt;X, R&gt; R readPage(
      * @throws IgniteCheckedException If failed.
      */
     public static &lt;X, R&gt; R writePage(
-        long pageId,
         Page page,
         PageLockListener lockListener,
         PageHandler&lt;X, R&gt; h,
         X arg,
         int intArg
     ) throws IgniteCheckedException {
-        return writePage(pageId, page, lockListener, h, null, null, arg, intArg);
     }
 
     /**
-     * @param pageId Page ID.
      * @param page Page.
      * @param lockListener Lock listener.
      * @param init IO for new page initialization or {@code null} if it is an existing page.
      * @throws IgniteCheckedException If failed.
      */
     public static void initPage(
-        long pageId,
         Page page,
         PageLockListener lockListener,
         PageIO init,
         IgniteWriteAheadLogManager wal
     ) throws IgniteCheckedException {
-        writePage(pageId, page, lockListener, NOOP, init, wal, null, 0);
     }
 
     /**
-     * @param pageId Page ID.
      * @param page Page.
      * @param lockListener Lock listener.
      * @param h Handler.
@@ -149,7 +140,6 @@ public static void initPage(
      * @throws IgniteCheckedException If failed.
      */
     public static &lt;X, R&gt; R writePage(
-        long pageId,
         Page page,
         PageLockListener lockListener,
         PageHandler&lt;X, R&gt; h,
@@ -158,7 +148,7 @@ public static &lt;X, R&gt; R writePage(
         X arg,
         int intArg
     ) throws IgniteCheckedException {
-        lockListener.onBeforeWriteLock(pageId, page);
 
         R res;
 
@@ -172,18 +162,18 @@ public static &lt;X, R&gt; R writePage(
             lockListener.onWriteLock(page, buf);
 
             if (init != null) // It is a new page and we have to initialize it.
-                doInitPage(pageId, page, buf, init, wal);
             else
                 init = PageIO.getPageIO(buf);
 
-            res = h.run(pageId, page, init, buf, arg, intArg);
 
             ok = true;
         }
         finally {
             assert PageIO.getCrc(buf) == 0; //TODO GG-11480
 
-            if (h.releaseAfterWrite(pageId, page, arg, intArg)) {
                 lockListener.onWriteUnlock(page, buf);
 
                 page.releaseWrite(ok);
@@ -194,22 +184,22 @@ public static &lt;X, R&gt; R writePage(
     }
 
     /**
-     * @param pageId Page ID.
      * @param page Page.
      * @param buf Buffer.
      * @param init Initial IO.
      * @param wal Write ahead log.
      * @throws IgniteCheckedException If failed.
      */
     private static void doInitPage(
-        long pageId,
         Page page,
         ByteBuffer buf,
         PageIO init,
         IgniteWriteAheadLogManager wal
     ) throws IgniteCheckedException {
         assert PageIO.getCrc(buf) == 0; //TODO GG-11480
 
         init.initNewPage(buf, pageId);
 
         // Here we should never write full page, because it is known to be new.
</code_before><code_after>@@ -35,14 +35,13 @@
 public abstract class PageHandler&lt;X, R&gt; {
     /** */
     private static final PageHandler&lt;Void, Void&gt; NOOP = new PageHandler&lt;Void, Void&gt;() {
+        @Override public Void run( Page page, PageIO io, ByteBuffer buf, Void arg, int intArg)
             throws IgniteCheckedException {
             return null;
         }
     };
 
     /**
      * @param page Page.
      * @param io IO.
      * @param buf Page buffer.
@@ -51,22 +50,20 @@ public abstract class PageHandler&lt;X, R&gt; {
      * @return Result.
      * @throws IgniteCheckedException If failed.
      */
+    public abstract R run(Page page, PageIO io, ByteBuffer buf, X arg, int intArg)
         throws IgniteCheckedException;
 
     /**
      * @param page Page.
      * @param arg Argument.
      * @param intArg Argument of type {@code int}.
      * @return {@code true} If release.
      */
+    public boolean releaseAfterWrite(Page page, X arg, int intArg) {
         return true;
     }
 
     /**
      * @param page Page.
      * @param h Handler.
      * @param arg Argument.
@@ -75,14 +72,13 @@ public boolean releaseAfterWrite(long pageId, Page page, X arg, int intArg) {
      * @throws IgniteCheckedException If failed.
      */
     public static &lt;X, R&gt; R readPage(
         Page page,
         PageLockListener lockListener,
         PageHandler&lt;X, R&gt; h,
         X arg,
         int intArg
     ) throws IgniteCheckedException {
+        lockListener.onBeforeReadLock(page);
 
         ByteBuffer buf = page.getForRead();
 
@@ -91,7 +87,7 @@ public static &lt;X, R&gt; R readPage(
 
             PageIO io = PageIO.getPageIO(buf);
 
+            return h.run(page, io, buf, arg, intArg);
         }
         finally {
             lockListener.onReadUnlock(page, buf);
@@ -101,7 +97,6 @@ public static &lt;X, R&gt; R readPage(
     }
 
     /**
      * @param page Page.
      * @param h Handler.
      * @param arg Argument.
@@ -110,35 +105,31 @@ public static &lt;X, R&gt; R readPage(
      * @throws IgniteCheckedException If failed.
      */
     public static &lt;X, R&gt; R writePage(
         Page page,
         PageLockListener lockListener,
         PageHandler&lt;X, R&gt; h,
         X arg,
         int intArg
     ) throws IgniteCheckedException {
+        return writePage(page, lockListener, h, null, null, arg, intArg);
     }
 
     /**
      * @param page Page.
      * @param lockListener Lock listener.
      * @param init IO for new page initialization or {@code null} if it is an existing page.
      * @throws IgniteCheckedException If failed.
      */
     public static void initPage(
         Page page,
         PageLockListener lockListener,
         PageIO init,
         IgniteWriteAheadLogManager wal
     ) throws IgniteCheckedException {
+        writePage(page, lockListener, NOOP, init, wal, null, 0);
     }
 
     /**
      * @param page Page.
      * @param lockListener Lock listener.
      * @param h Handler.
@@ -149,7 +140,6 @@ public static void initPage(
      * @throws IgniteCheckedException If failed.
      */
     public static &lt;X, R&gt; R writePage(
         Page page,
         PageLockListener lockListener,
         PageHandler&lt;X, R&gt; h,
@@ -158,7 +148,7 @@ public static &lt;X, R&gt; R writePage(
         X arg,
         int intArg
     ) throws IgniteCheckedException {
+        lockListener.onBeforeWriteLock(page);
 
         R res;
 
@@ -172,18 +162,18 @@ public static &lt;X, R&gt; R writePage(
             lockListener.onWriteLock(page, buf);
 
             if (init != null) // It is a new page and we have to initialize it.
+                doInitPage(page, buf, init, wal);
             else
                 init = PageIO.getPageIO(buf);
 
+            res = h.run(page, init, buf, arg, intArg);
 
             ok = true;
         }
         finally {
             assert PageIO.getCrc(buf) == 0; //TODO GG-11480
 
+            if (h.releaseAfterWrite(page, arg, intArg)) {
                 lockListener.onWriteUnlock(page, buf);
 
                 page.releaseWrite(ok);
@@ -194,22 +184,22 @@ public static &lt;X, R&gt; R writePage(
     }
 
     /**
      * @param page Page.
      * @param buf Buffer.
      * @param init Initial IO.
      * @param wal Write ahead log.
      * @throws IgniteCheckedException If failed.
      */
     private static void doInitPage(
         Page page,
         ByteBuffer buf,
         PageIO init,
         IgniteWriteAheadLogManager wal
     ) throws IgniteCheckedException {
         assert PageIO.getCrc(buf) == 0; //TODO GG-11480
 
+        long pageId = page.id();
+
         init.initNewPage(buf, pageId);
 
         // Here we should never write full page, because it is known to be new.
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>523449</refactoring_id><commit_sha>ce773f31f6ee8a663f46558ab3fcee44c53d21f6</commit_sha><commit_link>https://github.com/teammates/teammates/commit/ce773f31f6ee8a663f46558ab3fcee44c53d21f6</commit_link><file_path>src/main/java/teammates/ui/template/CommentRow.java</file_path><description>Remove Parameter showRecipientNameTo : String in method public CommentRow(giverDetails String, comment CommentAttributes, recipientDetails String, creationTime String, editButton ElementTag, isInstructorAllowedToModifyCommentInSection Boolean, typeOfPeopleCanViewComment String, editedAt String, visibilityCheckboxes VisibilityCheckboxes, showCommentsTo String, showGiverNameTo String, showRecipientNameTo String) from class teammates.ui.template.CommentRow</description><code_before>@@ -3,38 +3,23 @@
 import teammates.common.datatransfer.CommentAttributes;
 
 public class CommentRow {
-    private String giverDetails;
-    private CommentAttributes comment;
-    private String recipientDetails;
-    private String creationTime;
-    private ElementTag editButton;
-    private Boolean isInstructorAllowedToModifyCommentInSection;
-    private String typeOfPeopleCanViewComment;
-    private String editedAt;
-    private VisibilityCheckboxes visibilityCheckboxes;
-    
-    // Visibility Settings
-    private String showCommentsTo;
-    private String showGiverNameTo;
-    private String showRecipientNameTo;
     
-    public CommentRow(String giverDetails, CommentAttributes comment, String recipientDetails, String creationTime,
-                                    ElementTag editButton, Boolean isInstructorAllowedToModifyCommentInSection,
-                                    String typeOfPeopleCanViewComment, String editedAt, VisibilityCheckboxes visibilityCheckboxes,
-                                    String showCommentsTo, String showGiverNameTo, String showRecipientNameTo) {
         this.giverDetails = giverDetails;
         this.comment = comment;
         this.recipientDetails = recipientDetails;
         this.creationTime = creationTime;
         this.editButton = editButton;
-        this.isInstructorAllowedToModifyCommentInSection = isInstructorAllowedToModifyCommentInSection;
-        this.typeOfPeopleCanViewComment = typeOfPeopleCanViewComment;
-        this.editedAt = editedAt;
-        this.visibilityCheckboxes = visibilityCheckboxes;
-        
-        this.showCommentsTo = showCommentsTo;
-        this.showGiverNameTo = showGiverNameTo;
-        this.showRecipientNameTo = showRecipientNameTo;
     }
     
     public String getGiverDetails() {
@@ -56,32 +41,4 @@ public String getCreationTime() {
     public ElementTag getEditButton() {
         return editButton;
     }
-    
-    public boolean isInstructorAllowedToModifyCommentInSection() {
-        return isInstructorAllowedToModifyCommentInSection;
-    }
-    
-    public String getTypeOfPeopleCanViewComment() {
-        return typeOfPeopleCanViewComment;
-    }
-    
-    public String getEditedAt() {
-        return editedAt;
-    }
-    
-    public VisibilityCheckboxes getVisibilityCheckboxes() {
-        return visibilityCheckboxes;
-    }
-    
-    public String getShowCommentsTo() {
-        return showCommentsTo;
-    }
-    
-    public String getShowGiverNameTo() {
-        return showGiverNameTo;
-    }
-    
-    public String getShowRecipientNameTo() {
-        return showRecipientNameTo;
-    }
 }
</code_before><code_after>@@ -3,38 +3,23 @@
 import teammates.common.datatransfer.CommentAttributes;
 
 public class CommentRow {
+    protected String giverDetails;
+    protected CommentAttributes comment;
+    protected String recipientDetails;
+    protected String creationTime;
+    protected ElementTag editButton;
+   
+    public CommentRow() {
+        
+    }
     
+    public CommentRow(String giverDetails, CommentAttributes comment,
+                      String recipientDetails, String creationTime, ElementTag editButton) {
         this.giverDetails = giverDetails;
         this.comment = comment;
         this.recipientDetails = recipientDetails;
         this.creationTime = creationTime;
         this.editButton = editButton;
     }
     
     public String getGiverDetails() {
@@ -56,32 +41,4 @@ public String getCreationTime() {
     public ElementTag getEditButton() {
         return editButton;
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>512803</refactoring_id><commit_sha>939ef5b24903ff9a799b22ca24ab6d2af449a983</commit_sha><commit_link>https://github.com/camunda/camunda/commit/939ef5b24903ff9a799b22ca24ab6d2af449a983</commit_link><file_path>backend/src/test/java/org/camunda/optimize/test/util/DateUtilHelper.java</file_path><description>Remove Parameter filterValue : int in method public createDurationFilter(operator String, filterValue int, unit String) : List&lt;ProcessFilterDto&gt; from class org.camunda.optimize.test.util.DateUtilHelper</description><code_before>@@ -1,99 +0,0 @@
-package org.camunda.optimize.test.util;
-
-import org.camunda.optimize.dto.optimize.query.analysis.BranchAnalysisQueryDto;
-import org.camunda.optimize.dto.optimize.query.report.single.filter.data.date.FixedDateFilterDataDto;
-import org.camunda.optimize.dto.optimize.query.report.single.filter.data.date.RelativeDateFilterDataDto;
-import org.camunda.optimize.dto.optimize.query.report.single.filter.data.date.RelativeDateFilterStartDto;
-import org.camunda.optimize.dto.optimize.query.report.single.process.filter.DurationFilterDto;
-import org.camunda.optimize.dto.optimize.query.report.single.process.filter.EndDateFilterDto;
-import org.camunda.optimize.dto.optimize.query.report.single.process.filter.ProcessFilterDto;
-import org.camunda.optimize.dto.optimize.query.report.single.process.filter.StartDateFilterDto;
-import org.camunda.optimize.dto.optimize.query.report.single.process.filter.data.DurationFilterDataDto;
-
-import java.time.OffsetDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-
-public class DateUtilHelper {
-
-  public static void addStartDateFilter(OffsetDateTime startDate, OffsetDateTime endDate, BranchAnalysisQueryDto dto) {
-    List&lt;ProcessFilterDto&gt; dateFilter = createFixedStartDateFilter(startDate, endDate);
-    dto.getFilter().addAll(dateFilter);
-  }
-
-  public static List&lt;ProcessFilterDto&gt; createFixedStartDateFilter(OffsetDateTime startDate, OffsetDateTime endDate) {
-    StartDateFilterDto filter = new StartDateFilterDto();
-    FixedDateFilterDataDto filterData = new FixedDateFilterDataDto();
-
-    filterData.setStart(startDate);
-    filterData.setEnd(endDate);
-    filter.setData(filterData);
-
-    ArrayList&lt;ProcessFilterDto&gt; filters = new ArrayList&lt;&gt;();
-    filters.add(filter);
-
-    return filters;
-  }
-
-  public static List&lt;ProcessFilterDto&gt; createFixedEndDateFilter(OffsetDateTime startDate, OffsetDateTime endDate) {
-    EndDateFilterDto filterDto = new EndDateFilterDto();
-    FixedDateFilterDataDto filterData = new FixedDateFilterDataDto();
-
-    filterData.setStart(startDate);
-    filterData.setEnd(endDate);
-    filterDto.setData(filterData);
-
-    ArrayList&lt;ProcessFilterDto&gt; filters = new ArrayList&lt;&gt;();
-    filters.add(filterDto);
-
-    return filters;
-  }
-
-  public static List&lt;ProcessFilterDto&gt; createRollingStartDateFilter(Long value, String unit) {
-    StartDateFilterDto filter = new StartDateFilterDto();
-    RelativeDateFilterDataDto filterData = new RelativeDateFilterDataDto();
-    RelativeDateFilterStartDto startDate = new RelativeDateFilterStartDto();
-
-    startDate.setUnit(unit);
-    startDate.setValue(value);
-    filterData.setStart(startDate);
-    filter.setData(filterData);
-
-    List&lt;ProcessFilterDto&gt; filters = new ArrayList&lt;&gt;();
-    filters.add(filter);
-
-    return filters;
-  }
-
-  public static List&lt;ProcessFilterDto&gt; createRollingEndDateFilter(Long value, String unit) {
-    EndDateFilterDto filter = new EndDateFilterDto();
-    RelativeDateFilterDataDto filterData = new RelativeDateFilterDataDto();
-    RelativeDateFilterStartDto startDate = new RelativeDateFilterStartDto();
-
-    startDate.setUnit(unit);
-    startDate.setValue(value);
-    filterData.setStart(startDate);
-    filter.setData(filterData);
-
-    List&lt;ProcessFilterDto&gt; filters = new ArrayList&lt;&gt;();
-    filters.add(filter);
-
-    return filters;
-  }
-
-  public static List&lt;ProcessFilterDto&gt; createDurationFilter(String operator, int filterValue, String unit) {
-    List&lt;ProcessFilterDto&gt; result = new ArrayList&lt;&gt;();
-
-    DurationFilterDto filter = new DurationFilterDto();
-
-    DurationFilterDataDto filterData = new DurationFilterDataDto();
-    filterData.setOperator(operator);
-    filterData.setUnit(unit);
-    filterData.setValue(Long.valueOf(filterValue));
-
-    filter.setData(filterData);
-    result.add(filter);
-    return result;
-  }
-}
</code_before><code_after>@@ -1,99 +0,0 @@
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>537900</refactoring_id><commit_sha>2f9f7d42fb73e4f352337ed1b8f089bcc3abf8ab</commit_sha><commit_link>https://github.com/real-logic/aeron/commit/2f9f7d42fb73e4f352337ed1b8f089bcc3abf8ab</commit_link><file_path>aeron-client/src/main/java/io/aeron/logbuffer/ExclusiveTermAppender.java</file_path><description>Remove Parameter rawTail : long in method public appendUnfragmentedMessage(rawTail long, termId int, termOffset int, header HeaderWriter, srcBuffer DirectBuffer, srcOffset int, length int, reservedValueSupplier ReservedValueSupplier) : int from class io.aeron.logbuffer.ExclusiveTermAppender</description><code_before>@@ -98,7 +98,6 @@ public void tailTermId(final int termId)
     /**
      * Claim length of a the term buffer for writing in the message with zero copy semantics.
      *
-     * @param rawTail     value from the meta data.
      * @param termId      for the current term.
      * @param termOffset  in the term at which to append.
      * @param header      for writing the default header.
@@ -108,7 +107,6 @@ public void tailTermId(final int termId)
      * {@link #FAILED}.
      */
     public int claim(
-        final long rawTail,
         final int termId,
         final int termOffset,
         final HeaderWriter header,
@@ -120,7 +118,7 @@ public int claim(
         final UnsafeBuffer termBuffer = this.termBuffer;
         final int termLength = termBuffer.capacity();
 
-        putRawTailOrdered(rawTail + alignedLength);
 
         int resultingOffset = termOffset + alignedLength;
         if (resultingOffset &gt; termLength)
@@ -139,7 +137,6 @@ public int claim(
     /**
      * Append an unfragmented message to the the term buffer.
      *
-     * @param rawTail               value from the meta data.
      * @param termId                for the current term.
      * @param termOffset            in the term at which to append.
      * @param header                for writing the default header.
@@ -151,7 +148,6 @@ public int claim(
      * {@link #FAILED}.
      */
     public int appendUnfragmentedMessage(
-        final long rawTail,
         final int termId,
         final int termOffset,
         final HeaderWriter header,
@@ -165,7 +161,7 @@ public int appendUnfragmentedMessage(
         final UnsafeBuffer termBuffer = this.termBuffer;
         final int termLength = termBuffer.capacity();
 
-        putRawTailOrdered(rawTail + alignedLength);
 
         int resultingOffset = termOffset + alignedLength;
         if (resultingOffset &gt; termLength)
@@ -193,7 +189,6 @@ public int appendUnfragmentedMessage(
      * Append a fragmented message to the the term buffer.
      * The message will be split up into fragments of MTU length minus header.
      *
-     * @param rawTail               value from the meta data.
      * @param termId                for the current term.
      * @param termOffset            in the term at which to append.
      * @param header                for writing the default header.
@@ -206,7 +201,6 @@ public int appendUnfragmentedMessage(
      * {@link #FAILED}.
      */
     public int appendFragmentedMessage(
-        final long rawTail,
         final int termId,
         final int termOffset,
         final HeaderWriter header,
@@ -223,7 +217,7 @@ public int appendFragmentedMessage(
         final UnsafeBuffer termBuffer = this.termBuffer;
         final int termLength = termBuffer.capacity();
 
-        putRawTailOrdered(rawTail + requiredLength);
 
         int resultingOffset = termOffset + requiredLength;
         if (resultingOffset &gt; termLength)
@@ -299,8 +293,8 @@ private int handleEndOfLogCondition(
         return resultingOffset;
     }
 
-    private void putRawTailOrdered(final long rawTail)
     {
-        UnsafeAccess.UNSAFE.putOrderedLong(tailBuffer, tailAddressOffset, rawTail);
     }
 }
</code_before><code_after>@@ -98,7 +98,6 @@ public void tailTermId(final int termId)
     /**
      * Claim length of a the term buffer for writing in the message with zero copy semantics.
      *
      * @param termId      for the current term.
      * @param termOffset  in the term at which to append.
      * @param header      for writing the default header.
@@ -108,7 +107,6 @@ public void tailTermId(final int termId)
      * {@link #FAILED}.
      */
     public int claim(
         final int termId,
         final int termOffset,
         final HeaderWriter header,
@@ -120,7 +118,7 @@ public int claim(
         final UnsafeBuffer termBuffer = this.termBuffer;
         final int termLength = termBuffer.capacity();
 
+        putRawTailOrdered(termId, termOffset + alignedLength);
 
         int resultingOffset = termOffset + alignedLength;
         if (resultingOffset &gt; termLength)
@@ -139,7 +137,6 @@ public int claim(
     /**
      * Append an unfragmented message to the the term buffer.
      *
      * @param termId                for the current term.
      * @param termOffset            in the term at which to append.
      * @param header                for writing the default header.
@@ -151,7 +148,6 @@ public int claim(
      * {@link #FAILED}.
      */
     public int appendUnfragmentedMessage(
         final int termId,
         final int termOffset,
         final HeaderWriter header,
@@ -165,7 +161,7 @@ public int appendUnfragmentedMessage(
         final UnsafeBuffer termBuffer = this.termBuffer;
         final int termLength = termBuffer.capacity();
 
+        putRawTailOrdered(termId, termOffset + alignedLength);
 
         int resultingOffset = termOffset + alignedLength;
         if (resultingOffset &gt; termLength)
@@ -193,7 +189,6 @@ public int appendUnfragmentedMessage(
      * Append a fragmented message to the the term buffer.
      * The message will be split up into fragments of MTU length minus header.
      *
      * @param termId                for the current term.
      * @param termOffset            in the term at which to append.
      * @param header                for writing the default header.
@@ -206,7 +201,6 @@ public int appendUnfragmentedMessage(
      * {@link #FAILED}.
      */
     public int appendFragmentedMessage(
         final int termId,
         final int termOffset,
         final HeaderWriter header,
@@ -223,7 +217,7 @@ public int appendFragmentedMessage(
         final UnsafeBuffer termBuffer = this.termBuffer;
         final int termLength = termBuffer.capacity();
 
+        putRawTailOrdered(termId, termOffset + requiredLength);
 
         int resultingOffset = termOffset + requiredLength;
         if (resultingOffset &gt; termLength)
@@ -299,8 +293,8 @@ private int handleEndOfLogCondition(
         return resultingOffset;
     }
 
+    private void putRawTailOrdered(final int termId, final int termOffset)
     {
+        UnsafeAccess.UNSAFE.putOrderedLong(tailBuffer, tailAddressOffset, (((long)termId) &lt;&lt; 32) + termOffset);
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>555007</refactoring_id><commit_sha>a0d9062e971cf615effcc31fae735ad876e62a38</commit_sha><commit_link>https://github.com/universalmediaserver/universalmediaserver/commit/a0d9062e971cf615effcc31fae735ad876e62a38</commit_link><file_path>src/main/java/net/pms/configuration/PmsConfiguration.java</file_path><description>Remove Parameter tags : ArrayList&lt;String&gt; in method public isHideNewMediaFolder(tags ArrayList&lt;String&gt;) : boolean from class net.pms.configuration.PmsConfiguration</description><code_before>@@ -1584,7 +1584,7 @@ public void setAutoloadExternalSubtitles(boolean value) {
 	 *
 	 * @return True if PMS should hide the folder, false othewise.
 	 */
-	public boolean getHideVideoSettings(ArrayList&lt;String&gt; tags) {
 		return getBoolean(KEY_HIDE_VIDEO_SETTINGS, true);
 	}
 
@@ -2415,15 +2415,15 @@ public void setRunWizard(boolean value) {
 		configuration.setProperty(KEY_RUN_WIZARD, value);
 	}
 
-	public boolean isHideNewMediaFolder(ArrayList&lt;String&gt; tags) {
 		return getBoolean(KEY_HIDE_NEW_MEDIA_FOLDER, false);
 	}
 
 	public void setHideNewMediaFolder(final boolean value) {
 		this.configuration.setProperty(KEY_HIDE_NEW_MEDIA_FOLDER, value);
 	}
 
-	public boolean isHideRecentlyPlayedFolder(ArrayList&lt;String&gt; tags) {
 		return getBoolean(PmsConfiguration.KEY_HIDE_RECENTLY_PLAYED_FOLDER, false);
 	}
 
</code_before><code_after>@@ -1584,7 +1584,7 @@ public void setAutoloadExternalSubtitles(boolean value) {
 	 *
 	 * @return True if PMS should hide the folder, false othewise.
 	 */
+	public boolean getHideVideoSettings() {
 		return getBoolean(KEY_HIDE_VIDEO_SETTINGS, true);
 	}
 
@@ -2415,15 +2415,15 @@ public void setRunWizard(boolean value) {
 		configuration.setProperty(KEY_RUN_WIZARD, value);
 	}
 
+	public boolean isHideNewMediaFolder() {
 		return getBoolean(KEY_HIDE_NEW_MEDIA_FOLDER, false);
 	}
 
 	public void setHideNewMediaFolder(final boolean value) {
 		this.configuration.setProperty(KEY_HIDE_NEW_MEDIA_FOLDER, value);
 	}
 
+	public boolean isHideRecentlyPlayedFolder() {
 		return getBoolean(PmsConfiguration.KEY_HIDE_RECENTLY_PLAYED_FOLDER, false);
 	}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>510619</refactoring_id><commit_sha>950a9cc8f8660b3f3d750391ddc1429d5dc38b34</commit_sha><commit_link>https://github.com/osmandapp/osmand/commit/950a9cc8f8660b3f3d750391ddc1429d5dc38b34</commit_link><file_path>OsmAnd/src/net/osmand/plus/OsmandApplication.java</file_path><description>Remove Parameter interval : int in method public startNavigationService(intent int, interval int) : void from class net.osmand.plus.OsmandApplication</description><code_before>@@ -945,34 +945,14 @@ public int getVersionCode() {
 		}
 	}
 
-
-	public int navigationServiceGpsInterval(int interval) {
-		// Issue 5632 Workaround: Keep GPS always on instead of using AlarmManager, as API&gt;=19 restricts repeated AlarmManager reception
-		// Maybe do not apply to API=19 devices, many still behave acceptably (often restriction not worse than 1/min)
-		if ((Build.VERSION.SDK_INT &gt; 19) &amp;&amp; (getSettings().SAVE_GLOBAL_TRACK_INTERVAL.get() &lt; 5 * 60000)) {
-			return 0;
-		}
-		// Default: Save battery power by turning off GPS between measurements
-		if (interval &gt;= 30000) {
-			return interval;
-		// GPS continuous
-		} else {
-			return 0;
-		}
-	}
-
-
-	public void startNavigationService(int intent, int interval) {
 		final Intent serviceIntent = new Intent(this, NavigationService.class);
-		
 		if (getNavigationService() != null) {
 			intent |= getNavigationService().getUsedBy();
-			interval = Math.min(getNavigationService().getServiceOffInterval(), interval);
 			getNavigationService().stopSelf();
 			
 		}
 		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
-		serviceIntent.putExtra(NavigationService.USAGE_OFF_INTERVAL, interval);
 		if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
 			startForegroundService(serviceIntent);
 		} else {
</code_before><code_after>@@ -945,34 +945,14 @@ public int getVersionCode() {
 		}
 	}
 
+	public void startNavigationService(int intent) {
 		final Intent serviceIntent = new Intent(this, NavigationService.class);
 		if (getNavigationService() != null) {
 			intent |= getNavigationService().getUsedBy();
 			getNavigationService().stopSelf();
 			
 		}
 		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
 		if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
 			startForegroundService(serviceIntent);
 		} else {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>488901</refactoring_id><commit_sha>2800fcac437413493018c684576e0869e4d30e93</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/2800fcac437413493018c684576e0869e4d30e93</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/factory/DataSourceModule.java</file_path><description>Remove Parameter logging : LogService in method protected createGuard(clock Clock, logging LogService) : TimeoutGuard from class org.neo4j.kernel.impl.factory.DataSourceModule</description><code_before>@@ -47,7 +47,7 @@
 import org.neo4j.kernel.builtinprocs.SpecialBuiltInProcedures;
 import org.neo4j.kernel.configuration.Config;
 import org.neo4j.kernel.guard.Guard;
-import org.neo4j.kernel.guard.TimeoutGuard;
 import org.neo4j.kernel.impl.api.NonTransactionalTokenNameLookup;
 import org.neo4j.kernel.impl.api.SchemaWriteGuard;
 import org.neo4j.kernel.impl.api.dbms.NonTransactionalDbmsOperations;
@@ -84,7 +84,6 @@
 import org.neo4j.kernel.lifecycle.LifecycleAdapter;
 import org.neo4j.logging.Log;
 import org.neo4j.procedure.ProcedureTransaction;
-import org.neo4j.procedure.TerminationGuard;
 
 import static org.neo4j.kernel.api.proc.Context.KERNEL_TRANSACTION;
 import static org.neo4j.kernel.api.proc.Context.SECURITY_CONTEXT;
@@ -339,14 +338,14 @@ public Relationship newRelationshipProxy( long id, long startNodeId, int typeId,
 
     private Guard createGuard( Dependencies deps, Clock clock, LogService logging )
     {
-        TimeoutGuard guard = createGuard( clock, logging );
         deps.satisfyDependency( guard );
         return guard;
     }
 
-    protected TimeoutGuard createGuard( Clock clock, LogService logging )
     {
-        return new TimeoutGuard( clock, logging.getInternalLog( TimeoutGuard.class ) );
     }
 
     private Procedures setupProcedures( PlatformModule platform, EditionModule editionModule )
@@ -373,7 +372,7 @@ private Procedures setupProcedures( PlatformModule platform, EditionModule editi
 
         Guard guard = platform.dependencies.resolveDependency( Guard.class );
         procedures.registerComponent( ProcedureTransaction.class, new ProcedureTransactionProvider(), true );
-        procedures.registerComponent( TerminationGuard.class, new TerminationGuardProvider( guard ), true );
 
         // Below components are not public API, but are made available for internal
         // procedures to call, and to provide temporary workarounds for the following
</code_before><code_after>@@ -47,7 +47,7 @@
 import org.neo4j.kernel.builtinprocs.SpecialBuiltInProcedures;
 import org.neo4j.kernel.configuration.Config;
 import org.neo4j.kernel.guard.Guard;
+import org.neo4j.kernel.guard.TerminationGuard;
 import org.neo4j.kernel.impl.api.NonTransactionalTokenNameLookup;
 import org.neo4j.kernel.impl.api.SchemaWriteGuard;
 import org.neo4j.kernel.impl.api.dbms.NonTransactionalDbmsOperations;
@@ -84,7 +84,6 @@
 import org.neo4j.kernel.lifecycle.LifecycleAdapter;
 import org.neo4j.logging.Log;
 import org.neo4j.procedure.ProcedureTransaction;
 
 import static org.neo4j.kernel.api.proc.Context.KERNEL_TRANSACTION;
 import static org.neo4j.kernel.api.proc.Context.SECURITY_CONTEXT;
@@ -339,14 +338,14 @@ public Relationship newRelationshipProxy( long id, long startNodeId, int typeId,
 
     private Guard createGuard( Dependencies deps, Clock clock, LogService logging )
     {
+        TerminationGuard guard = createGuard();
         deps.satisfyDependency( guard );
         return guard;
     }
 
+    protected TerminationGuard createGuard()
     {
+        return new TerminationGuard();
     }
 
     private Procedures setupProcedures( PlatformModule platform, EditionModule editionModule )
@@ -373,7 +372,7 @@ private Procedures setupProcedures( PlatformModule platform, EditionModule editi
 
         Guard guard = platform.dependencies.resolveDependency( Guard.class );
         procedures.registerComponent( ProcedureTransaction.class, new ProcedureTransactionProvider(), true );
+        procedures.registerComponent( org.neo4j.procedure.TerminationGuard.class, new TerminationGuardProvider( guard ), true );
 
         // Below components are not public API, but are made available for internal
         // procedures to call, and to provide temporary workarounds for the following
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>551261</refactoring_id><commit_sha>57767145d9f7be6763f9088e50051d301d2512c3</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/57767145d9f7be6763f9088e50051d301d2512c3</commit_link><file_path>src/com/google/javascript/jscomp/J2clEqualitySameRewriterPass.java</file_path><description>Remove Parameter j2clChangeTracker : J2clChangeTracker in method package J2clEqualitySameRewriterPass(compiler AbstractCompiler, j2clChangeTracker J2clChangeTracker) from class com.google.javascript.jscomp.J2clEqualitySameRewriterPass</description><code_before>@@ -15,7 +15,6 @@
  */
 package com.google.javascript.jscomp;
 
-import com.google.javascript.jscomp.J2clSourceFileChecker.J2clChangeTracker;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
@@ -32,23 +31,16 @@ private static enum Eq {
   }
 
   private final AbstractCompiler compiler;
-  private final J2clChangeTracker j2clChangeTracker;
 
-  J2clEqualitySameRewriterPass(AbstractCompiler compiler, J2clChangeTracker j2clChangeTracker) {
     this.compiler = compiler;
-    this.j2clChangeTracker = j2clChangeTracker;
   }
 
   @Override
   public void process(Node externs, Node root) {
     if (!J2clSourceFileChecker.shouldRunJ2clPasses(compiler)) {
       return;
     }
-    if (j2clChangeTracker != null
-        &amp;&amp; j2clChangeTracker.isEnabled()
-        &amp;&amp; !j2clChangeTracker.hasChanged()) {
-      return;
-    }
 
     NodeTraversal.traverseEs6(compiler, root, this);
   }
</code_before><code_after>@@ -15,7 +15,6 @@
  */
 package com.google.javascript.jscomp;
 
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
@@ -32,23 +31,16 @@ private static enum Eq {
   }
 
   private final AbstractCompiler compiler;
 
+  J2clEqualitySameRewriterPass(AbstractCompiler compiler) {
     this.compiler = compiler;
   }
 
   @Override
   public void process(Node externs, Node root) {
     if (!J2clSourceFileChecker.shouldRunJ2clPasses(compiler)) {
       return;
     }
 
     NodeTraversal.traverseEs6(compiler, root, this);
   }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>584942</refactoring_id><commit_sha>071eccab2f1efd91d2571597cd9bb52c3c5b3cf3</commit_sha><commit_link>https://github.com/oracle/graal/commit/071eccab2f1efd91d2571597cd9bb52c3c5b3cf3</commit_link><file_path>substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/snippets/SubstrateGraphBuilderPlugins.java</file_path><description>Remove Parameter analysis : boolean in method private registerKnownIntrinsicsPlugins(plugins InvocationPlugins, analysis boolean) : void from class com.oracle.svm.hosted.snippets.SubstrateGraphBuilderPlugins</description><code_before>@@ -182,7 +182,7 @@ public static void registerInvocationPlugins(AnnotationSubstitutionProcessor ann
         registerAtomicUpdaterPlugins(metaAccess, snippetReflection, plugins, analysis);
         registerObjectPlugins(plugins);
         registerUnsafePlugins(metaAccess, plugins, snippetReflection, analysis);
-        registerKnownIntrinsicsPlugins(plugins, analysis);
         registerStackValuePlugins(snippetReflection, plugins);
         registerArraysPlugins(plugins, analysis);
         registerArrayPlugins(plugins, snippetReflection, analysis);
@@ -711,7 +711,7 @@ public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Rec
 
     }
 
-    private static void registerKnownIntrinsicsPlugins(InvocationPlugins plugins, boolean analysis) {
         Registration r = new Registration(plugins, KnownIntrinsics.class);
         r.register0("heapBase", new InvocationPlugin() {
             @Override
@@ -804,11 +804,14 @@ public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Rec
                 ResolvedJavaType type = typeValue(b.getConstantReflection(), b, targetMethod, typeNode, "type");
                 TypeReference typeRef = TypeReference.createTrustedWithoutAssumptions(type);
                 Stamp stamp = StampFactory.object(typeRef);
-                if (analysis) {
-                    b.addPush(JavaKind.Object, new ConvertUnknownValueNode(object, stamp));
-                } else {
-                    b.addPush(JavaKind.Object, PiNode.create(object, stamp));
-                }
                 return true;
             }
         });
</code_before><code_after>@@ -182,7 +182,7 @@ public static void registerInvocationPlugins(AnnotationSubstitutionProcessor ann
         registerAtomicUpdaterPlugins(metaAccess, snippetReflection, plugins, analysis);
         registerObjectPlugins(plugins);
         registerUnsafePlugins(metaAccess, plugins, snippetReflection, analysis);
+        registerKnownIntrinsicsPlugins(plugins);
         registerStackValuePlugins(snippetReflection, plugins);
         registerArraysPlugins(plugins, analysis);
         registerArrayPlugins(plugins, snippetReflection, analysis);
@@ -711,7 +711,7 @@ public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Rec
 
     }
 
+    private static void registerKnownIntrinsicsPlugins(InvocationPlugins plugins) {
         Registration r = new Registration(plugins, KnownIntrinsics.class);
         r.register0("heapBase", new InvocationPlugin() {
             @Override
@@ -804,11 +804,14 @@ public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Rec
                 ResolvedJavaType type = typeValue(b.getConstantReflection(), b, targetMethod, typeNode, "type");
                 TypeReference typeRef = TypeReference.createTrustedWithoutAssumptions(type);
                 Stamp stamp = StampFactory.object(typeRef);
+
+                /* The type cast for Graal optimization phases. */
+                ValueNode piNode = PiNode.create(object, stamp);
+                /*
+                 * The special handling node for static analysis. This node removes itself during
+                 * compilation.
+                 */
+                b.addPush(JavaKind.Object, new ConvertUnknownValueNode(piNode, stamp));
                 return true;
             }
         });
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>551363</refactoring_id><commit_sha>eb8b58af42b061d736c2d14660f95cff45c87c1a</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/eb8b58af42b061d736c2d14660f95cff45c87c1a</commit_link><file_path>src/com/google/javascript/rhino/jstype/ObjectType.java</file_path><description>Remove Parameter optionality : PropertyOptionality in method package isStructuralSubtypeHelper(subtype ObjectType, supertype ObjectType, implicitImplCache ImplCache, subtypingMode SubtypingMode, optionality PropertyOptionality) : boolean from class com.google.javascript.rhino.jstype.ObjectType</description><code_before>@@ -39,7 +39,6 @@
 
 package com.google.javascript.rhino.jstype;
 
-import static com.google.javascript.rhino.jstype.ObjectType.PropertyOptionality.VOIDABLE_PROPS_ARE_OPTIONAL;
 import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;
 import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;
 
@@ -640,61 +639,6 @@ final boolean checkStructuralEquivalenceHelper(
     return true;
   }
 
-  static boolean isStructuralSubtypeHelper(
-      ObjectType subtype,
-      ObjectType supertype,
-      ImplCache implicitImplCache,
-      SubtypingMode subtypingMode,
-      PropertyOptionality optionality) {
-
-    MatchStatus cachedResult = implicitImplCache.checkCache(subtype, supertype);
-    if (cachedResult != null) {
-      return cachedResult.subtypeValue();
-    }
-
-    // subtype is a subtype of record type supertype iff:
-    // 1) subtype has all the non-optional properties declared in supertype.
-    // 2) And for each property of supertype, its type must be
-    //    a super type of the corresponding property of subtype.
-
-    Iterable&lt;String&gt; props =
-        // NOTE: Inline record literal types always have Object as a supertype. In these cases, we
-        // really only care about the properties explicitly declared in the record literal, and not
-        // about any properties inherited from Object.prototype. On the other hand, @record types
-        // allow inheritance and we need to match against inherited properties as well.
-        supertype.isRecordType() ? supertype.getOwnPropertyNames() : supertype.getPropertyNames();
-
-    boolean result = true;
-    for (String property : props) {
-      JSType supertypeProp = supertype.getPropertyType(property);
-      if (subtype.hasProperty(property)) {
-        JSType subtypeProp = subtype.getPropertyType(property);
-        if (!subtypeProp.isSubtype(supertypeProp, implicitImplCache, subtypingMode)) {
-          result = false;
-          break;
-        }
-      } else if (!optionality.isOptional(supertypeProp)) {
-        // Currently, any type that explicitly includes undefined (eg, `?|undefined`) is optional.
-        result = false;
-        break;
-      }
-    }
-
-    return implicitImplCache.updateCache(subtype, supertype, MatchStatus.valueOf(result));
-  }
-
-  /** How to treat explicitly voidable properties for structural subtype checking. */
-  enum PropertyOptionality {
-    /** Explicitly voidable properties are treated as optional. */
-    VOIDABLE_PROPS_ARE_OPTIONAL,
-    /** All properties are always required, even if explicitly voidable. */
-    ALL_PROPS_ARE_REQUIRED;
-
-    boolean isOptional(JSType propType) {
-      return this == VOIDABLE_PROPS_ARE_OPTIONAL &amp;&amp; propType.isExplicitlyVoidable();
-    }
-  }
-
   /**
    * Returns a list of properties defined or inferred on this type and any of
    * its supertypes.
</code_before><code_after>@@ -39,7 +39,6 @@
 
 package com.google.javascript.rhino.jstype;
 
 import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;
 import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;
 
@@ -640,61 +639,6 @@ final boolean checkStructuralEquivalenceHelper(
     return true;
   }
 
   /**
    * Returns a list of properties defined or inferred on this type and any of
    * its supertypes.
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>543869</refactoring_id><commit_sha>73b9e13b740ee17d039162cce58efb25a3b39ada</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/73b9e13b740ee17d039162cce58efb25a3b39ada</commit_link><file_path>src/edu/stanford/nlp/ling/tokensregex/PhraseTable.java</file_path><description>Remove Parameter phraseData : Object in method private addPhrase(phraseText String, tag String, wordList WordList, phraseData Object) : boolean from class edu.stanford.nlp.ling.tokensregex.PhraseTable</description><code_before>@@ -181,14 +181,9 @@ public boolean addPhrase(String phraseText)
   }
 
   public boolean addPhrase(String phraseText, String tag)
-  {
-    return addPhrase(phraseText, tag, null);
-  }
-
-  public boolean addPhrase(String phraseText, String tag, Object phraseData)
   {
     WordList wordList = toNormalizedWordList(phraseText);
-    return addPhrase(phraseText, tag, wordList, phraseData);
   }
 
   public boolean addPhrase(List&lt;String&gt; tokens)
@@ -197,23 +192,18 @@ public boolean addPhrase(List&lt;String&gt; tokens)
   }
 
   public boolean addPhrase(List&lt;String&gt; tokens, String tag)
-  {
-    return addPhrase(tokens, tag, null);
-  }
-
-  public boolean addPhrase(List&lt;String&gt; tokens, String tag, Object phraseData)
   {
     WordList wordList = new StringList(tokens);
-    return addPhrase(StringUtils.join(tokens, " "), tag, wordList, phraseData);
   }
 
   private int MAX_LIST_SIZE = 20;
-  private synchronized boolean addPhrase(String phraseText, String tag, WordList wordList, Object phraseData)
   {
     if (rootTree == null) {
       rootTree = new HashMap&lt;String,Object&gt;();
     }
-    return addPhrase(rootTree, phraseText, tag, wordList, phraseData, 0);
   }
 
   private synchronized void addPhrase(Map&lt;String,Object&gt; tree, Phrase phrase, int wordIndex)
@@ -238,8 +228,7 @@ private synchronized void addPhrase(Map&lt;String,Object&gt; tree, Phrase phrase, int
     }
   }
 
-  private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
-                                         String phraseText, String tag, WordList wordList, Object phraseData, int wordIndex)
   {
     // Find place to insert this item
     boolean phraseAdded = false;  // True if this phrase was successfully added to the phrase table
@@ -250,7 +239,7 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
       Object node = tree.get(word);
       if (node == null) {
         // insert here
-        Phrase phrase = new Phrase(wordList, phraseText, tag, phraseData);
         tree.put(word, phrase);
         phraseAdded = true;
         newPhraseAdded = true;
@@ -263,7 +252,7 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
           oldPhraseNewFormAdded = oldphrase.addForm(phraseText);
         } else {
           // create list with this phrase and other and put it here
-          Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);
           List list = new ArrayList(2);
           list.add(oldphrase);
           list.add(newphrase);
@@ -302,7 +291,7 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
         }
         if (!phraseAdded &amp;&amp; nMaps == 0) {
           // add to list
-          Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);
           lookupList.add(newphrase);
           newPhraseAdded = true;
           phraseAdded = true;
@@ -340,15 +329,15 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
             oldPhraseNewFormAdded = oldphrase.addForm(phraseText);
           } else {
             // create list with this phrase and other and put it here
-            Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);
             List list = new ArrayList(2);
             list.add(oldphrase);
             list.add(newphrase);
             tree.put(PHRASE_END, list);
             newPhraseAdded = true;
           }
         } else {
-          Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);
           tree.put(PHRASE_END, newphrase);
           newPhraseAdded = true;
         }
@@ -793,18 +782,16 @@ public static class Phrase
     WordList wordList;
     String text;
     String tag;
-    Object data; // additional data associated with the phrase
-
     // Alternate forms that can be used for lookup elsewhere
     private Set&lt;String&gt; alternateForms;
 
-    public Phrase(WordList wordList, String text, String tag, Object data) {
       this.wordList = wordList;
       this.text = text;
       this.tag = tag;
-      this.data = data;
     }
 
     public boolean isLonger(Phrase phrase)
     {
       return (this.getWordList().size() &gt; phrase.getWordList().size()
</code_before><code_after>@@ -181,14 +181,9 @@ public boolean addPhrase(String phraseText)
   }
 
   public boolean addPhrase(String phraseText, String tag)
   {
     WordList wordList = toNormalizedWordList(phraseText);
+    return addPhrase(phraseText, tag, wordList);
   }
 
   public boolean addPhrase(List&lt;String&gt; tokens)
@@ -197,23 +192,18 @@ public boolean addPhrase(List&lt;String&gt; tokens)
   }
 
   public boolean addPhrase(List&lt;String&gt; tokens, String tag)
   {
     WordList wordList = new StringList(tokens);
+    return addPhrase(StringUtils.join(tokens, " "), tag, wordList);
   }
 
   private int MAX_LIST_SIZE = 20;
+  private synchronized boolean addPhrase(String phraseText, String tag, WordList wordList)
   {
     if (rootTree == null) {
       rootTree = new HashMap&lt;String,Object&gt;();
     }
+    return addPhrase(rootTree, phraseText, tag, wordList, 0);
   }
 
   private synchronized void addPhrase(Map&lt;String,Object&gt; tree, Phrase phrase, int wordIndex)
@@ -238,8 +228,7 @@ private synchronized void addPhrase(Map&lt;String,Object&gt; tree, Phrase phrase, int
     }
   }
 
+  private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree, String phraseText, String tag, WordList wordList, int wordIndex)
   {
     // Find place to insert this item
     boolean phraseAdded = false;  // True if this phrase was successfully added to the phrase table
@@ -250,7 +239,7 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
       Object node = tree.get(word);
       if (node == null) {
         // insert here
+        Phrase phrase = new Phrase(wordList, phraseText, tag);
         tree.put(word, phrase);
         phraseAdded = true;
         newPhraseAdded = true;
@@ -263,7 +252,7 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
           oldPhraseNewFormAdded = oldphrase.addForm(phraseText);
         } else {
           // create list with this phrase and other and put it here
+          Phrase newphrase = new Phrase(wordList, phraseText, tag);
           List list = new ArrayList(2);
           list.add(oldphrase);
           list.add(newphrase);
@@ -302,7 +291,7 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
         }
         if (!phraseAdded &amp;&amp; nMaps == 0) {
           // add to list
+          Phrase newphrase = new Phrase(wordList, phraseText, tag);
           lookupList.add(newphrase);
           newPhraseAdded = true;
           phraseAdded = true;
@@ -340,15 +329,15 @@ private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
             oldPhraseNewFormAdded = oldphrase.addForm(phraseText);
           } else {
             // create list with this phrase and other and put it here
+            Phrase newphrase = new Phrase(wordList, phraseText, tag);
             List list = new ArrayList(2);
             list.add(oldphrase);
             list.add(newphrase);
             tree.put(PHRASE_END, list);
             newPhraseAdded = true;
           }
         } else {
+          Phrase newphrase = new Phrase(wordList, phraseText, tag);
           tree.put(PHRASE_END, newphrase);
           newPhraseAdded = true;
         }
@@ -793,18 +782,16 @@ public static class Phrase
     WordList wordList;
     String text;
     String tag;
     // Alternate forms that can be used for lookup elsewhere
     private Set&lt;String&gt; alternateForms;
 
+    public Phrase(WordList wordList, String text, String tag) {
       this.wordList = wordList;
       this.text = text;
       this.tag = tag;
     }
 
+
     public boolean isLonger(Phrase phrase)
     {
       return (this.getWordList().size() &gt; phrase.getWordList().size()
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>472886</refactoring_id><commit_sha>1817e75b5db7cbb8d2499994533dda49c2b497be</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/1817e75b5db7cbb8d2499994533dda49c2b497be</commit_link><file_path>src/main/java/vazkii/botania/common/block/decor/BlockManaFlame.java</file_path><description>Remove Parameter x : int in method public onBlockActivated(world World, x int, y int, z int, player EntityPlayer, s int, xs float, ys float, zs float) : boolean from class vazkii.botania.common.block.decor.BlockManaFlame</description><code_before>@@ -11,16 +11,18 @@
 package vazkii.botania.common.block.decor;
 
 import java.util.ArrayList;
 
 import net.minecraft.block.material.Material;
-import net.minecraft.client.renderer.texture.IIconRegister;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.AxisAlignedBB;
-import net.minecraft.util.IIcon;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
 import vazkii.botania.common.block.BlockModContainer;
@@ -48,13 +50,8 @@ public boolean registerInCreative() {
 
 	@Override
 	@Optional.Method(modid = "easycoloredlights")
-	public int getLightValue(IBlockAccess world, int x, int y, int z) {
-		return ((TileManaFlame) world.getTileEntity(x, y, z)).getLightColor();
-	}
-
-	@Override
-	public void registerBlockIcons(IIconRegister par1IconRegister) {
-		// NO-OP
 	}
 
 	@Override
@@ -68,22 +65,22 @@ public boolean isOpaqueCube() {
 	}
 
 	@Override
-	public boolean renderAsNormalBlock() {
 		return false;
 	}
 
 	@Override
-	public boolean getBlocksMovement(IBlockAccess p_149655_1_, int p_149655_2_, int p_149655_3_, int p_149655_4_) {
 		return true;
 	}
 
 	@Override
-	public AxisAlignedBB getCollisionBoundingBoxFromPool(World p_149668_1_, int p_149668_2_, int p_149668_3_, int p_149668_4_) {
 		return null;
 	}
 
 	@Override
-	public boolean onBlockActivated(World world, int x, int y, int z, EntityPlayer player, int s, float xs, float ys, float zs) {
 		if(WorldTypeSkyblock.isWorldSkyblock(world)) {
 			ItemStack stack = player.getCurrentEquippedItem();
 			if(stack != null &amp;&amp; stack.getItem() == Item.getItemFromBlock(Blocks.sapling) &amp;&amp; !player.inventory.hasItem(ModItems.lexicon)) {
@@ -99,12 +96,7 @@ public boolean onBlockActivated(World world, int x, int y, int z, EntityPlayer p
 	}
 
 	@Override
-	public IIcon getIcon(int side, int meta) {
-		return Blocks.fire.getIcon(side, meta);
-	}
-
-	@Override
-	public ArrayList&lt;ItemStack&gt; getDrops(World world, int x, int y, int z, int metadata, int fortune) {
 		return new ArrayList();
 	}
 
</code_before><code_after>@@ -11,16 +11,18 @@
 package vazkii.botania.common.block.decor;
 
 import java.util.ArrayList;
+import java.util.List;
 
 import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.AxisAlignedBB;
+import net.minecraft.util.BlockPos;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
 import vazkii.botania.common.block.BlockModContainer;
@@ -48,13 +50,8 @@ public boolean registerInCreative() {
 
 	@Override
 	@Optional.Method(modid = "easycoloredlights")
+	public int getLightValue(IBlockAccess world, BlockPos pos) {
+		return ((TileManaFlame) world.getTileEntity(pos)).getLightColor();
 	}
 
 	@Override
@@ -68,22 +65,22 @@ public boolean isOpaqueCube() {
 	}
 
 	@Override
+	public boolean isFullCube() {
 		return false;
 	}
 
 	@Override
+	public boolean isPassable(IBlockAccess p_149655_1_, BlockPos pos) {
 		return true;
 	}
 
 	@Override
+	public AxisAlignedBB getCollisionBoundingBox(World p_149668_1_, BlockPos pos, IBlockState state) {
 		return null;
 	}
 
 	@Override
+	public boolean onBlockActivated(World world, BlockPos pos, IBlockState state, EntityPlayer player, EnumFacing s, float xs, float ys, float zs) {
 		if(WorldTypeSkyblock.isWorldSkyblock(world)) {
 			ItemStack stack = player.getCurrentEquippedItem();
 			if(stack != null &amp;&amp; stack.getItem() == Item.getItemFromBlock(Blocks.sapling) &amp;&amp; !player.inventory.hasItem(ModItems.lexicon)) {
@@ -99,12 +96,7 @@ public boolean onBlockActivated(World world, int x, int y, int z, EntityPlayer p
 	}
 
 	@Override
+	public List&lt;ItemStack&gt; getDrops(IBlockAccess world, BlockPos pos, IBlockState state, int fortune) {
 		return new ArrayList();
 	}
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>523359</refactoring_id><commit_sha>b9926b8e3e0dc67dd54231425b0fa797efa878a0</commit_sha><commit_link>https://github.com/opensolon/solon/commit/b9926b8e3e0dc67dd54231425b0fa797efa878a0</commit_link><file_path>_extend/solon.cloud.tracing/src/main/java/org/noear/solon/cloud/tracing/integration/SpanSimulate.java</file_path><description>Remove Parameter fields : Map&lt;String,?&gt; in method public log(fields Map&lt;String,?&gt;) : Span from class org.noear.solon.cloud.tracing.integration.SpanSimulate</description><code_before>@@ -13,7 +13,11 @@
  * @since 1.7
  */
 public class SpanSimulate implements Span {
-    public static final Span instance = new SpanSimulate();
 
     @Override
     public SpanContext context() {
@@ -22,47 +26,47 @@ public SpanContext context() {
 
     @Override
     public Span setTag(String key, String value) {
-        return instance;
     }
 
     @Override
     public Span setTag(String key, boolean value) {
-        return instance;
     }
 
     @Override
     public Span setTag(String key, Number value) {
-        return instance;
     }
 
     @Override
     public &lt;T&gt; Span setTag(Tag&lt;T&gt; tag, T value) {
-        return instance;
     }
 
     @Override
     public Span log(Map&lt;String, ?&gt; fields) {
-        return instance;
     }
 
     @Override
     public Span log(long timestampMicroseconds, Map&lt;String, ?&gt; fields) {
-        return instance;
     }
 
     @Override
     public Span log(String event) {
-        return instance;
     }
 
     @Override
     public Span log(long timestampMicroseconds, String event) {
-        return instance;
     }
 
     @Override
     public Span setBaggageItem(String key, String value) {
-        return instance;
     }
 
     @Override
@@ -72,7 +76,7 @@ public String getBaggageItem(String key) {
 
     @Override
     public Span setOperationName(String operationName) {
-        return instance;
     }
 
     @Override
</code_before><code_after>@@ -13,7 +13,11 @@
  * @since 1.7
  */
 public class SpanSimulate implements Span {
+    private static final Span instance = new SpanSimulate();
+
+    public static Span getInstance() {
+        return instance;
+    }
 
     @Override
     public SpanContext context() {
@@ -22,47 +26,47 @@ public SpanContext context() {
 
     @Override
     public Span setTag(String key, String value) {
+        return this;
     }
 
     @Override
     public Span setTag(String key, boolean value) {
+        return this;
     }
 
     @Override
     public Span setTag(String key, Number value) {
+        return this;
     }
 
     @Override
     public &lt;T&gt; Span setTag(Tag&lt;T&gt; tag, T value) {
+        return this;
     }
 
     @Override
     public Span log(Map&lt;String, ?&gt; fields) {
+        return this;
     }
 
     @Override
     public Span log(long timestampMicroseconds, Map&lt;String, ?&gt; fields) {
+        return this;
     }
 
     @Override
     public Span log(String event) {
+        return this;
     }
 
     @Override
     public Span log(long timestampMicroseconds, String event) {
+        return this;
     }
 
     @Override
     public Span setBaggageItem(String key, String value) {
+        return this;
     }
 
     @Override
@@ -72,7 +76,7 @@ public String getBaggageItem(String key) {
 
     @Override
     public Span setOperationName(String operationName) {
+        return this;
     }
 
     @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>530751</refactoring_id><commit_sha>c221a2634b0d2f6b8f6e7d15c9e7632001668425</commit_sha><commit_link>https://github.com/apache/druid/commit/c221a2634b0d2f6b8f6e7d15c9e7632001668425</commit_link><file_path>processing/src/main/java/org/apache/druid/query/filter/StringPredicateDruidPredicateFactory.java</file_path><description>Remove Parameter isNullInputUnknown : boolean in method public of(predicate Predicate&lt;String&gt;, isNullInputUnknown boolean) : StringPredicateDruidPredicateFactory from class org.apache.druid.query.filter.StringPredicateDruidPredicateFactory</description><code_before>@@ -19,8 +19,6 @@
 
 package org.apache.druid.query.filter;
 
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import org.apache.druid.error.DruidException;
 
 import javax.annotation.Nullable;
@@ -30,26 +28,27 @@ public class StringPredicateDruidPredicateFactory implements DruidPredicateFacto
 {
   public static StringPredicateDruidPredicateFactory equalTo(@Nullable String value)
   {
-    return new StringPredicateDruidPredicateFactory(Predicates.equalTo(value), value != null);
   }
 
-  public static StringPredicateDruidPredicateFactory of(@Nullable Predicate&lt;String&gt; predicate, boolean isNullInputUnknown)
   {
-    return new StringPredicateDruidPredicateFactory(predicate, isNullInputUnknown);
   }
 
-  private final boolean isNullInputUnknown;
   @Nullable
-  private final Predicate&lt;String&gt; predicate;
 
-  public StringPredicateDruidPredicateFactory(Predicate&lt;String&gt; predicate, boolean isNullInputUnknown)
   {
     this.predicate = predicate;
-    this.isNullInputUnknown = isNullInputUnknown;
   }
 
   @Override
-  public Predicate&lt;String&gt; makeStringPredicate()
   {
     return predicate;
   }
@@ -72,12 +71,6 @@ public DruidDoublePredicate makeDoublePredicate()
     throw DruidException.defensive("String equality predicate factory only supports string predicates");
   }
 
-  @Override
-  public boolean isNullInputUnknown()
-  {
-    return isNullInputUnknown;
-  }
-
   @Override
   public boolean equals(Object o)
   {
@@ -88,12 +81,12 @@ public boolean equals(Object o)
       return false;
     }
     StringPredicateDruidPredicateFactory that = (StringPredicateDruidPredicateFactory) o;
-    return isNullInputUnknown == that.isNullInputUnknown &amp;&amp; Objects.equals(predicate, that.predicate);
   }
 
   @Override
   public int hashCode()
   {
-    return Objects.hash(isNullInputUnknown, predicate);
   }
 }
</code_before><code_after>@@ -19,8 +19,6 @@
 
 package org.apache.druid.query.filter;
 
 import org.apache.druid.error.DruidException;
 
 import javax.annotation.Nullable;
@@ -30,26 +28,27 @@ public class StringPredicateDruidPredicateFactory implements DruidPredicateFacto
 {
   public static StringPredicateDruidPredicateFactory equalTo(@Nullable String value)
   {
+    if (value == null) {
+      return new StringPredicateDruidPredicateFactory(DruidObjectPredicate.isNull());
+    }
+    return new StringPredicateDruidPredicateFactory(DruidObjectPredicate.equalTo(value));
   }
 
+  public static StringPredicateDruidPredicateFactory of(@Nullable DruidObjectPredicate&lt;String&gt; predicate)
   {
+    return new StringPredicateDruidPredicateFactory(predicate);
   }
 
   @Nullable
+  private final DruidObjectPredicate&lt;String&gt; predicate;
 
+  private StringPredicateDruidPredicateFactory(DruidObjectPredicate&lt;String&gt; predicate)
   {
     this.predicate = predicate;
   }
 
   @Override
+  public DruidObjectPredicate&lt;String&gt; makeStringPredicate()
   {
     return predicate;
   }
@@ -72,12 +71,6 @@ public DruidDoublePredicate makeDoublePredicate()
     throw DruidException.defensive("String equality predicate factory only supports string predicates");
   }
 
   @Override
   public boolean equals(Object o)
   {
@@ -88,12 +81,12 @@ public boolean equals(Object o)
       return false;
     }
     StringPredicateDruidPredicateFactory that = (StringPredicateDruidPredicateFactory) o;
+    return Objects.equals(predicate, that.predicate);
   }
 
   @Override
   public int hashCode()
   {
+    return Objects.hash(predicate);
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>520374</refactoring_id><commit_sha>3b1cd40f5288c5ac086145fdb03e9032c7a856b1</commit_sha><commit_link>https://github.com/jenkinsci/jenkins/commit/3b1cd40f5288c5ac086145fdb03e9032c7a856b1</commit_link><file_path>core/src/main/java/hudson/model/Hudson.java</file_path><description>Remove Parameter req : StaplerRequest in method public doGc(req StaplerRequest, rsp StaplerResponse) : void from class hudson.model.Hudson</description><code_before>@@ -1560,13 +1560,13 @@ public synchronized void doSubmitDescription( StaplerRequest req, StaplerRespons
         rsp.sendRedirect(".");
     }
 
-    public synchronized void doQuietDown( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
         checkPermission(ADMINISTER);
         isQuietingDown = true;
         rsp.sendRedirect2(".");
     }
 
-    public synchronized void doCancelQuietDown( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
         checkPermission(ADMINISTER);
         isQuietingDown = false;
         getQueue().scheduleMaintenance();
@@ -1576,7 +1576,7 @@ public synchronized void doCancelQuietDown( StaplerRequest req, StaplerResponse
     /**
      * Backward compatibility. Redirect to the thread dump.
      */
-    public void doClassicThreadDump( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
         rsp.sendRedirect2("threadDump");
     }
 
@@ -1965,7 +1965,7 @@ public void doNocacheImages( StaplerRequest req, StaplerResponse rsp ) throws IO
     /**
      * For debugging. Expose URL to perform GC.
      */
-    public void doGc( StaplerRequest req, StaplerResponse rsp ) throws IOException {
         System.gc();
         rsp.setStatus(HttpServletResponse.SC_OK);
         rsp.setContentType("text/plain");
@@ -2007,7 +2007,7 @@ public static Authentication getAuthentication() {
     /**
      * Configure the logging level.
      */
-    public void doConfigLogger( StaplerRequest req, StaplerResponse rsp, @QueryParameter("name") String name, @QueryParameter("level") String level) throws IOException {
         checkPermission(ADMINISTER);
         Level lv;
         if(level.equals("inherit"))
@@ -2061,14 +2061,14 @@ public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOExcep
         rsp.sendRedirect2(ref);
     }
 
-    public void doFingerprintCleanup( StaplerRequest req, StaplerResponse rsp ) throws IOException {
         FingerprintCleanupThread.invoke();
         rsp.setStatus(HttpServletResponse.SC_OK);
         rsp.setContentType("text/plain");
         rsp.getWriter().println("Invoked");
     }
 
-    public void doWorkspaceCleanup( StaplerRequest req, StaplerResponse rsp ) throws IOException {
         WorkspaceCleanupThread.invoke();
         rsp.setStatus(HttpServletResponse.SC_OK);
         rsp.setContentType("text/plain");
</code_before><code_after>@@ -1560,13 +1560,13 @@ public synchronized void doSubmitDescription( StaplerRequest req, StaplerRespons
         rsp.sendRedirect(".");
     }
 
+    public synchronized void doQuietDown(StaplerResponse rsp) throws IOException, ServletException {
         checkPermission(ADMINISTER);
         isQuietingDown = true;
         rsp.sendRedirect2(".");
     }
 
+    public synchronized void doCancelQuietDown(StaplerResponse rsp) throws IOException, ServletException {
         checkPermission(ADMINISTER);
         isQuietingDown = false;
         getQueue().scheduleMaintenance();
@@ -1576,7 +1576,7 @@ public synchronized void doCancelQuietDown( StaplerRequest req, StaplerResponse
     /**
      * Backward compatibility. Redirect to the thread dump.
      */
+    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {
         rsp.sendRedirect2("threadDump");
     }
 
@@ -1965,7 +1965,7 @@ public void doNocacheImages( StaplerRequest req, StaplerResponse rsp ) throws IO
     /**
      * For debugging. Expose URL to perform GC.
      */
+    public void doGc(StaplerResponse rsp) throws IOException {
         System.gc();
         rsp.setStatus(HttpServletResponse.SC_OK);
         rsp.setContentType("text/plain");
@@ -2007,7 +2007,7 @@ public static Authentication getAuthentication() {
     /**
      * Configure the logging level.
      */
+    public void doConfigLogger(StaplerResponse rsp, @QueryParameter("name")String name, @QueryParameter("level")String level) throws IOException {
         checkPermission(ADMINISTER);
         Level lv;
         if(level.equals("inherit"))
@@ -2061,14 +2061,14 @@ public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOExcep
         rsp.sendRedirect2(ref);
     }
 
+    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {
         FingerprintCleanupThread.invoke();
         rsp.setStatus(HttpServletResponse.SC_OK);
         rsp.setContentType("text/plain");
         rsp.getWriter().println("Invoked");
     }
 
+    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {
         WorkspaceCleanupThread.invoke();
         rsp.setStatus(HttpServletResponse.SC_OK);
         rsp.setContentType("text/plain");
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>514278</refactoring_id><commit_sha>a24d4c7c3f2e2255c6f344bf7d05b0c3f2ae1601</commit_sha><commit_link>https://github.com/camunda/camunda/commit/a24d4c7c3f2e2255c6f344bf7d05b0c3f2ae1601</commit_link><file_path>qa/data-generation/src/main/java/org/camunda/optimize/data/generation/DataGenerationMain.java</file_path><description>Remove Parameter args : String[] in method private extractDataGenerationInformation(args String[]) : DataGenerationInformation from class org.camunda.optimize.data.generation.DataGenerationMain</description><code_before>@@ -8,34 +8,50 @@
 import io.github.classgraph.ClassGraph;
 import io.github.classgraph.ClassInfoList;
 import io.github.classgraph.ScanResult;
-import lombok.AllArgsConstructor;
 import org.apache.commons.lang3.StringUtils;
 import org.camunda.optimize.data.generation.generators.DataGenerator;
 import org.camunda.optimize.data.generation.generators.dto.DataGenerationInformation;
 import org.camunda.optimize.data.generation.generators.impl.decision.DecisionDataGenerator;
 import org.camunda.optimize.data.generation.generators.impl.process.ProcessDataGenerator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.HashMap;
 import java.util.Map;
 
-@AllArgsConstructor
 public class DataGenerationMain {
-
-  private final Logger logger = LoggerFactory.getLogger(getClass());
 
   private final DataGenerationInformation dataGenerationInformation;
 
-  public static void main(String[] args) {
-    DataGenerationInformation dataGenerationInformation = extractDataGenerationInformation(args);
     DataGenerationMain main = new DataGenerationMain(dataGenerationInformation);
     main.generateData();
   }
 
-  private static DataGenerationInformation extractDataGenerationInformation(final String[] args) {
-    final Map&lt;String, String&gt; arguments = extractArguments(args);
-
     // argument is being adjusted
     long processInstanceCountToGenerate =
       Long.parseLong(arguments.get("numberOfProcessInstances"));
@@ -87,6 +103,20 @@ private static Map&lt;String, String&gt; extractArguments(final String[] args) {
     return arguments;
   }
 
   private static void ensureIdentifierIsKnown(Map&lt;String, String&gt; arguments, String identifier) {
     if (!arguments.containsKey(identifier)) {
       throw new RuntimeException("Unknown argument [" + identifier + "]!");
@@ -98,6 +128,12 @@ private static void fillArgumentMapWithDefaultValues(Map&lt;String, String&gt; argumen
     arguments.put("numberOfDecisionInstances", String.valueOf(10_000));
     arguments.put("engineRest", "http://localhost:8080/engine-rest");
     arguments.put("removeDeployments", "true");
     arguments.put("processDefinitions", getDefaultDefinitionsOfClass(ProcessDataGenerator.class));
     arguments.put("decisionDefinitions", getDefaultDefinitionsOfClass(DecisionDataGenerator.class));
   }
@@ -131,4 +167,11 @@ public void generateData() {
     dataGenerationExecutor.awaitDataGenerationTermination();
     logger.info("Finished data generation!");
   }
 }
</code_before><code_after>@@ -8,34 +8,50 @@
 import io.github.classgraph.ClassGraph;
 import io.github.classgraph.ClassInfoList;
 import io.github.classgraph.ScanResult;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
 import org.apache.commons.lang3.StringUtils;
+import org.camunda.optimize.data.generation.generators.DBConnector;
 import org.camunda.optimize.data.generation.generators.DataGenerator;
 import org.camunda.optimize.data.generation.generators.dto.DataGenerationInformation;
 import org.camunda.optimize.data.generation.generators.impl.decision.DecisionDataGenerator;
 import org.camunda.optimize.data.generation.generators.impl.process.ProcessDataGenerator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
 
+@Slf4j
+@RequiredArgsConstructor
 public class DataGenerationMain {
+  private static final Logger logger = LoggerFactory.getLogger(DataGenerationMain.class);
 
   private final DataGenerationInformation dataGenerationInformation;
 
+  private static final String DB_URL_H2_TEMPLATE = "jdbc:h2:tcp://localhost:9092/./camunda-h2-dbs/process-engine";
+  private static final String JDBC_DRIVER = "org.h2.Driver";
+  private static final String USER_H2 = "sa";
+  private static final String PASS_H2 = "sa";
+
+
+  public static void main(String[] args) throws ParseException {
+    final Map&lt;String, String&gt; arguments = extractArguments(args);
+    DataGenerationInformation dataGenerationInformation = extractDataGenerationInformation(arguments);
     DataGenerationMain main = new DataGenerationMain(dataGenerationInformation);
+    String startDate = arguments.get("startDate");
+    String endDate = arguments.get("endDate");
+    checkDateSprectrum(startDate, endDate);
     main.generateData();
+    String dbUser = "dbUser";
+    String dbUrl = arguments.get("dbUrl");
+    update(startDate, endDate, arguments.get("jdbcDriver"), arguments.get("dbUrl"), arguments.get("dbUser"), arguments.get("dbPassword"));
   }
 
+  private static DataGenerationInformation extractDataGenerationInformation(Map&lt;String, String&gt; arguments) {
     // argument is being adjusted
     long processInstanceCountToGenerate =
       Long.parseLong(arguments.get("numberOfProcessInstances"));
@@ -87,6 +103,20 @@ private static Map&lt;String, String&gt; extractArguments(final String[] args) {
     return arguments;
   }
 
+  public static void checkDateSprectrum(String startDate, String endDate) throws ParseException {
+    SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
+    try {
+      Date startDateObject = format.parse(startDate);
+      Date endDateObject = format.parse(endDate);
+
+      if (startDateObject.compareTo(endDateObject) &gt;= 0) {
+        throw new IllegalArgumentException("startDate argument cannot be greater than endDate");
+      }
+    } catch (ParseException e) {
+      throw new ParseException("There was an error while parsing the dates", e.getErrorOffset());
+    }
+  }
+
   private static void ensureIdentifierIsKnown(Map&lt;String, String&gt; arguments, String identifier) {
     if (!arguments.containsKey(identifier)) {
       throw new RuntimeException("Unknown argument [" + identifier + "]!");
@@ -98,6 +128,12 @@ private static void fillArgumentMapWithDefaultValues(Map&lt;String, String&gt; argumen
     arguments.put("numberOfDecisionInstances", String.valueOf(10_000));
     arguments.put("engineRest", "http://localhost:8080/engine-rest");
     arguments.put("removeDeployments", "true");
+    arguments.put("startDate", "01/01/2018");
+    arguments.put("endDate", "01/01/2020");
+    arguments.put("jdbcDriver", JDBC_DRIVER);
+    arguments.put("dbUrl", DB_URL_H2_TEMPLATE);
+    arguments.put("dbUser", USER_H2);
+    arguments.put("dbPassword", PASS_H2);
     arguments.put("processDefinitions", getDefaultDefinitionsOfClass(ProcessDataGenerator.class));
     arguments.put("decisionDefinitions", getDefaultDefinitionsOfClass(DecisionDataGenerator.class));
   }
@@ -131,4 +167,11 @@ public void generateData() {
     dataGenerationExecutor.awaitDataGenerationTermination();
     logger.info("Finished data generation!");
   }
+
+  public static void update(String startDate, String endDate, String driver, String url, String user,
+                            String userPassword) {
+    DBConnector dbConnector = new DBConnector(driver, url, user, userPassword);
+    dbConnector.updateProcessInstances(startDate, endDate);
+    logger.info("Updated endDate and startDate of process instances in db!");
+  }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>532975</refactoring_id><commit_sha>b2f79d2e9f1c0a2c6e7053987c36f505754b62df</commit_sha><commit_link>https://github.com/apache/tomcat/commit/b2f79d2e9f1c0a2c6e7053987c36f505754b62df</commit_link><file_path>java/org/apache/coyote/ajp/AjpProcessor.java</file_path><description>Remove Parameter endpoint : AbstractEndpoint&lt;?,?&gt; in method public AjpProcessor(packetSize int, endpoint AbstractEndpoint&lt;?,?&gt;) from class org.apache.coyote.ajp.AjpProcessor</description><code_before>@@ -41,7 +41,6 @@
 import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.MimeHeaders;
-import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.ApplicationBufferHandler;
 import org.apache.tomcat.util.net.SSLSupport;
@@ -243,10 +242,11 @@ public class AjpProcessor extends AbstractProcessor {
 
     // ------------------------------------------------------------ Constructor
 
-    public AjpProcessor(int packetSize, AbstractEndpoint&lt;?,?&gt; endpoint) {
 
-        super(endpoint);
 
         // Calculate maximum chunk size as packetSize may have been changed from
         // the default (Constants.MAX_PACKET_SIZE)
         this.outputMaxChunkSize =
</code_before><code_after>@@ -41,7 +41,6 @@
 import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.ApplicationBufferHandler;
 import org.apache.tomcat.util.net.SSLSupport;
@@ -243,10 +242,11 @@ public class AjpProcessor extends AbstractProcessor {
 
     // ------------------------------------------------------------ Constructor
 
+    public AjpProcessor(AbstractAjpProtocol&lt;?&gt; protocol) {
 
+        super(protocol);
 
+        int packetSize = protocol.getPacketSize();
         // Calculate maximum chunk size as packetSize may have been changed from
         // the default (Constants.MAX_PACKET_SIZE)
         this.outputMaxChunkSize =
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>475507</refactoring_id><commit_sha>cd591b9f9e01327ff31bc86622105c940d4d8609</commit_sha><commit_link>https://github.com/bisq-network/bisq/commit/cd591b9f9e01327ff31bc86622105c940d4d8609</commit_link><file_path>core/src/main/java/io/bisq/core/dao/blockchain/BsqBlockchainService.java</file_path><description>Remove Parameter bsqUTXOMap : BsqUTXOMap in method package abstract syncFromGenesisCompete(bsqUTXOMap BsqUTXOMap, bsqTXOMap BsqTXOMap, genesisTxId String, genesisBlockHeight int, onNewBlockHandler Consumer&lt;Block&gt;) : void from class io.bisq.core.dao.blockchain.BsqBlockchainService</description><code_before>@@ -27,18 +27,17 @@
 import io.bisq.common.handlers.ErrorMessageHandler;
 import io.bisq.common.handlers.ResultHandler;
 import io.bisq.common.util.Profiler;
-import io.bisq.common.util.Tuple2;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.util.*;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
 abstract public class BsqBlockchainService {
-    private static final Logger log = LoggerFactory.getLogger(BsqBlockchainService.class);
 
 
     ///////////////////////////////////////////////////////////////////////////////////////////
@@ -56,9 +55,13 @@ public BsqBlockchainService() {
 
     abstract void setup(ResultHandler resultHandler, ErrorMessageHandler errorMessageHandler);
 
-    abstract ListenableFuture&lt;Tuple2&lt;BsqUTXOMap, Integer&gt;&gt; syncFromGenesis(BsqUTXOMap bsqUTXOMap, BsqTXOMap bsqTXOMap, int genesisBlockHeight, String genesisTxId);
 
-    abstract void syncFromGenesisCompete(BsqUTXOMap bsqUTXOMap, BsqTXOMap bsqTXOMap, String genesisTxId, int genesisBlockHeight, Consumer&lt;Block&gt; onNewBlockHandler);
 
     abstract int requestChainHeadHeight() throws BitcoindException, CommunicationException;
 
@@ -67,15 +70,16 @@ public BsqBlockchainService() {
     abstract Tx requestTransaction(String txId) throws BsqBlockchainException;
 
     @VisibleForTesting
-    BsqUTXOMap parseAllBlocksFromGenesis(BsqUTXOMap bsqUTXOMap,
-                                         BsqTXOMap bsqTXOMap,
-                                         int chainHeadHeight,
-                                         int genesisBlockHeight,
-                                         String genesisTxId) throws BsqBlockchainException {
         try {
             log.info("chainHeadHeight=" + chainHeadHeight);
             long startTotalTs = System.currentTimeMillis();
-            for (int height = genesisBlockHeight; height &lt;= chainHeadHeight; height++) {
                 long startBlockTs = System.currentTimeMillis();
                 Block btcdBlock = requestBlock(height);
                 log.info("Current block height=" + height);
@@ -97,11 +101,10 @@ BsqUTXOMap parseAllBlocksFromGenesis(BsqUTXOMap bsqUTXOMap,
                         height,
                         (System.currentTimeMillis() - startBlockTs),
                         (System.currentTimeMillis() - startTotalTs),
-                        (height - genesisBlockHeight));
                 Profiler.printSystemLoad(log);
             }
             log.info("Parsing for all blocks since genesis took {} ms", System.currentTimeMillis() - startTotalTs);
-            return bsqUTXOMap;
         } catch (Throwable t) {
             log.error(t.toString());
             t.printStackTrace();
@@ -141,6 +144,17 @@ void parseBlock(BsqBlock block,
         // Min tx size is 189 bytes (normally about 240 bytes), 1 MB can contain max. about 5300 txs (usually 2000).
         // Realistically we don't expect more then a few recursive calls.
         updateBsqUtxoMapFromBlock(txByTxIdMap.values(), bsqUTXOMap, bsqTXOMap, blockHeight, 0, 5300);
     }
 
     // Recursive method
@@ -238,7 +252,6 @@ private boolean updateBsqUtxoMapFromTx(Tx tx,
                 availableValue = availableValue + bsqUTXO.getValue();
 
                 bsqUTXOMap.removeByTuple(spendingTxId, spendingTxOutputIndex);
-                bsqUTXOMap.setLastBlockHeight(blockHeight);
                 utxoChanged = true;
 
                 if (bsqUTXOMap.isEmpty())
@@ -263,10 +276,8 @@ private boolean updateBsqUtxoMapFromTx(Tx tx,
                     }
                     // We are spending available tokens
                     bsqUTXOMap.add(new BsqUTXO(txOutput, blockHeight, false));
-                    bsqUTXOMap.setLastBlockHeight(blockHeight);
                     bsqTXOMap.add(txOutput);
-                    bsqTXOMap.setLastBlockHeight(blockHeight);
-                    
                     if (availableValue == 0) {
                         log.debug("We don't have anymore BSQ to spend");
                         break;
@@ -312,9 +323,7 @@ void parseGenesisTx(Tx tx,
                     throw new RuntimeException(msg);
             }
             bsqUTXOMap.add(new BsqUTXO(txOutput, blockHeight, true));
-            bsqUTXOMap.setLastBlockHeight(blockHeight);
             bsqTXOMap.add(txOutput);
-            bsqTXOMap.setLastBlockHeight(blockHeight);
         }
         checkArgument(!bsqUTXOMap.isEmpty(), "Genesis tx need to have BSQ utxo when parsing genesis block");
     }
</code_before><code_after>@@ -27,18 +27,17 @@
 import io.bisq.common.handlers.ErrorMessageHandler;
 import io.bisq.common.handlers.ResultHandler;
 import io.bisq.common.util.Profiler;
+import lombok.extern.slf4j.Slf4j;
 
 import java.util.*;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
+@Slf4j
 abstract public class BsqBlockchainService {
+    private int snapshotHeight;
 
 
     ///////////////////////////////////////////////////////////////////////////////////////////
@@ -56,9 +55,13 @@ public BsqBlockchainService() {
 
     abstract void setup(ResultHandler resultHandler, ErrorMessageHandler errorMessageHandler);
 
+    abstract ListenableFuture&lt;Integer&gt; executeParseBlockchain(BsqUTXOMap bsqUTXOMap,
+                                                              BsqTXOMap bsqTXOMap,
+                                                              int startBlockHeight,
+                                                              int genesisBlockHeight,
+                                                              String genesisTxId);
 
+    abstract void parseBlockchainCompete(Consumer&lt;Block&gt; onNewBlockHandler);
 
     abstract int requestChainHeadHeight() throws BitcoindException, CommunicationException;
 
@@ -67,15 +70,16 @@ public BsqBlockchainService() {
     abstract Tx requestTransaction(String txId) throws BsqBlockchainException;
 
     @VisibleForTesting
+    void parseBlockchain(BsqUTXOMap bsqUTXOMap,
+                         BsqTXOMap bsqTXOMap,
+                         int chainHeadHeight,
+                         int startBlockHeight,
+                         int genesisBlockHeight,
+                         String genesisTxId) throws BsqBlockchainException {
         try {
             log.info("chainHeadHeight=" + chainHeadHeight);
             long startTotalTs = System.currentTimeMillis();
+            for (int height = startBlockHeight; height &lt;= chainHeadHeight; height++) {
                 long startBlockTs = System.currentTimeMillis();
                 Block btcdBlock = requestBlock(height);
                 log.info("Current block height=" + height);
@@ -97,11 +101,10 @@ BsqUTXOMap parseAllBlocksFromGenesis(BsqUTXOMap bsqUTXOMap,
                         height,
                         (System.currentTimeMillis() - startBlockTs),
                         (System.currentTimeMillis() - startTotalTs),
+                        (height - startBlockHeight + 1));
                 Profiler.printSystemLoad(log);
             }
             log.info("Parsing for all blocks since genesis took {} ms", System.currentTimeMillis() - startTotalTs);
         } catch (Throwable t) {
             log.error(t.toString());
             t.printStackTrace();
@@ -141,6 +144,17 @@ void parseBlock(BsqBlock block,
         // Min tx size is 189 bytes (normally about 240 bytes), 1 MB can contain max. about 5300 txs (usually 2000).
         // Realistically we don't expect more then a few recursive calls.
         updateBsqUtxoMapFromBlock(txByTxIdMap.values(), bsqUTXOMap, bsqTXOMap, blockHeight, 0, 5300);
+
+        int trigger = BsqBlockchainManager.getSnapshotTrigger();
+        if (blockHeight % trigger == 0 &amp;&amp; blockHeight &gt; snapshotHeight - trigger) {
+            snapshotHeight = blockHeight - trigger;
+            log.info("We reached a new snapshot trigger at height {}. New snapshotHeight is {}",
+                    blockHeight, snapshotHeight);
+            bsqUTXOMap.setSnapshotHeight(snapshotHeight);
+            bsqUTXOMap.persist();
+            bsqTXOMap.setSnapshotHeight(snapshotHeight);
+            bsqTXOMap.persist();
+        }
     }
 
     // Recursive method
@@ -238,7 +252,6 @@ private boolean updateBsqUtxoMapFromTx(Tx tx,
                 availableValue = availableValue + bsqUTXO.getValue();
 
                 bsqUTXOMap.removeByTuple(spendingTxId, spendingTxOutputIndex);
                 utxoChanged = true;
 
                 if (bsqUTXOMap.isEmpty())
@@ -263,10 +276,8 @@ private boolean updateBsqUtxoMapFromTx(Tx tx,
                     }
                     // We are spending available tokens
                     bsqUTXOMap.add(new BsqUTXO(txOutput, blockHeight, false));
                     bsqTXOMap.add(txOutput);
+
                     if (availableValue == 0) {
                         log.debug("We don't have anymore BSQ to spend");
                         break;
@@ -312,9 +323,7 @@ void parseGenesisTx(Tx tx,
                     throw new RuntimeException(msg);
             }
             bsqUTXOMap.add(new BsqUTXO(txOutput, blockHeight, true));
             bsqTXOMap.add(txOutput);
         }
         checkArgument(!bsqUTXOMap.isEmpty(), "Genesis tx need to have BSQ utxo when parsing genesis block");
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>491817</refactoring_id><commit_sha>502dc6b4e1fdf31633fca076c04c790c6ea22fbb</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/502dc6b4e1fdf31633fca076c04c790c6ea22fbb</commit_link><file_path>community/server/src/main/java/org/neo4j/server/modules/WebAdminModule.java</file_path><description>Remove Parameter neoServer : NeoServerWithEmbeddedWebServer in method public start(neoServer NeoServerWithEmbeddedWebServer, logger StringLogger) : void from class org.neo4j.server.modules.WebAdminModule</description><code_before>@@ -19,12 +19,15 @@
  */
 package org.neo4j.server.modules;
 
 import org.neo4j.kernel.impl.util.StringLogger;
-import org.neo4j.server.NeoServerWithEmbeddedWebServer;
 import org.neo4j.server.RoundRobinJobScheduler;
 import org.neo4j.server.database.Database;
 import org.neo4j.server.logging.Logger;
 import org.neo4j.server.rrd.RrdFactory;
 import org.rrd4j.core.RrdDb;
 
 public class WebAdminModule implements ServerModule
@@ -36,33 +39,47 @@ public class WebAdminModule implements ServerModule
 
     private final RoundRobinJobScheduler jobScheduler = new RoundRobinJobScheduler();
 
-    public void start( NeoServerWithEmbeddedWebServer neoServer, StringLogger logger )
     {
-        try
-        {
-            startRoundRobinDB( neoServer );
-        }
-        catch ( RuntimeException e )
-        {
-            log.error( e );
-            return;
-        }
-        neoServer.getWebServer()
-                .addStaticContent( DEFAULT_WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, DEFAULT_WEB_ADMIN_PATH );
         log.info( "Mounted webadmin at [%s]", DEFAULT_WEB_ADMIN_PATH );
         if ( logger != null ) logger.logMessage( "Mounted webadmin at: " + DEFAULT_WEB_ADMIN_PATH );
     }
 
-    public void stop()
     {
-        jobScheduler.stopJobs();
     }
 
-    private void startRoundRobinDB( NeoServerWithEmbeddedWebServer neoServer )
     {
-        Database db = neoServer.getDatabase();
-        RrdFactory rrdFactory = new RrdFactory( neoServer.getConfiguration() );
-        RrdDb rrdDb = rrdFactory.createRrdDbAndSampler( db, jobScheduler );
-        db.setRrdDb( rrdDb );
     }
 }
</code_before><code_after>@@ -19,12 +19,15 @@
  */
 package org.neo4j.server.modules;
 
+import java.io.IOException;
+
+import org.apache.commons.configuration.Configuration;
 import org.neo4j.kernel.impl.util.StringLogger;
 import org.neo4j.server.RoundRobinJobScheduler;
 import org.neo4j.server.database.Database;
 import org.neo4j.server.logging.Logger;
 import org.neo4j.server.rrd.RrdFactory;
+import org.neo4j.server.web.WebServer;
 import org.rrd4j.core.RrdDb;
 
 public class WebAdminModule implements ServerModule
@@ -36,33 +39,47 @@ public class WebAdminModule implements ServerModule
 
     private final RoundRobinJobScheduler jobScheduler = new RoundRobinJobScheduler();
 
+	private final Configuration config;
+	private final WebServer webServer;
+	private final Database database;
+
+	private RrdDb rrdDb;
+
+    public WebAdminModule(WebServer webServer, Configuration config, Database database)
+    {
+    	this.webServer = webServer;
+    	this.config = config;
+    	this.database = database;
+    }
+    
+    @Override
+	public void start(StringLogger logger)
     {
+        startRoundRobinDB( );
+        webServer.addStaticContent( DEFAULT_WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, DEFAULT_WEB_ADMIN_PATH );
         log.info( "Mounted webadmin at [%s]", DEFAULT_WEB_ADMIN_PATH );
         if ( logger != null ) logger.logMessage( "Mounted webadmin at: " + DEFAULT_WEB_ADMIN_PATH );
     }
 
+    @Override
+	public void stop()
     {
+    	jobScheduler.stopJobs();
+    	webServer.removeStaticContent( DEFAULT_WEB_ADMIN_STATIC_WEB_CONTENT_LOCATION, DEFAULT_WEB_ADMIN_PATH );
+        try {
+        	if(rrdDb != null)
+        	{
+        		this.rrdDb.close();
+        	}
+		} catch (IOException e) {
+			throw new RuntimeException(e);
+		}
     }
 
+    private void startRoundRobinDB( )
     {
+        RrdFactory rrdFactory = new RrdFactory( config );
+        this.rrdDb = rrdFactory.createRrdDbAndSampler( database, jobScheduler );
+        database.setRrdDb( rrdDb );
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>520434</refactoring_id><commit_sha>a3d099b6528234e630a4c9225e96c2333e5de13a</commit_sha><commit_link>https://github.com/jenkinsci/jenkins/commit/a3d099b6528234e630a4c9225e96c2333e5de13a</commit_link><file_path>test/src/test/java/hudson/maven/MavenMultiModuleTest.java</file_path><description>Remove Parameter build : Run&lt;?,?&gt; in method public archive(build Run&lt;?,?&gt;, workspace FilePath, launcher Launcher, listener BuildListener, artifacts Map&lt;String,String&gt;) : void from class hudson.maven.MavenMultiModuleTest.TestAM</description><code_before>@@ -31,6 +31,8 @@
 import jenkins.model.ArtifactManager;
 import java.util.Set;
 import java.util.TreeSet;
 import static org.junit.Assert.*;
 import org.junit.Assume;
 import org.junit.Ignore;
@@ -472,10 +474,8 @@ else if (parentModuleName.equals("org.jvnet.hudson.main.test.multimod.incr:modul
     }
 
     @Bug(17236)
-    @SuppressWarnings("deprecation") // ExtensionList.add useful during tests
     @Test public void artifactArchiving() throws Exception {
-        TestAM am = new TestAM();
-        ArtifactManager.all().add(am);
         j.configureDefaultMaven(); // using Maven 2 so we can test single-module builds
         MavenModuleSet mms = j.createMavenProject();
         mms.setScm(new ExtractResourceSCM(getClass().getResource("maven-multimod.zip")));
@@ -492,24 +492,36 @@ else if (parentModuleName.equals("org.jvnet.hudson.main.test.multimod.incr:modul
             m.put("org.jvnet.hudson.main.test.multimod/" + module + "/1.0-SNAPSHOT/" + module + "-1.0-SNAPSHOT.jar", ws.child("target/" + module + "-1.0-SNAPSHOT.jar"));
             expected.put("org.jvnet.hudson.main.test.multimod:" + module, m);
         }
-        assertEquals(expected.toString(), am.archivings.toString()); // easy to read
-        assertEquals(expected, am.archivings); // compares also FileChannel
         // Also check single-module build.
         expected.clear();
-        am.archivings.clear();
         MavenBuild isolated = j.buildAndAssertSuccess(mms.getModule("org.jvnet.hudson.main.test.multimod$moduleA"));
         assertEquals(2, isolated.number);
         Map&lt;String,FilePath&gt; m = new TreeMap&lt;String,FilePath&gt;();
         ws = isolated.getWorkspace();
         m.put("org.jvnet.hudson.main.test.multimod/moduleA/1.0-SNAPSHOT/moduleA-1.0-SNAPSHOT.pom", ws.child("pom.xml"));
         m.put("org.jvnet.hudson.main.test.multimod/moduleA/1.0-SNAPSHOT/moduleA-1.0-SNAPSHOT.jar", ws.child("target/moduleA-1.0-SNAPSHOT.jar"));
         expected.put("org.jvnet.hudson.main.test.multimod:moduleA", m);
-        assertEquals(expected, am.archivings);
     }
 
     public static final class TestAM extends ArtifactManager {
-        final Map&lt;/* module name */String,Map&lt;/* archive path */String,/* file in workspace */FilePath&gt;&gt; archivings = new TreeMap&lt;String,Map&lt;String,FilePath&gt;&gt;();
-        @Override public void archive(Run&lt;?,?&gt; build, FilePath workspace, Launcher launcher, BuildListener listener, Map&lt;String,String&gt; artifacts) throws IOException, InterruptedException {
             String name = build.getParent().getName();
             if (archivings.containsKey(name)) {
                 // Would be legitimate only if some archived files for a given module were outside workspace, such as repository parent POM, *and* others were inside, which is not the case in this test.
@@ -530,16 +542,16 @@ public static final class TestAM extends ArtifactManager {
             }
             archivings.put(name, m);
         }
-        @Override public boolean deleteArtifacts(Run&lt;?,?&gt; build) throws IOException, InterruptedException {
             throw new IOException();
         }
-        @Override public Object browseArtifacts(Run&lt;?,?&gt; build) {
             throw new UnsupportedOperationException();
         }
-        @Override public &lt;JobT extends Job&lt;JobT,RunT&gt;,RunT extends Run&lt;JobT,RunT&gt;&gt; Run&lt;JobT,RunT&gt;.ArtifactList getArtifactsUpTo(Run&lt;JobT,RunT&gt; build, int n) {
             throw new UnsupportedOperationException();
         }
-        @Override public InputStream loadArtifact(Run&lt;?,?&gt; build, String artifact) throws IOException {
             throw new IOException();
         }
     }
</code_before><code_after>@@ -31,6 +31,8 @@
 import jenkins.model.ArtifactManager;
 import java.util.Set;
 import java.util.TreeSet;
+import jenkins.model.ArtifactManagerConfiguration;
+import jenkins.model.ArtifactManagerFactory;
 import static org.junit.Assert.*;
 import org.junit.Assume;
 import org.junit.Ignore;
@@ -472,10 +474,8 @@ else if (parentModuleName.equals("org.jvnet.hudson.main.test.multimod.incr:modul
     }
 
     @Bug(17236)
     @Test public void artifactArchiving() throws Exception {
+        ArtifactManagerConfiguration.get().getArtifactManagerFactories().add(new TestAMF());
         j.configureDefaultMaven(); // using Maven 2 so we can test single-module builds
         MavenModuleSet mms = j.createMavenProject();
         mms.setScm(new ExtractResourceSCM(getClass().getResource("maven-multimod.zip")));
@@ -492,24 +492,36 @@ else if (parentModuleName.equals("org.jvnet.hudson.main.test.multimod.incr:modul
             m.put("org.jvnet.hudson.main.test.multimod/" + module + "/1.0-SNAPSHOT/" + module + "-1.0-SNAPSHOT.jar", ws.child("target/" + module + "-1.0-SNAPSHOT.jar"));
             expected.put("org.jvnet.hudson.main.test.multimod:" + module, m);
         }
+        assertEquals(expected.toString(), TestAM.archivings.toString()); // easy to read
+        assertEquals(expected, TestAM.archivings); // compares also FileChannel
         // Also check single-module build.
         expected.clear();
+        TestAM.archivings.clear();
         MavenBuild isolated = j.buildAndAssertSuccess(mms.getModule("org.jvnet.hudson.main.test.multimod$moduleA"));
         assertEquals(2, isolated.number);
         Map&lt;String,FilePath&gt; m = new TreeMap&lt;String,FilePath&gt;();
         ws = isolated.getWorkspace();
         m.put("org.jvnet.hudson.main.test.multimod/moduleA/1.0-SNAPSHOT/moduleA-1.0-SNAPSHOT.pom", ws.child("pom.xml"));
         m.put("org.jvnet.hudson.main.test.multimod/moduleA/1.0-SNAPSHOT/moduleA-1.0-SNAPSHOT.jar", ws.child("target/moduleA-1.0-SNAPSHOT.jar"));
         expected.put("org.jvnet.hudson.main.test.multimod:moduleA", m);
+        assertEquals(expected, TestAM.archivings);
     }
 
+    public static final class TestAMF extends ArtifactManagerFactory {
+        @Override public ArtifactManager managerFor(Run&lt;?,?&gt; build) {
+            return new TestAM(build);
+        }
+    }
     public static final class TestAM extends ArtifactManager {
+        static final Map&lt;/* module name */String,Map&lt;/* archive path */String,/* file in workspace */FilePath&gt;&gt; archivings = new TreeMap&lt;String,Map&lt;String,FilePath&gt;&gt;();
+        transient Run&lt;?,?&gt; build;
+        TestAM(Run&lt;?,?&gt; build) {
+            onLoad(build);
+        }
+        @Override public void onLoad(Run&lt;?, ?&gt; build) {
+            this.build = build;
+        }
+        @Override public void archive(FilePath workspace, Launcher launcher, BuildListener listener, Map&lt;String,String&gt; artifacts) throws IOException, InterruptedException {
             String name = build.getParent().getName();
             if (archivings.containsKey(name)) {
                 // Would be legitimate only if some archived files for a given module were outside workspace, such as repository parent POM, *and* others were inside, which is not the case in this test.
@@ -530,16 +542,16 @@ public static final class TestAM extends ArtifactManager {
             }
             archivings.put(name, m);
         }
+        @Override public boolean deleteArtifacts() throws IOException, InterruptedException {
             throw new IOException();
         }
+        @Override public Object browseArtifacts() {
             throw new UnsupportedOperationException();
         }
+        @Override public Run.ArtifactList getArtifactsUpTo(int n) {
             throw new UnsupportedOperationException();
         }
+        @Override public InputStream loadArtifact(String artifact) throws IOException {
             throw new IOException();
         }
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>532876</refactoring_id><commit_sha>454884791529c959c2a7e2a489d7659dad1155c6</commit_sha><commit_link>https://github.com/apache/tomcat/commit/454884791529c959c2a7e2a489d7659dad1155c6</commit_link><file_path>java/org/apache/tomcat/util/bcel/classfile/AnnotationEntry.java</file_path><description>Remove Parameter isRuntimeVisible : boolean in method public AnnotationEntry(type_index int, constant_pool ConstantPool, isRuntimeVisible boolean) from class org.apache.tomcat.util.bcel.classfile.AnnotationEntry</description><code_before>@@ -39,7 +39,6 @@ public class AnnotationEntry implements Constants, Serializable {
     
     private int type_index;
     private ConstantPool constant_pool;
-    private boolean isRuntimeVisible;
 
     private List element_value_pairs;
     
@@ -51,9 +50,9 @@ public class AnnotationEntry implements Constants, Serializable {
      * @param isRuntimeVisible
      * @throws IOException
      */
-    public static AnnotationEntry read(DataInputStream file, ConstantPool constant_pool, boolean isRuntimeVisible) throws IOException {
         
-        final AnnotationEntry annotationEntry = new AnnotationEntry(file.readUnsignedShort(), constant_pool, isRuntimeVisible);
         final int num_element_value_pairs = (file.readUnsignedShort());
         annotationEntry.element_value_pairs = new ArrayList();
         for (int i = 0; i &lt; num_element_value_pairs; i++) {
@@ -63,10 +62,9 @@ public static AnnotationEntry read(DataInputStream file, ConstantPool constant_p
         return annotationEntry;
     }
 
-    public AnnotationEntry(int type_index, ConstantPool constant_pool, boolean isRuntimeVisible) {
         this.type_index = type_index;
         this.constant_pool = constant_pool;
-        this.isRuntimeVisible = isRuntimeVisible;
     }
     
     /**
</code_before><code_after>@@ -39,7 +39,6 @@ public class AnnotationEntry implements Constants, Serializable {
     
     private int type_index;
     private ConstantPool constant_pool;
 
     private List element_value_pairs;
     
@@ -51,9 +50,9 @@ public class AnnotationEntry implements Constants, Serializable {
      * @param isRuntimeVisible
      * @throws IOException
      */
+    public static AnnotationEntry read(DataInputStream file, ConstantPool constant_pool) throws IOException {
         
+        final AnnotationEntry annotationEntry = new AnnotationEntry(file.readUnsignedShort(), constant_pool);
         final int num_element_value_pairs = (file.readUnsignedShort());
         annotationEntry.element_value_pairs = new ArrayList();
         for (int i = 0; i &lt; num_element_value_pairs; i++) {
@@ -63,10 +62,9 @@ public static AnnotationEntry read(DataInputStream file, ConstantPool constant_p
         return annotationEntry;
     }
 
+    public AnnotationEntry(int type_index, ConstantPool constant_pool) {
         this.type_index = type_index;
         this.constant_pool = constant_pool;
     }
     
     /**
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>535102</refactoring_id><commit_sha>79b310bc207ea01d14bff2881fc0c133ac5e5c03</commit_sha><commit_link>https://github.com/rstudio/rstudio/commit/79b310bc207ea01d14bff2881fc0c133ac5e5c03</commit_link><file_path>src/gwt/src/org/rstudio/studio/client/common/reditor/EditorLanguage.java</file_path><description>Remove Parameter parserIndex : int in method public EditorLanguage(parserIndex int, parserName String, useRCompletion boolean) from class org.rstudio.studio.client.common.reditor.EditorLanguage</description><code_before>@@ -12,10 +12,6 @@
  */
 package org.rstudio.studio.client.common.reditor;
 
-import com.google.gwt.core.client.JavaScriptObject;
-import com.google.gwt.core.client.JsArrayString;
-import org.rstudio.studio.client.common.reditor.resources.REditorResources;
-
 /**
  * Models a language for CodeMirror.
  *
@@ -31,59 +27,32 @@
  */
 public class EditorLanguage
 {
-   public static final String STYLES_URL =
-         REditorResources.INSTANCE.colors().getUrl();
-
-   // All possible parser URLs we might want to use must be listed here.
-   // CodeMirror must have access to them all at startup or else it won't
-   // be able to dynamically switch between them.
-   private static final String[] ALL_PARSER_URLS = {
-         REditorResources.INSTANCE.parser_r().getUrl(),
-         REditorResources.INSTANCE.parser_latex().getUrl(),
-         REditorResources.INSTANCE.parser_sweave().getUrl(),
-         REditorResources.INSTANCE.parser_dummy().getUrl(),
-   };
-
    public static final EditorLanguage LANG_R = new EditorLanguage(
-         0, "mode/r", true);
    public static final EditorLanguage LANG_TEX = new EditorLanguage(
-         1, "mode/tex", false);
    public static final EditorLanguage LANG_SWEAVE = new EditorLanguage(
-         2, "mode/sweave", true);
    public static final EditorLanguage LANG_PLAIN = new EditorLanguage(
-         3, "ace/mode/text", false);
 
    /**
     *
-    * @param parserIndex The index within ALL_PARSER_URLS that corresponds with
-    *    this language's parser.
     * @param parserName The name of the parser--it's found at the top of the
-    *    parser .js file. This MUST match the value inside the .js file or else
     *    dynamic language switching (Save As... with a different extension)
     *    won't work.
     * @param useRCompletion If true, then Tab is intercepted for completion
-    *    purposes. If not, then CodeMirror always handles it.
     */
-   public EditorLanguage(int parserIndex,
-                         String parserName,
-                         boolean useRCompletion)
    {
-      parserIndex_ = parserIndex;
       parserName_ = parserName;
       useRCompletion_ = useRCompletion;
    }
 
-   public JsArrayString getAllParserUrlsWithThisOneLast()
-   {
-      JsArrayString arr = JavaScriptObject.createArray().cast();
-      for (int i = 0; i &lt; ALL_PARSER_URLS.length; i++)
-      {
-         arr.push(ALL_PARSER_URLS[i]);
-      }
-      arr.push(ALL_PARSER_URLS[parserIndex_]);
-      return arr;
-   }
-
    public String getParserName()
    {
       return parserName_;
@@ -94,7 +63,6 @@ public boolean useRCompletion()
       return useRCompletion_;
    }
 
-   private final int parserIndex_;
    private final String parserName_;
    private final boolean useRCompletion_;
 }
</code_before><code_after>@@ -12,10 +12,6 @@
  */
 package org.rstudio.studio.client.common.reditor;
 
 /**
  * Models a language for CodeMirror.
  *
@@ -31,59 +27,32 @@
  */
 public class EditorLanguage
 {
    public static final EditorLanguage LANG_R = new EditorLanguage(
+         "mode/r", true);
    public static final EditorLanguage LANG_TEX = new EditorLanguage(
+         "mode/tex", false);
    public static final EditorLanguage LANG_SWEAVE = new EditorLanguage(
+         "mode/sweave", true);
    public static final EditorLanguage LANG_PLAIN = new EditorLanguage(
+         "ace/mode/text", false);
 
    /**
     *
     * @param parserName The name of the parser--it's found at the top of the
+    *    parser .js fil
+    * e. This MUST match the value inside the .js file or else
     *    dynamic language switching (Save As... with a different extension)
     *    won't work.
     * @param useRCompletion If true, then Tab is intercepted for completion
     */
+   public EditorLanguage(
+         String parserName,
+         boolean useRCompletion)
    {
       parserName_ = parserName;
       useRCompletion_ = useRCompletion;
    }
 
    public String getParserName()
    {
       return parserName_;
@@ -94,7 +63,6 @@ public boolean useRCompletion()
       return useRCompletion_;
    }
 
    private final String parserName_;
    private final boolean useRCompletion_;
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>472225</refactoring_id><commit_sha>12129ea4708c0e17c9f87198c4f25cd02983cd30</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/12129ea4708c0e17c9f87198c4f25cd02983cd30</commit_link><file_path>src/main/java/vazkii/botania/api/brew/Brew.java</file_path><description>Remove Parameter name : String in method public Brew(key String, name String, color int, cost int, effects EffectInstance...) from class vazkii.botania.api.brew.Brew</description><code_before>@@ -12,32 +12,29 @@
 
 import net.minecraft.item.ItemStack;
 import net.minecraft.potion.EffectInstance;
 
 import java.util.List;
 
 /**
  * The class for a Brew definition, each one is a singleton.
  */
-public class Brew {
-
-	private final String key;
-	private final String name;
 	private final int color;
 	private final int cost;
 	private final List&lt;EffectInstance&gt; effects;
 	private boolean canInfuseBloodPendant = true;
 	private boolean canInfuseIncense = true;
 
 	/**
-	 * @param name    The unlocalized name of this potion.
 	 * @param color   The color for the potion to be rendered in the bottle, note that it will get
 	 *                changed a bit when it renders (for more or less brightness) to give a fancy effect.
 	 * @param cost    The cost, in Mana for this brew.
 	 * @param effects A list of effects to apply to the player when they drink it.
 	 */
-	public Brew(String key, String name, int color, int cost, EffectInstance... effects) {
-		this.key = key;
-		this.name = name;
 		this.color = color;
 		this.cost = cost;
 		this.effects = ImmutableList.copyOf(effects);
@@ -67,26 +64,18 @@ public boolean canInfuseIncense() {
 		return canInfuseIncense;
 	}
 
-	/**
-	 * Returns the key for this brew, for it to be found in the map in the API.
-	 * This should ALWAYS return the same result.
-	 */
-	public String getKey() {
-		return key;
-	}
-
 	/**
 	 * Gets the insensitive unlocalized name. This is used for the lexicon.
 	 */
-	public String getUnlocalizedName() {
-		return name;
 	}
 
 	/**
 	 * Gets the unlocalized name for the ItemStack passed in.
 	 */
-	public String getUnlocalizedName(ItemStack stack) {
-		return getUnlocalizedName();
 	}
 
 	/**
</code_before><code_after>@@ -12,32 +12,29 @@
 
 import net.minecraft.item.ItemStack;
 import net.minecraft.potion.EffectInstance;
+import net.minecraftforge.registries.ForgeRegistryEntry;
 
 import java.util.List;
 
 /**
  * The class for a Brew definition, each one is a singleton.
  */
+public class Brew extends ForgeRegistryEntry&lt;Brew&gt; {
 	private final int color;
 	private final int cost;
 	private final List&lt;EffectInstance&gt; effects;
 	private boolean canInfuseBloodPendant = true;
 	private boolean canInfuseIncense = true;
 
 	/**
 	 * @param color   The color for the potion to be rendered in the bottle, note that it will get
 	 *                changed a bit when it renders (for more or less brightness) to give a fancy effect.
+	 *                See {@link net.minecraft.potion.PotionUtils#getPotionColorFromEffectList} for a method
+	 *                to calculate this automatically.
 	 * @param cost    The cost, in Mana for this brew.
 	 * @param effects A list of effects to apply to the player when they drink it.
 	 */
+	public Brew(int color, int cost, EffectInstance... effects) {
 		this.color = color;
 		this.cost = cost;
 		this.effects = ImmutableList.copyOf(effects);
@@ -67,26 +64,18 @@ public boolean canInfuseIncense() {
 		return canInfuseIncense;
 	}
 
 	/**
 	 * Gets the insensitive unlocalized name. This is used for the lexicon.
 	 */
+	public String getTranslationKey() {
+		return String.format("%s.brew.%s", getRegistryName().getNamespace(), getRegistryName().getPath());
 	}
 
 	/**
 	 * Gets the unlocalized name for the ItemStack passed in.
 	 */
+	public String getTranslationKey(ItemStack stack) {
+		return getTranslationKey();
 	}
 
 	/**
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>544541</refactoring_id><commit_sha>c9dccec75cf3a8e37128c4f6173c7905af21af59</commit_sha><commit_link>https://github.com/typetools/checker-framework/commit/c9dccec75cf3a8e37128c4f6173c7905af21af59</commit_link><file_path>dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/LambdaResultExpressionNode.java</file_path><description>Remove Parameter types : Types in method public LambdaResultExpressionNode(t ExpressionTree, result Node, types Types) from class org.checkerframework.dataflow.cfg.node.LambdaResultExpressionNode</description><code_before>@@ -4,17 +4,25 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Objects;
-import javax.lang.model.util.Types;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.javacutil.TreeUtils;
 
 /** A node for the single expression body of a single expression lambda. */
 public class LambdaResultExpressionNode extends Node {
 
   protected final ExpressionTree tree;
-  protected final @Nullable Node result;
 
-  public LambdaResultExpressionNode(ExpressionTree t, @Nullable Node result, Types types) {
     super(TreeUtils.typeOf(t));
     this.result = result;
     tree = t;
@@ -23,14 +31,19 @@ public LambdaResultExpressionNode(ExpressionTree t, @Nullable Node result, Types
   /**
    * Returns the final node of the CFG corresponding to the lambda expression body (see {@link
    * #getTree()}).
    */
-  public @Nullable Node getResult() {
     return result;
   }
 
   /**
    * Returns the {@link ExpressionTree} corresponding to the body of a lambda expression with an
    * expression body (e.g. X for ({@code o -&gt; X}) where X is an expression and not a {...} block).
    */
   @Override
   public ExpressionTree getTree() {
@@ -44,10 +57,7 @@ public &lt;R, P&gt; R accept(NodeVisitor&lt;R, P&gt; visitor, P p) {
 
   @Override
   public String toString() {
-    if (result != null) {
-      return "-&gt; " + result;
-    }
-    return "-&gt; ()";
   }
 
   @Override
@@ -70,10 +80,6 @@ public int hashCode() {
 
   @Override
   public Collection&lt;Node&gt; getOperands() {
-    if (result == null) {
-      return Collections.emptyList();
-    } else {
-      return Collections.singletonList(result);
-    }
   }
 }
</code_before><code_after>@@ -4,17 +4,25 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Objects;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.javacutil.TreeUtils;
 
 /** A node for the single expression body of a single expression lambda. */
 public class LambdaResultExpressionNode extends Node {
 
+  /** Tree for the lambda expression body. */
   protected final ExpressionTree tree;
 
+  /** Final CFG node corresponding to the lambda expression body. */
+  protected final Node result;
+
+  /**
+   * Creates a LambdaResultExpressionNode.
+   *
+   * @param t tree for the lambda expression body
+   * @param result final CFG node corresponding to the lambda expression body
+   */
+  public LambdaResultExpressionNode(ExpressionTree t, Node result) {
     super(TreeUtils.typeOf(t));
     this.result = result;
     tree = t;
@@ -23,14 +31,19 @@ public LambdaResultExpressionNode(ExpressionTree t, @Nullable Node result, Types
   /**
    * Returns the final node of the CFG corresponding to the lambda expression body (see {@link
    * #getTree()}).
+   *
+   * @return the final node of the CFG corresponding to the lambda expression body
    */
+  public Node getResult() {
     return result;
   }
 
   /**
    * Returns the {@link ExpressionTree} corresponding to the body of a lambda expression with an
    * expression body (e.g. X for ({@code o -&gt; X}) where X is an expression and not a {...} block).
+   *
+   * @return the {@link ExpressionTree} corresponding to the body of a lambda expression with an
+   *     expression body
    */
   @Override
   public ExpressionTree getTree() {
@@ -44,10 +57,7 @@ public &lt;R, P&gt; R accept(NodeVisitor&lt;R, P&gt; visitor, P p) {
 
   @Override
   public String toString() {
+    return "-&gt; " + result;
   }
 
   @Override
@@ -70,10 +80,6 @@ public int hashCode() {
 
   @Override
   public Collection&lt;Node&gt; getOperands() {
+    return Collections.singletonList(result);
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>527238</refactoring_id><commit_sha>fb9f16ad29bcc54facdc2cc67ed8b9f6e54fcf8c</commit_sha><commit_link>https://github.com/mollyim/mollyim-android/commit/fb9f16ad29bcc54facdc2cc67ed8b9f6e54fcf8c</commit_link><file_path>src/org/thoughtcrime/securesms/contacts/avatars/ResourceContactPhoto.java</file_path><description>Remove Parameter color : int in method package ResourceContactPhoto(resourceId int, color int) from class org.thoughtcrime.securesms.contacts.avatars.ResourceContactPhoto</description><code_before>@@ -11,16 +11,14 @@
 public class ResourceContactPhoto implements ContactPhoto {
 
   private final int resourceId;
-  private final int color;
 
-  ResourceContactPhoto(int resourceId, int color) {
     this.resourceId = resourceId;
-    this.color      = color;
   }
 
   @Override
-  public Drawable asDrawable(Context context) {
-    Drawable        background = TextDrawable.builder().buildRound(" ", color);
     RoundedDrawable foreground = (RoundedDrawable) RoundedDrawable.fromDrawable(context.getResources().getDrawable(resourceId));
     foreground.setScaleType(ImageView.ScaleType.CENTER);
 
</code_before><code_after>@@ -11,16 +11,14 @@
 public class ResourceContactPhoto implements ContactPhoto {
 
   private final int resourceId;
 
+  ResourceContactPhoto(int resourceId) {
     this.resourceId = resourceId;
   }
 
   @Override
+  public Drawable asDrawable(Context context, int backgroundColor) {
+    Drawable        background = TextDrawable.builder().buildRound(" ", backgroundColor);
     RoundedDrawable foreground = (RoundedDrawable) RoundedDrawable.fromDrawable(context.getResources().getDrawable(resourceId));
     foreground.setScaleType(ImageView.ScaleType.CENTER);
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>470319</refactoring_id><commit_sha>5dacd413f7b7049387334e4c71cd4c86a8d2175a</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/5dacd413f7b7049387334e4c71cd4c86a8d2175a</commit_link><file_path>plugins/org.jkiss.dbeaver.mysql/src/org/jkiss/dbeaver/ext/mysql/edit/MySQLIndexManager.java</file_path><description>Remove Parameter workbenchWindow : IWorkbenchWindow in method protected createDatabaseObject(workbenchWindow IWorkbenchWindow, context DBECommandContext, parent MySQLTable, from Object) : MySQLTableIndex from class org.jkiss.dbeaver.ext.mysql.edit.MySQLIndexManager</description><code_before>@@ -19,8 +19,8 @@
 package org.jkiss.dbeaver.ext.mysql.edit;
 
 import org.eclipse.jface.dialogs.IDialogConstants;
-import org.eclipse.ui.IWorkbenchWindow;
 import org.jkiss.code.Nullable;
 import org.jkiss.dbeaver.ext.mysql.MySQLMessages;
 import org.jkiss.dbeaver.ext.mysql.model.*;
 import org.jkiss.dbeaver.model.edit.DBECommandContext;
@@ -48,12 +48,11 @@ public DBSObjectCache&lt;MySQLCatalog, MySQLTableIndex&gt; getObjectsCache(MySQLTableI
 
     @Override
     protected MySQLTableIndex createDatabaseObject(
-        IWorkbenchWindow workbenchWindow,
         DBECommandContext context, MySQLTable parent,
         Object from)
     {
         EditIndexDialog editDialog = new EditIndexDialog(
-            workbenchWindow.getShell(),
             MySQLMessages.edit_index_manager_title,
             parent,
             Collections.singletonList(DBSIndexType.OTHER));
</code_before><code_after>@@ -19,8 +19,8 @@
 package org.jkiss.dbeaver.ext.mysql.edit;
 
 import org.eclipse.jface.dialogs.IDialogConstants;
 import org.jkiss.code.Nullable;
+import org.jkiss.dbeaver.core.DBeaverUI;
 import org.jkiss.dbeaver.ext.mysql.MySQLMessages;
 import org.jkiss.dbeaver.ext.mysql.model.*;
 import org.jkiss.dbeaver.model.edit.DBECommandContext;
@@ -48,12 +48,11 @@ public DBSObjectCache&lt;MySQLCatalog, MySQLTableIndex&gt; getObjectsCache(MySQLTableI
 
     @Override
     protected MySQLTableIndex createDatabaseObject(
         DBECommandContext context, MySQLTable parent,
         Object from)
     {
         EditIndexDialog editDialog = new EditIndexDialog(
+            DBeaverUI.getActiveWorkbenchShell(),
             MySQLMessages.edit_index_manager_title,
             parent,
             Collections.singletonList(DBSIndexType.OTHER));
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>466402</refactoring_id><commit_sha>c7f166cd80041f272b103007d6216f4c3f1afe63</commit_sha><commit_link>https://github.com/metasfresh/metasfresh/commit/c7f166cd80041f272b103007d6216f4c3f1afe63</commit_link><file_path>de.metas.swat/de.metas.swat.base/src/main/java/de/metas/invoicecandidate/spi/impl/M_InOutLine_Handler.java</file_path><description>Remove Parameter trxName : String in method public retrieveAllModelsWithMissingCandidates(ctx Properties, limit int, trxName String) : Iterator&lt;I_M_InOutLine&gt; from class de.metas.invoicecandidate.spi.impl.M_InOutLine_Handler</description><code_before>@@ -53,6 +53,7 @@
 import org.compiere.model.I_M_AttributeSetInstance;
 import org.compiere.model.I_M_Product;
 import org.compiere.process.DocAction;
 
 import de.metas.document.engine.IDocActionBL;
 import de.metas.inout.IInOutBL;
@@ -108,9 +109,9 @@ public Object getModelForInvoiceCandidateGenerateScheduling(final Object model)
 	}
 
 	@Override
-	public Iterator&lt;I_M_InOutLine&gt; retrieveAllModelsWithMissingCandidates(final Properties ctx, final int limit, final String trxName)
 	{
-		return dao.retrieveAllLinesWithoutOrderLine(ctx, limit, trxName);
 	}
 
 	@Override
</code_before><code_after>@@ -53,6 +53,7 @@
 import org.compiere.model.I_M_AttributeSetInstance;
 import org.compiere.model.I_M_Product;
 import org.compiere.process.DocAction;
+import org.compiere.util.Env;
 
 import de.metas.document.engine.IDocActionBL;
 import de.metas.inout.IInOutBL;
@@ -108,9 +109,9 @@ public Object getModelForInvoiceCandidateGenerateScheduling(final Object model)
 	}
 
 	@Override
+	public Iterator&lt;I_M_InOutLine&gt; retrieveAllModelsWithMissingCandidates(final int limit)
 	{
+		return dao.retrieveAllLinesWithoutOrderLine(Env.getCtx(), limit, ITrx.TRXNAME_ThreadInherited);
 	}
 
 	@Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>491769</refactoring_id><commit_sha>103ab14c404dd7252564feb1a0eeac83c28a1883</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/103ab14c404dd7252564feb1a0eeac83c28a1883</commit_link><file_path>community/bolt/src/main/java/org/neo4j/bolt/protocol/v40/BoltProtocolV40.java</file_path><description>Remove Parameter defaultDatabaseResolver : DefaultDatabaseResolver in method public BoltProtocolV40(logging LogService, boltGraphDatabaseManagementServiceSPI BoltGraphDatabaseManagementServiceSPI, defaultDatabaseResolver DefaultDatabaseResolver, transactionManager TransactionManager, clock SystemNanoClock) from class org.neo4j.bolt.protocol.v40.BoltProtocolV40</description><code_before>@@ -26,6 +26,8 @@
 import org.neo4j.bolt.protocol.common.connector.connection.Connection;
 import org.neo4j.bolt.protocol.common.fsm.StateMachine;
 import org.neo4j.bolt.protocol.common.fsm.StateMachineSPIImpl;
 import org.neo4j.bolt.protocol.common.message.encoder.FailureMessageEncoder;
 import org.neo4j.bolt.protocol.common.message.encoder.IgnoredMessageEncoder;
 import org.neo4j.bolt.protocol.common.message.encoder.SuccessMessageEncoder;
@@ -52,9 +54,6 @@
 import org.neo4j.bolt.protocol.v40.messaging.decoder.ResetMessageDecoder;
 import org.neo4j.bolt.protocol.v40.messaging.decoder.RollbackMessageDecoder;
 import org.neo4j.bolt.protocol.v40.messaging.decoder.RunMessageDecoder;
-import org.neo4j.bolt.protocol.v40.transaction.TransactionStateMachineSPIProviderV4;
-import org.neo4j.bolt.transaction.TransactionManager;
-import org.neo4j.kernel.database.DefaultDatabaseResolver;
 import org.neo4j.logging.Log;
 import org.neo4j.logging.internal.LogService;
 import org.neo4j.packstream.signal.FrameSignal;
@@ -72,8 +71,6 @@ public class BoltProtocolV40 implements BoltProtocol {
     protected final Log log;
 
     protected final BoltGraphDatabaseManagementServiceSPI boltGraphDatabaseManagementServiceSPI;
-    protected final DefaultDatabaseResolver defaultDatabaseResolver;
-    protected final TransactionManager transactionManager;
     protected final SystemNanoClock clock;
 
     private final StructRegistry&lt;Connection, RequestMessage&gt; requestMessageStructRegistry;
@@ -82,15 +79,11 @@ public class BoltProtocolV40 implements BoltProtocol {
     public BoltProtocolV40(
             LogService logging,
             BoltGraphDatabaseManagementServiceSPI boltGraphDatabaseManagementServiceSPI,
-            DefaultDatabaseResolver defaultDatabaseResolver,
-            TransactionManager transactionManager,
             SystemNanoClock clock) {
         this.logging = logging;
         this.log = logging.getInternalLog(getClass());
 
         this.boltGraphDatabaseManagementServiceSPI = boltGraphDatabaseManagementServiceSPI;
-        this.defaultDatabaseResolver = defaultDatabaseResolver;
-        this.transactionManager = transactionManager;
         this.clock = clock;
 
         this.requestMessageStructRegistry = this.createRequestMessageRegistry();
@@ -110,17 +103,11 @@ public Predicate&lt;FrameSignal&gt; frameSignalFilter() {
 
     @Override
     public StateMachine createStateMachine(Connection connection) {
-        connection
-                .memoryTracker()
-                .allocateHeap(TransactionStateMachineSPIProviderV4.SHALLOW_SIZE
-                        + StateMachineSPIImpl.SHALLOW_SIZE
-                        + StateMachineV40.SHALLOW_SIZE);
 
-        var transactionSpiProvider =
-                new TransactionStateMachineSPIProviderV4(boltGraphDatabaseManagementServiceSPI, connection, clock);
-        var boltSPI = new StateMachineSPIImpl(logging, transactionSpiProvider);
 
-        return new StateMachineV40(boltSPI, connection, clock, defaultDatabaseResolver, transactionManager);
     }
 
     protected StructRegistry&lt;Connection, RequestMessage&gt; createRequestMessageRegistry() {
@@ -177,6 +164,11 @@ public void registerStructWriters(WriterPipeline pipeline) {
         pipeline.addFirst(LegacyStructWriter.getInstance());
     }
 
     @Override
     public String toString() {
         return this.version().toString();
</code_before><code_after>@@ -26,6 +26,8 @@
 import org.neo4j.bolt.protocol.common.connector.connection.Connection;
 import org.neo4j.bolt.protocol.common.fsm.StateMachine;
 import org.neo4j.bolt.protocol.common.fsm.StateMachineSPIImpl;
+import org.neo4j.bolt.protocol.common.fsm.response.metadata.LegacyMetadataHandler;
+import org.neo4j.bolt.protocol.common.fsm.response.metadata.MetadataHandler;
 import org.neo4j.bolt.protocol.common.message.encoder.FailureMessageEncoder;
 import org.neo4j.bolt.protocol.common.message.encoder.IgnoredMessageEncoder;
 import org.neo4j.bolt.protocol.common.message.encoder.SuccessMessageEncoder;
@@ -52,9 +54,6 @@
 import org.neo4j.bolt.protocol.v40.messaging.decoder.ResetMessageDecoder;
 import org.neo4j.bolt.protocol.v40.messaging.decoder.RollbackMessageDecoder;
 import org.neo4j.bolt.protocol.v40.messaging.decoder.RunMessageDecoder;
 import org.neo4j.logging.Log;
 import org.neo4j.logging.internal.LogService;
 import org.neo4j.packstream.signal.FrameSignal;
@@ -72,8 +71,6 @@ public class BoltProtocolV40 implements BoltProtocol {
     protected final Log log;
 
     protected final BoltGraphDatabaseManagementServiceSPI boltGraphDatabaseManagementServiceSPI;
     protected final SystemNanoClock clock;
 
     private final StructRegistry&lt;Connection, RequestMessage&gt; requestMessageStructRegistry;
@@ -82,15 +79,11 @@ public class BoltProtocolV40 implements BoltProtocol {
     public BoltProtocolV40(
             LogService logging,
             BoltGraphDatabaseManagementServiceSPI boltGraphDatabaseManagementServiceSPI,
             SystemNanoClock clock) {
         this.logging = logging;
         this.log = logging.getInternalLog(getClass());
 
         this.boltGraphDatabaseManagementServiceSPI = boltGraphDatabaseManagementServiceSPI;
         this.clock = clock;
 
         this.requestMessageStructRegistry = this.createRequestMessageRegistry();
@@ -110,17 +103,11 @@ public Predicate&lt;FrameSignal&gt; frameSignalFilter() {
 
     @Override
     public StateMachine createStateMachine(Connection connection) {
+        connection.memoryTracker().allocateHeap(StateMachineSPIImpl.SHALLOW_SIZE + StateMachineV40.SHALLOW_SIZE);
 
+        var boltSPI = new StateMachineSPIImpl(logging);
 
+        return new StateMachineV40(boltSPI, connection, clock);
     }
 
     protected StructRegistry&lt;Connection, RequestMessage&gt; createRequestMessageRegistry() {
@@ -177,6 +164,11 @@ public void registerStructWriters(WriterPipeline pipeline) {
         pipeline.addFirst(LegacyStructWriter.getInstance());
     }
 
+    @Override
+    public MetadataHandler metadataHandler() {
+        return LegacyMetadataHandler.getInstance();
+    }
+
     @Override
     public String toString() {
         return this.version().toString();
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>478077</refactoring_id><commit_sha>2cd02e0fc195ad6b7a0d7a55448ff96450d69c7f</commit_sha><commit_link>https://github.com/apache/pinot/commit/2cd02e0fc195ad6b7a0d7a55448ff96450d69c7f</commit_link><file_path>pinot-core/src/main/java/com/linkedin/pinot/core/segment/index/SegmentMetadataImpl.java</file_path><description>Remove Parameter segmentVersion : String in method public getDictionaryFileName(column String, segmentVersion String) : String from class com.linkedin.pinot.core.segment.index.SegmentMetadataImpl</description><code_before>@@ -45,7 +45,6 @@
 import java.util.Set;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
-import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import org.apache.commons.configuration.ConfigurationException;
 import org.apache.commons.configuration.PropertiesConfiguration;
@@ -95,42 +94,12 @@ public class SegmentMetadataImpl implements SegmentMetadata {
   private long _segmentEndTime;
   private List&lt;String&gt; _optimizations;
 
-  /**
-   * Load segment metadata based on the segment version passed in.
-   * &lt;p&gt;Index directory passed in should be top level segment directory.
-   */
-  public SegmentMetadataImpl(@Nonnull File indexDir, @Nonnull SegmentVersion segmentVersion)
-      throws ConfigurationException, IOException {
-    _metadataFile = SegmentDirectoryPaths.findMetadataFile(indexDir, segmentVersion);
-    Preconditions.checkNotNull(_metadataFile, "Cannot find segment metadata file under directory: %s", indexDir);
-
-    _segmentMetadataPropertiesConfiguration = new PropertiesConfiguration(_metadataFile);
-    _columnMetadataMap = new HashMap&lt;&gt;();
-    _allColumns = new HashSet&lt;&gt;();
-    _schema = new Schema();
-    _indexDir = indexDir.getPath();
-
-    init();
-    File creationMetaFile = SegmentDirectoryPaths.findCreationMetaFile(indexDir, segmentVersion);
-    if (creationMetaFile != null) {
-      loadCreationMeta(creationMetaFile);
-    }
-
-    setTimeInfo();
-    _totalDocs = _segmentMetadataPropertiesConfiguration.getInt(V1Constants.MetadataKeys.Segment.SEGMENT_TOTAL_DOCS);
-    _totalRawDocs =
-        _segmentMetadataPropertiesConfiguration.getInt(V1Constants.MetadataKeys.Segment.SEGMENT_TOTAL_RAW_DOCS,
-            _totalDocs);
-  }
-
   /**
    * Load segment metadata in any segment version.
    * &lt;p&gt;Index directory passed in should be top level segment directory.
-   * &lt;p&gt;If segment metadata file exists in multiple segment version, load the one in lowest segment version.
    */
-  // TODO: check if loading file in highest segment version is better
-  public SegmentMetadataImpl(File indexDir)
-      throws ConfigurationException, IOException {
     _metadataFile = SegmentDirectoryPaths.findMetadataFile(indexDir);
     Preconditions.checkNotNull(_metadataFile, "Cannot find segment metadata file under directory: %s", indexDir);
 
@@ -611,7 +580,7 @@ public StarTreeMetadata getStarTreeMetadata() {
   }
 
   @Override
-  public String getForwardIndexFileName(String column, String segmentVersion) {
     ColumnMetadata columnMetadata = getColumnMetadataFor(column);
     StringBuilder fileNameBuilder = new StringBuilder(column);
     // starting v2 we will append the forward index files with version
@@ -633,12 +602,12 @@ public String getForwardIndexFileName(String column, String segmentVersion) {
   }
 
   @Override
-  public String getDictionaryFileName(String column, String segmentVersion) {
     return column + V1Constants.Dict.FILE_EXTENTION;
   }
 
   @Override
-  public String getBitmapInvertedIndexFileName(String column, String segmentVersion) {
     return column + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION;
   }
 
</code_before><code_after>@@ -45,7 +45,6 @@
 import java.util.Set;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
 import org.apache.commons.configuration.ConfigurationException;
 import org.apache.commons.configuration.PropertiesConfiguration;
@@ -95,42 +94,12 @@ public class SegmentMetadataImpl implements SegmentMetadata {
   private long _segmentEndTime;
   private List&lt;String&gt; _optimizations;
 
   /**
    * Load segment metadata in any segment version.
    * &lt;p&gt;Index directory passed in should be top level segment directory.
+   * &lt;p&gt;If segment metadata file exists in multiple segment version, load the one in highest segment version.
    */
+  public SegmentMetadataImpl(File indexDir) throws ConfigurationException, IOException {
     _metadataFile = SegmentDirectoryPaths.findMetadataFile(indexDir);
     Preconditions.checkNotNull(_metadataFile, "Cannot find segment metadata file under directory: %s", indexDir);
 
@@ -611,7 +580,7 @@ public StarTreeMetadata getStarTreeMetadata() {
   }
 
   @Override
+  public String getForwardIndexFileName(String column) {
     ColumnMetadata columnMetadata = getColumnMetadataFor(column);
     StringBuilder fileNameBuilder = new StringBuilder(column);
     // starting v2 we will append the forward index files with version
@@ -633,12 +602,12 @@ public String getForwardIndexFileName(String column, String segmentVersion) {
   }
 
   @Override
+  public String getDictionaryFileName(String column) {
     return column + V1Constants.Dict.FILE_EXTENTION;
   }
 
   @Override
+  public String getBitmapInvertedIndexFileName(String column) {
     return column + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION;
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>529836</refactoring_id><commit_sha>9f568858efbf11175fed4633aaeb05237fa119dc</commit_sha><commit_link>https://github.com/apache/druid/commit/9f568858efbf11175fed4633aaeb05237fa119dc</commit_link><file_path>server/src/main/java/org/apache/druid/server/http/LookupCoordinatorResource.java</file_path><description>Remove Parameter author : String in method public createOrUpdateLookup(tier String, lookup String, author String, comment String, in InputStream, req HttpServletRequest) : Response from class org.apache.druid.server.http.LookupCoordinatorResource</description><code_before>@@ -29,8 +29,6 @@
 import com.google.common.net.HostAndPort;
 import com.google.inject.Inject;
 import com.sun.jersey.spi.container.ResourceFilters;
-import org.apache.druid.audit.AuditInfo;
-import org.apache.druid.audit.AuditManager;
 import org.apache.druid.common.utils.ServletResourceUtils;
 import org.apache.druid.guice.annotations.Json;
 import org.apache.druid.guice.annotations.Smile;
@@ -41,14 +39,14 @@
 import org.apache.druid.server.http.security.ConfigResourceFilter;
 import org.apache.druid.server.lookup.cache.LookupCoordinatorManager;
 import org.apache.druid.server.lookup.cache.LookupExtractorFactoryMapContainer;
 
 import javax.annotation.Nullable;
 import javax.servlet.http.HttpServletRequest;
 import javax.ws.rs.Consumes;
 import javax.ws.rs.DELETE;
 import javax.ws.rs.DefaultValue;
 import javax.ws.rs.GET;
-import javax.ws.rs.HeaderParam;
 import javax.ws.rs.POST;
 import javax.ws.rs.Path;
 import javax.ws.rs.PathParam;
@@ -149,8 +147,6 @@ public Response getAllLookupSpecs()
   @Consumes({MediaType.APPLICATION_JSON, SmileMediaTypes.APPLICATION_JACKSON_SMILE})
   public Response updateAllLookups(
       InputStream in,
-      @HeaderParam(AuditManager.X_DRUID_AUTHOR) @DefaultValue("") final String author,
-      @HeaderParam(AuditManager.X_DRUID_COMMENT) @DefaultValue("") final String comment,
       @Context HttpServletRequest req
   )
   {
@@ -166,7 +162,7 @@ public Response updateAllLookups(
       catch (IOException e) {
         return Response.status(Response.Status.BAD_REQUEST).entity(ServletResourceUtils.sanitizeException(e)).build();
       }
-      if (lookupCoordinatorManager.updateLookups(map, new AuditInfo(author, comment, req.getRemoteAddr()))) {
         return Response.status(Response.Status.ACCEPTED).entity(map).build();
       } else {
         throw new RuntimeException("Unknown error updating configuration");
@@ -183,8 +179,6 @@ public Response updateAllLookups(
   @Path("/config/{tier}")
   public Response deleteTier(
       @PathParam("tier") String tier,
-      @HeaderParam(AuditManager.X_DRUID_AUTHOR) @DefaultValue("") final String author,
-      @HeaderParam(AuditManager.X_DRUID_COMMENT) @DefaultValue("") final String comment,
       @Context HttpServletRequest req
   )
   {
@@ -195,7 +189,7 @@ public Response deleteTier(
                        .build();
       }
 
-      if (lookupCoordinatorManager.deleteTier(tier, new AuditInfo(author, comment, req.getRemoteAddr()))) {
         return Response.status(Response.Status.ACCEPTED).build();
       } else {
         return Response.status(Response.Status.NOT_FOUND).build();
@@ -213,8 +207,6 @@ public Response deleteTier(
   public Response deleteLookup(
       @PathParam("tier") String tier,
       @PathParam("lookup") String lookup,
-      @HeaderParam(AuditManager.X_DRUID_AUTHOR) @DefaultValue("") final String author,
-      @HeaderParam(AuditManager.X_DRUID_COMMENT) @DefaultValue("") final String comment,
       @Context HttpServletRequest req
   )
   {
@@ -231,7 +223,7 @@ public Response deleteLookup(
                        .build();
       }
 
-      if (lookupCoordinatorManager.deleteLookup(tier, lookup, new AuditInfo(author, comment, req.getRemoteAddr()))) {
         return Response.status(Response.Status.ACCEPTED).build();
       } else {
         return Response.status(Response.Status.NOT_FOUND).build();
@@ -249,8 +241,6 @@ public Response deleteLookup(
   public Response createOrUpdateLookup(
       @PathParam("tier") String tier,
       @PathParam("lookup") String lookup,
-      @HeaderParam(AuditManager.X_DRUID_AUTHOR) @DefaultValue("") final String author,
-      @HeaderParam(AuditManager.X_DRUID_COMMENT) @DefaultValue("") final String comment,
       InputStream in,
       @Context HttpServletRequest req
   )
@@ -280,7 +270,7 @@ public Response createOrUpdateLookup(
           tier,
           lookup,
           lookupSpec,
-          new AuditInfo(author, comment, req.getRemoteAddr())
       )) {
         return Response.status(Response.Status.ACCEPTED).build();
       } else {
</code_before><code_after>@@ -29,8 +29,6 @@
 import com.google.common.net.HostAndPort;
 import com.google.inject.Inject;
 import com.sun.jersey.spi.container.ResourceFilters;
 import org.apache.druid.common.utils.ServletResourceUtils;
 import org.apache.druid.guice.annotations.Json;
 import org.apache.druid.guice.annotations.Smile;
@@ -41,14 +39,14 @@
 import org.apache.druid.server.http.security.ConfigResourceFilter;
 import org.apache.druid.server.lookup.cache.LookupCoordinatorManager;
 import org.apache.druid.server.lookup.cache.LookupExtractorFactoryMapContainer;
+import org.apache.druid.server.security.AuthorizationUtils;
 
 import javax.annotation.Nullable;
 import javax.servlet.http.HttpServletRequest;
 import javax.ws.rs.Consumes;
 import javax.ws.rs.DELETE;
 import javax.ws.rs.DefaultValue;
 import javax.ws.rs.GET;
 import javax.ws.rs.POST;
 import javax.ws.rs.Path;
 import javax.ws.rs.PathParam;
@@ -149,8 +147,6 @@ public Response getAllLookupSpecs()
   @Consumes({MediaType.APPLICATION_JSON, SmileMediaTypes.APPLICATION_JACKSON_SMILE})
   public Response updateAllLookups(
       InputStream in,
       @Context HttpServletRequest req
   )
   {
@@ -166,7 +162,7 @@ public Response updateAllLookups(
       catch (IOException e) {
         return Response.status(Response.Status.BAD_REQUEST).entity(ServletResourceUtils.sanitizeException(e)).build();
       }
+      if (lookupCoordinatorManager.updateLookups(map, AuthorizationUtils.buildAuditInfo(req))) {
         return Response.status(Response.Status.ACCEPTED).entity(map).build();
       } else {
         throw new RuntimeException("Unknown error updating configuration");
@@ -183,8 +179,6 @@ public Response updateAllLookups(
   @Path("/config/{tier}")
   public Response deleteTier(
       @PathParam("tier") String tier,
       @Context HttpServletRequest req
   )
   {
@@ -195,7 +189,7 @@ public Response deleteTier(
                        .build();
       }
 
+      if (lookupCoordinatorManager.deleteTier(tier, AuthorizationUtils.buildAuditInfo(req))) {
         return Response.status(Response.Status.ACCEPTED).build();
       } else {
         return Response.status(Response.Status.NOT_FOUND).build();
@@ -213,8 +207,6 @@ public Response deleteTier(
   public Response deleteLookup(
       @PathParam("tier") String tier,
       @PathParam("lookup") String lookup,
       @Context HttpServletRequest req
   )
   {
@@ -231,7 +223,7 @@ public Response deleteLookup(
                        .build();
       }
 
+      if (lookupCoordinatorManager.deleteLookup(tier, lookup, AuthorizationUtils.buildAuditInfo(req))) {
         return Response.status(Response.Status.ACCEPTED).build();
       } else {
         return Response.status(Response.Status.NOT_FOUND).build();
@@ -249,8 +241,6 @@ public Response deleteLookup(
   public Response createOrUpdateLookup(
       @PathParam("tier") String tier,
       @PathParam("lookup") String lookup,
       InputStream in,
       @Context HttpServletRequest req
   )
@@ -280,7 +270,7 @@ public Response createOrUpdateLookup(
           tier,
           lookup,
           lookupSpec,
+          AuthorizationUtils.buildAuditInfo(req)
       )) {
         return Response.status(Response.Status.ACCEPTED).build();
       } else {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>568631</refactoring_id><commit_sha>8543d84e30cdeff7f7b11e971318a79170669a8d</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/8543d84e30cdeff7f7b11e971318a79170669a8d</commit_link><file_path>jdk/src/share/classes/java/nio/file/FileTreeWalker.java</file_path><description>Remove Parameter maxDepth : int in method package walk(start Path, maxDepth int) : void from class java.nio.file.FileTreeWalker</description><code_before>@@ -41,8 +41,12 @@ class FileTreeWalker {
     private final boolean detectCycles;
     private final LinkOption[] linkOptions;
     private final FileVisitor&lt;? super Path&gt; visitor;
 
-    FileTreeWalker(Set&lt;FileVisitOption&gt; options, FileVisitor&lt;? super Path&gt; visitor) {
         boolean fl = false;
         boolean dc = false;
         for (FileVisitOption option: options) {
@@ -58,18 +62,15 @@ class FileTreeWalker {
         this.linkOptions = (fl) ? new LinkOption[0] :
             new LinkOption[] { LinkOption.NOFOLLOW_LINKS };
         this.visitor = visitor;
     }
 
     /**
      * Walk file tree starting at the given file
      */
-    void walk(Path start, int maxDepth) {
-        // don't use attributes of starting file as they may be stale
-        if (start instanceof BasicFileAttributesHolder) {
-            ((BasicFileAttributesHolder)start).invalidate();
-        }
         FileVisitResult result = walk(start,
-                                      maxDepth,
                                       new ArrayList&lt;AncestorDirectory&gt;());
         if (result == null) {
             throw new NullPointerException("Visitor returned 'null'");
@@ -89,12 +90,15 @@ private FileVisitResult walk(Path file,
                                  List&lt;AncestorDirectory&gt; ancestors)
     {
         // depth check
-        if (depth-- &lt; 0)
             return FileVisitResult.CONTINUE;
 
         // if attributes are cached then use them if possible
         BasicFileAttributes attrs = null;
-        if (file instanceof BasicFileAttributesHolder) {
             BasicFileAttributes cached = ((BasicFileAttributesHolder)file).get();
             if (!followLinks || !cached.isSymbolicLink())
                 attrs = cached;
@@ -120,6 +124,10 @@ private FileVisitResult walk(Path file,
                     }
                 }
             } catch (SecurityException x) {
                 return FileVisitResult.CONTINUE;
             }
         }
@@ -196,7 +204,7 @@ private FileVisitResult walk(Path file,
                 try {
                     for (Path entry: stream) {
                         inAction = true;
-                        result = walk(entry, depth, ancestors);
                         inAction = false;
 
                         // returning null will cause NPE to be thrown
</code_before><code_after>@@ -41,8 +41,12 @@ class FileTreeWalker {
     private final boolean detectCycles;
     private final LinkOption[] linkOptions;
     private final FileVisitor&lt;? super Path&gt; visitor;
+    private final int maxDepth;
 
+    FileTreeWalker(Set&lt;FileVisitOption&gt; options,
+                   FileVisitor&lt;? super Path&gt; visitor,
+                   int maxDepth)
+    {
         boolean fl = false;
         boolean dc = false;
         for (FileVisitOption option: options) {
@@ -58,18 +62,15 @@ class FileTreeWalker {
         this.linkOptions = (fl) ? new LinkOption[0] :
             new LinkOption[] { LinkOption.NOFOLLOW_LINKS };
         this.visitor = visitor;
+        this.maxDepth = maxDepth;
     }
 
     /**
      * Walk file tree starting at the given file
      */
+    void walk(Path start) {
         FileVisitResult result = walk(start,
+                                      0,
                                       new ArrayList&lt;AncestorDirectory&gt;());
         if (result == null) {
             throw new NullPointerException("Visitor returned 'null'");
@@ -89,12 +90,15 @@ private FileVisitResult walk(Path file,
                                  List&lt;AncestorDirectory&gt; ancestors)
     {
         // depth check
+        if (depth &gt; maxDepth)
             return FileVisitResult.CONTINUE;
 
         // if attributes are cached then use them if possible
         BasicFileAttributes attrs = null;
+        if ((depth &gt; 0) &amp;&amp;
+            (file instanceof BasicFileAttributesHolder) &amp;&amp;
+            (System.getSecurityManager() == null))
+        {
             BasicFileAttributes cached = ((BasicFileAttributesHolder)file).get();
             if (!followLinks || !cached.isSymbolicLink())
                 attrs = cached;
@@ -120,6 +124,10 @@ private FileVisitResult walk(Path file,
                     }
                 }
             } catch (SecurityException x) {
+                // If access to starting file is denied then SecurityException
+                // is thrown, otherwise the file is ignored.
+                if (depth == 0)
+                    throw x;
                 return FileVisitResult.CONTINUE;
             }
         }
@@ -196,7 +204,7 @@ private FileVisitResult walk(Path file,
                 try {
                     for (Path entry: stream) {
                         inAction = true;
+                        result = walk(entry, depth+1, ancestors);
                         inAction = false;
 
                         // returning null will cause NPE to be thrown
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>560022</refactoring_id><commit_sha>869114e09a794c208cc1ee41acf25546471248b7</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/869114e09a794c208cc1ee41acf25546471248b7</commit_link><file_path>core/src/test/java/ch/cyberduck/core/transfer/UploadTransferTest.java</file_path><description>Remove Parameter passwordCallback : PasswordCallback in method public transfer(source Session&lt;?&gt;, destination Session&lt;?&gt;, file Path, local Local, options TransferOptions, status TransferStatus, connectionCallback ConnectionCallback, passwordCallback PasswordCallback, listener ProgressListener, streamListener StreamListener) : Path from class ch.cyberduck.core.transfer.UploadTransferTest.testCacheRename.t.new UploadTransfer</description><code_before>@@ -142,7 +142,7 @@ public AttributedList&lt;Path&gt; list(final Path folder, final ListProgressListener l
             public Path transfer(final Session&lt;?&gt; source, final Session&lt;?&gt; destination, final Path file, Local local,
                                  final TransferOptions options, final TransferStatus status,
                                  final ConnectionCallback connectionCallback,
-                                 final PasswordCallback passwordCallback, final ProgressListener listener, final StreamListener streamListener) {
                 assertTrue(options.resumeRequested);
                 return file;
             }
@@ -207,7 +207,7 @@ public AttributedList&lt;Path&gt; list(final Path folder, final ListProgressListener l
             public Path transfer(final Session&lt;?&gt; source, final Session&lt;?&gt; destination, final Path file, Local local,
                                  final TransferOptions options, final TransferStatus status,
                                  final ConnectionCallback connectionCallback,
-                                 final PasswordCallback passwordCallback, final ProgressListener listener, final StreamListener streamListener) {
                 //
                 return file;
             }
@@ -395,7 +395,7 @@ public boolean random() {
             @Override
             public Path transfer(final Session&lt;?&gt; source, final Session&lt;?&gt; destination, final Path file, Local local,
                                  final TransferOptions options, final TransferStatus status,
-                                 final ConnectionCallback connectionCallback, final PasswordCallback passwordCallback, final ProgressListener listener, final StreamListener streamListener) {
                 status.setComplete();
                 set.set(true);
                 return file;
</code_before><code_after>@@ -142,7 +142,7 @@ public AttributedList&lt;Path&gt; list(final Path folder, final ListProgressListener l
             public Path transfer(final Session&lt;?&gt; source, final Session&lt;?&gt; destination, final Path file, Local local,
                                  final TransferOptions options, final TransferStatus status,
                                  final ConnectionCallback connectionCallback,
+                                 final ProgressListener listener, final StreamListener streamListener) {
                 assertTrue(options.resumeRequested);
                 return file;
             }
@@ -207,7 +207,7 @@ public AttributedList&lt;Path&gt; list(final Path folder, final ListProgressListener l
             public Path transfer(final Session&lt;?&gt; source, final Session&lt;?&gt; destination, final Path file, Local local,
                                  final TransferOptions options, final TransferStatus status,
                                  final ConnectionCallback connectionCallback,
+                                 final ProgressListener listener, final StreamListener streamListener) {
                 //
                 return file;
             }
@@ -395,7 +395,7 @@ public boolean random() {
             @Override
             public Path transfer(final Session&lt;?&gt; source, final Session&lt;?&gt; destination, final Path file, Local local,
                                  final TransferOptions options, final TransferStatus status,
+                                 final ConnectionCallback connectionCallback, final ProgressListener listener, final StreamListener streamListener) {
                 status.setComplete();
                 set.set(true);
                 return file;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>570695</refactoring_id><commit_sha>b678607b9eaa737f144ef5a56d0ef979813b483c</commit_sha><commit_link>https://github.com/hyphanet/fred/commit/b678607b9eaa737f144ef5a56d0ef979813b483c</commit_link><file_path>src/freenet/node/fcp/PersistentPut.java</file_path><description>Remove Parameter uri : FreenetURI in method public PersistentPut(identifier String, uri FreenetURI, verbosity int, priorityClass short, uploadFrom short, targetURI FreenetURI, persistenceType short, origFilename File, mimeType String, global boolean, size long, clientToken String, started boolean, maxRetries int, targetFilename String, binaryBlob boolean, compatMode InsertContext.CompatibilityMode, dontCompress boolean, compressorDescriptor String, realTime boolean, splitfileCryptoKey byte[]) from class freenet.node.fcp.PersistentPut</description><code_before>@@ -19,6 +19,7 @@ public class PersistentPut extends FCPMessage {
 	
 	final String identifier;
 	final FreenetURI uri;
 	final int verbosity; 
 	final short priorityClass;
 	final short uploadFrom;
@@ -39,13 +40,14 @@ public class PersistentPut extends FCPMessage {
 	final byte[] splitfileCryptoKey;
 	final String compressorDescriptor;
 	
-	public PersistentPut(String identifier, FreenetURI uri, int verbosity, 
 			short priorityClass, short uploadFrom, FreenetURI targetURI, 
 			short persistenceType, File origFilename, String mimeType, 
 			boolean global, long size, String clientToken, boolean started, 
 			int maxRetries, String targetFilename, boolean binaryBlob, InsertContext.CompatibilityMode compatMode, boolean dontCompress, String compressorDescriptor, boolean realTime, byte[] splitfileCryptoKey) {
 		this.identifier = identifier;
-		this.uri = uri;
 		this.verbosity = verbosity;
 		this.priorityClass = priorityClass;
 		this.uploadFrom = uploadFrom;
@@ -72,6 +74,7 @@ public SimpleFieldSet getFieldSet() {
 		SimpleFieldSet fs = new SimpleFieldSet(true);
 		fs.putSingle("Identifier", identifier);
 		fs.putSingle("URI", uri.toString(false, false));
 		fs.put("Verbosity", verbosity);
 		fs.put("PriorityClass", priorityClass);
 		fs.putSingle("UploadFrom", ClientPutMessage.uploadFromString(uploadFrom));
</code_before><code_after>@@ -19,6 +19,7 @@ public class PersistentPut extends FCPMessage {
 	
 	final String identifier;
 	final FreenetURI uri;
+	final FreenetURI privateURI;
 	final int verbosity; 
 	final short priorityClass;
 	final short uploadFrom;
@@ -39,13 +40,14 @@ public class PersistentPut extends FCPMessage {
 	final byte[] splitfileCryptoKey;
 	final String compressorDescriptor;
 	
+	public PersistentPut(String identifier, FreenetURI publicURI, FreenetURI privateURI, int verbosity, 
 			short priorityClass, short uploadFrom, FreenetURI targetURI, 
 			short persistenceType, File origFilename, String mimeType, 
 			boolean global, long size, String clientToken, boolean started, 
 			int maxRetries, String targetFilename, boolean binaryBlob, InsertContext.CompatibilityMode compatMode, boolean dontCompress, String compressorDescriptor, boolean realTime, byte[] splitfileCryptoKey) {
 		this.identifier = identifier;
+		this.uri = publicURI;
+		this.privateURI = privateURI;
 		this.verbosity = verbosity;
 		this.priorityClass = priorityClass;
 		this.uploadFrom = uploadFrom;
@@ -72,6 +74,7 @@ public SimpleFieldSet getFieldSet() {
 		SimpleFieldSet fs = new SimpleFieldSet(true);
 		fs.putSingle("Identifier", identifier);
 		fs.putSingle("URI", uri.toString(false, false));
+		fs.putSingle("PrivateURI", uri.toString(false, false));
 		fs.put("Verbosity", verbosity);
 		fs.put("PriorityClass", priorityClass);
 		fs.putSingle("UploadFrom", ClientPutMessage.uploadFromString(uploadFrom));
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>571222</refactoring_id><commit_sha>09c5a92ca94d60e0c25a724763face7255c3d11d</commit_sha><commit_link>https://github.com/hyphanet/fred/commit/09c5a92ca94d60e0c25a724763face7255c3d11d</commit_link><file_path>src/freenet/client/async/BaseSingleFileFetcher.java</file_path><description>Remove Parameter delayed : boolean in method public schedule(container ObjectContainer, context ClientContext, delayed boolean) : void from class freenet.client.async.BaseSingleFileFetcher</description><code_before>@@ -20,7 +20,7 @@
 import freenet.node.SendableGet;
 import freenet.support.Logger;
 
-public abstract class BaseSingleFileFetcher extends SendableGet implements GotKeyListener {
 
 	final ClientKey key;
 	protected boolean cancelled;
@@ -109,7 +109,7 @@ protected boolean retry(ObjectContainer container, ClientContext context) {
 				}
 				return true; // We will retry, just not yet. See requeueAfterCooldown(Key).
 			} else {
-				schedule(container, context, false);
 			}
 			return true;
 		}
@@ -151,7 +151,7 @@ public void cancel(ObjectContainer container, ClientContext context) {
 	 * Call unregister(container) if you only want to remove from the queue.
 	 */
 	public void unregisterAll(ObjectContainer container, ClientContext context) {
-		getScheduler(context).removePendingKey(this, false, key.getNodeKey(), container);
 		super.unregister(container, context);
 	}
 
@@ -238,13 +238,25 @@ public void requeueAfterCooldown(Key key, long time, ObjectContainer container,
 		}
 		if(Logger.shouldLog(Logger.MINOR, this))
 			Logger.minor(this, "Requeueing after cooldown "+key+" for "+this);
-		schedule(container, context, false);
 		if(persistent)
 			container.deactivate(this.key, 5);
 	}
 
-	public void schedule(ObjectContainer container, ClientContext context, boolean delayed) {
-		getScheduler(context).register(this, new SendableGet[] { this }, delayed, persistent, true, ctx.blocks, null);
 	}
 	
 	public SendableGet getRequest(Key key, ObjectContainer container) {
@@ -270,4 +282,19 @@ public List&lt;PersistentChosenBlock&gt; makeBlocks(PersistentChosenRequest request, R
 		return Collections.singletonList(block);
 	}
 
 }
</code_before><code_after>@@ -20,7 +20,7 @@
 import freenet.node.SendableGet;
 import freenet.support.Logger;
 
+public abstract class BaseSingleFileFetcher extends SendableGet implements HasKeyListener {
 
 	final ClientKey key;
 	protected boolean cancelled;
@@ -109,7 +109,7 @@ protected boolean retry(ObjectContainer container, ClientContext context) {
 				}
 				return true; // We will retry, just not yet. See requeueAfterCooldown(Key).
 			} else {
+				reschedule(container, context);
 			}
 			return true;
 		}
@@ -151,7 +151,7 @@ public void cancel(ObjectContainer container, ClientContext context) {
 	 * Call unregister(container) if you only want to remove from the queue.
 	 */
 	public void unregisterAll(ObjectContainer container, ClientContext context) {
+		getScheduler(context).removePendingKeys(this, false);
 		super.unregister(container, context);
 	}
 
@@ -238,13 +238,25 @@ public void requeueAfterCooldown(Key key, long time, ObjectContainer container,
 		}
 		if(Logger.shouldLog(Logger.MINOR, this))
 			Logger.minor(this, "Requeueing after cooldown "+key+" for "+this);
+		reschedule(container, context);
 		if(persistent)
 			container.deactivate(this.key, 5);
 	}
 
+	public void schedule(ObjectContainer container, ClientContext context) {
+		try {
+			getScheduler(context).register(this, new SendableGet[] { this }, persistent, true, ctx.blocks, false);
+		} catch (KeyListenerConstructionException e) {
+			Logger.error(this, "Impossible: "+e+" on "+this, e);
+		}
+	}
+	
+	public void reschedule(ObjectContainer container, ClientContext context) {
+		try {
+			getScheduler(context).register(null, new SendableGet[] { this }, persistent, true, ctx.blocks, true);
+		} catch (KeyListenerConstructionException e) {
+			Logger.error(this, "Impossible: "+e+" on "+this, e);
+		}
 	}
 	
 	public SendableGet getRequest(Key key, ObjectContainer container) {
@@ -270,4 +282,19 @@ public List&lt;PersistentChosenBlock&gt; makeBlocks(PersistentChosenRequest request, R
 		return Collections.singletonList(block);
 	}
 
+	public KeyListener makeKeyListener(ObjectContainer container, ClientContext context) {
+		if(persistent) {
+			container.activate(key, 5);
+			container.activate(parent, 1);
+			container.activate(ctx, 1);
+		}
+		KeyListener ret = new SingleKeyListener(key.getNodeKey().cloneKey(), this, !ctx.cacheLocalRequests, parent.getPriorityClass(), persistent);
+		if(persistent) {
+			container.deactivate(key, 5);
+			container.deactivate(parent, 1);
+			container.deactivate(ctx, 1);
+		}
+		return ret;
+	}
+	
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>559168</refactoring_id><commit_sha>ce5a7e5ee4c880081faef3a508f68725d0317ee9</commit_sha><commit_link>https://github.com/lawnchairlauncher/lawnchair/commit/ce5a7e5ee4c880081faef3a508f68725d0317ee9</commit_link><file_path>src/com/android/launcher3/LauncherStateTransitionAnimation.java</file_path><description>Remove Parameter toWorkspacePage : int in method private startAnimationToWorkspaceFromOverlay(toWorkspaceState Workspace.State, toWorkspacePage int, fromView View, contentView View, revealView View, overlaySearchBarView View, animated boolean, onCompleteRunnable Runnable, pCb PrivateTransitionCallbacks) : void from class com.android.launcher3.LauncherStateTransitionAnimation</description><code_before>@@ -182,7 +182,6 @@ public void onAnimationEnd(Animator animation) {
      */
     public void startAnimationToWidgets(final boolean animated) {
         final WidgetsContainerView toView = mLauncher.getWidgetsView();
-        final Resources res = mLauncher.getResources();
         PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks() {
             @Override
             public void onRevealViewVisible(View revealView, View contentView,
@@ -206,7 +205,7 @@ public float getMaterialRevealViewFinalYDrift(View revealView) {
      * Starts and animation to the workspace from the current overlay view.
      */
     public void startAnimationToWorkspace(final Launcher.State fromState,
-              final Workspace.State toWorkspaceState, final int toWorkspacePage,
               final boolean animated, final Runnable onCompleteRunnable) {
         if (toWorkspaceState != Workspace.State.NORMAL &amp;&amp;
                 toWorkspaceState != Workspace.State.SPRING_LOADED &amp;&amp;
@@ -215,11 +214,9 @@ public void startAnimationToWorkspace(final Launcher.State fromState,
         }
 
         if (fromState == Launcher.State.APPS || fromState == Launcher.State.APPS_SPRING_LOADED) {
-            startAnimationToWorkspaceFromAllApps(toWorkspaceState, toWorkspacePage,
-                    animated, onCompleteRunnable);
         } else {
-            startAnimationToWorkspaceFromWidgets(toWorkspaceState, toWorkspacePage,
-                    animated, onCompleteRunnable);
         }
     }
 
@@ -250,7 +247,7 @@ private void startAnimationToOverlay(final Workspace.State toWorkspaceState, fin
 
         // Create the workspace animation.
         // NOTE: this call apparently also sets the state for the workspace if !animated
-        Animator workspaceAnim = mLauncher.startWorkspaceStateChangeAnimation(toWorkspaceState, -1,
                 animated, overlaySearchBarView != null /* hasOverlaySearchBar */, layerViews);
 
         if (animated &amp;&amp; initialized) {
@@ -435,7 +432,7 @@ public void run() {
      * Starts and animation to the workspace from the apps view.
      */
     private void startAnimationToWorkspaceFromAllApps(final Workspace.State toWorkspaceState,
-            final int toWorkspacePage, final boolean animated, final Runnable onCompleteRunnable) {
         AllAppsContainerView appsView = mLauncher.getAppsView();
         PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks() {
             int[] mAllAppsToPanelDelta;
@@ -487,18 +484,17 @@ public void onAnimationEnd(Animator animation) {
             }
         };
         // Only animate the search bar if animating to spring loaded mode from all apps
-        startAnimationToWorkspaceFromOverlay(toWorkspaceState, toWorkspacePage, appsView,
-                appsView.getContentView(), appsView.getRevealView(), appsView.getSearchBarView(),
                 animated, onCompleteRunnable, cb);
     }
 
     /**
      * Starts and animation to the workspace from the widgets view.
      */
     private void startAnimationToWorkspaceFromWidgets(final Workspace.State toWorkspaceState,
-              final int toWorkspacePage, final boolean animated, final Runnable onCompleteRunnable) {
         final WidgetsContainerView widgetsView = mLauncher.getWidgetsView();
-        final Resources res = mLauncher.getResources();
         PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks() {
             @Override
             public void onRevealViewVisible(View revealView, View contentView,
@@ -523,7 +519,7 @@ public void onAnimationEnd(Animator animation) {
                 };
             }
         };
-        startAnimationToWorkspaceFromOverlay(toWorkspaceState, toWorkspacePage, widgetsView,
                 widgetsView.getContentView(), widgetsView.getRevealView(), null, animated,
                 onCompleteRunnable, cb);
     }
@@ -532,7 +528,7 @@ public void onAnimationEnd(Animator animation) {
      * Creates and starts a new animation to the workspace.
      */
     private void startAnimationToWorkspaceFromOverlay(final Workspace.State toWorkspaceState,
-              final int toWorkspacePage, final View fromView, final View contentView,
               final View revealView, final View overlaySearchBarView, final boolean animated,
               final Runnable onCompleteRunnable, final PrivateTransitionCallbacks pCb) {
         final Resources res = mLauncher.getResources();
@@ -555,7 +551,7 @@ private void startAnimationToWorkspaceFromOverlay(final Workspace.State toWorksp
         // Create the workspace animation.
         // NOTE: this call apparently also sets the state for the workspace if !animated
         Animator workspaceAnim = mLauncher.startWorkspaceStateChangeAnimation(toWorkspaceState,
-                toWorkspacePage, animated, overlaySearchBarView != null /* hasOverlaySearchBar */,
                 layerViews);
 
         if (animated &amp;&amp; initialized) {
</code_before><code_after>@@ -182,7 +182,6 @@ public void onAnimationEnd(Animator animation) {
      */
     public void startAnimationToWidgets(final boolean animated) {
         final WidgetsContainerView toView = mLauncher.getWidgetsView();
         PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks() {
             @Override
             public void onRevealViewVisible(View revealView, View contentView,
@@ -206,7 +205,7 @@ public float getMaterialRevealViewFinalYDrift(View revealView) {
      * Starts and animation to the workspace from the current overlay view.
      */
     public void startAnimationToWorkspace(final Launcher.State fromState,
+              final Workspace.State toWorkspaceState,
               final boolean animated, final Runnable onCompleteRunnable) {
         if (toWorkspaceState != Workspace.State.NORMAL &amp;&amp;
                 toWorkspaceState != Workspace.State.SPRING_LOADED &amp;&amp;
@@ -215,11 +214,9 @@ public void startAnimationToWorkspace(final Launcher.State fromState,
         }
 
         if (fromState == Launcher.State.APPS || fromState == Launcher.State.APPS_SPRING_LOADED) {
+            startAnimationToWorkspaceFromAllApps(toWorkspaceState, animated, onCompleteRunnable);
         } else {
+            startAnimationToWorkspaceFromWidgets(toWorkspaceState, animated, onCompleteRunnable);
         }
     }
 
@@ -250,7 +247,7 @@ private void startAnimationToOverlay(final Workspace.State toWorkspaceState, fin
 
         // Create the workspace animation.
         // NOTE: this call apparently also sets the state for the workspace if !animated
+        Animator workspaceAnim = mLauncher.startWorkspaceStateChangeAnimation(toWorkspaceState,
                 animated, overlaySearchBarView != null /* hasOverlaySearchBar */, layerViews);
 
         if (animated &amp;&amp; initialized) {
@@ -435,7 +432,7 @@ public void run() {
      * Starts and animation to the workspace from the apps view.
      */
     private void startAnimationToWorkspaceFromAllApps(final Workspace.State toWorkspaceState,
+            final boolean animated, final Runnable onCompleteRunnable) {
         AllAppsContainerView appsView = mLauncher.getAppsView();
         PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks() {
             int[] mAllAppsToPanelDelta;
@@ -487,18 +484,17 @@ public void onAnimationEnd(Animator animation) {
             }
         };
         // Only animate the search bar if animating to spring loaded mode from all apps
+        startAnimationToWorkspaceFromOverlay(toWorkspaceState, appsView, appsView.getContentView(),
+                appsView.getRevealView(), appsView.getSearchBarView(),
                 animated, onCompleteRunnable, cb);
     }
 
     /**
      * Starts and animation to the workspace from the widgets view.
      */
     private void startAnimationToWorkspaceFromWidgets(final Workspace.State toWorkspaceState,
+              final boolean animated, final Runnable onCompleteRunnable) {
         final WidgetsContainerView widgetsView = mLauncher.getWidgetsView();
         PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks() {
             @Override
             public void onRevealViewVisible(View revealView, View contentView,
@@ -523,7 +519,7 @@ public void onAnimationEnd(Animator animation) {
                 };
             }
         };
+        startAnimationToWorkspaceFromOverlay(toWorkspaceState, widgetsView,
                 widgetsView.getContentView(), widgetsView.getRevealView(), null, animated,
                 onCompleteRunnable, cb);
     }
@@ -532,7 +528,7 @@ public void onAnimationEnd(Animator animation) {
      * Creates and starts a new animation to the workspace.
      */
     private void startAnimationToWorkspaceFromOverlay(final Workspace.State toWorkspaceState,
+              final View fromView, final View contentView,
               final View revealView, final View overlaySearchBarView, final boolean animated,
               final Runnable onCompleteRunnable, final PrivateTransitionCallbacks pCb) {
         final Resources res = mLauncher.getResources();
@@ -555,7 +551,7 @@ private void startAnimationToWorkspaceFromOverlay(final Workspace.State toWorksp
         // Create the workspace animation.
         // NOTE: this call apparently also sets the state for the workspace if !animated
         Animator workspaceAnim = mLauncher.startWorkspaceStateChangeAnimation(toWorkspaceState,
+                animated, overlaySearchBarView != null /* hasOverlaySearchBar */,
                 layerViews);
 
         if (animated &amp;&amp; initialized) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>506498</refactoring_id><commit_sha>0d88835670241ba9b4859f41098bec0889ddf801</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/0d88835670241ba9b4859f41098bec0889ddf801</commit_link><file_path>src/main/java/com/google/devtools/build/lib/rules/proto/ProtoCompileActionBuilder.java</file_path><description>Remove Parameter langPrefix : String in method public ProtoCompileActionBuilder(protoInfo ProtoInfo, protoCompiler FilesToRunProvider, progressMessage String, langPrefix String, outputs Iterable&lt;Artifact&gt;) from class com.google.devtools.build.lib.rules.proto.ProtoCompileActionBuilder</description><code_before>@@ -66,11 +66,12 @@ public class ProtoCompileActionBuilder {
   private final ProtoInfo protoInfo;
   private final FilesToRunProvider protoCompiler;
   private final String progressMessage;
-  private final String langPrefix;
   private final Iterable&lt;Artifact&gt; outputs;
   private Iterable&lt;Artifact&gt; inputs;
   private FilesToRunProvider langPlugin;
   private Supplier&lt;String&gt; langPluginParameter;
   private boolean hasServices;
   private Iterable&lt;String&gt; additionalCommandLineArguments;
   private Iterable&lt;FilesToRunProvider&gt; additionalTools;
@@ -87,8 +88,10 @@ public ProtoCompileActionBuilder setInputs(Iterable&lt;Artifact&gt; inputs) {
     return this;
   }
 
-  public ProtoCompileActionBuilder setLangPlugin(FilesToRunProvider langPlugin) {
     this.langPlugin = langPlugin;
     return this;
   }
 
@@ -97,8 +100,10 @@ public ProtoCompileActionBuilder setMnemonic(String mnemonic) {
     return this;
   }
 
-  public ProtoCompileActionBuilder setLangPluginParameter(Supplier&lt;String&gt; langPluginParameter) {
     this.langPluginParameter = langPluginParameter;
     return this;
   }
 
@@ -123,12 +128,10 @@ public ProtoCompileActionBuilder(
       ProtoInfo protoInfo,
       FilesToRunProvider protoCompiler,
       String progressMessage,
-      String langPrefix,
       Iterable&lt;Artifact&gt; outputs) {
     this.protoInfo = protoInfo;
     this.protoCompiler = protoCompiler;
     this.progressMessage = progressMessage;
-    this.langPrefix = langPrefix;
     this.outputs = outputs;
     this.mnemonic = DEFAULT_MNEMONIC;
   }
@@ -172,14 +175,11 @@ public void maybeRegister(RuleContext ruleContext)
     if (langPlugin != null &amp;&amp; langPlugin.getExecutable() != null) {
       // We pass a separate langPlugin as there are plugins that cannot be overridden
       // and thus we have to deal with "$xx_plugin" and "xx_plugin".
-      additionalArgs.add(
-          Tuple.of(
-              langPlugin.getExecutable(), String.format("--plugin=protoc-gen-%s=%%s", langPrefix)));
     }
 
     if (langPluginParameter != null) {
-      additionalArgs.add(
-          Tuple.of(langPluginParameter.get(), String.format("--%s_out=%%s", langPrefix)));
     }
 
     if (!hasServices) {
</code_before><code_after>@@ -66,11 +66,12 @@ public class ProtoCompileActionBuilder {
   private final ProtoInfo protoInfo;
   private final FilesToRunProvider protoCompiler;
   private final String progressMessage;
   private final Iterable&lt;Artifact&gt; outputs;
   private Iterable&lt;Artifact&gt; inputs;
   private FilesToRunProvider langPlugin;
+  private String langPluginFormat;
   private Supplier&lt;String&gt; langPluginParameter;
+  private String langPluginParameterFormat;
   private boolean hasServices;
   private Iterable&lt;String&gt; additionalCommandLineArguments;
   private Iterable&lt;FilesToRunProvider&gt; additionalTools;
@@ -87,8 +88,10 @@ public ProtoCompileActionBuilder setInputs(Iterable&lt;Artifact&gt; inputs) {
     return this;
   }
 
+  public ProtoCompileActionBuilder setLangPlugin(
+      FilesToRunProvider langPlugin, String langPluginFormat) {
     this.langPlugin = langPlugin;
+    this.langPluginFormat = langPluginFormat;
     return this;
   }
 
@@ -97,8 +100,10 @@ public ProtoCompileActionBuilder setMnemonic(String mnemonic) {
     return this;
   }
 
+  public ProtoCompileActionBuilder setLangPluginParameter(
+      Supplier&lt;String&gt; langPluginParameter, String langPluginParameterFormat) {
     this.langPluginParameter = langPluginParameter;
+    this.langPluginParameterFormat = langPluginParameterFormat;
     return this;
   }
 
@@ -123,12 +128,10 @@ public ProtoCompileActionBuilder(
       ProtoInfo protoInfo,
       FilesToRunProvider protoCompiler,
       String progressMessage,
       Iterable&lt;Artifact&gt; outputs) {
     this.protoInfo = protoInfo;
     this.protoCompiler = protoCompiler;
     this.progressMessage = progressMessage;
     this.outputs = outputs;
     this.mnemonic = DEFAULT_MNEMONIC;
   }
@@ -172,14 +175,11 @@ public void maybeRegister(RuleContext ruleContext)
     if (langPlugin != null &amp;&amp; langPlugin.getExecutable() != null) {
       // We pass a separate langPlugin as there are plugins that cannot be overridden
       // and thus we have to deal with "$xx_plugin" and "xx_plugin".
+      additionalArgs.add(Tuple.of(langPlugin.getExecutable(), langPluginFormat));
     }
 
     if (langPluginParameter != null) {
+      additionalArgs.add(Tuple.of(langPluginParameter.get(), langPluginParameterFormat));
     }
 
     if (!hasServices) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>469786</refactoring_id><commit_sha>57a1559ff5b2ec74c2b1d7de4ac7c1fcdad1ebc2</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/57a1559ff5b2ec74c2b1d7de4ac7c1fcdad1ebc2</commit_link><file_path>activiti-webapp-explorer2/src/main/java/org/activiti/explorer/ui/task/TaskDetailPanel.java</file_path><description>Remove Parameter viewManager : ViewManager in method public TaskDetailPanel(viewManager ViewManager, taskId String) from class org.activiti.explorer.ui.task.TaskDetailPanel</description><code_before>@@ -16,7 +16,8 @@
 import org.activiti.engine.TaskService;
 import org.activiti.engine.task.Task;
 import org.activiti.explorer.Constants;
-import org.activiti.explorer.ui.ViewManager;
 import org.activiti.explorer.ui.profile.ProfilePopupWindow;
 
 import com.ocpsoft.pretty.time.PrettyTime;
@@ -40,16 +41,14 @@ public class TaskDetailPanel extends HorizontalLayout {
   
   private static final long serialVersionUID = -2018798598805436750L;
   
-  protected ViewManager viewManager;
   protected TaskService taskService;
   protected Task task;
   
   protected Panel leftPanel;
   protected Panel rightPanel;
   
-  public TaskDetailPanel(ViewManager viewManager, String taskId) {
     super();
-    this.viewManager = viewManager;
     setSizeFull();
     addStyleName(Reindeer.LAYOUT_WHITE);
     
@@ -69,7 +68,7 @@ public TaskDetailPanel(ViewManager viewManager, String taskId) {
     
     
     // Right panel: the task comments
-    this.rightPanel = new TaskCommentPanel(viewManager, taskId);
     rightPanel.addStyleName(Reindeer.PANEL_LIGHT);
     addComponent(rightPanel);
     setExpandRatio(rightPanel, 25.0f);
@@ -110,7 +109,7 @@ protected void initTimeDetails() {
     timeDetailsLayout.setSizeUndefined();
     leftPanel.addComponent(timeDetailsLayout);
 
-    Embedded clockImage = new Embedded(null, new ThemeResource(Constants.IMAGE_CLOCK));
     timeDetailsLayout.addComponent(clockImage);
 
     // The other time fields are layed out in a 2 column grid
@@ -162,7 +161,7 @@ protected void initPeopleDetails() {
     leftPanel.addComponent(layout);
     
     // people icon
-    Embedded peopleImage = new Embedded(null, new ThemeResource(Constants.IMAGE_PEOPLE));
     layout.addComponent(peopleImage);
     
     // The involved people are layed out in a grid with two rows
@@ -180,7 +179,7 @@ protected void initPeopleDetails() {
       owner.addStyleName(Reindeer.BUTTON_LINK);
       owner.addListener(new ClickListener() {
         public void buttonClick(ClickEvent event) {
-          viewManager.showPopupWindow(new ProfilePopupWindow(viewManager, task.getOwner()));
         }
       });
       
@@ -193,7 +192,7 @@ public void buttonClick(ClickEvent event) {
       assignee.addStyleName(Reindeer.BUTTON_LINK);
       assignee.addListener(new ClickListener() {
         public void buttonClick(ClickEvent event) {
-          viewManager.showPopupWindow(new ProfilePopupWindow(viewManager, task.getAssignee()));
         }
       });
       grid.addComponent(assignee);
</code_before><code_after>@@ -16,7 +16,8 @@
 import org.activiti.engine.TaskService;
 import org.activiti.engine.task.Task;
 import org.activiti.explorer.Constants;
+import org.activiti.explorer.ExplorerApplication;
+import org.activiti.explorer.Images;
 import org.activiti.explorer.ui.profile.ProfilePopupWindow;
 
 import com.ocpsoft.pretty.time.PrettyTime;
@@ -40,16 +41,14 @@ public class TaskDetailPanel extends HorizontalLayout {
   
   private static final long serialVersionUID = -2018798598805436750L;
   
   protected TaskService taskService;
   protected Task task;
   
   protected Panel leftPanel;
   protected Panel rightPanel;
   
+  public TaskDetailPanel(String taskId) {
     super();
     setSizeFull();
     addStyleName(Reindeer.LAYOUT_WHITE);
     
@@ -69,7 +68,7 @@ public TaskDetailPanel(ViewManager viewManager, String taskId) {
     
     
     // Right panel: the task comments
+    this.rightPanel = new TaskCommentPanel(taskId);
     rightPanel.addStyleName(Reindeer.PANEL_LIGHT);
     addComponent(rightPanel);
     setExpandRatio(rightPanel, 25.0f);
@@ -110,7 +109,7 @@ protected void initTimeDetails() {
     timeDetailsLayout.setSizeUndefined();
     leftPanel.addComponent(timeDetailsLayout);
 
+    Embedded clockImage = new Embedded(null, Images.CLOCK);
     timeDetailsLayout.addComponent(clockImage);
 
     // The other time fields are layed out in a 2 column grid
@@ -162,7 +161,7 @@ protected void initPeopleDetails() {
     leftPanel.addComponent(layout);
     
     // people icon
+    Embedded peopleImage = new Embedded(null, Images.PEOPLE);
     layout.addComponent(peopleImage);
     
     // The involved people are layed out in a grid with two rows
@@ -180,7 +179,7 @@ protected void initPeopleDetails() {
       owner.addStyleName(Reindeer.BUTTON_LINK);
       owner.addListener(new ClickListener() {
         public void buttonClick(ClickEvent event) {
+          ExplorerApplication.getCurrent().showPopupWindow(new ProfilePopupWindow(task.getOwner()));
         }
       });
       
@@ -193,7 +192,7 @@ public void buttonClick(ClickEvent event) {
       assignee.addStyleName(Reindeer.BUTTON_LINK);
       assignee.addListener(new ClickListener() {
         public void buttonClick(ClickEvent event) {
+          ExplorerApplication.getCurrent().showPopupWindow(new ProfilePopupWindow(task.getAssignee()));
         }
       });
       grid.addComponent(assignee);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>571072</refactoring_id><commit_sha>21b71f6ba7a14af3b5e4e31fa49b3547587e553b</commit_sha><commit_link>https://github.com/hyphanet/fred/commit/21b71f6ba7a14af3b5e4e31fa49b3547587e553b</commit_link><file_path>src/freenet/client/async/ClientGetter.java</file_path><description>Remove Parameter sskSched : RequestScheduler in method public ClientGetter(client ClientCallback, chkSched RequestScheduler, sskSched RequestScheduler, uri FreenetURI, ctx FetchContext, priorityClass short, clientContext RequestClient, returnBucket Bucket, binaryBlobBucket Bucket) from class freenet.client.async.ClientGetter</description><code_before>@@ -61,7 +61,7 @@ public class ClientGetter extends BaseClientGetter {
 	 * write the data directly to the bucket, or copy it and free the original temporary bucket. Preferably the
 	 * former, obviously!
 	 */
-	public ClientGetter(ClientCallback client, RequestScheduler chkSched, RequestScheduler sskSched,
 			    FreenetURI uri, FetchContext ctx, short priorityClass, RequestClient clientContext, Bucket returnBucket, Bucket binaryBlobBucket) {
 		super(priorityClass, clientContext);
 		this.clientCallback = client;
</code_before><code_after>@@ -61,7 +61,7 @@ public class ClientGetter extends BaseClientGetter {
 	 * write the data directly to the bucket, or copy it and free the original temporary bucket. Preferably the
 	 * former, obviously!
 	 */
+	public ClientGetter(ClientCallback client, 
 			    FreenetURI uri, FetchContext ctx, short priorityClass, RequestClient clientContext, Bucket returnBucket, Bucket binaryBlobBucket) {
 		super(priorityClass, clientContext);
 		this.clientCallback = client;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>532962</refactoring_id><commit_sha>4658623886971a68cc894e5405c6b3406b0e7fe3</commit_sha><commit_link>https://github.com/apache/tomcat/commit/4658623886971a68cc894e5405c6b3406b0e7fe3</commit_link><file_path>java/org/apache/tomcat/util/bcel/classfile/ConstantInvokeDynamic.java</file_path><description>Remove Parameter name_and_type_index : int in method public ConstantInvokeDynamic(bootstrap_method_attr_index int, name_and_type_index int) from class org.apache.tomcat.util.bcel.classfile.ConstantInvokeDynamic</description><code_before>@@ -32,8 +32,6 @@
 public final class ConstantInvokeDynamic extends Constant {
 
     private static final long serialVersionUID = 4310367359017396174L;
-    private int bootstrap_method_attr_index;
-    private int name_and_type_index;
 
 
     /**
@@ -43,24 +41,13 @@ public final class ConstantInvokeDynamic extends Constant {
      * @throws IOException
      */
     ConstantInvokeDynamic(DataInput file) throws IOException {
-        this(file.readUnsignedShort(), file.readUnsignedShort());
     }
 
 
-    public ConstantInvokeDynamic(int bootstrap_method_attr_index,
-            int name_and_type_index) {
         super(Constants.CONSTANT_InvokeDynamic);
-        this.bootstrap_method_attr_index = bootstrap_method_attr_index;
-        this.name_and_type_index = name_and_type_index;
-    }
-
-
-    public int getBootstrapMethodAttrIndex() {
-        return bootstrap_method_attr_index;
-    }
-
-
-    public int getNameAndTypeIndex() {
-        return name_and_type_index;
     }
 }
</code_before><code_after>@@ -32,8 +32,6 @@
 public final class ConstantInvokeDynamic extends Constant {
 
     private static final long serialVersionUID = 4310367359017396174L;
 
 
     /**
@@ -43,24 +41,13 @@ public final class ConstantInvokeDynamic extends Constant {
      * @throws IOException
      */
     ConstantInvokeDynamic(DataInput file) throws IOException {
+        this();
+        file.readUnsignedShort();
+        file.readUnsignedShort();
     }
 
 
+    public ConstantInvokeDynamic() {
         super(Constants.CONSTANT_InvokeDynamic);
     }
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>487162</refactoring_id><commit_sha>8d59596bc1a6985fe58696ae630daa82bd2a9688</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/8d59596bc1a6985fe58696ae630daa82bd2a9688</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/store/format/BaseOneByteHeaderRecordFormat.java</file_path><description>Remove Parameter storeFile : PagedFile in method public write(record RECORD, cursor PageCursor, recordSize int, storeFile PagedFile) : void from class org.neo4j.kernel.impl.store.format.BaseOneByteHeaderRecordFormat</description><code_before>@@ -19,15 +19,11 @@
  */
 package org.neo4j.kernel.impl.store.format;
 
-import java.io.IOException;
 import java.util.function.Function;
 
 import org.neo4j.io.pagecache.PageCursor;
-import org.neo4j.io.pagecache.PagedFile;
-import org.neo4j.kernel.impl.store.RecordStore;
 import org.neo4j.kernel.impl.store.StoreHeader;
 import org.neo4j.kernel.impl.store.record.AbstractBaseRecord;
-import org.neo4j.kernel.impl.store.record.RecordLoad;
 
 /**
  * Implementation of a very common type of format where the first byte, at least one bit in it,
@@ -38,72 +34,32 @@
  */
 public abstract class BaseOneByteHeaderRecordFormat&lt;RECORD extends AbstractBaseRecord&gt; extends BaseRecordFormat&lt;RECORD&gt;
 {
     protected BaseOneByteHeaderRecordFormat( Function&lt;StoreHeader,Integer&gt; recordSize, int recordHeaderSize,
             int inUseBitMaskForFirstByte )
     {
-        super( recordSize, recordHeaderSize, inUseBitMaskForFirstByte );
     }
 
-    @Override
-    public final void read( RECORD record, PageCursor cursor, RecordLoad mode, int recordSize, PagedFile storeFile )
-            throws IOException
     {
-        byte headerByte = cursor.getByte();
-        boolean inUse = isInUse( headerByte );
-        if ( mode.shouldLoad( inUse ) )
-        {
-            doRead( record, cursor, recordSize, storeFile, headerByte, inUse );
-        }
     }
 
-    /**
-     * Reads contents at {@code cursor} into the given record. This method is only called if the {@link RecordLoad}
-     * mode in {@link #read(AbstractBaseRecord, PageCursor, RecordLoad, int, PagedFile)} thinks it's OK to load the
-     * record, given its inUse status.
-     *
-     * @param record to put read data into, replacing any existing data in that record object.
-     * @param cursor {@link PageCursor} to read data from.
-     * See {@link RecordStore#getRecord(long, AbstractBaseRecord, RecordLoad)} for more information.
-     * @param recordSize size of records of this format. This is passed in like this since not all formats
-     * know the record size in advance, but may be read from store header when opening the store.
-     * @param storeFile {@link PagedFile} to get additional {@link PageCursor} from, if need be.
-     * @param headerByte the first byte read, in order to determine inUse status and other header flags.
-     * @param inUse whether or not the record is in use. Keep in mind that this method may be called
-     * even on an unused record, depending on {@link RecordLoad} mode.
-     * @throws IOException on error reading.
-     */
-    protected abstract void doRead( RECORD record, PageCursor cursor, int recordSize, PagedFile storeFile,
-            long headerByte, boolean inUse ) throws IOException;
-
     @Override
-    public final void write( RECORD record, PageCursor cursor, int recordSize, PagedFile storeFile )
-            throws IOException
     {
-        if ( record.inUse() )
-        {
-            doWrite( record, cursor, recordSize, storeFile );
-        }
-        else
-        {
-            byte inUseByte = cursor.getByte( cursor.getOffset() );
-            inUseByte &amp;= ~inUseBitMaskForFirstByte;
-            cursor.putByte( inUseByte );
-        }
     }
 
-    /**
-     * Writes record contents to the {@code cursor} in the format specified by this implementation if
-     * the record is {@link AbstractBaseRecord#inUse()}, otherwise only the inUse bit is cleared and the
-     * rest of the bytes in the record left untouched.
-     *
-     * @param record containing data to write.
-     * @param cursor {@link PageCursor} to write the record data into.
-     * @param recordSize size of records of this format. This is passed in like this since not all formats
-     * know the record size in advance, but may be read from store header when opening the store.
-     * @throws IOException on error writing.
-     */
-    protected abstract void doWrite( RECORD record, PageCursor cursor, int recordSize, PagedFile storeFile )
-            throws IOException;
 
     protected static boolean has( long headerByte, int bitMask )
     {
</code_before><code_after>@@ -19,15 +19,11 @@
  */
 package org.neo4j.kernel.impl.store.format;
 
 import java.util.function.Function;
 
 import org.neo4j.io.pagecache.PageCursor;
 import org.neo4j.kernel.impl.store.StoreHeader;
 import org.neo4j.kernel.impl.store.record.AbstractBaseRecord;
 
 /**
  * Implementation of a very common type of format where the first byte, at least one bit in it,
@@ -38,72 +34,32 @@
  */
 public abstract class BaseOneByteHeaderRecordFormat&lt;RECORD extends AbstractBaseRecord&gt; extends BaseRecordFormat&lt;RECORD&gt;
 {
+    private final int inUseBitMaskForFirstByte;
+
     protected BaseOneByteHeaderRecordFormat( Function&lt;StoreHeader,Integer&gt; recordSize, int recordHeaderSize,
             int inUseBitMaskForFirstByte )
     {
+        super( recordSize, recordHeaderSize );
+        this.inUseBitMaskForFirstByte = inUseBitMaskForFirstByte;
     }
 
+    protected void markFirstByteAsUnused( PageCursor cursor )
     {
+        byte inUseByte = cursor.getByte( cursor.getOffset() );
+        inUseByte &amp;= ~inUseBitMaskForFirstByte;
+        cursor.putByte( inUseByte );
     }
 
     @Override
+    public boolean isInUse( PageCursor cursor )
     {
+        return isInUse( cursor.getByte( cursor.getOffset() ) );
     }
 
+    protected boolean isInUse( byte firstByte )
+    {
+        return (firstByte &amp; inUseBitMaskForFirstByte) != 0;
+    }
 
     protected static boolean has( long headerByte, int bitMask )
     {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>515216</refactoring_id><commit_sha>f9a791a10c741a0abbd79470bf43b0bd8f361830</commit_sha><commit_link>https://github.com/pmd/pmd/commit/f9a791a10c741a0abbd79470bf43b0bd8f361830</commit_link><file_path>pmd-ui/src/main/java/net/sourceforge/pmd/util/fxdesigner/util/codearea/NodeStyleSpan.java</file_path><description>Remove Parameter style : Collection&lt;String&gt; in method private NodeStyleSpan(node Node, style Collection&lt;String&gt;, codeArea CustomCodeArea) from class net.sourceforge.pmd.util.fxdesigner.util.codearea.NodeStyleSpan</description><code_before>@@ -5,30 +5,32 @@
 package net.sourceforge.pmd.util.fxdesigner.util.codearea;
 
 import java.util.Collection;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.fxmisc.richtext.model.Paragraph;
-import org.fxmisc.richtext.model.StyleSpan;
 
 import net.sourceforge.pmd.lang.ast.Node;
 
 
 /**
  * @author Cl&#xE9;ment Fournier
  * @since 6.5.0
  */
 public class NodeStyleSpan {
 
     private static final Pattern TAB_INDENT = Pattern.compile("^(\t*).*$");
     private final Node node;
-    private final Collection&lt;String&gt; style;
     private final CustomCodeArea codeArea;
 
 
-    private NodeStyleSpan(Node node, Collection&lt;String&gt; style, CustomCodeArea codeArea) {
         this.node = node;
-        this.style = style;
         this.codeArea = codeArea;
     }
 
@@ -39,12 +41,11 @@ public Node getNode() {
 
 
     /**
-     * Snapshots the node's position, which factors-in changes to the nodes's position
-     * that occurred since the node was parsed.
      */
     public PositionSnapshot snapshot() {
         try {
-
             int lastKnownStart = getAbsolutePosition(node.getBeginLine(), node.getBeginColumn() - 1);
             int lastKnownEnd = getAbsolutePosition(node.getEndLine(), node.getEndColumn());
             return new PositionSnapshot(lastKnownStart, lastKnownEnd);
@@ -55,12 +56,6 @@ public PositionSnapshot snapshot() {
 
     }
 
-
-    public Collection&lt;String&gt; getStyle() {
-        return style;
-    }
-
-
     private int getAbsolutePosition(int line, int column) {
         return codeArea.getAbsolutePosition(line - 1, column) - indentationOffset(line - 1);
     }
@@ -84,8 +79,17 @@ public String toString() {
     }
 
 
-    public static NodeStyleSpan fromNode(Node node, Collection&lt;String&gt; styles, CustomCodeArea codeArea) {
-        return new NodeStyleSpan(node, styles, codeArea);
     }
 
 
@@ -100,23 +104,18 @@ private PositionSnapshot(int beginIndex, int endIndex) {
         }
 
 
-        public PositionSnapshot update() {
-            PositionSnapshot newSnap = NodeStyleSpan.this.snapshot();
-            beginIndex = newSnap.beginIndex;
-            endIndex = newSnap.endIndex;
-            return this;
-        }
-
         @Override
         public String toString() {
             // debug only
             return getText() + "@[" + beginIndex + "," + endIndex + ']';
         }
 
         private String getText() {
             return codeArea.getText(beginIndex, endIndex);
         }
 
         public int getBeginIndex() {
             return beginIndex;
         }
@@ -131,18 +130,5 @@ public int getLength() {
             return endIndex - beginIndex;
         }
 
-        //        public boolean isBefore(PositionSnapshot other) {
-        //            return other.getBeginIndex()
-        //        }
-
-
-        public Collection&lt;String&gt; getStyle() {
-            return NodeStyleSpan.this.getStyle();
-        }
-
-
-        public StyleSpan&lt;Collection&lt;String&gt;&gt; toSpan() {
-            return new StyleSpan&lt;&gt;(getStyle(), getLength());
-        }
     }
 }
</code_before><code_after>@@ -5,30 +5,32 @@
 package net.sourceforge.pmd.util.fxdesigner.util.codearea;
 
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.fxmisc.richtext.model.Paragraph;
 
 import net.sourceforge.pmd.lang.ast.Node;
 
 
 /**
+ * Wrapper around a node used to declutter the layering algorithm with
+ * convenience methods. See {@link #snapshot()}.
+ *
  * @author Cl&#xE9;ment Fournier
  * @since 6.5.0
  */
 public class NodeStyleSpan {
 
     private static final Pattern TAB_INDENT = Pattern.compile("^(\t*).*$");
+    private static final Comparator&lt;NodeStyleSpan&gt; COMPARATOR = Comparator.comparing(NodeStyleSpan::getNode, Comparator.comparingInt(Node::getBeginLine).thenComparing(Node::getBeginColumn));
     private final Node node;
     private final CustomCodeArea codeArea;
 
 
+    private NodeStyleSpan(Node node, CustomCodeArea codeArea) {
         this.node = node;
         this.codeArea = codeArea;
     }
 
@@ -39,12 +41,11 @@ public Node getNode() {
 
 
     /**
+     * Snapshots the absolute coordinates of the node in the code area
+     * for the duration of the layering algorithm.
      */
     public PositionSnapshot snapshot() {
         try {
             int lastKnownStart = getAbsolutePosition(node.getBeginLine(), node.getBeginColumn() - 1);
             int lastKnownEnd = getAbsolutePosition(node.getEndLine(), node.getEndColumn());
             return new PositionSnapshot(lastKnownStart, lastKnownEnd);
@@ -55,12 +56,6 @@ public PositionSnapshot snapshot() {
 
     }
 
     private int getAbsolutePosition(int line, int column) {
         return codeArea.getAbsolutePosition(line - 1, column) - indentationOffset(line - 1);
     }
@@ -84,8 +79,17 @@ public String toString() {
     }
 
 
+    /**
+     * Returns a comparator that orders spans according to the start
+     * index of the node they wrap.
+     */
+    public static Comparator&lt;NodeStyleSpan&gt; documentOrderComparator() {
+        return COMPARATOR;
+    }
+
+
+    public static NodeStyleSpan fromNode(Node node, CustomCodeArea codeArea) {
+        return new NodeStyleSpan(node, codeArea);
     }
 
 
@@ -100,23 +104,18 @@ private PositionSnapshot(int beginIndex, int endIndex) {
         }
 
 
         @Override
         public String toString() {
             // debug only
             return getText() + "@[" + beginIndex + "," + endIndex + ']';
         }
 
+
         private String getText() {
             return codeArea.getText(beginIndex, endIndex);
         }
 
+
         public int getBeginIndex() {
             return beginIndex;
         }
@@ -131,18 +130,5 @@ public int getLength() {
             return endIndex - beginIndex;
         }
 
     }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>541196</refactoring_id><commit_sha>11fe7811ba06e6e71eb37b17fbb7984ec08f5b3e</commit_sha><commit_link>https://github.com/stanfordnlp/corenlp/commit/11fe7811ba06e6e71eb37b17fbb7984ec08f5b3e</commit_link><file_path>src/edu/stanford/nlp/trees/GrammaticalStructure.java</file_path><description>Remove Parameter extraTreeDepFilter : Filter&lt;TypedDependency&gt; in method private getTreeDeps(t TreeGraphNode, basicDep List&lt;TypedDependency&gt;, puncTypedDepFilter Filter&lt;TypedDependency&gt;, extraTreeDepFilter Filter&lt;TypedDependency&gt;) : void from class edu.stanford.nlp.trees.GrammaticalStructure</description><code_before>@@ -265,7 +265,7 @@ private static void analyzeNode(TreeGraphNode t, TreeGraphNode root, Collection&lt;
    * @param getExtra If true, the list of typed dependencies will contain extra ones.
    *              If false, the list of typed dependencies will respect the tree structure.
    */
-  private List&lt;TypedDependency&gt; getDeps(boolean getExtra, Filter&lt;TypedDependency&gt; puncTypedDepFilter) {
     List&lt;TypedDependency&gt; basicDep = Generics.newArrayList();
 
     for (Dependency&lt;Label, Label, Object&gt; d : dependencies()) {
@@ -307,7 +307,7 @@ private List&lt;TypedDependency&gt; getDeps(boolean getExtra, Filter&lt;TypedDependency&gt;
     if (rootDep != null) {
       TypedDependency rootTypedDep =
         new TypedDependency(ROOT, dependencyRoot, rootDep);
-      if (puncTypedDepFilter.accept(rootTypedDep)) {
         basicDep.add(rootTypedDep);
       }
     }
@@ -316,26 +316,13 @@ private List&lt;TypedDependency&gt; getDeps(boolean getExtra, Filter&lt;TypedDependency&gt;
 
     if (getExtra) {
       getExtras(basicDep);
-      // adds stuff to basicDep based on the tregex patterns over the tree
-      getTreeDeps(root(), basicDep, puncTypedDepFilter, extraTreeDepFilter());
     }
     Collections.sort(basicDep);
 
     return basicDep;
   }
 
-  /**
-   * Returns a Filter which checks dependencies for usefulness as
-   * extra tree-based dependencies.  By default, everything is
-   * accepted.  One example of how this can be useful is in the
-   * English dependencies, where the REL dependency is used as an
-   * intermediate and we do not want this to be added when we make a
-   * second pass over the trees for missing dependencies.
-   */
-  protected Filter&lt;TypedDependency&gt; extraTreeDepFilter() {
-    return Filters.acceptFilter();
-  }
-
   /**
    * Post process the dependencies in whatever way this language
    * requires.  For example, English might replace "rel" dependencies
@@ -357,15 +344,14 @@ protected void getExtras(List&lt;TypedDependency&gt; basicDep) {
 
 
   /** Look through the tree t and adds to the List basicDep dependencies
-   *  which aren't in it but which satisfy the filter puncTypedDepFilter.
    *
    * @param t The tree to examine (not changed)
    * @param basicDep The list of dependencies which may be augmented
    * @param f Additional dependencies are added only if they pass this filter
    */
   private static void getTreeDeps(TreeGraphNode t, List&lt;TypedDependency&gt; basicDep,
-                                  Filter&lt;TypedDependency&gt; puncTypedDepFilter,
-                                  Filter&lt;TypedDependency&gt; extraTreeDepFilter) {
     if (t.isPhrasal()) {          // don't do leaves of POS tags (chris changed this from numChildren &gt; 0 in 2010)
       Map&lt;Class&lt;? extends GrammaticalRelationAnnotation&gt;, Set&lt;TreeGraphNode&gt;&gt; depMap = getAllDependents(t);
       for (Class&lt;? extends GrammaticalRelationAnnotation&gt; depName : depMap.keySet()) {
@@ -377,7 +363,7 @@ private static void getTreeDeps(TreeGraphNode t, List&lt;TypedDependency&gt; basicDep,
             if (!rels.isEmpty()) {
               for (GrammaticalRelation rel : rels) {
                 TypedDependency newDep = new TypedDependency(rel, gov, dep);
-                if (!basicDep.contains(newDep) &amp;&amp; puncTypedDepFilter.accept(newDep) &amp;&amp; extraTreeDepFilter.accept(newDep)) {
                   newDep.setExtra();
                   basicDep.add(newDep);
                 }
@@ -388,7 +374,7 @@ private static void getTreeDeps(TreeGraphNode t, List&lt;TypedDependency&gt; basicDep,
       }
       // now recurse into children
       for (Tree kid : t.children()) {
-        getTreeDeps((TreeGraphNode) kid, basicDep, puncTypedDepFilter, extraTreeDepFilter);
       }
     }
   }
@@ -697,7 +683,7 @@ public List&lt;TypedDependency&gt; typedDependenciesCollapsed(boolean includeExtras) {
     // nsubjs than they originally do.  If we wait until that occurs
     // to add xsubj for xcomp dependencies, we get better coverage.
     if (includeExtras) {
-      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter());
     }
     collapseDependencies(tdl, false, includeExtras);
     return tdl;
@@ -727,7 +713,7 @@ public List&lt;TypedDependency&gt; typedDependenciesCCprocessed(boolean includeExtras)
     // nsubjs than they originally do.  If we wait until that occurs
     // to add xsubj for xcomp dependencies, we get better coverage.
     if (includeExtras) {
-      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter());
     }
     collapseDependencies(tdl, true, includeExtras);
     return tdl;
</code_before><code_after>@@ -265,7 +265,7 @@ private static void analyzeNode(TreeGraphNode t, TreeGraphNode root, Collection&lt;
    * @param getExtra If true, the list of typed dependencies will contain extra ones.
    *              If false, the list of typed dependencies will respect the tree structure.
    */
+  private List&lt;TypedDependency&gt; getDeps(boolean getExtra, Filter&lt;TypedDependency&gt; f) {
     List&lt;TypedDependency&gt; basicDep = Generics.newArrayList();
 
     for (Dependency&lt;Label, Label, Object&gt; d : dependencies()) {
@@ -307,7 +307,7 @@ private List&lt;TypedDependency&gt; getDeps(boolean getExtra, Filter&lt;TypedDependency&gt;
     if (rootDep != null) {
       TypedDependency rootTypedDep =
         new TypedDependency(ROOT, dependencyRoot, rootDep);
+      if (f.accept(rootTypedDep)) {
         basicDep.add(rootTypedDep);
       }
     }
@@ -316,26 +316,13 @@ private List&lt;TypedDependency&gt; getDeps(boolean getExtra, Filter&lt;TypedDependency&gt;
 
     if (getExtra) {
       getExtras(basicDep);
+      getTreeDeps(root(), basicDep, f); // adds stuff to basicDep
     }
     Collections.sort(basicDep);
 
     return basicDep;
   }
 
   /**
    * Post process the dependencies in whatever way this language
    * requires.  For example, English might replace "rel" dependencies
@@ -357,15 +344,14 @@ protected void getExtras(List&lt;TypedDependency&gt; basicDep) {
 
 
   /** Look through the tree t and adds to the List basicDep dependencies
+   *  which aren't in it but which satisfy the filter f.
    *
    * @param t The tree to examine (not changed)
    * @param basicDep The list of dependencies which may be augmented
    * @param f Additional dependencies are added only if they pass this filter
    */
   private static void getTreeDeps(TreeGraphNode t, List&lt;TypedDependency&gt; basicDep,
+                                  Filter&lt;TypedDependency&gt; f) {
     if (t.isPhrasal()) {          // don't do leaves of POS tags (chris changed this from numChildren &gt; 0 in 2010)
       Map&lt;Class&lt;? extends GrammaticalRelationAnnotation&gt;, Set&lt;TreeGraphNode&gt;&gt; depMap = getAllDependents(t);
       for (Class&lt;? extends GrammaticalRelationAnnotation&gt; depName : depMap.keySet()) {
@@ -377,7 +363,7 @@ private static void getTreeDeps(TreeGraphNode t, List&lt;TypedDependency&gt; basicDep,
             if (!rels.isEmpty()) {
               for (GrammaticalRelation rel : rels) {
                 TypedDependency newDep = new TypedDependency(rel, gov, dep);
+                if (!basicDep.contains(newDep) &amp;&amp; f.accept(newDep)) {
                   newDep.setExtra();
                   basicDep.add(newDep);
                 }
@@ -388,7 +374,7 @@ private static void getTreeDeps(TreeGraphNode t, List&lt;TypedDependency&gt; basicDep,
       }
       // now recurse into children
       for (Tree kid : t.children()) {
+        getTreeDeps((TreeGraphNode) kid, basicDep, f);
       }
     }
   }
@@ -697,7 +683,7 @@ public List&lt;TypedDependency&gt; typedDependenciesCollapsed(boolean includeExtras) {
     // nsubjs than they originally do.  If we wait until that occurs
     // to add xsubj for xcomp dependencies, we get better coverage.
     if (includeExtras) {
+      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter));
     }
     collapseDependencies(tdl, false, includeExtras);
     return tdl;
@@ -727,7 +713,7 @@ public List&lt;TypedDependency&gt; typedDependenciesCCprocessed(boolean includeExtras)
     // nsubjs than they originally do.  If we wait until that occurs
     // to add xsubj for xcomp dependencies, we get better coverage.
     if (includeExtras) {
+      getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter));
     }
     collapseDependencies(tdl, true, includeExtras);
     return tdl;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>471560</refactoring_id><commit_sha>920324b13599a46726239361d00f199f3b9b0d70</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/920324b13599a46726239361d00f199f3b9b0d70</commit_link><file_path>src/main/java/vazkii/botania/common/core/handler/InternalMethodHandler.java</file_path><description>Remove Parameter x : int in method public isBotaniaFlower(world World, x int, y int, z int) : boolean from class vazkii.botania.common.core.handler.InternalMethodHandler</description><code_before>@@ -23,6 +23,7 @@
 import net.minecraft.item.ItemStack;
 import net.minecraft.item.crafting.IRecipe;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.IIcon;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.world.World;
@@ -243,7 +244,7 @@ public long getWorldElapsedTicks() {
 	}
 
 	@Override
-	public boolean isBotaniaFlower(World world, int x, int y, int z) {
 		Block block = world.getBlock(x, y, z);
 		return block == ModBlocks.flower || block == ModBlocks.shinyFlower || block == ModBlocks.specialFlower;
 	}
</code_before><code_after>@@ -23,6 +23,7 @@
 import net.minecraft.item.ItemStack;
 import net.minecraft.item.crafting.IRecipe;
 import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.BlockPos;
 import net.minecraft.util.IIcon;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.world.World;
@@ -243,7 +244,7 @@ public long getWorldElapsedTicks() {
 	}
 
 	@Override
+	public boolean isBotaniaFlower(World world, BlockPos pos) {
 		Block block = world.getBlock(x, y, z);
 		return block == ModBlocks.flower || block == ModBlocks.shinyFlower || block == ModBlocks.specialFlower;
 	}
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>525588</refactoring_id><commit_sha>a1adaf2f900a87b065a2b14e8acaf50e00542819</commit_sha><commit_link>https://github.com/apache/iotdb/commit/a1adaf2f900a87b065a2b14e8acaf50e00542819</commit_link><file_path>tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/BatchData.java</file_path><description>Remove Parameter idx : int in method public setBinary(idx int, v Binary) : void from class org.apache.iotdb.tsfile.read.common.BatchData</description><code_before>@@ -424,51 +424,51 @@ public boolean getBoolean() {
     return this.booleanRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
-  public void setBoolean(int idx, boolean v) {
     this.booleanRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public int getInt() {
     return this.intRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
-  public void setInt(int idx, int v) {
     this.intRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public long getLong() {
     return this.longRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
-  public void setLong(int idx, long v) {
     this.longRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public float getFloat() {
     return this.floatRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
-  public void setFloat(int idx, float v) {
     this.floatRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public double getDouble() {
     return this.doubleRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
-  public void setDouble(int idx, double v) {
     this.doubleRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public Binary getBinary() {
     return this.binaryRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
-  public void setBinary(int idx, Binary v) {
     this.binaryRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
-  public void setTime(int idx, long v) {
     this.timeRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
</code_before><code_after>@@ -424,51 +424,51 @@ public boolean getBoolean() {
     return this.booleanRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
+  public void setBoolean(boolean v) {
     this.booleanRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public int getInt() {
     return this.intRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
+  public void setInt(int v) {
     this.intRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public long getLong() {
     return this.longRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
+  public void setLong(long v) {
     this.longRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public float getFloat() {
     return this.floatRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
+  public void setFloat(float v) {
     this.floatRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public double getDouble() {
     return this.doubleRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
+  public void setDouble(double v) {
     this.doubleRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
   public Binary getBinary() {
     return this.binaryRet.get(readCurListIndex)[readCurArrayIndex];
   }
 
+  public void setBinary(Binary v) {
     this.binaryRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
+  public void setTime(long v) {
     this.timeRet.get(readCurListIndex)[readCurArrayIndex] = v;
   }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>519687</refactoring_id><commit_sha>a97abd2375915bec4d5ad3760833da85f84bbde4</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/a97abd2375915bec4d5ad3760833da85f84bbde4</commit_link><file_path>clients/unshaded/src/main/java/tachyon/client/lineage/options/CreateLineageOptions.java</file_path><description>Remove Parameter buidler : CreateLineageOptions.Builder in method private CreateLineageOptions(buidler CreateLineageOptions.Builder) from class tachyon.client.lineage.options.CreateLineageOptions</description><code_before>@@ -16,36 +16,20 @@
 package tachyon.client.lineage.options;
 
 import tachyon.annotation.PublicApi;
-import tachyon.client.ClientContext;
-import tachyon.conf.TachyonConf;
 
 /**
  * Method option for creating lineage.
  */
 @PublicApi
 public final class CreateLineageOptions {
-  private static class Builder {
-    /**
-     * Creates a new builder for {@link CreateLineageOptions}.
-     *
-     * @param conf a Tachyon configuration
-     */
-    public Builder(TachyonConf conf) {}
-
-    /**
-     * @return builds a new instance of {@link CreateLineageOptions}
-     */
-    public CreateLineageOptions build() {
-      return new CreateLineageOptions(this);
-    }
-  }
-
   /**
    * @return the default options
    */
   public static CreateLineageOptions defaults() {
-    return new Builder(ClientContext.getConf()).build();
   }
 
-  private CreateLineageOptions(CreateLineageOptions.Builder buidler) {}
 }
</code_before><code_after>@@ -16,36 +16,20 @@
 package tachyon.client.lineage.options;
 
 import tachyon.annotation.PublicApi;
 
 /**
  * Method option for creating lineage.
  */
 @PublicApi
 public final class CreateLineageOptions {
   /**
    * @return the default options
    */
   public static CreateLineageOptions defaults() {
+    return new CreateLineageOptions();
   }
 
+  private CreateLineageOptions() {
+
+  }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>518042</refactoring_id><commit_sha>0b2e955aff1555616e0d5b1d5047f1737347bdfe</commit_sha><commit_link>https://github.com/netty/netty/commit/0b2e955aff1555616e0d5b1d5047f1737347bdfe</commit_link><file_path>handler/src/main/java/io/netty/handler/ssl/SslHandler.java</file_path><description>Remove Parameter completeTask : Runnable in method private runAllDelegatedTasks(engine SSLEngine, completeTask Runnable) : void from class io.netty.handler.ssl.SslHandler</description><code_before>@@ -1506,18 +1506,13 @@ private static boolean inEventLoop(Executor executor) {
         return executor instanceof EventExecutor &amp;&amp; ((EventExecutor) executor).inEventLoop();
     }
 
-    private static void runAllDelegatedTasks(SSLEngine engine, Runnable completeTask) {
         for (;;) {
             Runnable task = engine.getDelegatedTask();
             if (task == null) {
                 return;
             }
-            if (task instanceof AsyncRunnable) {
-                ((AsyncRunnable) task).run(completeTask);
-            } else {
-                task.run();
-                completeTask.run();
-            }
         }
     }
 
@@ -1529,8 +1524,14 @@ private static void runAllDelegatedTasks(SSLEngine engine, Runnable completeTask
      * more tasks to process.
      */
     private boolean runDelegatedTasks(boolean inUnwrap) {
-        executeDelegatedTasks(inUnwrap);
-        return false;
     }
 
     private void executeDelegatedTasks(boolean inUnwrap) {
@@ -1692,20 +1693,18 @@ private void resumeOnEventExecutor() {
         @Override
         public void run() {
             try {
-                runAllDelegatedTasks(engine, new Runnable() {
                     @Override
                     public void run() {
-                        // All tasks were processed.
-                        // Jump back on the EventExecutor.
-                        ctx.executor().execute(new Runnable() {
-                            @Override
-                            public void run() {
-                                resumeOnEventExecutor();
-                            }
-                        });
                     }
                 });
-
             } catch (final Throwable cause) {
                 handleException(cause);
             }
</code_before><code_after>@@ -1506,18 +1506,13 @@ private static boolean inEventLoop(Executor executor) {
         return executor instanceof EventExecutor &amp;&amp; ((EventExecutor) executor).inEventLoop();
     }
 
+    private static void runAllDelegatedTasks(SSLEngine engine) {
         for (;;) {
             Runnable task = engine.getDelegatedTask();
             if (task == null) {
                 return;
             }
+            task.run();
         }
     }
 
@@ -1529,8 +1524,14 @@ private static void runAllDelegatedTasks(SSLEngine engine, Runnable completeTask
      * more tasks to process.
      */
     private boolean runDelegatedTasks(boolean inUnwrap) {
+        if (delegatedTaskExecutor == ImmediateExecutor.INSTANCE || inEventLoop(delegatedTaskExecutor)) {
+            // We should run the task directly in the EventExecutor thread and not offload at all.
+            runAllDelegatedTasks(engine);
+            return true;
+        } else {
+            executeDelegatedTasks(inUnwrap);
+            return false;
+        }
     }
 
     private void executeDelegatedTasks(boolean inUnwrap) {
@@ -1692,20 +1693,18 @@ private void resumeOnEventExecutor() {
         @Override
         public void run() {
             try {
+                runAllDelegatedTasks(engine);
+
+                // All tasks were processed.
+                assert engine.getHandshakeStatus() != HandshakeStatus.NEED_TASK;
+
+                // Jump back on the EventExecutor.
+                ctx.executor().execute(new Runnable() {
                     @Override
                     public void run() {
+                        resumeOnEventExecutor();
                     }
                 });
             } catch (final Throwable cause) {
                 handleException(cause);
             }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>481560</refactoring_id><commit_sha>8943580a6167fda820e64a283966ed81101bf9fc</commit_sha><commit_link>https://github.com/vespa-engine/vespa/commit/8943580a6167fda820e64a283966ed81101bf9fc</commit_link><file_path>config/src/main/java/com/yahoo/vespa/config/benchmark/LoadTester.java</file_path><description>Remove Parameter defContent : String[] in method private createRequest(reqKey ConfigKey&lt;?&gt;, defContent String[]) : JRTClientConfigRequest from class com.yahoo.vespa.config.benchmark.LoadTester.LoadThread</description><code_before>@@ -233,14 +233,14 @@ public void run() {
             int numberOfConfigs = configs.size();
             for (int i = 0; i &lt; iterations; i++) {
                 ConfigKey&lt;?&gt; reqKey = configs.get(ThreadLocalRandom.current().nextInt(numberOfConfigs));
-                ConfigDefinitionKey dKey = new ConfigDefinitionKey(reqKey);
-                Tuple2&lt;String, String[]&gt; defContent = defs.get(dKey);
-                ConfigKey&lt;?&gt; configKey = createFull(reqKey.getName(), reqKey.getConfigId(), reqKey.getNamespace(), defContent.first);
-                JRTClientConfigRequest request = createRequest(configKey, defContent.second);
-                if (debug) System.out.println("# Requesting: " + reqKey);
                 long start = System.nanoTime();
                 target.invokeSync(request.getRequest(), 10.0);
                 long durationInMillis = (System.nanoTime() - start) / 1_000_000;
                 if (request.isError()) {
                     target = handleError(request, spec, target);
                 } else {
@@ -249,11 +249,15 @@ public void run() {
             }
         }
 
-        private JRTClientConfigRequest createRequest(ConfigKey&lt;?&gt; reqKey, String[] defContent) {
-            if (defContent == null) defContent = new String[0];
             final long serverTimeout = 1000;
-            return JRTClientConfigRequestV3.createWithParams(reqKey, DefContent.fromList(Arrays.asList(defContent)),
-                                                             ConfigUtils.getCanonicalHostName(), "", 0, serverTimeout, Trace.createDummy(),
                                                              compressionType, Optional.empty());
         }
 
</code_before><code_after>@@ -233,14 +233,14 @@ public void run() {
             int numberOfConfigs = configs.size();
             for (int i = 0; i &lt; iterations; i++) {
                 ConfigKey&lt;?&gt; reqKey = configs.get(ThreadLocalRandom.current().nextInt(numberOfConfigs));
+                JRTClientConfigRequest request = createRequest(reqKey);
+                if (debug)
+                    System.out.println("# Requesting: " + reqKey);
+
                 long start = System.nanoTime();
                 target.invokeSync(request.getRequest(), 10.0);
                 long durationInMillis = (System.nanoTime() - start) / 1_000_000;
+
                 if (request.isError()) {
                     target = handleError(request, spec, target);
                 } else {
@@ -249,11 +249,15 @@ public void run() {
             }
         }
 
+        private JRTClientConfigRequest createRequest(ConfigKey&lt;?&gt; reqKey) {
+            ConfigDefinitionKey dKey = new ConfigDefinitionKey(reqKey);
+            Tuple2&lt;String, String[]&gt; defContent = defs.get(dKey);
+            ConfigKey&lt;?&gt; fullKey = createFull(reqKey.getName(), reqKey.getConfigId(), reqKey.getNamespace(), defContent.first);
+
             final long serverTimeout = 1000;
+            return JRTClientConfigRequestV3.createWithParams(fullKey, DefContent.fromList(List.of(defContent.second)),
+                                                             ConfigUtils.getCanonicalHostName(), "",
+                                                             0, serverTimeout, Trace.createDummy(),
                                                              compressionType, Optional.empty());
         }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>468600</refactoring_id><commit_sha>361ab1c98803b617c2e57f1075e519cfc04d2374</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/361ab1c98803b617c2e57f1075e519cfc04d2374</commit_link><file_path>services/src/main/java/org/keycloak/email/DefaultEmailSenderProvider.java</file_path><description>Remove Parameter realm : RealmModel in method public send(realm RealmModel, user UserModel, subject String, textBody String, htmlBody String) : void from class org.keycloak.email.DefaultEmailSenderProvider</description><code_before>@@ -20,7 +20,6 @@
 import com.sun.mail.smtp.SMTPMessage;
 import org.jboss.logging.Logger;
 import org.keycloak.models.KeycloakSession;
-import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.services.ServicesLogger;
 import org.keycloak.truststore.HostnameVerificationPolicy;
@@ -57,20 +56,22 @@ public DefaultEmailSenderProvider(KeycloakSession session) {
     }
 
     @Override
-    public void send(RealmModel realm, UserModel user, String subject, String textBody, String htmlBody) throws EmailException {
         Transport transport = null;
         try {
             String address = retrieveEmailAddress(user);
-            Map&lt;String, String&gt; config = realm.getSmtpConfig();
 
             Properties props = new Properties();
-            props.setProperty("mail.smtp.host", config.get("host"));
 
             boolean auth = "true".equals(config.get("auth"));
             boolean ssl = "true".equals(config.get("ssl"));
             boolean starttls = "true".equals(config.get("starttls"));
 
-            if (config.containsKey("port")) {
                 props.setProperty("mail.smtp.port", config.get("port"));
             }
 
@@ -103,13 +104,13 @@ public void send(RealmModel realm, UserModel user, String subject, String textBo
 
             Multipart multipart = new MimeMultipart("alternative");
 
-            if(textBody != null) {
                 MimeBodyPart textPart = new MimeBodyPart();
                 textPart.setText(textBody, "UTF-8");
                 multipart.addBodyPart(textPart);
             }
 
-            if(htmlBody != null) {
                 MimeBodyPart htmlPart = new MimeBodyPart();
                 htmlPart.setContent(htmlBody, "text/html; charset=UTF-8");
                 multipart.addBodyPart(htmlPart);
@@ -153,13 +154,16 @@ public void send(RealmModel realm, UserModel user, String subject, String textBo
         }
     }
 
-    protected InternetAddress toInternetAddress(String email, String displayName) throws UnsupportedEncodingException, AddressException {
         if (displayName == null || "".equals(displayName.trim())) {
             return new InternetAddress(email);
         }
         return new InternetAddress(email, displayName, "utf-8");
     }
-    
     protected String retrieveEmailAddress(UserModel user) {
         return user.getEmail();
     }
</code_before><code_after>@@ -20,7 +20,6 @@
 import com.sun.mail.smtp.SMTPMessage;
 import org.jboss.logging.Logger;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.UserModel;
 import org.keycloak.services.ServicesLogger;
 import org.keycloak.truststore.HostnameVerificationPolicy;
@@ -57,20 +56,22 @@ public DefaultEmailSenderProvider(KeycloakSession session) {
     }
 
     @Override
+    public void send(Map&lt;String, String&gt; config, UserModel user, String subject, String textBody, String htmlBody) throws EmailException {
         Transport transport = null;
         try {
             String address = retrieveEmailAddress(user);
 
             Properties props = new Properties();
+
+            if (config.containsKey("host")) {
+                props.setProperty("mail.smtp.host", config.get("host"));
+            }
 
             boolean auth = "true".equals(config.get("auth"));
             boolean ssl = "true".equals(config.get("ssl"));
             boolean starttls = "true".equals(config.get("starttls"));
 
+            if (config.containsKey("port") &amp;&amp; config.get("port") != null) {
                 props.setProperty("mail.smtp.port", config.get("port"));
             }
 
@@ -103,13 +104,13 @@ public void send(RealmModel realm, UserModel user, String subject, String textBo
 
             Multipart multipart = new MimeMultipart("alternative");
 
+            if (textBody != null) {
                 MimeBodyPart textPart = new MimeBodyPart();
                 textPart.setText(textBody, "UTF-8");
                 multipart.addBodyPart(textPart);
             }
 
+            if (htmlBody != null) {
                 MimeBodyPart htmlPart = new MimeBodyPart();
                 htmlPart.setContent(htmlBody, "text/html; charset=UTF-8");
                 multipart.addBodyPart(htmlPart);
@@ -153,13 +154,16 @@ public void send(RealmModel realm, UserModel user, String subject, String textBo
         }
     }
 
+    protected InternetAddress toInternetAddress(String email, String displayName) throws UnsupportedEncodingException, AddressException, EmailException {
+        if (email == null || "".equals(email.trim())) {
+            throw new EmailException("Please provide a valid address", null);
+        }
         if (displayName == null || "".equals(displayName.trim())) {
             return new InternetAddress(email);
         }
         return new InternetAddress(email, displayName, "utf-8");
     }
+
     protected String retrieveEmailAddress(UserModel user) {
         return user.getEmail();
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>472382</refactoring_id><commit_sha>8aefdf57ea90bf5efed97a0632044d6efeb43a34</commit_sha><commit_link>https://github.com/vazkiimods/botania/commit/8aefdf57ea90bf5efed97a0632044d6efeb43a34</commit_link><file_path>src/main/java/vazkii/botania/client/render/tile/RenderTileLightRelay.java</file_path><description>Remove Parameter unused : float in method public render(tile TileLightRelay, x double, y double, z double, pticks float, digProgress int, unused float) : void from class vazkii.botania.client.render.tile.RenderTileLightRelay</description><code_before>@@ -10,76 +10,82 @@
  */
 package vazkii.botania.client.render.tile;
 
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureMap;
-import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
 import org.lwjgl.opengl.GL11;
 import vazkii.botania.api.state.BotaniaStateProps;
 import vazkii.botania.api.state.enums.LuminizerVariant;
 import vazkii.botania.client.core.handler.ClientTickHandler;
 import vazkii.botania.client.core.handler.MiscellaneousIcons;
 import vazkii.botania.client.core.helper.ShaderHelper;
 import vazkii.botania.client.core.proxy.ClientProxy;
 import vazkii.botania.common.block.ModBlocks;
 import vazkii.botania.common.block.tile.TileLightRelay;
 
 import javax.annotation.Nonnull;
-import java.util.HashMap;
 import java.util.Map;
 
-public class RenderTileLightRelay extends TileEntitySpecialRenderer&lt;TileLightRelay&gt; {
 
-	private static Map&lt;LuminizerVariant, TextureAtlasSprite&gt; sprites = new HashMap();
 
 	@Override
-	public void render(@Nonnull TileLightRelay tile, double x, double y, double z, float pticks, int digProgress, float unused) {
-		if(!tile.getWorld().isBlockLoaded(tile.getPos(), false) || tile.getWorld().getBlockState(tile.getPos()).getBlock() != ModBlocks.lightRelay)
 			return;
 
-		Minecraft mc = Minecraft.getMinecraft();
 		if(sprites.isEmpty()) {
 			sprites.put(LuminizerVariant.DEFAULT, MiscellaneousIcons.INSTANCE.lightRelayWorldIcon);
 			sprites.put(LuminizerVariant.DETECTOR, MiscellaneousIcons.INSTANCE.lightRelayWorldIconRed);
 			sprites.put(LuminizerVariant.FORK, MiscellaneousIcons.INSTANCE.lightRelayWorldIconGreen);
 			sprites.put(LuminizerVariant.TOGGLE, MiscellaneousIcons.INSTANCE.lightRelayWorldIconPurple);
 		}
 
-		TextureAtlasSprite iicon = sprites.get(tile.getWorld().getBlockState(tile.getPos()).getValue(BotaniaStateProps.LUMINIZER_VARIANT));
 
 		GlStateManager.pushMatrix();
-		GlStateManager.translate(x + 0.5, y + 0.3, z + 0.5);
 		GlStateManager.enableRescaleNormal();
 		GlStateManager.enableBlend();
 		GlStateManager.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GlStateManager.alphaFunc(GL11.GL_GREATER, 0.05F);
 
 		double time = ClientTickHandler.ticksInGame + pticks;
-		GlStateManager.color(1F, 1F, 1F, 1F);
 
 		float scale = 0.75F;
-		GlStateManager.scale(scale, scale, scale);
 		Tessellator tessellator = Tessellator.getInstance();
 
 		GlStateManager.pushMatrix();
 		float r = 180.0F - mc.getRenderManager().playerViewY;
-		GlStateManager.rotate(r, 0F, 1F, 0F);
-		GlStateManager.rotate(-mc.getRenderManager().playerViewX, 1F, 0F, 0F);
 
 		float off = 0.25F;
-		GlStateManager.translate(0F, off, 0F);
-		GlStateManager.rotate((float) time, 0F, 0F, 1F);
-		GlStateManager.translate(0F, -off, 0F);
 
-		mc.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
 		ShaderHelper.useShader(ShaderHelper.halo);
 		renderIcon(tessellator, iicon);
 		ShaderHelper.releaseShader();
 
 		GlStateManager.popMatrix();
-		GlStateManager.color(1F, 1F, 1F, 1F);
 		GlStateManager.disableBlend();
 		GlStateManager.disableRescaleNormal();
 		GlStateManager.popMatrix();
</code_before><code_after>@@ -10,76 +10,82 @@
  */
 package vazkii.botania.client.render.tile;
 
+import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureMap;
+import net.minecraft.client.renderer.tileentity.TileEntityRenderer;
 import org.lwjgl.opengl.GL11;
 import vazkii.botania.api.state.BotaniaStateProps;
 import vazkii.botania.api.state.enums.LuminizerVariant;
 import vazkii.botania.client.core.handler.ClientTickHandler;
 import vazkii.botania.client.core.handler.MiscellaneousIcons;
 import vazkii.botania.client.core.helper.ShaderHelper;
 import vazkii.botania.client.core.proxy.ClientProxy;
+import vazkii.botania.common.block.BlockLightRelay;
 import vazkii.botania.common.block.ModBlocks;
 import vazkii.botania.common.block.tile.TileLightRelay;
 
 import javax.annotation.Nonnull;
+import java.util.EnumMap;
 import java.util.Map;
 
+public class RenderTileLightRelay extends TileEntityRenderer&lt;TileLightRelay&gt; {
 
+	private static Map&lt;LuminizerVariant, TextureAtlasSprite&gt; sprites = new EnumMap&lt;&gt;(LuminizerVariant.class);
 
 	@Override
+	public void render(@Nonnull TileLightRelay tile, double x, double y, double z, float pticks, int digProgress) {
+		if(!tile.getWorld().isBlockLoaded(tile.getPos(), false))
 			return;
 
+		IBlockState state = tile.getWorld().getBlockState(tile.getPos());
+		if(!(state.getBlock() instanceof BlockLightRelay))
+			return;
+
+		Minecraft mc = Minecraft.getInstance();
 		if(sprites.isEmpty()) {
 			sprites.put(LuminizerVariant.DEFAULT, MiscellaneousIcons.INSTANCE.lightRelayWorldIcon);
 			sprites.put(LuminizerVariant.DETECTOR, MiscellaneousIcons.INSTANCE.lightRelayWorldIconRed);
 			sprites.put(LuminizerVariant.FORK, MiscellaneousIcons.INSTANCE.lightRelayWorldIconGreen);
 			sprites.put(LuminizerVariant.TOGGLE, MiscellaneousIcons.INSTANCE.lightRelayWorldIconPurple);
 		}
 
+		TextureAtlasSprite iicon = sprites.get(((BlockLightRelay) state.getBlock()).variant);
 
 		GlStateManager.pushMatrix();
+		GlStateManager.translated(x + 0.5, y + 0.3, z + 0.5);
 		GlStateManager.enableRescaleNormal();
 		GlStateManager.enableBlend();
 		GlStateManager.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
 		GlStateManager.alphaFunc(GL11.GL_GREATER, 0.05F);
 
 		double time = ClientTickHandler.ticksInGame + pticks;
+		GlStateManager.color4f(1F, 1F, 1F, 1F);
 
 		float scale = 0.75F;
+		GlStateManager.scalef(scale, scale, scale);
 		Tessellator tessellator = Tessellator.getInstance();
 
 		GlStateManager.pushMatrix();
 		float r = 180.0F - mc.getRenderManager().playerViewY;
+		GlStateManager.rotatef(r, 0F, 1F, 0F);
+		GlStateManager.rotatef(-mc.getRenderManager().playerViewX, 1F, 0F, 0F);
 
 		float off = 0.25F;
+		GlStateManager.translatef(0F, off, 0F);
+		GlStateManager.rotatef((float) time, 0F, 0F, 1F);
+		GlStateManager.translatef(0F, -off, 0F);
 
+		mc.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
 		ShaderHelper.useShader(ShaderHelper.halo);
 		renderIcon(tessellator, iicon);
 		ShaderHelper.releaseShader();
 
 		GlStateManager.popMatrix();
+		GlStateManager.color4f(1F, 1F, 1F, 1F);
 		GlStateManager.disableBlend();
 		GlStateManager.disableRescaleNormal();
 		GlStateManager.popMatrix();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>468153</refactoring_id><commit_sha>d2a540352771f2dfffecc302909905fb2737eace</commit_sha><commit_link>https://github.com/keycloak/keycloak/commit/d2a540352771f2dfffecc302909905fb2737eace</commit_link><file_path>broker/oidc/src/main/java/org/keycloak/broker/oidc/AbstractOAuth2IdentityProvider.java</file_path><description>Remove Parameter notes : Map&lt;String,String&gt; in method protected getFederatedIdentity(notes Map&lt;String,String&gt;, response String) : FederatedIdentity from class org.keycloak.broker.oidc.AbstractOAuth2IdentityProvider</description><code_before>@@ -25,14 +25,18 @@
 import org.keycloak.broker.oidc.util.SimpleHttp;
 import org.keycloak.broker.provider.AbstractIdentityProvider;
 import org.keycloak.broker.provider.AuthenticationRequest;
 import org.keycloak.broker.provider.FederatedIdentity;
 import org.keycloak.broker.provider.IdentityBrokerException;
 import org.keycloak.events.Errors;
 import org.keycloak.events.EventBuilder;
 import org.keycloak.events.EventType;
 import org.keycloak.models.FederatedIdentityModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.services.messages.Messages;
 import org.keycloak.services.resources.flows.Flows;
 
@@ -87,7 +91,7 @@ public Object callback(RealmModel realm, AuthenticationCallback callback, EventB
     }
 
     @Override
-    public Response handleRequest(AuthenticationRequest request) {
         try {
             URI authorizationUrl = createAuthorizationUrl(request).build();
 
@@ -125,7 +129,7 @@ protected String extractTokenFromResponse(String response, String tokenName) {
         return null;
     }
 
-    protected FederatedIdentity getFederatedIdentity(Map&lt;String, String&gt; notes, String response) {
         String accessToken = extractTokenFromResponse(response, OAUTH2_PARAMETER_ACCESS_TOKEN);
 
         if (accessToken == null) {
@@ -136,7 +140,7 @@ protected FederatedIdentity getFederatedIdentity(Map&lt;String, String&gt; notes, Stri
     }
 
 
-    protected FederatedIdentity doGetFederatedIdentity(String accessToken) {
         return null;
     }
 
@@ -204,14 +208,17 @@ public Response authResponse(@QueryParam(AbstractOAuth2IdentityProvider.OAUTH2_P
                 if (authorizationCode != null) {
                     String response = generateTokenRequest(authorizationCode).asString();
 
-                    HashMap&lt;String, String&gt; userNotes = new HashMap&lt;String, String&gt;();
-                    FederatedIdentity federatedIdentity = getFederatedIdentity(userNotes, response);
 
                     if (getConfig().isStoreToken()) {
                         federatedIdentity.setToken(response);
                     }
 
-                    return callback.authenticated(userNotes, getConfig(), federatedIdentity, state);
                 }
             } catch (Exception e) {
                 logger.error("Failed to make identity provider oauth callback", e);
</code_before><code_after>@@ -25,14 +25,18 @@
 import org.keycloak.broker.oidc.util.SimpleHttp;
 import org.keycloak.broker.provider.AbstractIdentityProvider;
 import org.keycloak.broker.provider.AuthenticationRequest;
+import org.keycloak.broker.provider.BrokeredIdentityContext;
 import org.keycloak.broker.provider.FederatedIdentity;
 import org.keycloak.broker.provider.IdentityBrokerException;
 import org.keycloak.events.Errors;
 import org.keycloak.events.EventBuilder;
 import org.keycloak.events.EventType;
+import org.keycloak.models.ClientSessionModel;
 import org.keycloak.models.FederatedIdentityModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserModel;
+import org.keycloak.models.UserSessionModel;
 import org.keycloak.services.messages.Messages;
 import org.keycloak.services.resources.flows.Flows;
 
@@ -87,7 +91,7 @@ public Object callback(RealmModel realm, AuthenticationCallback callback, EventB
     }
 
     @Override
+    public Response performLogin(AuthenticationRequest request) {
         try {
             URI authorizationUrl = createAuthorizationUrl(request).build();
 
@@ -125,7 +129,7 @@ protected String extractTokenFromResponse(String response, String tokenName) {
         return null;
     }
 
+    protected BrokeredIdentityContext getFederatedIdentity(String response) {
         String accessToken = extractTokenFromResponse(response, OAUTH2_PARAMETER_ACCESS_TOKEN);
 
         if (accessToken == null) {
@@ -136,7 +140,7 @@ protected FederatedIdentity getFederatedIdentity(Map&lt;String, String&gt; notes, Stri
     }
 
 
+    protected BrokeredIdentityContext doGetFederatedIdentity(String accessToken) {
         return null;
     }
 
@@ -204,14 +208,17 @@ public Response authResponse(@QueryParam(AbstractOAuth2IdentityProvider.OAUTH2_P
                 if (authorizationCode != null) {
                     String response = generateTokenRequest(authorizationCode).asString();
 
+                    BrokeredIdentityContext federatedIdentity = getFederatedIdentity(response);
 
                     if (getConfig().isStoreToken()) {
                         federatedIdentity.setToken(response);
                     }
 
+                    federatedIdentity.setCode(state);
+                    federatedIdentity.setIdpConfig(getConfig());
+                    federatedIdentity.setIdp(AbstractOAuth2IdentityProvider.this);
+
+                    return callback.authenticated(federatedIdentity);
                 }
             } catch (Exception e) {
                 logger.error("Failed to make identity provider oauth callback", e);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>586671</refactoring_id><commit_sha>93a5c8991b093cd7a1106c70f8a1914d3e8f89bc</commit_sha><commit_link>https://github.com/oracle/graal/commit/93a5c8991b093cd7a1106c70f8a1914d3e8f89bc</commit_link><file_path>graal/com.oracle.graal.java/src/com/oracle/graal/java/FrameStateBuilder.java</file_path><description>Remove Parameter stampFromValue : boolean in method private createLoopPhi(block AbstractMergeNode, value ValueNode, stampFromValue boolean) : ValueNode from class com.oracle.graal.java.FrameStateBuilder</description><code_before>@@ -425,16 +425,16 @@ private void propagateDelete(FloatingNode node) {
 
     public void insertLoopPhis(LocalLiveness liveness, int loopId, LoopBeginNode loopBegin, boolean forcePhis) {
         for (int i = 0; i &lt; localsSize(); i++) {
-            boolean changedInLoop = liveness.localIsChangedInLoop(loopId, i);
-            if (changedInLoop || forcePhis) {
-                locals[i] = createLoopPhi(loopBegin, locals[i], !changedInLoop);
             }
         }
         for (int i = 0; i &lt; stackSize(); i++) {
-            stack[i] = createLoopPhi(loopBegin, stack[i], false);
         }
         for (int i = 0; i &lt; lockedObjects.length; i++) {
-            lockedObjects[i] = createLoopPhi(loopBegin, lockedObjects[i], false);
         }
     }
 
@@ -486,13 +486,13 @@ public void insertProxies(Function&lt;ValueNode, ValueNode&gt; proxyFunction) {
         }
     }
 
-    private ValueNode createLoopPhi(AbstractMergeNode block, ValueNode value, boolean stampFromValue) {
         if (value == null || value == TWO_SLOT_MARKER) {
             return value;
         }
         assert !block.isPhiAtMerge(value) : "phi function for this block already created";
 
-        ValuePhiNode phi = graph.addWithoutUnique(new ValuePhiNode(stampFromValue ? value.stamp() : value.stamp().unrestricted(), block));
         phi.addInput(value);
         return phi;
     }
</code_before><code_after>@@ -425,16 +425,16 @@ private void propagateDelete(FloatingNode node) {
 
     public void insertLoopPhis(LocalLiveness liveness, int loopId, LoopBeginNode loopBegin, boolean forcePhis) {
         for (int i = 0; i &lt; localsSize(); i++) {
+            boolean needPhi = forcePhis || liveness.localIsChangedInLoop(loopId, i);
+            if (needPhi) {
+                locals[i] = createLoopPhi(loopBegin, locals[i]);
             }
         }
         for (int i = 0; i &lt; stackSize(); i++) {
+            stack[i] = createLoopPhi(loopBegin, stack[i]);
         }
         for (int i = 0; i &lt; lockedObjects.length; i++) {
+            lockedObjects[i] = createLoopPhi(loopBegin, lockedObjects[i]);
         }
     }
 
@@ -486,13 +486,13 @@ public void insertProxies(Function&lt;ValueNode, ValueNode&gt; proxyFunction) {
         }
     }
 
+    private ValueNode createLoopPhi(AbstractMergeNode block, ValueNode value) {
         if (value == null || value == TWO_SLOT_MARKER) {
             return value;
         }
         assert !block.isPhiAtMerge(value) : "phi function for this block already created";
 
+        ValuePhiNode phi = graph.addWithoutUnique(new ValuePhiNode(value.stamp().unrestricted(), block));
         phi.addInput(value);
         return phi;
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>568471</refactoring_id><commit_sha>16ce875fc6a8d7da100a634757e14f80d1377fad</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/16ce875fc6a8d7da100a634757e14f80d1377fad</commit_link><file_path>nashorn/src/jdk/nashorn/internal/ir/IndexNode.java</file_path><description>Remove Parameter hasCallSiteType : boolean in method private IndexNode(indexNode IndexNode, base Expression, index Expression, isFunction boolean, hasCallSiteType boolean) from class jdk.nashorn.internal.ir.IndexNode</description><code_before>@@ -25,7 +25,6 @@
 
 package jdk.nashorn.internal.ir;
 
-import jdk.nashorn.internal.codegen.types.Type;
 import jdk.nashorn.internal.ir.annotations.Immutable;
 import jdk.nashorn.internal.ir.visitor.NodeVisitor;
 
@@ -46,12 +45,12 @@ public final class IndexNode extends BaseNode {
      * @param index   index for access
      */
     public IndexNode(final long token, final int finish, final Expression base, final Expression index) {
-        super(token, finish, base, false, false);
         this.index = index;
     }
 
-    private IndexNode(final IndexNode indexNode, final Expression base, final Expression index, final boolean isFunction, final boolean hasCallSiteType) {
-        super(indexNode, base, isFunction, hasCallSiteType);
         this.index = index;
     }
 
@@ -69,13 +68,6 @@ public Node accept(final NodeVisitor&lt;? extends LexicalContext&gt; visitor) {
     public void toString(final StringBuilder sb) {
         final boolean needsParen = tokenType().needsParens(base.tokenType(), true);
 
-        if (hasCallSiteType()) {
-            sb.append('{');
-            final String desc = getType().getDescriptor();
-            sb.append(desc.charAt(desc.length() - 1) == ';' ? "O" : getType().getDescriptor());
-            sb.append('}');
-        }
-
         if (needsParen) {
             sb.append('(');
         }
@@ -103,7 +95,7 @@ private IndexNode setBase(final Expression base) {
         if (this.base == base) {
             return this;
         }
-        return new IndexNode(this, base, index, isFunction(), hasCallSiteType());
     }
 
     /**
@@ -115,22 +107,15 @@ public IndexNode setIndex(Expression index) {
         if(this.index == index) {
             return this;
         }
-        return new IndexNode(this, base, index, isFunction(), hasCallSiteType());
     }
 
     @Override
     public BaseNode setIsFunction() {
         if (isFunction()) {
             return this;
         }
-        return new IndexNode(this, base, index, true, hasCallSiteType());
-    }
-
-    @Override
-    public IndexNode setType(final TemporarySymbols ts, final LexicalContext lc, final Type type) {
-        logTypeChange(type);
-        final IndexNode newIndexNode = (IndexNode)setSymbol(lc, getSymbol().setTypeOverrideShared(type, ts));
-        return new IndexNode(newIndexNode, base, index, isFunction(), true);
     }
 
 }
</code_before><code_after>@@ -25,7 +25,6 @@
 
 package jdk.nashorn.internal.ir;
 
 import jdk.nashorn.internal.ir.annotations.Immutable;
 import jdk.nashorn.internal.ir.visitor.NodeVisitor;
 
@@ -46,12 +45,12 @@ public final class IndexNode extends BaseNode {
      * @param index   index for access
      */
     public IndexNode(final long token, final int finish, final Expression base, final Expression index) {
+        super(token, finish, base, false);
         this.index = index;
     }
 
+    private IndexNode(final IndexNode indexNode, final Expression base, final Expression index, final boolean isFunction) {
+        super(indexNode, base, isFunction);
         this.index = index;
     }
 
@@ -69,13 +68,6 @@ public Node accept(final NodeVisitor&lt;? extends LexicalContext&gt; visitor) {
     public void toString(final StringBuilder sb) {
         final boolean needsParen = tokenType().needsParens(base.tokenType(), true);
 
         if (needsParen) {
             sb.append('(');
         }
@@ -103,7 +95,7 @@ private IndexNode setBase(final Expression base) {
         if (this.base == base) {
             return this;
         }
+        return new IndexNode(this, base, index, isFunction());
     }
 
     /**
@@ -115,22 +107,15 @@ public IndexNode setIndex(Expression index) {
         if(this.index == index) {
             return this;
         }
+        return new IndexNode(this, base, index, isFunction());
     }
 
     @Override
     public BaseNode setIsFunction() {
         if (isFunction()) {
             return this;
         }
+        return new IndexNode(this, base, index, true);
     }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>500595</refactoring_id><commit_sha>0a8e71e89ec0ab997ed93bbb0f899e6bcc354eac</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/0a8e71e89ec0ab997ed93bbb0f899e6bcc354eac</commit_link><file_path>jetty-http/src/main/java/org/eclipse/jetty/http/HttpGenerator.java</file_path><description>Remove Parameter headerBufferSize : int in method public HttpGenerator(buffers Buffers, io EndPoint, headerBufferSize int, contentBufferSize int) from class org.eclipse.jetty.http.HttpGenerator</description><code_before>@@ -115,9 +115,9 @@ public static void setServerVersion(String version)
      * @param headerBufferSize Size of the buffer to allocate for HTTP header
      * @param contentBufferSize Size of the buffer to allocate for HTTP content
      */
-    public HttpGenerator(Buffers buffers, EndPoint io, int headerBufferSize, int contentBufferSize)
     {
-        super(buffers,io,headerBufferSize,contentBufferSize);
     }
 
     /* ------------------------------------------------------------------------------- */
@@ -188,7 +188,7 @@ else if (_endp != null &amp;&amp; _buffer == null &amp;&amp; content.length() &gt; 0 &amp;&amp; _last)
         {
             // Yes - so we better check we have a buffer
             if (_buffer == null) 
-                _buffer = _buffers.getBuffer(_contentBufferSize);
 
             // Copy _content to buffer;
             int len=_buffer.put(_content);
@@ -255,7 +255,7 @@ public boolean addContent(byte b) throws IOException
         
         // we better check we have a buffer
         if (_buffer == null) 
-            _buffer = _buffers.getBuffer(_contentBufferSize);
         
         // Copy _content to buffer;
         _buffer.put(b);
@@ -288,7 +288,7 @@ public int prepareUncheckedAddContent() throws IOException
 
         // we better check we have a buffer
         if (_buffer == null) 
-            _buffer = _buffers.getBuffer(_contentBufferSize);
 
         _contentWritten-=_buffer.length();
         
@@ -323,7 +323,7 @@ public void completeHeader(HttpFields fields, boolean allContentAdded) throws IO
 
         // get a header buffer
         if (_header == null) 
-            _header = _buffers.getBuffer(_headerBufferSize);
         
         boolean has_server = false;
         
</code_before><code_after>@@ -115,9 +115,9 @@ public static void setServerVersion(String version)
      * @param headerBufferSize Size of the buffer to allocate for HTTP header
      * @param contentBufferSize Size of the buffer to allocate for HTTP content
      */
+    public HttpGenerator(Buffers buffers, EndPoint io)
     {
+        super(buffers,io);
     }
 
     /* ------------------------------------------------------------------------------- */
@@ -188,7 +188,7 @@ else if (_endp != null &amp;&amp; _buffer == null &amp;&amp; content.length() &gt; 0 &amp;&amp; _last)
         {
             // Yes - so we better check we have a buffer
             if (_buffer == null) 
+                _buffer = _buffers.getBuffer();
 
             // Copy _content to buffer;
             int len=_buffer.put(_content);
@@ -255,7 +255,7 @@ public boolean addContent(byte b) throws IOException
         
         // we better check we have a buffer
         if (_buffer == null) 
+            _buffer = _buffers.getBuffer();
         
         // Copy _content to buffer;
         _buffer.put(b);
@@ -288,7 +288,7 @@ public int prepareUncheckedAddContent() throws IOException
 
         // we better check we have a buffer
         if (_buffer == null) 
+            _buffer = _buffers.getBuffer();
 
         _contentWritten-=_buffer.length();
         
@@ -323,7 +323,7 @@ public void completeHeader(HttpFields fields, boolean allContentAdded) throws IO
 
         // get a header buffer
         if (_header == null) 
+            _header = _buffers.getHeader();
         
         boolean has_server = false;
         
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>508376</refactoring_id><commit_sha>d4916da55e7b25afe0c07c2ae1726a0638520abb</commit_sha><commit_link>https://github.com/infinispan/infinispan/commit/d4916da55e7b25afe0c07c2ae1726a0638520abb</commit_link><file_path>server/runtime/src/main/java/org/infinispan/server/configuration/security/CredentialStoreConfigurationBuilder.java</file_path><description>Remove Parameter credentialStoresConfigurationBuilder : CredentialStoresConfigurationBuilder in method package CredentialStoreConfigurationBuilder(credentialStoresConfigurationBuilder CredentialStoresConfigurationBuilder, name String) from class org.infinispan.server.configuration.security.CredentialStoreConfigurationBuilder</description><code_before>@@ -10,7 +10,7 @@
 
 import org.infinispan.commons.configuration.Builder;
 import org.infinispan.commons.configuration.attributes.AttributeSet;
-import org.infinispan.commons.util.InstanceSupplier;
 
 /**
  * @author Tristan Tarrant &amp;lt;tristan@infinispan.org&amp;gt;
@@ -19,7 +19,7 @@
 public class CredentialStoreConfigurationBuilder implements Builder&lt;CredentialStoreConfiguration&gt; {
    private final AttributeSet attributes;
 
-   CredentialStoreConfigurationBuilder(CredentialStoresConfigurationBuilder credentialStoresConfigurationBuilder, String name) {
       this.attributes = CredentialStoreConfiguration.attributeDefinitionSet();
       attributes.attribute(NAME).set(name);
    }
@@ -39,12 +39,7 @@ public CredentialStoreConfigurationBuilder type(String type) {
       return this;
    }
 
-   public CredentialStoreConfigurationBuilder credential(char[] credential) {
-      attributes.attribute(CREDENTIAL).set(new InstanceSupplier&lt;&gt;(credential));
-      return this;
-   }
-
-   public CredentialStoreConfigurationBuilder credential(Supplier&lt;char[]&gt; credential) {
       attributes.attribute(CREDENTIAL).set(credential);
       return this;
    }
</code_before><code_after>@@ -10,7 +10,7 @@
 
 import org.infinispan.commons.configuration.Builder;
 import org.infinispan.commons.configuration.attributes.AttributeSet;
+import org.wildfly.security.credential.source.CredentialSource;
 
 /**
  * @author Tristan Tarrant &amp;lt;tristan@infinispan.org&amp;gt;
@@ -19,7 +19,7 @@
 public class CredentialStoreConfigurationBuilder implements Builder&lt;CredentialStoreConfiguration&gt; {
    private final AttributeSet attributes;
 
+   CredentialStoreConfigurationBuilder(String name) {
       this.attributes = CredentialStoreConfiguration.attributeDefinitionSet();
       attributes.attribute(NAME).set(name);
    }
@@ -39,12 +39,7 @@ public CredentialStoreConfigurationBuilder type(String type) {
       return this;
    }
 
+   public CredentialStoreConfigurationBuilder credential(Supplier&lt;CredentialSource&gt; credential) {
       attributes.attribute(CREDENTIAL).set(credential);
       return this;
    }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>501861</refactoring_id><commit_sha>e722c79d380c8a70d628deed7d0cbc5fe4609715</commit_sha><commit_link>https://github.com/bazelbuild/bazel/commit/e722c79d380c8a70d628deed7d0cbc5fe4609715</commit_link><file_path>src/tools/android/java/com/google/devtools/build/android/DataValueFile.java</file_path><description>Remove Parameter key : DataKey in method public serializeTo(key DataKey, sourceTable DataSourceTable, output OutputStream) : int from class com.google.devtools.build.android.DataValueFile</description><code_before>@@ -85,7 +85,7 @@ public void writeResource(FullyQualifiedName key, AndroidDataWritingVisitor merg
   }
 
   @Override
-  public int serializeTo(DataKey key, DataSourceTable sourceTable, OutputStream output)
       throws IOException {
     SerializeFormat.DataValue.Builder builder = SerializeFormat.DataValue.newBuilder();
     SerializeFormat.DataValue value = builder.setSourceId(sourceTable.getSourceId(source)).build();
</code_before><code_after>@@ -85,7 +85,7 @@ public void writeResource(FullyQualifiedName key, AndroidDataWritingVisitor merg
   }
 
   @Override
+  public int serializeTo(DataSourceTable sourceTable, OutputStream output)
       throws IOException {
     SerializeFormat.DataValue.Builder builder = SerializeFormat.DataValue.newBuilder();
     SerializeFormat.DataValue value = builder.setSourceId(sourceTable.getSourceId(source)).build();
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>568692</refactoring_id><commit_sha>a788347b73dcbaaba6ee338601490101d5f6af19</commit_sha><commit_link>https://github.com/corretto/corretto-8/commit/a788347b73dcbaaba6ee338601490101d5f6af19</commit_link><file_path>nashorn/src/jdk/nashorn/internal/ir/ForNode.java</file_path><description>Remove Parameter source : Source in method public ForNode(source Source, token long, finish int, init Node, test Node, body Block, modify Node, flags int) from class jdk.nashorn.internal.ir.ForNode</description><code_before>@@ -27,7 +27,6 @@
 
 import jdk.nashorn.internal.ir.annotations.Immutable;
 import jdk.nashorn.internal.ir.visitor.NodeVisitor;
-import jdk.nashorn.internal.runtime.Source;
 
 /**
  * IR representing a FOR statement.
@@ -57,7 +56,6 @@ public final class ForNode extends LoopNode {
     /**
      * Constructor
      *
-     * @param source the source
      * @param token  token
      * @param finish finish
      * @param init   init
@@ -66,8 +64,8 @@ public final class ForNode extends LoopNode {
      * @param modify modify
      * @param flags  flags
      */
-    public ForNode(final Source source, final long token, final int finish, final Node init, final Node test, final Block body, final Node modify, final int flags) {
-        super(source, token, finish, test, body, false);
         this.init   = init;
         this.modify = modify;
         this.flags  = flags;
</code_before><code_after>@@ -27,7 +27,6 @@
 
 import jdk.nashorn.internal.ir.annotations.Immutable;
 import jdk.nashorn.internal.ir.visitor.NodeVisitor;
 
 /**
  * IR representing a FOR statement.
@@ -57,7 +56,6 @@ public final class ForNode extends LoopNode {
     /**
      * Constructor
      *
      * @param token  token
      * @param finish finish
      * @param init   init
@@ -66,8 +64,8 @@ public final class ForNode extends LoopNode {
      * @param modify modify
      * @param flags  flags
      */
+    public ForNode(final long token, final int finish, final Node init, final Node test, final Block body, final Node modify, final int flags) {
+        super(token, finish, test, body, false);
         this.init   = init;
         this.modify = modify;
         this.flags  = flags;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>519349</refactoring_id><commit_sha>afdf0f3eceef2a956068e4658f5aa5ea09dc94de</commit_sha><commit_link>https://github.com/alluxio/alluxio/commit/afdf0f3eceef2a956068e4658f5aa5ea09dc94de</commit_link><file_path>servers/src/main/java/tachyon/master/file/FileSystemMaster.java</file_path><description>Remove Parameter masterSource : MasterSource in method public FileSystemMaster(tachyonConf TachyonConf, blockMaster BlockMaster, journal Journal, masterSource MasterSource) from class tachyon.master.file.FileSystemMaster</description><code_before>@@ -36,6 +36,7 @@
 import tachyon.TachyonURI;
 import tachyon.conf.TachyonConf;
 import tachyon.master.MasterBase;
 import tachyon.master.MasterSource;
 import tachyon.master.block.BlockId;
 import tachyon.master.block.BlockMaster;
@@ -81,7 +82,6 @@ public final class FileSystemMaster extends MasterBase {
   private static final Logger LOG = LoggerFactory.getLogger(Constants.LOGGER_TYPE);
 
   private final BlockMaster mBlockMaster;
-  private final MasterSource mMasterSource;
 
   /** This manages the file system inode structure. This must be journaled. */
   private final InodeTree mInodeTree;
@@ -101,12 +101,11 @@ public static String getJournalDirectory(String baseDirectory) {
   }
 
   public FileSystemMaster(TachyonConf tachyonConf, BlockMaster blockMaster,
-      Journal journal, MasterSource masterSource) {
     super(journal,
         Executors.newFixedThreadPool(2, ThreadFactoryUtils.build("file-system-master-%d", true)),
         tachyonConf);
     mBlockMaster = blockMaster;
-    mMasterSource = masterSource;
 
     mDirectoryIdGenerator = new InodeDirectoryIdGenerator(mBlockMaster);
     mInodeTree = new InodeTree(mBlockMaster, mDirectoryIdGenerator);
@@ -273,7 +272,7 @@ boolean completeFileCheckpointInternal(long workerId, long fileId,
     mDependencyMap.addFileCheckpoint(fileId);
     file.setLastModificationTimeMs(opTimeMs);
     file.setComplete(length);
-    mMasterSource.incFilesCheckpointed();
     // TODO: This probably should always be true since the last mod time is updated
     return needLog;
   }
@@ -336,7 +335,7 @@ public long getFileId(TachyonURI path) throws InvalidPathException {
    * @throws InvalidPathException
    */
   public FileInfo getFileInfo(long fileId) throws FileDoesNotExistException, InvalidPathException {
-    mMasterSource.incGetFileStatusOps();
     synchronized (mInodeTree) {
       Inode inode = mInodeTree.getInodeById(fileId);
       return getFileInfo(inode);
@@ -449,7 +448,7 @@ private void completeFileFromEntry(CompleteFileEntry entry) {
    */
   public long createFile(TachyonURI path, long blockSizeBytes, boolean recursive)
       throws InvalidPathException, FileAlreadyExistException, BlockInfoException {
-    mMasterSource.incCreateFileOps();
     synchronized (mInodeTree) {
       InodeTree.CreatePathResult createResult =
           createFileInternal(path, blockSizeBytes, recursive, System.currentTimeMillis());
@@ -473,7 +472,7 @@ InodeTree.CreatePathResult createFileInternal(TachyonURI path, long blockSizeByt
     if (mWhitelist.inList(path.toString())) {
       inode.setCache(true);
     }
-    mMasterSource.incFilesCreated(created.size());
     return createResult;
   }
 
@@ -528,7 +527,7 @@ public int getNumberOfPinnedFiles() {
    */
   public boolean deleteFile(long fileId, boolean recursive)
       throws TachyonException, FileDoesNotExistException {
-    mMasterSource.incDeleteFileOps();
     synchronized (mInodeTree) {
       long opTimeMs = System.currentTimeMillis();
       boolean ret = deleteFileInternal(fileId, recursive, opTimeMs);
@@ -539,7 +538,7 @@ public boolean deleteFile(long fileId, boolean recursive)
   }
 
   private void deleteFileFromEntry(DeleteFileEntry entry) {
-    mMasterSource.incDeleteFileOps();
     try {
       deleteFileInternal(entry.mFileId, entry.mRecursive, entry.mOpTimeMs);
     } catch (Exception e) {
@@ -601,7 +600,7 @@ private boolean deleteInodeInternal(Inode inode, boolean recursive, long opTimeM
 
       mInodeTree.deleteInode(delInode, opTimeMs);
     }
-    mMasterSource.incFilesDeleted(delInodes.size());
     return true;
   }
 
@@ -848,7 +847,7 @@ private void journalCreatePathResult(InodeTree.CreatePathResult createResult) {
    */
   public boolean rename(long fileId, TachyonURI dstPath)
       throws InvalidPathException, FileDoesNotExistException {
-    mMasterSource.incRenameOps();
     synchronized (mInodeTree) {
       Inode srcInode = mInodeTree.getInodeById(fileId);
       TachyonURI srcPath = mInodeTree.getPath(srcInode);
@@ -918,11 +917,11 @@ void renameInternal(long fileId, TachyonURI dstPath, long opTimeMs)
     srcInode.setName(dstPath.getName());
     ((InodeDirectory) dstParentInode).addChild(srcInode);
     dstParentInode.setLastModificationTimeMs(opTimeMs);
-    mMasterSource.incFilesRenamed();
   }
 
   private void renameFromEntry(RenameEntry entry) {
-    mMasterSource.incRenameOps();
     try {
       renameInternal(entry.mFileId, new TachyonURI(entry.mDstPath), entry.mOpTimeMs);
     } catch (Exception e) {
</code_before><code_after>@@ -36,6 +36,7 @@
 import tachyon.TachyonURI;
 import tachyon.conf.TachyonConf;
 import tachyon.master.MasterBase;
+import tachyon.master.MasterContext;
 import tachyon.master.MasterSource;
 import tachyon.master.block.BlockId;
 import tachyon.master.block.BlockMaster;
@@ -81,7 +82,6 @@ public final class FileSystemMaster extends MasterBase {
   private static final Logger LOG = LoggerFactory.getLogger(Constants.LOGGER_TYPE);
 
   private final BlockMaster mBlockMaster;
 
   /** This manages the file system inode structure. This must be journaled. */
   private final InodeTree mInodeTree;
@@ -101,12 +101,11 @@ public static String getJournalDirectory(String baseDirectory) {
   }
 
   public FileSystemMaster(TachyonConf tachyonConf, BlockMaster blockMaster,
+      Journal journal) {
     super(journal,
         Executors.newFixedThreadPool(2, ThreadFactoryUtils.build("file-system-master-%d", true)),
         tachyonConf);
     mBlockMaster = blockMaster;
 
     mDirectoryIdGenerator = new InodeDirectoryIdGenerator(mBlockMaster);
     mInodeTree = new InodeTree(mBlockMaster, mDirectoryIdGenerator);
@@ -273,7 +272,7 @@ boolean completeFileCheckpointInternal(long workerId, long fileId,
     mDependencyMap.addFileCheckpoint(fileId);
     file.setLastModificationTimeMs(opTimeMs);
     file.setComplete(length);
+    MasterContext.getMasterSource().incFilesCheckpointed();
     // TODO: This probably should always be true since the last mod time is updated
     return needLog;
   }
@@ -336,7 +335,7 @@ public long getFileId(TachyonURI path) throws InvalidPathException {
    * @throws InvalidPathException
    */
   public FileInfo getFileInfo(long fileId) throws FileDoesNotExistException, InvalidPathException {
+    MasterContext.getMasterSource().incGetFileStatusOps();
     synchronized (mInodeTree) {
       Inode inode = mInodeTree.getInodeById(fileId);
       return getFileInfo(inode);
@@ -449,7 +448,7 @@ private void completeFileFromEntry(CompleteFileEntry entry) {
    */
   public long createFile(TachyonURI path, long blockSizeBytes, boolean recursive)
       throws InvalidPathException, FileAlreadyExistException, BlockInfoException {
+    MasterContext.getMasterSource().incCreateFileOps();
     synchronized (mInodeTree) {
       InodeTree.CreatePathResult createResult =
           createFileInternal(path, blockSizeBytes, recursive, System.currentTimeMillis());
@@ -473,7 +472,7 @@ InodeTree.CreatePathResult createFileInternal(TachyonURI path, long blockSizeByt
     if (mWhitelist.inList(path.toString())) {
       inode.setCache(true);
     }
+    MasterContext.getMasterSource().incFilesCreated(created.size());
     return createResult;
   }
 
@@ -528,7 +527,7 @@ public int getNumberOfPinnedFiles() {
    */
   public boolean deleteFile(long fileId, boolean recursive)
       throws TachyonException, FileDoesNotExistException {
+    MasterContext.getMasterSource().incDeleteFileOps();
     synchronized (mInodeTree) {
       long opTimeMs = System.currentTimeMillis();
       boolean ret = deleteFileInternal(fileId, recursive, opTimeMs);
@@ -539,7 +538,7 @@ public boolean deleteFile(long fileId, boolean recursive)
   }
 
   private void deleteFileFromEntry(DeleteFileEntry entry) {
+    MasterContext.getMasterSource().incDeleteFileOps();
     try {
       deleteFileInternal(entry.mFileId, entry.mRecursive, entry.mOpTimeMs);
     } catch (Exception e) {
@@ -601,7 +600,7 @@ private boolean deleteInodeInternal(Inode inode, boolean recursive, long opTimeM
 
       mInodeTree.deleteInode(delInode, opTimeMs);
     }
+    MasterContext.getMasterSource().incFilesDeleted(delInodes.size());
     return true;
   }
 
@@ -848,7 +847,7 @@ private void journalCreatePathResult(InodeTree.CreatePathResult createResult) {
    */
   public boolean rename(long fileId, TachyonURI dstPath)
       throws InvalidPathException, FileDoesNotExistException {
+    MasterContext.getMasterSource().incRenameOps();
     synchronized (mInodeTree) {
       Inode srcInode = mInodeTree.getInodeById(fileId);
       TachyonURI srcPath = mInodeTree.getPath(srcInode);
@@ -918,11 +917,11 @@ void renameInternal(long fileId, TachyonURI dstPath, long opTimeMs)
     srcInode.setName(dstPath.getName());
     ((InodeDirectory) dstParentInode).addChild(srcInode);
     dstParentInode.setLastModificationTimeMs(opTimeMs);
+    MasterContext.getMasterSource().incFilesRenamed();
   }
 
   private void renameFromEntry(RenameEntry entry) {
+    MasterContext.getMasterSource().incRenameOps();
     try {
       renameInternal(entry.mFileId, new TachyonURI(entry.mDstPath), entry.mOpTimeMs);
     } catch (Exception e) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>525693</refactoring_id><commit_sha>1a2ea0c03a262c00bbcb77dcf4e1a9530c3fd0c1</commit_sha><commit_link>https://github.com/apache/iotdb/commit/1a2ea0c03a262c00bbcb77dcf4e1a9530c3fd0c1</commit_link><file_path>tsfile/src/main/java/org/apache/iotdb/tsfile/read/common/block/column/ColumnBuilder.java</file_path><description>Remove Parameter timeBuilder : TimeColumnBuilder in method public appendColumn(timeColumn TimeColumn, valueColumn Column, offset int, timeBuilder TimeColumnBuilder) : int from class org.apache.iotdb.tsfile.read.common.block.column.ColumnBuilder</description><code_before>@@ -64,12 +64,25 @@ default ColumnBuilder writeObject(Object value) {
     throw new UnsupportedOperationException(getClass().getName());
   }
 
-  int appendColumn(
-      TimeColumn timeColumn, Column valueColumn, int offset, TimeColumnBuilder timeBuilder);
 
   /** Appends a null value to the block. */
   ColumnBuilder appendNull();
 
   /** Builds the block. This method can be called multiple times. */
   Column build();
 
</code_before><code_after>@@ -64,12 +64,25 @@ default ColumnBuilder writeObject(Object value) {
     throw new UnsupportedOperationException(getClass().getName());
   }
 
+  /**
+   * Write value at index of passing column
+   *
+   * @param column source column whose type should be same as ColumnBuilder
+   * @param index index of source column to read from
+   */
+  ColumnBuilder write(Column column, int index);
 
   /** Appends a null value to the block. */
   ColumnBuilder appendNull();
 
+  /** Appends nullCount null value to the block. */
+  default ColumnBuilder appendNull(int nullCount) {
+    for (int i = 0; i &lt; nullCount; i++) {
+      appendNull();
+    }
+    return this;
+  }
+
   /** Builds the block. This method can be called multiple times. */
   Column build();
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>577093</refactoring_id><commit_sha>ee9f9b227a7703c2688924070c4746a70bff3fd8</commit_sha><commit_link>https://github.com/apache/flink/commit/ee9f9b227a7703c2688924070c4746a70bff3fd8</commit_link><file_path>flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java</file_path><description>Remove Parameter streamStatusProvider : StreamStatusProvider in method public ChainingOutput(operator OneInputStreamOperator&lt;T,?&gt;, streamStatusProvider StreamStatusProvider, outputTag OutputTag&lt;T&gt;) from class org.apache.flink.streaming.runtime.tasks.ChainingOutput</description><code_before>@@ -29,7 +29,6 @@
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.util.OutputTag;
 
 import org.slf4j.Logger;
@@ -43,26 +42,16 @@ class ChainingOutput&lt;T&gt; implements WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt;
     protected final Input&lt;T&gt; input;
     protected final Counter numRecordsIn;
     protected final WatermarkGauge watermarkGauge = new WatermarkGauge();
-    protected final StreamStatusProvider streamStatusProvider;
     @Nullable protected final OutputTag&lt;T&gt; outputTag;
     @Nullable protected final AutoCloseable closeable;
 
-    public ChainingOutput(
-            OneInputStreamOperator&lt;T, ?&gt; operator,
-            StreamStatusProvider streamStatusProvider,
-            @Nullable OutputTag&lt;T&gt; outputTag) {
-        this(
-                operator,
-                (OperatorMetricGroup) operator.getMetricGroup(),
-                streamStatusProvider,
-                outputTag,
-                operator::close);
     }
 
     public ChainingOutput(
             Input&lt;T&gt; input,
             OperatorMetricGroup operatorMetricGroup,
-            StreamStatusProvider streamStatusProvider,
             @Nullable OutputTag&lt;T&gt; outputTag,
             @Nullable AutoCloseable closeable) {
         this.input = input;
@@ -80,7 +69,6 @@ public ChainingOutput(
             numRecordsIn = tmpNumRecordsIn;
         }
 
-        this.streamStatusProvider = streamStatusProvider;
         this.outputTag = outputTag;
     }
 
@@ -120,9 +108,7 @@ protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) {
     public void emitWatermark(Watermark mark) {
         try {
             watermarkGauge.setCurrentWatermark(mark.getTimestamp());
-            if (streamStatusProvider.getStreamStatus().isActive()) {
-                input.processWatermark(mark);
-            }
         } catch (Exception e) {
             throw new ExceptionInChainedOperatorException(e);
         }
</code_before><code_after>@@ -29,7 +29,6 @@
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.util.OutputTag;
 
 import org.slf4j.Logger;
@@ -43,26 +42,16 @@ class ChainingOutput&lt;T&gt; implements WatermarkGaugeExposingOutput&lt;StreamRecord&lt;T&gt;&gt;
     protected final Input&lt;T&gt; input;
     protected final Counter numRecordsIn;
     protected final WatermarkGauge watermarkGauge = new WatermarkGauge();
     @Nullable protected final OutputTag&lt;T&gt; outputTag;
     @Nullable protected final AutoCloseable closeable;
 
+    public ChainingOutput(OneInputStreamOperator&lt;T, ?&gt; operator, @Nullable OutputTag&lt;T&gt; outputTag) {
+        this(operator, (OperatorMetricGroup) operator.getMetricGroup(), outputTag, operator::close);
     }
 
     public ChainingOutput(
             Input&lt;T&gt; input,
             OperatorMetricGroup operatorMetricGroup,
             @Nullable OutputTag&lt;T&gt; outputTag,
             @Nullable AutoCloseable closeable) {
         this.input = input;
@@ -80,7 +69,6 @@ public ChainingOutput(
             numRecordsIn = tmpNumRecordsIn;
         }
 
         this.outputTag = outputTag;
     }
 
@@ -120,9 +108,7 @@ protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) {
     public void emitWatermark(Watermark mark) {
         try {
             watermarkGauge.setCurrentWatermark(mark.getTimestamp());
+            input.processWatermark(mark);
         } catch (Exception e) {
             throw new ExceptionInChainedOperatorException(e);
         }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>487419</refactoring_id><commit_sha>db90108089847774dd27cd5cc104454249a0939f</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/db90108089847774dd27cd5cc104454249a0939f</commit_link><file_path>community/neo4j-slf4j-provider/src/main/java/org/neo4j/server/logging/slf4j/SLF4JToLog4jLoggerFactory.java</file_path><description>Remove Parameter level : Level in method public SLF4JToLog4jLoggerFactory(logProvider Log4jLogProvider, markerFactory SLF4JToLog4jMarkerFactory, classPrefixes List&lt;String&gt;, level Level) from class org.neo4j.server.logging.slf4j.SLF4JToLog4jLoggerFactory</description><code_before>@@ -24,24 +24,18 @@
 import org.neo4j.logging.log4j.Log4jLogProvider;
 import org.slf4j.ILoggerFactory;
 import org.slf4j.Logger;
-import org.slf4j.event.Level;
 import org.slf4j.helpers.NOPLogger;
 
 public class SLF4JToLog4jLoggerFactory implements ILoggerFactory {
     private final Log4jLogProvider logProvider;
     private final SLF4JToLog4jMarkerFactory markerFactory;
     private final List&lt;String&gt; classPrefixes;
-    private final Level level;
 
     public SLF4JToLog4jLoggerFactory(
-            Log4jLogProvider logProvider,
-            SLF4JToLog4jMarkerFactory markerFactory,
-            List&lt;String&gt; classPrefixes,
-            Level level) {
         this.logProvider = logProvider;
         this.markerFactory = markerFactory;
         this.classPrefixes = classPrefixes;
-        this.level = level;
     }
 
     @Override
@@ -51,7 +45,7 @@ public Logger getLogger(String name) {
         }
 
         String key = remapRootLogger(name);
-        return new SLF4JToLog4jLogger(markerFactory, logProvider.getLog(key), name, level);
     }
 
     private boolean shouldInclude(String name) {
</code_before><code_after>@@ -24,24 +24,18 @@
 import org.neo4j.logging.log4j.Log4jLogProvider;
 import org.slf4j.ILoggerFactory;
 import org.slf4j.Logger;
 import org.slf4j.helpers.NOPLogger;
 
 public class SLF4JToLog4jLoggerFactory implements ILoggerFactory {
     private final Log4jLogProvider logProvider;
     private final SLF4JToLog4jMarkerFactory markerFactory;
     private final List&lt;String&gt; classPrefixes;
 
     public SLF4JToLog4jLoggerFactory(
+            Log4jLogProvider logProvider, SLF4JToLog4jMarkerFactory markerFactory, List&lt;String&gt; classPrefixes) {
         this.logProvider = logProvider;
         this.markerFactory = markerFactory;
         this.classPrefixes = classPrefixes;
     }
 
     @Override
@@ -51,7 +45,7 @@ public Logger getLogger(String name) {
         }
 
         String key = remapRootLogger(name);
+        return new SLF4JToLog4jLogger(markerFactory, logProvider.getLog(key), name);
     }
 
     private boolean shouldInclude(String name) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>581383</refactoring_id><commit_sha>481c8e4f02a5e329c810d0086b81e708e0a6790c</commit_sha><commit_link>https://github.com/bcgit/bc-java/commit/481c8e4f02a5e329c810d0086b81e708e0a6790c</commit_link><file_path>tls/src/main/java/org/bouncycastle/tls/TlsDHKeyExchange.java</file_path><description>Remove Parameter supportedSignatureAlgorithms : Vector in method public TlsDHKeyExchange(keyExchange int, supportedSignatureAlgorithms Vector) from class org.bouncycastle.tls.TlsDHKeyExchange</description><code_before>@@ -3,7 +3,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.util.Vector;
 
 import org.bouncycastle.tls.crypto.TlsCertificate;
 import org.bouncycastle.tls.crypto.TlsSecret;
@@ -29,9 +28,9 @@ private static int checkKeyExchange(int keyExchange)
     protected TlsCredentialedAgreement agreementCredentials;
     protected TlsCertificate dhPeerCertificate;
 
-    public TlsDHKeyExchange(int keyExchange, Vector supportedSignatureAlgorithms)
     {
-        super(checkKeyExchange(keyExchange), supportedSignatureAlgorithms);
     }
 
     public void skipServerCredentials() throws IOException
@@ -46,8 +45,7 @@ public void processServerCredentials(TlsCredentials serverCredentials) throws IO
 
     public void processServerCertificate(Certificate serverCertificate) throws IOException
     {
-        this.dhPeerCertificate = checkSigAlgOfServerCerts(serverCertificate)
-            .useInRole(ConnectionEnd.server, keyExchange);
     }
 
     public short[] getClientCertificateTypes()
</code_before><code_after>@@ -3,7 +3,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
 import org.bouncycastle.tls.crypto.TlsCertificate;
 import org.bouncycastle.tls.crypto.TlsSecret;
@@ -29,9 +28,9 @@ private static int checkKeyExchange(int keyExchange)
     protected TlsCredentialedAgreement agreementCredentials;
     protected TlsCertificate dhPeerCertificate;
 
+    public TlsDHKeyExchange(int keyExchange)
     {
+        super(checkKeyExchange(keyExchange));
     }
 
     public void skipServerCredentials() throws IOException
@@ -46,8 +45,7 @@ public void processServerCredentials(TlsCredentials serverCredentials) throws IO
 
     public void processServerCertificate(Certificate serverCertificate) throws IOException
     {
+        this.dhPeerCertificate = serverCertificate.getCertificateAt(0).useInRole(ConnectionEnd.server, keyExchange);
     }
 
     public short[] getClientCertificateTypes()
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>501553</refactoring_id><commit_sha>d34f64cb66eab01532b1514a7d31d557a694e049</commit_sha><commit_link>https://github.com/elastic/logstash/commit/d34f64cb66eab01532b1514a7d31d557a694e049</commit_link><file_path>logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java</file_path><description>Remove Parameter context : ThreadContext in method public id(context ThreadContext) : IRubyObject from class org.logstash.config.ir.compiler.FilterDelegatorExt</description><code_before>@@ -16,6 +16,7 @@
 import org.logstash.RubyUtil;
 import org.logstash.execution.WorkerLoop;
 import org.logstash.ext.JrubyEventExtLibrary;
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
 
@@ -40,21 +41,21 @@ public final class FilterDelegatorExt extends RubyObject {
 
     private boolean flushes;
 
-    @JRubyMethod(name = "initialize", required = 2)
-    public IRubyObject init(final ThreadContext context, final IRubyObject filter, final IRubyObject id) {
         this.id = (RubyString) id;
         this.filter = filter;
         this.filterClass = filter.getSingletonClass().getRealClass();
-        final IRubyObject namespacedMetric = filter.callMethod(context, "metric");
-        metricEvents = namespacedMetric.callMethod(context, "namespace", MetricKeys.EVENTS_KEY);
         eventMetricOut = LongCounter.fromRubyBase(metricEvents, MetricKeys.OUT_KEY);
         eventMetricIn = LongCounter.fromRubyBase(metricEvents, MetricKeys.IN_KEY);
         eventMetricTime = LongCounter.fromRubyBase(
             metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY
         );
-        namespacedMetric.callMethod(
-            context, "gauge", new IRubyObject[]{MetricKeys.NAME_KEY, configName(context)}
-        );
         flushes = filter.respondsTo("flush");
         return this;
     }
@@ -108,17 +109,18 @@ public IRubyObject configName(final ThreadContext context) {
         return filterClass.callMethod(context, "config_name");
     }
 
-    @JRubyMethod
-    public IRubyObject id(final ThreadContext context) {
         return id;
     }
 
     @SuppressWarnings("unchecked")
     public RubyArray multiFilter(final RubyArray batch) {
-        final ThreadContext context = WorkerLoop.THREAD_CONTEXT.get();
         eventMetricIn.increment((long) batch.size());
         final long start = System.nanoTime();
-        final RubyArray result = (RubyArray) filter.callMethod(context, "multi_filter", batch);
         eventMetricTime.increment(
             TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS)
         );
</code_before><code_after>@@ -16,6 +16,7 @@
 import org.logstash.RubyUtil;
 import org.logstash.execution.WorkerLoop;
 import org.logstash.ext.JrubyEventExtLibrary;
+import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
 
@@ -40,21 +41,21 @@ public final class FilterDelegatorExt extends RubyObject {
 
     private boolean flushes;
 
+    @JRubyMethod
+    public IRubyObject initialize(final ThreadContext context, final IRubyObject filter,
+        final IRubyObject id) {
         this.id = (RubyString) id;
         this.filter = filter;
         this.filterClass = filter.getSingletonClass().getRealClass();
+        final AbstractNamespacedMetricExt namespacedMetric =
+            (AbstractNamespacedMetricExt) filter.callMethod(context, "metric");
+        metricEvents = namespacedMetric.namespace(context, MetricKeys.EVENTS_KEY);
         eventMetricOut = LongCounter.fromRubyBase(metricEvents, MetricKeys.OUT_KEY);
         eventMetricIn = LongCounter.fromRubyBase(metricEvents, MetricKeys.IN_KEY);
         eventMetricTime = LongCounter.fromRubyBase(
             metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY
         );
+        namespacedMetric.gauge(context, MetricKeys.NAME_KEY, configName(context));
         flushes = filter.respondsTo("flush");
         return this;
     }
@@ -108,17 +109,18 @@ public IRubyObject configName(final ThreadContext context) {
         return filterClass.callMethod(context, "config_name");
     }
 
+    @JRubyMethod(name = "id")
+    public IRubyObject getId() {
         return id;
     }
 
     @SuppressWarnings("unchecked")
     public RubyArray multiFilter(final RubyArray batch) {
         eventMetricIn.increment((long) batch.size());
         final long start = System.nanoTime();
+        final RubyArray result = (RubyArray) filter.callMethod(
+            WorkerLoop.THREAD_CONTEXT.get(), "multi_filter", batch
+        );
         eventMetricTime.increment(
             TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS)
         );
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>532271</refactoring_id><commit_sha>84a508592afc8fde6e035f6fef7f5990752256f2</commit_sha><commit_link>https://github.com/apache/accumulo/commit/84a508592afc8fde6e035f6fef7f5990752256f2</commit_link><file_path>server/src/main/java/org/apache/accumulo/server/test/performance/scan/CollectTabletStats.java</file_path><description>Remove Parameter pass : byte[] in method private findTablets(selectLocalTablets boolean, user String, pass byte[], table String, zki Instance, locations Map&lt;KeyExtent,String&gt;) : List&lt;KeyExtent&gt; from class org.apache.accumulo.server.test.performance.scan.CollectTabletStats</description><code_before>@@ -18,7 +18,6 @@
 
 import java.io.IOException;
 import java.net.InetAddress;
-import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -64,7 +63,8 @@
 import org.apache.accumulo.core.iterators.system.MultiIterator;
 import org.apache.accumulo.core.iterators.system.VisibilityFilter;
 import org.apache.accumulo.core.security.Authorizations;
-import org.apache.accumulo.core.security.thrift.AuthInfo;
 import org.apache.accumulo.core.util.AddressUtil;
 import org.apache.accumulo.core.util.CachedConfiguration;
 import org.apache.accumulo.core.util.MetadataTable;
@@ -120,7 +120,7 @@ public static void main(String[] args) throws Exception {
     }
     
     Map&lt;KeyExtent,String&gt; locations = new HashMap&lt;KeyExtent,String&gt;();
-    List&lt;KeyExtent&gt; candidates = findTablets(!opts.selectFarTablets, opts.user, opts.getPassword(), opts.tableName, instance, locations);
     
     if (candidates.size() &lt; opts.numThreads) {
       System.err.println("ERROR : Unable to find " + opts.numThreads + " " + (opts.selectFarTablets ? "far" : "local") + " tablets");
@@ -132,7 +132,7 @@ public static void main(String[] args) throws Exception {
     Map&lt;KeyExtent,List&lt;String&gt;&gt; tabletFiles = new HashMap&lt;KeyExtent,List&lt;String&gt;&gt;();
     
     for (KeyExtent ke : tabletsToTest) {
-      List&lt;String&gt; files = getTabletFiles(opts.user, opts.getPassword(), opts.getInstance(), tableId, ke);
       tabletFiles.put(ke, files);
     }
     
@@ -340,11 +340,11 @@ private static void runTest(String desc, List&lt;Test&gt; tests, int numThreads, Execu
     
   }
   
-  private static List&lt;KeyExtent&gt; findTablets(boolean selectLocalTablets, String user, byte[] pass, String table, Instance zki,
       Map&lt;KeyExtent,String&gt; locations) throws Exception {
     SortedSet&lt;KeyExtent&gt; tablets = new TreeSet&lt;KeyExtent&gt;();
     
-    MetadataTable.getEntries(zki, new AuthInfo(user, ByteBuffer.wrap(pass), zki.getInstanceID()), table, false, locations, tablets);
     
     InetAddress localaddress = InetAddress.getLocalHost();
     
@@ -375,11 +375,11 @@ private static List&lt;KeyExtent&gt; selectRandomTablets(int numThreads, List&lt;KeyExten
     return tabletsToTest;
   }
   
-  private static List&lt;String&gt; getTabletFiles(String user, byte[] pass, Instance zki, String tableId, KeyExtent ke) {
     List&lt;String&gt; files = new ArrayList&lt;String&gt;();
     
     SortedMap&lt;Key,Value&gt; tkv = new TreeMap&lt;Key,Value&gt;();
-    MetadataTable.getTabletAndPrevTabletKeyValues(zki, tkv, ke, null, new AuthInfo(user, ByteBuffer.wrap(pass), zki.getInstanceID()));
     
     Set&lt;Entry&lt;Key,Value&gt;&gt; es = tkv.entrySet();
     for (Entry&lt;Key,Value&gt; entry : es) {
</code_before><code_after>@@ -18,7 +18,6 @@
 
 import java.io.IOException;
 import java.net.InetAddress;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -64,7 +63,8 @@
 import org.apache.accumulo.core.iterators.system.MultiIterator;
 import org.apache.accumulo.core.iterators.system.VisibilityFilter;
 import org.apache.accumulo.core.security.Authorizations;
+import org.apache.accumulo.core.security.tokens.AccumuloToken;
+import org.apache.accumulo.core.security.tokens.InstanceTokenWrapper;
 import org.apache.accumulo.core.util.AddressUtil;
 import org.apache.accumulo.core.util.CachedConfiguration;
 import org.apache.accumulo.core.util.MetadataTable;
@@ -120,7 +120,7 @@ public static void main(String[] args) throws Exception {
     }
     
     Map&lt;KeyExtent,String&gt; locations = new HashMap&lt;KeyExtent,String&gt;();
+    List&lt;KeyExtent&gt; candidates = findTablets(!opts.selectFarTablets, opts.getAccumuloToken(), opts.tableName, instance, locations);
     
     if (candidates.size() &lt; opts.numThreads) {
       System.err.println("ERROR : Unable to find " + opts.numThreads + " " + (opts.selectFarTablets ? "far" : "local") + " tablets");
@@ -132,7 +132,7 @@ public static void main(String[] args) throws Exception {
     Map&lt;KeyExtent,List&lt;String&gt;&gt; tabletFiles = new HashMap&lt;KeyExtent,List&lt;String&gt;&gt;();
     
     for (KeyExtent ke : tabletsToTest) {
+      List&lt;String&gt; files = getTabletFiles(opts.getAccumuloToken(), opts.getInstance(), tableId, ke);
       tabletFiles.put(ke, files);
     }
     
@@ -340,11 +340,11 @@ private static void runTest(String desc, List&lt;Test&gt; tests, int numThreads, Execu
     
   }
   
+  private static List&lt;KeyExtent&gt; findTablets(boolean selectLocalTablets, AccumuloToken&lt;?,?&gt; token, String table, Instance zki,
       Map&lt;KeyExtent,String&gt; locations) throws Exception {
     SortedSet&lt;KeyExtent&gt; tablets = new TreeSet&lt;KeyExtent&gt;();
     
+    MetadataTable.getEntries(zki, new InstanceTokenWrapper(token, zki.getInstanceID()), table, false, locations, tablets);
     
     InetAddress localaddress = InetAddress.getLocalHost();
     
@@ -375,11 +375,11 @@ private static List&lt;KeyExtent&gt; selectRandomTablets(int numThreads, List&lt;KeyExten
     return tabletsToTest;
   }
   
+  private static List&lt;String&gt; getTabletFiles(AccumuloToken&lt;?,?&gt; token, Instance zki, String tableId, KeyExtent ke) {
     List&lt;String&gt; files = new ArrayList&lt;String&gt;();
     
     SortedMap&lt;Key,Value&gt; tkv = new TreeMap&lt;Key,Value&gt;();
+    MetadataTable.getTabletAndPrevTabletKeyValues(zki, tkv, ke, null, new InstanceTokenWrapper(token, zki.getInstanceID()));
     
     Set&lt;Entry&lt;Key,Value&gt;&gt; es = tkv.entrySet();
     for (Entry&lt;Key,Value&gt; entry : es) {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>486593</refactoring_id><commit_sha>52d70ccb1fc327144db9c2a8296e0820a1f4aff2</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/52d70ccb1fc327144db9c2a8296e0820a1f4aff2</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/store/RelationshipGroupStore.java</file_path><description>Remove Parameter databaseName : String in method public RelationshipGroupStore(databaseName String, file File, idFile File, config Config, idGeneratorFactory IdGeneratorFactory, pageCache PageCache, logProvider LogProvider, recordFormats RecordFormats, openOptions OpenOption...) from class org.neo4j.kernel.impl.store.RelationshipGroupStore</description><code_before>@@ -36,7 +36,6 @@ public class RelationshipGroupStore extends CommonAbstractStore&lt;RelationshipGrou
     public static final String TYPE_DESCRIPTOR = "RelationshipGroupStore";
 
     public RelationshipGroupStore(
-            String databaseName,
             File file,
             File idFile,
             Config config,
@@ -46,7 +45,7 @@ public RelationshipGroupStore(
             RecordFormats recordFormats,
             OpenOption... openOptions )
     {
-        super( databaseName, file, idFile, config, IdType.RELATIONSHIP_GROUP, idGeneratorFactory, pageCache, logProvider, TYPE_DESCRIPTOR,
                 recordFormats.relationshipGroup(), new IntStoreHeaderFormat( config.get( GraphDatabaseSettings.dense_node_threshold ) ),
                 recordFormats.storeVersion(), openOptions );
     }
</code_before><code_after>@@ -36,7 +36,6 @@ public class RelationshipGroupStore extends CommonAbstractStore&lt;RelationshipGrou
     public static final String TYPE_DESCRIPTOR = "RelationshipGroupStore";
 
     public RelationshipGroupStore(
             File file,
             File idFile,
             Config config,
@@ -46,7 +45,7 @@ public RelationshipGroupStore(
             RecordFormats recordFormats,
             OpenOption... openOptions )
     {
+        super( file, idFile, config, IdType.RELATIONSHIP_GROUP, idGeneratorFactory, pageCache, logProvider, TYPE_DESCRIPTOR,
                 recordFormats.relationshipGroup(), new IntStoreHeaderFormat( config.get( GraphDatabaseSettings.dense_node_threshold ) ),
                 recordFormats.storeVersion(), openOptions );
     }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>567775</refactoring_id><commit_sha>2d8bd17158ac5c2791837f757a03bc2c887ee7d2</commit_sha><commit_link>https://github.com/cuba-platform/cuba/commit/2d8bd17158ac5c2791837f757a03bc2c887ee7d2</commit_link><file_path>modules/desktop/src/com/haulmont/cuba/desktop/gui/components/DesktopOptionsGroup.java</file_path><description>Remove Parameter enabled : boolean in method public setEnabled(enabled boolean) : void from class com.haulmont.cuba.desktop.gui.components.DesktopOptionsGroup</description><code_before>@@ -342,14 +342,11 @@ public void setOrientation(Orientation orientation) {
     }
 
     @Override
-    public boolean isEnabled() {
-        return enabled;
-    }
 
-    @Override
-    public void setEnabled(boolean enabled) {
-        this.enabled = enabled;
-        for (JToggleButton button : items.values())
-            button.setEnabled(enabled &amp;&amp; editable);
     }
 }
\ No newline at end of file
</code_before><code_after>@@ -342,14 +342,11 @@ public void setOrientation(Orientation orientation) {
     }
 
     @Override
+    public void updateEnabled() {
+        super.updateEnabled();
 
+        for (JToggleButton button : items.values()) {
+            button.setEnabled(enabled &amp;&amp; editable &amp;&amp; parentEnabled);
+        }
     }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>-1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>535974</refactoring_id><commit_sha>4f614fa0fd74ce29c5822e70f4815cc40745a2be</commit_sha><commit_link>https://github.com/spring-projects/spring-framework/commit/4f614fa0fd74ce29c5822e70f4815cc40745a2be</commit_link><file_path>spring-web-reactive/src/main/java/org/springframework/web/reactive/ResponseStatusExceptionHandler.java</file_path><description>Remove Parameter response : ServerHttpResponse in method public handle(request ServerHttpRequest, response ServerHttpResponse, ex Throwable) : Mono&lt;Void&gt; from class org.springframework.web.reactive.ResponseStatusExceptionHandler</description><code_before>@@ -17,23 +17,22 @@
 
 import reactor.Mono;
 
-import org.springframework.web.server.HttpExceptionHandler;
-import org.springframework.http.server.reactive.ServerHttpRequest;
-import org.springframework.http.server.reactive.ServerHttpResponse;
 import org.springframework.web.ResponseStatusException;
 
 /**
  * Handle {@link ResponseStatusException} by setting the response status.
  *
  * @author Rossen Stoyanchev
  */
-public class ResponseStatusExceptionHandler implements HttpExceptionHandler {
 
 
 	@Override
-	public Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response, Throwable ex) {
 		if (ex instanceof ResponseStatusException) {
-			response.setStatusCode(((ResponseStatusException) ex).getHttpStatus());
 			return Mono.empty();
 		}
 		return Mono.error(ex);
</code_before><code_after>@@ -17,23 +17,22 @@
 
 import reactor.Mono;
 
 import org.springframework.web.ResponseStatusException;
+import org.springframework.web.server.WebExceptionHandler;
+import org.springframework.web.server.WebServerExchange;
 
 /**
  * Handle {@link ResponseStatusException} by setting the response status.
  *
  * @author Rossen Stoyanchev
  */
+public class ResponseStatusExceptionHandler implements WebExceptionHandler {
 
 
 	@Override
+	public Mono&lt;Void&gt; handle(WebServerExchange exchange, Throwable ex) {
 		if (ex instanceof ResponseStatusException) {
+			exchange.getResponse().setStatusCode(((ResponseStatusException) ex).getHttpStatus());
 			return Mono.empty();
 		}
 		return Mono.error(ex);
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>526582</refactoring_id><commit_sha>4a3c173adb45d6371855c851fdf806b90db7950a</commit_sha><commit_link>https://github.com/mollyim/mollyim-android/commit/4a3c173adb45d6371855c851fdf806b90db7950a</commit_link><file_path>src/org/thoughtcrime/securesms/jobs/MultiDeviceVerifiedUpdateJob.java</file_path><description>Remove Parameter dataBuilder : Data.Builder in method protected serialize(dataBuilder Data.Builder) : Data from class org.thoughtcrime.securesms.jobs.MultiDeviceVerifiedUpdateJob</description><code_before>@@ -1,19 +1,18 @@
 package org.thoughtcrime.securesms.jobs;
 
 
-import android.content.Context;
 import android.support.annotation.NonNull;
 
-import org.thoughtcrime.securesms.jobmanager.SafeData;
 import org.thoughtcrime.securesms.logging.Log;
 
 import org.thoughtcrime.securesms.crypto.UnidentifiedAccessUtil;
 import org.thoughtcrime.securesms.database.Address;
 import org.thoughtcrime.securesms.database.IdentityDatabase.VerifiedStatus;
 import org.thoughtcrime.securesms.dependencies.InjectableType;
-import org.thoughtcrime.securesms.jobmanager.JobParameters;
 import org.thoughtcrime.securesms.util.Base64;
-import org.thoughtcrime.securesms.jobmanager.requirements.NetworkRequirement;
 import org.thoughtcrime.securesms.recipients.Recipient;
 import org.thoughtcrime.securesms.util.TextSecurePreferences;
 import org.whispersystems.libsignal.IdentityKey;
@@ -25,15 +24,13 @@
 import org.whispersystems.signalservice.api.push.exceptions.PushNetworkException;
 
 import java.io.IOException;
 
 import javax.inject.Inject;
 
-import androidx.work.Data;
-import androidx.work.WorkerParameters;
 
-public class MultiDeviceVerifiedUpdateJob extends ContextJob implements InjectableType {
-
-  private static final long serialVersionUID = 1L;
 
   private static final String TAG = MultiDeviceVerifiedUpdateJob.class.getSimpleName();
 
@@ -42,50 +39,52 @@ public class MultiDeviceVerifiedUpdateJob extends ContextJob implements Injectab
   private static final String KEY_VERIFIED_STATUS = "verified_status";
   private static final String KEY_TIMESTAMP       = "timestamp";
 
-  @Inject
-  transient SignalServiceMessageSender messageSender;
 
   private String         destination;
   private byte[]         identityKey;
   private VerifiedStatus verifiedStatus;
   private long           timestamp;
 
-  public MultiDeviceVerifiedUpdateJob(@NonNull Context context, @NonNull WorkerParameters workerParameters) {
-    super(context, workerParameters);
   }
 
-  public MultiDeviceVerifiedUpdateJob(Context context, Address destination, IdentityKey identityKey, VerifiedStatus verifiedStatus) {
-    super(context, JobParameters.newBuilder()
-                                .withNetworkRequirement()
-                                .withGroupId("__MULTI_DEVICE_VERIFIED_UPDATE__")
-                                .create());
 
     this.destination    = destination.serialize();
-    this.identityKey    = identityKey.serialize();
     this.verifiedStatus = verifiedStatus;
-    this.timestamp      = System.currentTimeMillis();
   }
 
   @Override
-  protected void initialize(@NonNull SafeData data) {
-    destination    = data.getString(KEY_DESTINATION);
-    verifiedStatus = VerifiedStatus.forState(data.getInt(KEY_VERIFIED_STATUS));
-    timestamp      = data.getLong(KEY_TIMESTAMP);
-
-    try {
-      identityKey = Base64.decode(data.getString(KEY_IDENTITY_KEY));
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
   }
 
   @Override
-  protected @NonNull Data serialize(@NonNull Data.Builder dataBuilder) {
-    return dataBuilder.putString(KEY_DESTINATION, destination)
-                      .putString(KEY_IDENTITY_KEY, Base64.encodeBytes(identityKey))
-                      .putInt(KEY_VERIFIED_STATUS, verifiedStatus.toInt())
-                      .putLong(KEY_TIMESTAMP, timestamp)
-                      .build();
   }
 
   @Override
@@ -134,4 +133,20 @@ public boolean onShouldRetry(Exception exception) {
   public void onCanceled() {
 
   }
 }
</code_before><code_after>@@ -1,19 +1,18 @@
 package org.thoughtcrime.securesms.jobs;
 
 
 import android.support.annotation.NonNull;
 
+import org.thoughtcrime.securesms.jobmanager.Data;
+import org.thoughtcrime.securesms.jobmanager.Job;
+import org.thoughtcrime.securesms.jobmanager.impl.NetworkConstraint;
 import org.thoughtcrime.securesms.logging.Log;
 
 import org.thoughtcrime.securesms.crypto.UnidentifiedAccessUtil;
 import org.thoughtcrime.securesms.database.Address;
 import org.thoughtcrime.securesms.database.IdentityDatabase.VerifiedStatus;
 import org.thoughtcrime.securesms.dependencies.InjectableType;
 import org.thoughtcrime.securesms.util.Base64;
 import org.thoughtcrime.securesms.recipients.Recipient;
 import org.thoughtcrime.securesms.util.TextSecurePreferences;
 import org.whispersystems.libsignal.IdentityKey;
@@ -25,15 +24,13 @@
 import org.whispersystems.signalservice.api.push.exceptions.PushNetworkException;
 
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 
 import javax.inject.Inject;
 
+public class MultiDeviceVerifiedUpdateJob extends BaseJob implements InjectableType {
 
+  public static final String KEY = "MultiDeviceVerifiedUpdateJob";
 
   private static final String TAG = MultiDeviceVerifiedUpdateJob.class.getSimpleName();
 
@@ -42,50 +39,52 @@ public class MultiDeviceVerifiedUpdateJob extends ContextJob implements Injectab
   private static final String KEY_VERIFIED_STATUS = "verified_status";
   private static final String KEY_TIMESTAMP       = "timestamp";
 
+  @Inject SignalServiceMessageSender messageSender;
 
   private String         destination;
   private byte[]         identityKey;
   private VerifiedStatus verifiedStatus;
   private long           timestamp;
 
+  public MultiDeviceVerifiedUpdateJob(Address destination, IdentityKey identityKey, VerifiedStatus verifiedStatus) {
+    this(new Job.Parameters.Builder()
+                           .addConstraint(NetworkConstraint.KEY)
+                           .setQueue("__MULTI_DEVICE_VERIFIED_UPDATE__")
+                           .setLifespan(TimeUnit.DAYS.toMillis(1))
+                           .setMaxAttempts(Parameters.UNLIMITED)
+                           .build(),
+         destination,
+         identityKey.serialize(),
+         verifiedStatus,
+         System.currentTimeMillis());
   }
 
+  private MultiDeviceVerifiedUpdateJob(@NonNull Job.Parameters parameters,
+                                       @NonNull Address destination,
+                                       @NonNull byte[] identityKey,
+                                       @NonNull VerifiedStatus verifiedStatus,
+                                       long timestamp)
+  {
+    super(parameters);
 
     this.destination    = destination.serialize();
+    this.identityKey    = identityKey;
     this.verifiedStatus = verifiedStatus;
+    this.timestamp      = timestamp;
   }
 
   @Override
+  public @NonNull Data serialize() {
+    return new Data.Builder().putString(KEY_DESTINATION, destination)
+                             .putString(KEY_IDENTITY_KEY, Base64.encodeBytes(identityKey))
+                             .putInt(KEY_VERIFIED_STATUS, verifiedStatus.toInt())
+                             .putLong(KEY_TIMESTAMP, timestamp)
+                             .build();
   }
 
   @Override
+  public @NonNull String getFactoryKey() {
+    return KEY;
   }
 
   @Override
@@ -134,4 +133,20 @@ public boolean onShouldRetry(Exception exception) {
   public void onCanceled() {
 
   }
+
+  public static final class Factory implements Job.Factory&lt;MultiDeviceVerifiedUpdateJob&gt; {
+    @Override
+    public @NonNull MultiDeviceVerifiedUpdateJob create(@NonNull Parameters parameters, @NonNull Data data) {
+      try {
+        Address        destination    = Address.fromSerialized(data.getString(KEY_DESTINATION));
+        VerifiedStatus verifiedStatus = VerifiedStatus.forState(data.getInt(KEY_VERIFIED_STATUS));
+        long           timestamp      = data.getLong(KEY_TIMESTAMP);
+        byte[]         identityKey    = Base64.decode(data.getString(KEY_IDENTITY_KEY));
+
+        return new MultiDeviceVerifiedUpdateJob(parameters, destination, identityKey, verifiedStatus, timestamp);
+      } catch (IOException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
 }
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>489659</refactoring_id><commit_sha>8225a063961a38153918bbeb9dd7c0a9e602edad</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/8225a063961a38153918bbeb9dd7c0a9e602edad</commit_link><file_path>community/kernel/src/main/java/org/neo4j/kernel/impl/core/NodeImpl.java</file_path><description>Remove Parameter firstRel : long in method package NodeImpl(id long, firstRel long, firstProp long) from class org.neo4j.kernel.impl.core.NodeImpl</description><code_before>@@ -62,13 +62,13 @@ public class NodeImpl extends ArrayBasedPrimitive
     private volatile long relChainPosition = Record.NO_NEXT_RELATIONSHIP.intValue();
     private final long id;
 
-    NodeImpl( long id, long firstRel, long firstProp )
     {
-        this( id, firstRel, firstProp, false );
     }
 
     // newNode will only be true for NodeManager.createNode
-    NodeImpl( long id, long firstRel, long firstProp, boolean newNode )
     {
         /* TODO firstRel/firstProp isn't used yet due to some unresolved issue with clearing
          * of cache and keeping those first ids in the node instead of loading on demand.
@@ -168,7 +168,7 @@ Iterable&lt;Relationship&gt; getAllRelationships( NodeManager nodeManager, DirectionWr
         {
             RelIdArray src = localRelationships[i];
             int type = src.getType();
-            RelIdIterator iterator = null;
             if ( addMap != null || skipMap != null )
             {
                 iterator = new CombinedRelIdIterator( type, direction, src,
@@ -231,16 +231,16 @@ Iterable&lt;Relationship&gt; getAllRelationshipsOfType( NodeManager nodeManager,
             skipMap = tx.getCowRelationshipRemoveMap( this );
         }
         int actualLength = 0;
-        for ( int i = 0; i &lt; types.length; i++ )
         {
-            Integer typeId = nodeManager.getRelationshipTypeIdFor( types[i] );
             if ( typeId == null )
             // This relationship type doesn't even exist in this database
             {
                 continue;
             }
 
-            result[actualLength++] = getRelationshipsIterator( nodeManager, direction,
                     addMap != null ? addMap.get( typeId ) : null,
                     skipMap != null ? skipMap.get( typeId ) : null, typeId );
         }
@@ -258,11 +258,11 @@ Iterable&lt;Relationship&gt; getAllRelationshipsOfType( NodeManager nodeManager,
         return new RelationshipIterator( result, this, direction, nodeManager, hasMore, false );
     }
 
-    private RelIdIterator getRelationshipsIterator( NodeManager nodeManager, DirectionWrapper direction,
                                                     RelIdArray add, Collection&lt;Long&gt; remove, int type )
     {
         RelIdArray src = getRelIdArray( type );
-        RelIdIterator iterator = null;
         if ( add != null || remove != null )
         {
             iterator = new CombinedRelIdIterator( type, direction, src, add, remove );
@@ -286,7 +286,7 @@ public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager, Directi
 
     public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager, RelationshipType type )
     {
-        return getAllRelationshipsOfType( nodeManager, DirectionWrapper.BOTH, new RelationshipType[]{type} );
     }
 
     public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager,
@@ -326,7 +326,7 @@ public Relationship getSingleRelationship( NodeManager nodeManager, Relationship
     public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager, RelationshipType type,
                                                     Direction dir )
     {
-        return getAllRelationshipsOfType( nodeManager, wrap( dir ), new RelationshipType[]{type} );
     }
 
     public void delete( NodeManager nodeManager, Node proxy )
@@ -448,7 +448,7 @@ public int compare( RelIdArray o1, RelIdArray o2 )
         @Override
         public int compare( Object o1, Object o2 )
         {
-            return ((RelIdArray) o1).getType() - ((Integer) o2).intValue();
         }
     };
 
@@ -655,7 +655,7 @@ public boolean hasRelationship( NodeManager nodeManager, RelationshipType type,
 
     protected void commitRelationshipMaps(
             ArrayMap&lt;Integer, RelIdArray&gt; cowRelationshipAddMap,
-            ArrayMap&lt;Integer, Collection&lt;Long&gt;&gt; cowRelationshipRemoveMap, long firstRel, NodeManager nodeManager )
     {
         if ( relationships == null )
         {
</code_before><code_after>@@ -62,13 +62,13 @@ public class NodeImpl extends ArrayBasedPrimitive
     private volatile long relChainPosition = Record.NO_NEXT_RELATIONSHIP.intValue();
     private final long id;
 
+    NodeImpl( long id )
     {
+        this( id, false );
     }
 
     // newNode will only be true for NodeManager.createNode
+    NodeImpl( long id, boolean newNode )
     {
         /* TODO firstRel/firstProp isn't used yet due to some unresolved issue with clearing
          * of cache and keeping those first ids in the node instead of loading on demand.
@@ -168,7 +168,7 @@ Iterable&lt;Relationship&gt; getAllRelationships( NodeManager nodeManager, DirectionWr
         {
             RelIdArray src = localRelationships[i];
             int type = src.getType();
+            RelIdIterator iterator;
             if ( addMap != null || skipMap != null )
             {
                 iterator = new CombinedRelIdIterator( type, direction, src,
@@ -231,16 +231,16 @@ Iterable&lt;Relationship&gt; getAllRelationshipsOfType( NodeManager nodeManager,
             skipMap = tx.getCowRelationshipRemoveMap( this );
         }
         int actualLength = 0;
+        for ( RelationshipType type : types )
         {
+            Integer typeId = nodeManager.getRelationshipTypeIdFor( type );
             if ( typeId == null )
             // This relationship type doesn't even exist in this database
             {
                 continue;
             }
 
+            result[actualLength++] = getRelationshipsIterator( direction,
                     addMap != null ? addMap.get( typeId ) : null,
                     skipMap != null ? skipMap.get( typeId ) : null, typeId );
         }
@@ -258,11 +258,11 @@ Iterable&lt;Relationship&gt; getAllRelationshipsOfType( NodeManager nodeManager,
         return new RelationshipIterator( result, this, direction, nodeManager, hasMore, false );
     }
 
+    private RelIdIterator getRelationshipsIterator( DirectionWrapper direction,
                                                     RelIdArray add, Collection&lt;Long&gt; remove, int type )
     {
         RelIdArray src = getRelIdArray( type );
+        RelIdIterator iterator;
         if ( add != null || remove != null )
         {
             iterator = new CombinedRelIdIterator( type, direction, src, add, remove );
@@ -286,7 +286,7 @@ public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager, Directi
 
     public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager, RelationshipType type )
     {
+        return getAllRelationshipsOfType( nodeManager, DirectionWrapper.BOTH, type );
     }
 
     public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager,
@@ -326,7 +326,7 @@ public Relationship getSingleRelationship( NodeManager nodeManager, Relationship
     public Iterable&lt;Relationship&gt; getRelationships( NodeManager nodeManager, RelationshipType type,
                                                     Direction dir )
     {
+        return getAllRelationshipsOfType( nodeManager, wrap( dir ), type );
     }
 
     public void delete( NodeManager nodeManager, Node proxy )
@@ -448,7 +448,7 @@ public int compare( RelIdArray o1, RelIdArray o2 )
         @Override
         public int compare( Object o1, Object o2 )
         {
+            return ((RelIdArray) o1).getType() - (Integer) o2;
         }
     };
 
@@ -655,7 +655,7 @@ public boolean hasRelationship( NodeManager nodeManager, RelationshipType type,
 
     protected void commitRelationshipMaps(
             ArrayMap&lt;Integer, RelIdArray&gt; cowRelationshipAddMap,
+            ArrayMap&lt;Integer, Collection&lt;Long&gt;&gt; cowRelationshipRemoveMap, NodeManager nodeManager )
     {
         if ( relationships == null )
         {
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>529343</refactoring_id><commit_sha>12b30b404c87c9b316dc691870a355fc46cf807b</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/12b30b404c87c9b316dc691870a355fc46cf807b</commit_link><file_path>Dart/src/com/jetbrains/lang/dart/ide/errorTreeView/DartProblemsTableModel.java</file_path><description>Remove Parameter project : Project in method package DartProblemsTableModel(project Project, presentationHelper DartProblemsPresentationHelper) from class com.jetbrains.lang.dart.ide.errorTreeView.DartProblemsTableModel</description><code_before>@@ -3,15 +3,10 @@
 
 import com.intellij.icons.AllIcons;
 import com.intellij.openapi.application.ApplicationManager;
-import com.intellij.openapi.project.Project;
-import com.intellij.openapi.roots.ProjectFileIndex;
 import com.intellij.openapi.util.text.StringUtil;
-import com.intellij.openapi.vfs.LocalFileSystem;
-import com.intellij.openapi.vfs.VirtualFile;
 import com.intellij.util.ui.ColumnInfo;
 import com.intellij.util.ui.ListTableModel;
 import com.jetbrains.lang.dart.DartBundle;
-import org.dartlang.analysis.server.protocol.AnalysisError;
 import org.dartlang.analysis.server.protocol.AnalysisErrorSeverity;
 import org.jetbrains.annotations.Nls;
 import org.jetbrains.annotations.NotNull;
@@ -60,7 +55,6 @@ public Component getTableCellRendererComponent(JTable table, Object value, boole
     }
   };
 
-  private final @NotNull Project myProject;
   private final @NotNull DartProblemsPresentationHelper myPresentationHelper;
 
   // Kind of hack to keep a reference to the live collection used in a super class, but it allows improving performance greatly.
@@ -80,15 +74,13 @@ public Component getTableCellRendererComponent(JTable table, Object value, boole
   private final Comparator&lt;DartProblem&gt; myDescriptionComparator = new DartProblemsComparator(DartProblemsComparator.MESSAGE_COLUMN_ID);
   private final Comparator&lt;DartProblem&gt; myLocationComparator = new DartProblemsComparator(DartProblemsComparator.LOCATION_COLUMN_ID);
 
-  DartProblemsTableModel(@NotNull Project project, @NotNull DartProblemsPresentationHelper presentationHelper) {
-    this(project, presentationHelper, new ArrayList&lt;&gt;());
   }
 
-  private DartProblemsTableModel(@NotNull Project project,
-                                 @NotNull DartProblemsPresentationHelper presentationHelper,
                                  @NotNull ArrayList&lt;DartProblem&gt; items) {
     super(ColumnInfo.EMPTY_ARRAY, items, 0, SortOrder.ASCENDING);
-    myProject = project;
     myPresentationHelper = presentationHelper;
     myItems = items;
     setColumnInfos(new ColumnInfo[]{createDescriptionColumn(), createLocationColumn()});
@@ -188,10 +180,10 @@ void removeAll() {
    * so that the caller could update selected row in the table
    */
   @Nullable
-  DartProblem setProblemsAndReturnReplacementForSelection(@NotNull Map&lt;String, List&lt;? extends AnalysisError&gt;&gt; filePathToErrors,
                                                           @Nullable DartProblem selectedProblem) {
-    boolean selectedProblemRemoved = removeRowsForFilesInSet(filePathToErrors.keySet(), selectedProblem);
-    return addErrorsAndReturnReplacementForSelection(filePathToErrors, selectedProblemRemoved ? selectedProblem : null);
   }
 
   private boolean removeRowsForFilesInSet(@NotNull Set&lt;String&gt; filePaths, @Nullable DartProblem selectedProblem) {
@@ -261,21 +253,15 @@ private boolean removeRowsForFilesInSet(@NotNull Set&lt;String&gt; filePaths, @Nullabl
     return selectedProblemRemoved;
   }
 
-  private @Nullable DartProblem addErrorsAndReturnReplacementForSelection(@NotNull Map&lt;String, List&lt;? extends AnalysisError&gt;&gt; filePathToErrors,
                                                                           @Nullable DartProblem oldSelectedProblem) {
     DartProblem newSelectedProblem = null;
-    DartProblemsViewSettings.ScopedAnalysisMode scopedAnalysisMode = myPresentationHelper.getScopedAnalysisMode();
 
     List&lt;DartProblem&gt; problemsToAdd = new ArrayList&lt;&gt;();
-    for (Map.Entry&lt;String, List&lt;? extends AnalysisError&gt;&gt; entry : filePathToErrors.entrySet()) {
-      String filePath = entry.getKey();
-      VirtualFile vFile = LocalFileSystem.getInstance().findFileByPath(filePath);
-      boolean fileOk = vFile != null &amp;&amp; (scopedAnalysisMode != DartProblemsViewSettings.ScopedAnalysisMode.All ||
-                                         ProjectFileIndex.getInstance(myProject).isInContent(vFile));
-      List&lt;? extends AnalysisError&gt; errors = fileOk ? entry.getValue() : AnalysisError.EMPTY_LIST;
-
-      for (AnalysisError analysisError : errors) {
-        DartProblem problem = new DartProblem(myProject, analysisError);
         problemsToAdd.add(problem);
 
         if (oldSelectedProblem != null &amp;&amp;
</code_before><code_after>@@ -3,15 +3,10 @@
 
 import com.intellij.icons.AllIcons;
 import com.intellij.openapi.application.ApplicationManager;
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.util.ui.ColumnInfo;
 import com.intellij.util.ui.ListTableModel;
 import com.jetbrains.lang.dart.DartBundle;
 import org.dartlang.analysis.server.protocol.AnalysisErrorSeverity;
 import org.jetbrains.annotations.Nls;
 import org.jetbrains.annotations.NotNull;
@@ -60,7 +55,6 @@ public Component getTableCellRendererComponent(JTable table, Object value, boole
     }
   };
 
   private final @NotNull DartProblemsPresentationHelper myPresentationHelper;
 
   // Kind of hack to keep a reference to the live collection used in a super class, but it allows improving performance greatly.
@@ -80,15 +74,13 @@ public Component getTableCellRendererComponent(JTable table, Object value, boole
   private final Comparator&lt;DartProblem&gt; myDescriptionComparator = new DartProblemsComparator(DartProblemsComparator.MESSAGE_COLUMN_ID);
   private final Comparator&lt;DartProblem&gt; myLocationComparator = new DartProblemsComparator(DartProblemsComparator.LOCATION_COLUMN_ID);
 
+  DartProblemsTableModel(@NotNull DartProblemsPresentationHelper presentationHelper) {
+    this(presentationHelper, new ArrayList&lt;&gt;());
   }
 
+  private DartProblemsTableModel(@NotNull DartProblemsPresentationHelper presentationHelper,
                                  @NotNull ArrayList&lt;DartProblem&gt; items) {
     super(ColumnInfo.EMPTY_ARRAY, items, 0, SortOrder.ASCENDING);
     myPresentationHelper = presentationHelper;
     myItems = items;
     setColumnInfos(new ColumnInfo[]{createDescriptionColumn(), createLocationColumn()});
@@ -188,10 +180,10 @@ void removeAll() {
    * so that the caller could update selected row in the table
    */
   @Nullable
+  DartProblem setProblemsAndReturnReplacementForSelection(@NotNull Map&lt;String, List&lt;DartProblem&gt;&gt; filePathToDartProblems,
                                                           @Nullable DartProblem selectedProblem) {
+    boolean selectedProblemRemoved = removeRowsForFilesInSet(filePathToDartProblems.keySet(), selectedProblem);
+    return addErrorsAndReturnReplacementForSelection(filePathToDartProblems, selectedProblemRemoved ? selectedProblem : null);
   }
 
   private boolean removeRowsForFilesInSet(@NotNull Set&lt;String&gt; filePaths, @Nullable DartProblem selectedProblem) {
@@ -261,21 +253,15 @@ private boolean removeRowsForFilesInSet(@NotNull Set&lt;String&gt; filePaths, @Nullabl
     return selectedProblemRemoved;
   }
 
+  private @Nullable DartProblem addErrorsAndReturnReplacementForSelection(@NotNull Map&lt;String, List&lt;DartProblem&gt;&gt; filePathToDartProblems,
                                                                           @Nullable DartProblem oldSelectedProblem) {
     DartProblem newSelectedProblem = null;
 
     List&lt;DartProblem&gt; problemsToAdd = new ArrayList&lt;&gt;();
+    for (Map.Entry&lt;String, List&lt;DartProblem&gt;&gt; entry : filePathToDartProblems.entrySet()) {
+      List&lt;DartProblem&gt; dartProblems = entry.getValue();
+
+      for (DartProblem problem : dartProblems) {
         problemsToAdd.add(problem);
 
         if (oldSelectedProblem != null &amp;&amp;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>470719</refactoring_id><commit_sha>f0000edc60ec4edf0b38c20344c2dccdc3e8d266</commit_sha><commit_link>https://github.com/dbeaver/dbeaver/commit/f0000edc60ec4edf0b38c20344c2dccdc3e8d266</commit_link><file_path>plugins/org.jkiss.dbeaver.db2/src/org/jkiss/dbeaver/ext/db2/model/plan/DB2PlanInstance.java</file_path><description>Remove Parameter dbResult : ResultSet in method private loadListPlanStatements(context JDBCExecutionContext, dbResult ResultSet) : List&lt;DB2PlanStatement&gt; from class org.jkiss.dbeaver.ext.db2.model.plan.DB2PlanInstance</description><code_before>@@ -21,7 +21,6 @@
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Timestamp;
-import java.util.ArrayList;
 /**
  * DB2 EXPLAIN_INSTANCE table
  * 
@@ -32,8 +31,6 @@
 
 import org.jkiss.dbeaver.ext.db2.model.DB2DataSource;
 import org.jkiss.dbeaver.model.exec.jdbc.JDBCExecutionContext;
-import org.jkiss.dbeaver.model.exec.jdbc.JDBCPreparedStatement;
-import org.jkiss.dbeaver.model.exec.jdbc.JDBCResultSet;
 import org.jkiss.dbeaver.model.impl.jdbc.JDBCUtils;
 
 /**
@@ -44,7 +41,19 @@
  */
 public class DB2PlanInstance {
 
-   private static String          SEL_EXP_STATEMENT; // See init below
 
    private List&lt;DB2PlanStatement&gt; listPlanStatements;
 
@@ -68,39 +77,6 @@ public DB2PlanInstance(DB2DataSource dataSource, JDBCExecutionContext context, R
       this.sourceSchema = JDBCUtils.safeGetStringTrimmed(dbResult, "SOURCE_SCHEMA");
       this.sourceVersion = JDBCUtils.safeGetStringTrimmed(dbResult, "SOURCE_VERSION");
 
-      this.listPlanStatements = loadListPlanStatements(context, dbResult);
-   }
-
-   // -------------
-   // Load children
-   // -------------
-   private List&lt;DB2PlanStatement&gt; loadListPlanStatements(JDBCExecutionContext context, ResultSet dbResult) throws SQLException {
-
-      List&lt;DB2PlanStatement&gt; listeRes = new ArrayList&lt;DB2PlanStatement&gt;();
-
-      JDBCPreparedStatement sqlStmt = context.prepareStatement(SEL_EXP_STATEMENT);
-      sqlStmt.setString(1, explainRequester);
-      sqlStmt.setTimestamp(2, explainTime);
-      sqlStmt.setString(3, sourceName);
-      sqlStmt.setString(4, sourceSchema);
-      sqlStmt.setString(5, sourceVersion);
-
-      JDBCResultSet res = null;
-      try {
-         res = sqlStmt.executeQuery();
-         while (dbResult.next()) {
-            listeRes.add(new DB2PlanStatement(context, res, this));
-         }
-      } finally {
-         if (res != null) {
-            res.close();
-         }
-         if (sqlStmt != null) {
-            sqlStmt.close();
-         }
-      }
-
-      return listeRes;
    }
 
    // -------------
@@ -141,15 +117,5 @@ public String getSourceVersion() {
    // -------
    // Queries
    // -------
-   static {
-      StringBuilder sb = new StringBuilder(1024);
-      sb.append("SELECT *");
-      sb.append(" FROM EXPLAIN_STATEMENT");
-      sb.append(" WHERE EXPLAIN_REQUESTER = ?");
-      sb.append("   AND EXPLAIN_TIME = ?");
-      sb.append("   AND SOURCE_NAME = ?");
-      sb.append("   AND SOURCE_SCHEMA = ?");
-      sb.append("   AND SOURCE_VERSION = ?");
-      SEL_EXP_STATEMENT = sb.toString();
-   }
 }
</code_before><code_after>@@ -21,7 +21,6 @@
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Timestamp;
 /**
  * DB2 EXPLAIN_INSTANCE table
  * 
@@ -32,8 +31,6 @@
 
 import org.jkiss.dbeaver.ext.db2.model.DB2DataSource;
 import org.jkiss.dbeaver.model.exec.jdbc.JDBCExecutionContext;
 import org.jkiss.dbeaver.model.impl.jdbc.JDBCUtils;
 
 /**
@@ -44,7 +41,19 @@
  */
 public class DB2PlanInstance {
 
+   private static String          SEL_EXP_STATEMENT;
+   static {
+      StringBuilder sb = new StringBuilder(1024);
+      sb.append("SELECT *");
+      sb.append(" FROM EXPLAIN_STATEMENT");
+      sb.append(" WHERE EXPLAIN_REQUESTER = ?");
+      sb.append("   AND EXPLAIN_TIME = ?");
+      sb.append("   AND SOURCE_NAME = ?");
+      sb.append("   AND SOURCE_SCHEMA = ?");
+      sb.append("   AND SOURCE_VERSION = ?");
+      sb.append(" WITH UR");
+      SEL_EXP_STATEMENT = sb.toString();
+   }
 
    private List&lt;DB2PlanStatement&gt; listPlanStatements;
 
@@ -68,39 +77,6 @@ public DB2PlanInstance(DB2DataSource dataSource, JDBCExecutionContext context, R
       this.sourceSchema = JDBCUtils.safeGetStringTrimmed(dbResult, "SOURCE_SCHEMA");
       this.sourceVersion = JDBCUtils.safeGetStringTrimmed(dbResult, "SOURCE_VERSION");
 
    }
 
    // -------------
@@ -141,15 +117,5 @@ public String getSourceVersion() {
    // -------
    // Queries
    // -------
+
 }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>592561</refactoring_id><commit_sha>80c9ff8f66a5708f64d5c0ac48f75e41d57fd915</commit_sha><commit_link>https://github.com/oracle/graal/commit/80c9ff8f66a5708f64d5c0ac48f75e41d57fd915</commit_link><file_path>substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/hosted/ReflectionDataBuilder.java</file_path><description>Remove Parameter finalIsWritable : boolean in method public register(finalIsWritable boolean, fields Field...) : void from class com.oracle.svm.reflect.hosted.ReflectionDataBuilder</description><code_before>@@ -42,6 +42,7 @@
 import java.util.stream.Collectors;
 
 import org.graalvm.nativeimage.hosted.Feature.DuringAnalysisAccess;
 import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;
 
 import com.oracle.graal.pointsto.meta.AnalysisType;
@@ -52,10 +53,11 @@
 import com.oracle.svm.core.util.VMError;
 import com.oracle.svm.hosted.FeatureImpl.DuringAnalysisAccessImpl;
 import com.oracle.svm.hosted.FeatureImpl.FeatureAccessImpl;
 import com.oracle.svm.hosted.substitute.SubstitutionReflectivityFilter;
 import com.oracle.svm.util.ReflectionUtil;
 
-public class ReflectionDataBuilder implements RuntimeReflectionSupport {
 
     public static final Field[] EMPTY_FIELDS = new Field[0];
     public static final Method[] EMPTY_METHODS = new Method[0];
@@ -70,7 +72,6 @@ public class ReflectionDataBuilder implements RuntimeReflectionSupport {
     private final Set&lt;Executable&gt; reflectionMethods = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());
     private final Set&lt;Field&gt; reflectionFields = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());
 
-    /* Keep track of classes already processed for reflection. */
     private final Set&lt;Class&lt;?&gt;&gt; processedClasses = new HashSet&lt;&gt;();
 
     private final ReflectionDataAccessors accessors;
@@ -108,8 +109,12 @@ private static DynamicHub.ReflectionData getArrayReflectionData() {
     }
 
     @Override
-    public void register(Class&lt;?&gt;... classes) {
         checkNotSealed();
         for (Class&lt;?&gt; clazz : classes) {
             if (reflectionClasses.add(clazz)) {
                 modifiedClasses.add(clazz);
@@ -118,8 +123,12 @@ public void register(Class&lt;?&gt;... classes) {
     }
 
     @Override
-    public void register(Executable... methods) {
         checkNotSealed();
         for (Executable method : methods) {
             if (reflectionMethods.add(method)) {
                 modifiedClasses.add(method.getDeclaringClass());
@@ -128,8 +137,12 @@ public void register(Executable... methods) {
     }
 
     @Override
-    public void register(boolean finalIsWritable, Field... fields) {
         checkNotSealed();
         // Unsafe and write accesses are always enabled for fields because accessors use Unsafe.
         for (Field field : fields) {
             if (reflectionFields.add(field)) {
</code_before><code_after>@@ -42,6 +42,7 @@
 import java.util.stream.Collectors;
 
 import org.graalvm.nativeimage.hosted.Feature.DuringAnalysisAccess;
+import org.graalvm.nativeimage.impl.ConfigurationCondition;
 import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;
 
 import com.oracle.graal.pointsto.meta.AnalysisType;
@@ -52,10 +53,11 @@
 import com.oracle.svm.core.util.VMError;
 import com.oracle.svm.hosted.FeatureImpl.DuringAnalysisAccessImpl;
 import com.oracle.svm.hosted.FeatureImpl.FeatureAccessImpl;
+import com.oracle.svm.hosted.ConditionalConfigurationRegistry;
 import com.oracle.svm.hosted.substitute.SubstitutionReflectivityFilter;
 import com.oracle.svm.util.ReflectionUtil;
 
+public class ReflectionDataBuilder extends ConditionalConfigurationRegistry implements RuntimeReflectionSupport {
 
     public static final Field[] EMPTY_FIELDS = new Field[0];
     public static final Method[] EMPTY_METHODS = new Method[0];
@@ -70,7 +72,6 @@ public class ReflectionDataBuilder implements RuntimeReflectionSupport {
     private final Set&lt;Executable&gt; reflectionMethods = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());
     private final Set&lt;Field&gt; reflectionFields = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());
 
     private final Set&lt;Class&lt;?&gt;&gt; processedClasses = new HashSet&lt;&gt;();
 
     private final ReflectionDataAccessors accessors;
@@ -108,8 +109,12 @@ private static DynamicHub.ReflectionData getArrayReflectionData() {
     }
 
     @Override
+    public void register(ConfigurationCondition condition, Class&lt;?&gt;... classes) {
         checkNotSealed();
+        registerConditionalConfiguration(condition, () -&gt; registerClasses(classes));
+    }
+
+    private void registerClasses(Class&lt;?&gt;[] classes) {
         for (Class&lt;?&gt; clazz : classes) {
             if (reflectionClasses.add(clazz)) {
                 modifiedClasses.add(clazz);
@@ -118,8 +123,12 @@ public void register(Class&lt;?&gt;... classes) {
     }
 
     @Override
+    public void register(ConfigurationCondition condition, Executable... methods) {
         checkNotSealed();
+        registerConditionalConfiguration(condition, () -&gt; registerMethods(methods));
+    }
+
+    private void registerMethods(Executable[] methods) {
         for (Executable method : methods) {
             if (reflectionMethods.add(method)) {
                 modifiedClasses.add(method.getDeclaringClass());
@@ -128,8 +137,12 @@ public void register(Executable... methods) {
     }
 
     @Override
+    public void register(ConfigurationCondition condition, boolean finalIsWritable, Field... fields) {
         checkNotSealed();
+        registerConditionalConfiguration(condition, () -&gt; registerFields(fields));
+    }
+
+    private void registerFields(Field[] fields) {
         // Unsafe and write accesses are always enabled for fields because accessors use Unsafe.
         for (Field field : fields) {
             if (reflectionFields.add(field)) {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>559378</refactoring_id><commit_sha>804365b89ae78e24eb2dddd5e0ba3b79a1793c5f</commit_sha><commit_link>https://github.com/iterate-ch/cyberduck/commit/804365b89ae78e24eb2dddd5e0ba3b79a1793c5f</commit_link><file_path>webdav/src/main/java/ch/cyberduck/core/dav/DAVTouchFeature.java</file_path><description>Remove Parameter attributes : AttributesFinder in method public DAVTouchFeature(writer Write&lt;Void&gt;, attributes AttributesFinder) from class ch.cyberduck.core.dav.DAVTouchFeature</description><code_before>@@ -15,28 +15,16 @@
  * GNU General Public License for more details.
  */
 
-import ch.cyberduck.core.Path;
-import ch.cyberduck.core.exception.BackgroundException;
-import ch.cyberduck.core.features.AttributesFinder;
 import ch.cyberduck.core.features.Write;
 import ch.cyberduck.core.shared.DefaultTouchFeature;
-import ch.cyberduck.core.transfer.TransferStatus;
 
 public class DAVTouchFeature extends DefaultTouchFeature&lt;Void&gt; {
 
-    private final AttributesFinder attributes;
-
     public DAVTouchFeature(final DAVSession session) {
-        this(new DAVWriteFeature(session), new DAVAttributesFinderFeature(session));
     }
 
-    public DAVTouchFeature(final Write&lt;Void&gt; writer, final AttributesFinder attributes) {
         super(writer);
-        this.attributes = attributes;
-    }
-
-    @Override
-    public Path touch(final Path file, final TransferStatus status) throws BackgroundException {
-        return super.touch(file, status).withAttributes(attributes.find(file));
     }
 }
</code_before><code_after>@@ -15,28 +15,16 @@
  * GNU General Public License for more details.
  */
 
 import ch.cyberduck.core.features.Write;
 import ch.cyberduck.core.shared.DefaultTouchFeature;
 
 public class DAVTouchFeature extends DefaultTouchFeature&lt;Void&gt; {
 
     public DAVTouchFeature(final DAVSession session) {
+        super(new DAVWriteFeature(session));
     }
 
+    public DAVTouchFeature(final Write&lt;Void&gt; writer) {
         super(writer);
     }
 }
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>570699</refactoring_id><commit_sha>21c0a8a915d2c05dd9d957fb502e1040ee5eafc7</commit_sha><commit_link>https://github.com/hyphanet/fred/commit/21c0a8a915d2c05dd9d957fb502e1040ee5eafc7</commit_link><file_path>src/freenet/support/PrioritizedSerialExecutor.java</file_path><description>Remove Parameter logMINOR : boolean in method private reallyStart(logMINOR boolean) : void from class freenet.support.PrioritizedSerialExecutor</description><code_before>@@ -9,6 +9,16 @@
 import freenet.support.io.NativeThread;
 
 public class PrioritizedSerialExecutor implements Executor {
 	
 	private final LinkedList&lt;Runnable&gt;[] jobs;
 	private final int priority;
@@ -46,7 +56,6 @@ public void run() {
 			}
 			try {
 			while(true) {
-				boolean logMINOR = Logger.shouldLog(Logger.MINOR, this);
 				Runnable job = null;
 				synchronized(jobs) {
 					job = checkQueue();
@@ -115,15 +124,15 @@ private Runnable checkQueue() {
 			if(!invertOrder) {
 				for(int i=0;i&lt;jobs.length;i++) {
 					if(!jobs[i].isEmpty()) {
-						if(Logger.shouldLog(Logger.MINOR, this))
 							Logger.minor(this, "Chosen job at priority "+i);
 						return (Runnable) jobs[i].removeFirst();
 					}
 				}
 			} else {
 				for(int i=jobs.length-1;i&gt;=0;i--) {
 					if(!jobs[i].isEmpty()) {
-						if(Logger.shouldLog(Logger.MINOR, this))
 							Logger.minor(this, "Chosen job at priority "+i);
 						return (Runnable) jobs[i].removeFirst();
 					}
@@ -162,11 +171,11 @@ public void start(Executor realExecutor, String name) {
 				}
 			}
 			if(!empty)
-				reallyStart(Logger.shouldLog(Logger.MINOR, this));
 		}
 	}
 	
-	private void reallyStart(boolean logMINOR) {
 		synchronized(jobs) {
 			if(running) {
 				Logger.error(this, "Not reallyStart()ing: ALREADY RUNNING", new Exception("error"));
@@ -186,20 +195,18 @@ public void execute(Runnable job, String jobName) {
 	}
 
 	public void execute(Runnable job, int prio, String jobName) {
-		boolean logMINOR = Logger.shouldLog(Logger.MINOR, this);
 		synchronized(jobs) {
 			if(logMINOR) 
 				Logger.minor(this, "Running "+jobName+" : "+job+" priority "+prio+" running="+running+" waiting="+waiting);
 			jobs[prio].addLast(job);
 			jobs.notifyAll();
 			if(!running &amp;&amp; realExecutor != null) {
-				reallyStart(logMINOR);
 			}
 		}
 	}
 
 	public void executeNoDupes(Runnable job, int prio, String jobName) {
-		boolean logMINOR = Logger.shouldLog(Logger.MINOR, this);
 		synchronized(jobs) {
 			if(logMINOR) 
 				Logger.minor(this, "Running "+jobName+" : "+job+" priority "+prio+" running="+running+" waiting="+waiting);
@@ -211,7 +218,7 @@ public void executeNoDupes(Runnable job, int prio, String jobName) {
 			jobs[prio].addLast(job);
 			jobs.notifyAll();
 			if(!running &amp;&amp; realExecutor != null) {
-				reallyStart(logMINOR);
 			}
 		}
 	}
</code_before><code_after>@@ -9,6 +9,16 @@
 import freenet.support.io.NativeThread;
 
 public class PrioritizedSerialExecutor implements Executor {
+	private static volatile boolean logMINOR;
+	
+	static {
+		Logger.registerLogThresholdCallback(new LogThresholdCallback() {
+			@Override
+			public void shouldUpdate() {
+				logMINOR = Logger.shouldLog(Logger.MINOR, this);
+			}
+		});
+	}
 	
 	private final LinkedList&lt;Runnable&gt;[] jobs;
 	private final int priority;
@@ -46,7 +56,6 @@ public void run() {
 			}
 			try {
 			while(true) {
 				Runnable job = null;
 				synchronized(jobs) {
 					job = checkQueue();
@@ -115,15 +124,15 @@ private Runnable checkQueue() {
 			if(!invertOrder) {
 				for(int i=0;i&lt;jobs.length;i++) {
 					if(!jobs[i].isEmpty()) {
+						if(logMINOR)
 							Logger.minor(this, "Chosen job at priority "+i);
 						return (Runnable) jobs[i].removeFirst();
 					}
 				}
 			} else {
 				for(int i=jobs.length-1;i&gt;=0;i--) {
 					if(!jobs[i].isEmpty()) {
+						if(logMINOR)
 							Logger.minor(this, "Chosen job at priority "+i);
 						return (Runnable) jobs[i].removeFirst();
 					}
@@ -162,11 +171,11 @@ public void start(Executor realExecutor, String name) {
 				}
 			}
 			if(!empty)
+				reallyStart();
 		}
 	}
 	
+	private void reallyStart() {
 		synchronized(jobs) {
 			if(running) {
 				Logger.error(this, "Not reallyStart()ing: ALREADY RUNNING", new Exception("error"));
@@ -186,20 +195,18 @@ public void execute(Runnable job, String jobName) {
 	}
 
 	public void execute(Runnable job, int prio, String jobName) {
 		synchronized(jobs) {
 			if(logMINOR) 
 				Logger.minor(this, "Running "+jobName+" : "+job+" priority "+prio+" running="+running+" waiting="+waiting);
 			jobs[prio].addLast(job);
 			jobs.notifyAll();
 			if(!running &amp;&amp; realExecutor != null) {
+				reallyStart();
 			}
 		}
 	}
 
 	public void executeNoDupes(Runnable job, int prio, String jobName) {
 		synchronized(jobs) {
 			if(logMINOR) 
 				Logger.minor(this, "Running "+jobName+" : "+job+" priority "+prio+" running="+running+" waiting="+waiting);
@@ -211,7 +218,7 @@ public void executeNoDupes(Runnable job, int prio, String jobName) {
 			jobs[prio].addLast(job);
 			jobs.notifyAll();
 			if(!running &amp;&amp; realExecutor != null) {
+				reallyStart();
 			}
 		}
 	}
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>490751</refactoring_id><commit_sha>a2ff0a94aff77a832db12e26734a03f97b5e809a</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/a2ff0a94aff77a832db12e26734a03f97b5e809a</commit_link><file_path>enterprise/kernel/src/main/java/org/neo4j/kernel/enterprise/builtinprocs/QueryStatusResult.java</file_path><description>Remove Parameter y : double in method private point(x double, y double, name String, code int, href String) : Point from class org.neo4j.kernel.enterprise.builtinprocs.QueryStatusResult.ParameterWriter</description><code_before>@@ -33,6 +33,7 @@
 import org.neo4j.kernel.api.query.QuerySnapshot;
 import org.neo4j.kernel.impl.core.NodeManager;
 import org.neo4j.kernel.impl.query.clientconnection.ClientConnectionInfo;
 import org.neo4j.kernel.impl.util.BaseToObjectValueWriter;
 import org.neo4j.values.virtual.MapValue;
 
@@ -153,19 +154,9 @@ protected Relationship newRelationshipProxyById( long id )
         }
 
         @Override
-        protected Point newGeographicPoint( double longitude, double latitude, String name, int code, String href )
-        {
-            return point( longitude, latitude, name, code, href );
-        }
-
-        @Override
-        protected Point newCartesianPoint( double x, double y, String name, int code, String href )
-        {
-            return point( x, y, name, code, href );
-        }
-
-        private Point point( double x, double y, String name, int code, String href )
         {
             return new Point()
             {
                 @Override
@@ -177,7 +168,7 @@ public String getGeometryType()
                 @Override
                 public List&lt;Coordinate&gt; getCoordinates()
                 {
-                    return singletonList( new Coordinate( x, y ) );
                 }
 
                 @Override
@@ -188,19 +179,19 @@ public CRS getCRS()
                         @Override
                         public int getCode()
                         {
-                            return code;
                         }
 
                         @Override
                         public String getType()
                         {
-                            return name;
                         }
 
                         @Override
                         public String getHref()
                         {
-                            return href;
                         }
                     };
                 }
</code_before><code_after>@@ -33,6 +33,7 @@
 import org.neo4j.kernel.api.query.QuerySnapshot;
 import org.neo4j.kernel.impl.core.NodeManager;
 import org.neo4j.kernel.impl.query.clientconnection.ClientConnectionInfo;
+import org.neo4j.values.virtual.CoordinateReferenceSystem;
 import org.neo4j.kernel.impl.util.BaseToObjectValueWriter;
 import org.neo4j.values.virtual.MapValue;
 
@@ -153,19 +154,9 @@ protected Relationship newRelationshipProxyById( long id )
         }
 
         @Override
+        protected Point newPoint( CoordinateReferenceSystem crs, double[] coordinate )
         {
+            //TODO: Is this required perhaps PointValue is sufficient without mapping to public?
             return new Point()
             {
                 @Override
@@ -177,7 +168,7 @@ public String getGeometryType()
                 @Override
                 public List&lt;Coordinate&gt; getCoordinates()
                 {
+                    return singletonList( new Coordinate( coordinate ) );
                 }
 
                 @Override
@@ -188,19 +179,19 @@ public CRS getCRS()
                         @Override
                         public int getCode()
                         {
+                            return crs.code;
                         }
 
                         @Override
                         public String getType()
                         {
+                            return crs.name;
                         }
 
                         @Override
                         public String getHref()
                         {
+                            return crs.href;
                         }
                     };
                 }
</code_after><evaluations><evaluation><vote>-1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>563836</refactoring_id><commit_sha>5b0566a70f373d6eb537c89c0db2a2e224706916</commit_sha><commit_link>https://github.com/apache/cassandra/commit/5b0566a70f373d6eb537c89c0db2a2e224706916</commit_link><file_path>src/java/org/apache/cassandra/db/ColumnFamilyStore.java</file_path><description>Remove Parameter sstableSet : SSTableSet in method public getOverlappingSSTables(sstableSet SSTableSet, sstables Iterable&lt;SSTableReader&gt;) : Collection&lt;SSTableReader&gt; from class org.apache.cassandra.db.ColumnFamilyStore</description><code_before>@@ -1231,7 +1231,7 @@ public void apply(PartitionUpdate update, UpdateTransaction indexer, OpOrder.Gro
      * @return sstables whose key range overlaps with that of the given sstables, not including itself.
      * (The given sstables may or may not overlap with each other.)
      */
-    public Collection&lt;SSTableReader&gt; getOverlappingSSTables(SSTableSet sstableSet, Iterable&lt;SSTableReader&gt; sstables)
     {
         logger.trace("Checking for sstables overlapping {}", sstables);
 
@@ -1282,19 +1282,19 @@ public Collection&lt;SSTableReader&gt; getOverlappingSSTables(SSTableSet sstableSet, I
         Set&lt;SSTableReader&gt; results = new HashSet&lt;&gt;();
 
         for (AbstractBounds&lt;PartitionPosition&gt; bound : bounds)
-            Iterables.addAll(results, view.sstablesInBounds(sstableSet, bound.left, bound.right));
 
         return Sets.difference(results, ImmutableSet.copyOf(sstables));
     }
 
     /**
      * like getOverlappingSSTables, but acquires references before returning
      */
-    public Refs&lt;SSTableReader&gt; getAndReferenceOverlappingSSTables(SSTableSet sstableSet, Iterable&lt;SSTableReader&gt; sstables)
     {
         while (true)
         {
-            Iterable&lt;SSTableReader&gt; overlapped = getOverlappingSSTables(sstableSet, sstables);
             Refs&lt;SSTableReader&gt; refs = Refs.tryRef(overlapped);
             if (refs != null)
                 return refs;
</code_before><code_after>@@ -1231,7 +1231,7 @@ public void apply(PartitionUpdate update, UpdateTransaction indexer, OpOrder.Gro
      * @return sstables whose key range overlaps with that of the given sstables, not including itself.
      * (The given sstables may or may not overlap with each other.)
      */
+    public Collection&lt;SSTableReader&gt; getOverlappingLiveSSTables(Iterable&lt;SSTableReader&gt; sstables)
     {
         logger.trace("Checking for sstables overlapping {}", sstables);
 
@@ -1282,19 +1282,19 @@ public Collection&lt;SSTableReader&gt; getOverlappingSSTables(SSTableSet sstableSet, I
         Set&lt;SSTableReader&gt; results = new HashSet&lt;&gt;();
 
         for (AbstractBounds&lt;PartitionPosition&gt; bound : bounds)
+            Iterables.addAll(results, view.liveSSTablesInBounds(bound.left, bound.right));
 
         return Sets.difference(results, ImmutableSet.copyOf(sstables));
     }
 
     /**
      * like getOverlappingSSTables, but acquires references before returning
      */
+    public Refs&lt;SSTableReader&gt; getAndReferenceOverlappingLiveSSTables(Iterable&lt;SSTableReader&gt; sstables)
     {
         while (true)
         {
+            Iterable&lt;SSTableReader&gt; overlapped = getOverlappingLiveSSTables(sstables);
             Refs&lt;SSTableReader&gt; refs = Refs.tryRef(overlapped);
             if (refs != null)
                 return refs;
</code_after><evaluations><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>497550</refactoring_id><commit_sha>d6b27e95a264bd6bbebec4d167cdbf20bfb6fd9e</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/d6b27e95a264bd6bbebec4d167cdbf20bfb6fd9e</commit_link><file_path>src/main/java/mekanism/client/gui/GuiFuelwoodHeater.java</file_path><description>Remove Parameter guiWidth : int in method protected drawGuiContainerBackgroundLayer(guiWidth int, guiHeight int, xAxis int, yAxis int) : void from class mekanism.client.gui.GuiFuelwoodHeater</description><code_before>@@ -43,10 +43,10 @@ protected void drawGuiContainerForegroundLayer(int mouseX, int mouseY) {
     }
 
     @Override
-    protected void drawGuiContainerBackgroundLayer(int guiWidth, int guiHeight, int xAxis, int yAxis) {
         if (tileEntity.burnTime &gt; 0) {
             int displayInt = tileEntity.burnTime * 13 / tileEntity.maxBurnTime;
-            drawTexturedModalRect(guiWidth + 143, guiHeight + 30 + 12 - displayInt, 176, 12 - displayInt, 14, displayInt + 1);
         }
     }
 
</code_before><code_after>@@ -43,10 +43,10 @@ protected void drawGuiContainerForegroundLayer(int mouseX, int mouseY) {
     }
 
     @Override
+    protected void drawGuiContainerBackgroundLayer(int xAxis, int yAxis) {
         if (tileEntity.burnTime &gt; 0) {
             int displayInt = tileEntity.burnTime * 13 / tileEntity.maxBurnTime;
+            drawTexturedModalRect(guiLeft + 143, guiTop + 30 + 12 - displayInt, 176, 12 - displayInt, 14, displayInt + 1);
         }
     }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>476742</refactoring_id><commit_sha>885402bbc3618b895c4b9b8f09300d3120a9abe8</commit_sha><commit_link>https://github.com/nationalsecurityagency/ghidra/commit/885402bbc3618b895c4b9b8f09300d3120a9abe8</commit_link><file_path>Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/actions/FindReferencesToSymbolAction.java</file_path><description>Remove Parameter tool : PluginTool in method public FindReferencesToSymbolAction(tool PluginTool) from class ghidra.app.plugin.core.decompile.actions.FindReferencesToSymbolAction</description><code_before>@@ -22,7 +22,6 @@
 import ghidra.app.plugin.core.decompile.DecompilerProvider;
 import ghidra.app.plugin.core.navigation.locationreferences.LocationReferencesService;
 import ghidra.app.util.HelpTopics;
-import ghidra.framework.plugintool.PluginTool;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.listing.Function;
 import ghidra.program.model.listing.Program;
@@ -40,11 +39,9 @@ public class FindReferencesToSymbolAction extends AbstractDecompilerAction {
 
 	private static final String MENU_ITEM_TEXT = "Find References to";
 	public static final String NAME = "Find References to Symbol";
-	private PluginTool tool;
 
-	public FindReferencesToSymbolAction(PluginTool tool) {
 		super(NAME);
-		this.tool = tool;
 
 		setPopupMenuData(
 			new MenuData(new String[] { LocationReferencesService.MENU_GROUP, MENU_ITEM_TEXT }));
@@ -116,7 +113,8 @@ protected boolean isEnabledForDecompilerContext(DecompilerActionContext context)
 
 	@Override
 	protected void decompilerActionPerformed(DecompilerActionContext context) {
-		LocationReferencesService service = tool.getService(LocationReferencesService.class);
 		if (service == null) {
 			Msg.showError(this, null, "Missing Plugin",
 				"The " + LocationReferencesService.class.getSimpleName() + " is not installed.\n" +
</code_before><code_after>@@ -22,7 +22,6 @@
 import ghidra.app.plugin.core.decompile.DecompilerProvider;
 import ghidra.app.plugin.core.navigation.locationreferences.LocationReferencesService;
 import ghidra.app.util.HelpTopics;
 import ghidra.program.model.address.Address;
 import ghidra.program.model.listing.Function;
 import ghidra.program.model.listing.Program;
@@ -40,11 +39,9 @@ public class FindReferencesToSymbolAction extends AbstractDecompilerAction {
 
 	private static final String MENU_ITEM_TEXT = "Find References to";
 	public static final String NAME = "Find References to Symbol";
 
+	public FindReferencesToSymbolAction() {
 		super(NAME);
 
 		setPopupMenuData(
 			new MenuData(new String[] { LocationReferencesService.MENU_GROUP, MENU_ITEM_TEXT }));
@@ -116,7 +113,8 @@ protected boolean isEnabledForDecompilerContext(DecompilerActionContext context)
 
 	@Override
 	protected void decompilerActionPerformed(DecompilerActionContext context) {
+		LocationReferencesService service =
+			context.getTool().getService(LocationReferencesService.class);
 		if (service == null) {
 			Msg.showError(this, null, "Missing Plugin",
 				"The " + LocationReferencesService.class.getSimpleName() + " is not installed.\n" +
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>567798</refactoring_id><commit_sha>86ecf76dd81a1635cc59871963ac996ad6a0840e</commit_sha><commit_link>https://github.com/cuba-platform/cuba/commit/86ecf76dd81a1635cc59871963ac996ad6a0840e</commit_link><file_path>modules/gui/src/com/haulmont/cuba/gui/xml/layout/LayoutLoader.java</file_path><description>Remove Parameter fragmentId : String in method public createFragmentContent(fragment Fragment, rootWindowElement Element, fragmentId String) : ComponentLoader&lt;Fragment&gt; from class com.haulmont.cuba.gui.xml.layout.LayoutLoader</description><code_before>@@ -16,7 +16,6 @@
  */
 package com.haulmont.cuba.gui.xml.layout;
 
-import com.haulmont.bali.datastruct.Pair;
 import com.haulmont.cuba.core.global.BeanLocator;
 import com.haulmont.cuba.gui.GuiDevelopmentException;
 import com.haulmont.cuba.gui.UiComponents;
@@ -33,7 +32,6 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Locale;
-import java.util.Map;
 
 @Scope(BeanDefinition.SCOPE_PROTOTYPE)
 @Component(LayoutLoader.NAME)
@@ -55,17 +53,17 @@ public LayoutLoader(ComponentLoader.Context context) {
     }
 
     @Inject
-    public void setBeanLocator(BeanLocator beanLocator) {
         this.beanLocator = beanLocator;
     }
 
     @Inject
-    public void setFactory(UiComponents factory) {
         this.factory = factory;
     }
 
     @Inject
-    public void setConfig(LayoutLoaderConfig config) {
         this.config = config;
     }
 
@@ -126,31 +124,15 @@ protected ComponentLoader initLoader(Element element, Class&lt;? extends ComponentL
         return loader;
     }
 
-    public Pair&lt;ComponentLoader, Element&gt; createFrameComponent(String resourcePath, String id,
-                                                               Map&lt;String, Object&gt; params) {
-        ScreenXmlLoader screenXmlLoader = beanLocator.get(ScreenXmlLoader.NAME);
-        Element element = screenXmlLoader.load(resourcePath, id, params);
-
-        ComponentLoader loader = getLoader(element);
-        FragmentLoader fragmentLoader = (FragmentLoader) loader;
-        fragmentLoader.setFrameId(id);
-
-        loader.createComponent();
-
-        return new Pair&lt;&gt;(loader, element);
-    }
-
     public ComponentLoader createComponent(Element element) {
         ComponentLoader loader = getLoader(element);
 
         loader.createComponent();
         return loader;
     }
 
-    public ComponentLoader&lt;Fragment&gt; createFragmentContent(Fragment fragment, Element rootWindowElement, String fragmentId) {
         FragmentLoader fragmentLoader = getFragmentLoader(rootWindowElement);
-
-        fragmentLoader.setFrameId(fragmentId);
         fragmentLoader.setResultComponent(fragment);
 
         Element layout = rootWindowElement.element("layout");
</code_before><code_after>@@ -16,7 +16,6 @@
  */
 package com.haulmont.cuba.gui.xml.layout;
 
 import com.haulmont.cuba.core.global.BeanLocator;
 import com.haulmont.cuba.gui.GuiDevelopmentException;
 import com.haulmont.cuba.gui.UiComponents;
@@ -33,7 +32,6 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Locale;
 
 @Scope(BeanDefinition.SCOPE_PROTOTYPE)
 @Component(LayoutLoader.NAME)
@@ -55,17 +53,17 @@ public LayoutLoader(ComponentLoader.Context context) {
     }
 
     @Inject
+    protected void setBeanLocator(BeanLocator beanLocator) {
         this.beanLocator = beanLocator;
     }
 
     @Inject
+    protected void setFactory(UiComponents factory) {
         this.factory = factory;
     }
 
     @Inject
+    protected void setConfig(LayoutLoaderConfig config) {
         this.config = config;
     }
 
@@ -126,31 +124,15 @@ protected ComponentLoader initLoader(Element element, Class&lt;? extends ComponentL
         return loader;
     }
 
     public ComponentLoader createComponent(Element element) {
         ComponentLoader loader = getLoader(element);
 
         loader.createComponent();
         return loader;
     }
 
+    public ComponentLoader&lt;Fragment&gt; createFragmentContent(Fragment fragment, Element rootWindowElement) {
         FragmentLoader fragmentLoader = getFragmentLoader(rootWindowElement);
         fragmentLoader.setResultComponent(fragment);
 
         Element layout = rootWindowElement.element("layout");
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>489889</refactoring_id><commit_sha>d95daad162d01eadf186d93c3c815be7b9e04689</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/d95daad162d01eadf186d93c3c815be7b9e04689</commit_link><file_path>community/server-api/src/main/java/org/neo4j/server/rest/repr/Representation.java</file_path><description>Remove Parameter extensions : ExtensionInjector in method package abstract serialize(format RepresentationFormat, baseUri URI, extensions ExtensionInjector) : String from class org.neo4j.server.rest.repr.Representation</description><code_before>@@ -78,7 +78,7 @@ public RepresentationType getRepresentationType()
         return this.type;
     }
 
-    abstract String serialize( RepresentationFormat format, URI baseUri, ExtensionInjector extensions );
 
     abstract void addTo( ListSerializer serializer );
 
@@ -100,7 +100,7 @@ boolean isEmpty()
             }
 
             @Override
-            String serialize( RepresentationFormat format, URI baseUri, ExtensionInjector extensions )
             {
                 return "";
             }
</code_before><code_after>@@ -78,7 +78,7 @@ public RepresentationType getRepresentationType()
         return this.type;
     }
 
+    abstract String serialize( RepresentationFormat format, URI baseUri );
 
     abstract void addTo( ListSerializer serializer );
 
@@ -100,7 +100,7 @@ boolean isEmpty()
             }
 
             @Override
+            String serialize( RepresentationFormat format, URI baseUri )
             {
                 return "";
             }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>479022</refactoring_id><commit_sha>d4fb2e0cb4c6c1bee69aa6452e4690e30f308829</commit_sha><commit_link>https://github.com/apache/pinot/commit/d4fb2e0cb4c6c1bee69aa6452e4690e30f308829</commit_link><file_path>pinot-controller/src/main/java/com/linkedin/pinot/controller/api/resources/ServerTableSizeReader.java</file_path><description>Remove Parameter connectionManager : HttpConnectionManager in method public ServerTableSizeReader(executor Executor, connectionManager HttpConnectionManager) from class com.linkedin.pinot.controller.api.resources.ServerTableSizeReader</description><code_before>@@ -30,7 +30,6 @@
 import java.util.concurrent.Executor;
 import org.apache.commons.httpclient.ConnectTimeoutException;
 import org.apache.commons.httpclient.ConnectionPoolTimeoutException;
-import org.apache.commons.httpclient.HttpConnectionManager;
 import org.apache.commons.httpclient.URI;
 import org.apache.commons.httpclient.methods.GetMethod;
 import org.codehaus.jackson.map.ObjectMapper;
@@ -47,11 +46,9 @@ public class ServerTableSizeReader {
       ServerTableSizeReader.class);
 
   private final Executor executor;
-  private final HttpConnectionManager connectionManager;
 
-  public ServerTableSizeReader(Executor executor, HttpConnectionManager connectionManager) {
     this.executor = executor;
-    this.connectionManager = connectionManager;
   }
 
   public Map&lt;String, List&lt;SegmentSizeInfo&gt;&gt; getSizeDetailsFromServers(BiMap&lt;String, String&gt; serverEndPoints,
@@ -64,7 +61,7 @@ public Map&lt;String, List&lt;SegmentSizeInfo&gt;&gt; getSizeDetailsFromServers(BiMap&lt;String
       serverUrls.add(tableSizeUri);
     }
 
-    MultiGetRequest mget = new MultiGetRequest(executor, connectionManager);
     LOGGER.info("Reading segment sizes from {} servers for table: {}, timeoutMsec: {}", serverUrls.size(), table, timeoutMsec);
     CompletionService&lt;GetMethod&gt; completionService = mget.execute(serverUrls, timeoutMsec);
 
</code_before><code_after>@@ -30,7 +30,6 @@
 import java.util.concurrent.Executor;
 import org.apache.commons.httpclient.ConnectTimeoutException;
 import org.apache.commons.httpclient.ConnectionPoolTimeoutException;
 import org.apache.commons.httpclient.URI;
 import org.apache.commons.httpclient.methods.GetMethod;
 import org.codehaus.jackson.map.ObjectMapper;
@@ -47,11 +46,9 @@ public class ServerTableSizeReader {
       ServerTableSizeReader.class);
 
   private final Executor executor;
 
+  public ServerTableSizeReader(Executor executor) {
     this.executor = executor;
   }
 
   public Map&lt;String, List&lt;SegmentSizeInfo&gt;&gt; getSizeDetailsFromServers(BiMap&lt;String, String&gt; serverEndPoints,
@@ -64,7 +61,7 @@ public Map&lt;String, List&lt;SegmentSizeInfo&gt;&gt; getSizeDetailsFromServers(BiMap&lt;String
       serverUrls.add(tableSizeUri);
     }
 
+    MultiGetRequest mget = new MultiGetRequest(executor);
     LOGGER.info("Reading segment sizes from {} servers for table: {}, timeoutMsec: {}", serverUrls.size(), table, timeoutMsec);
     CompletionService&lt;GetMethod&gt; completionService = mget.execute(serverUrls, timeoutMsec);
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>516611</refactoring_id><commit_sha>a314214f244be6e67e8bb7be01fda0f03195c696</commit_sha><commit_link>https://github.com/apache/ignite/commit/a314214f244be6e67e8bb7be01fda0f03195c696</commit_link><file_path>modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheMapEntry.java</file_path><description>Remove Parameter topVer : AffinityTopologyVersion in method public touch(topVer AffinityTopologyVersion) : void from class org.apache.ignite.internal.processors.cache.GridCacheMapEntry</description><code_before>@@ -1070,7 +1070,7 @@ private EntryGetResult entryGetResult(CacheObject val, GridCacheVersion ver, boo
         }
         finally {
             if (touch)
-                touch(cctx.affinity().affinityTopologyVersion());
         }
     }
 
@@ -1245,7 +1245,7 @@ else if (res.resultType() == ResultType.REMOVED_NOT_NULL) {
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
-                cctx.evicts().touch(this, AffinityTopologyVersion.NONE);
             }
         }
 
@@ -1361,7 +1361,7 @@ else if (res.resultType() == ResultType.LOCKED) {
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
-                cctx.evicts().touch(this, AffinityTopologyVersion.NONE);
             }
         }
 
@@ -1429,7 +1429,7 @@ else if (res.resultType() == ResultType.LOCKED) {
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
-                cctx.evicts().touch(this, AffinityTopologyVersion.NONE);
             }
         }
 
@@ -5083,8 +5083,8 @@ private void unlockListenerReadLock() {
     }
 
     /** {@inheritDoc} */
-    @Override public void touch(AffinityTopologyVersion topVer) {
-        context().evicts().touch(this, topVer);
     }
 
     /** {@inheritDoc} */
@@ -5284,7 +5284,7 @@ else if (res.resultType() == ResultType.LOCKED) {
                 if (entry.lockedByCurrentThread()) {
                     entry.unlockEntry();
 
-                    cctx.evicts().touch(entry, AffinityTopologyVersion.NONE);
                 }
             }
 
@@ -5389,7 +5389,7 @@ else if (res.resultType() == ResultType.LOCKED) {
                 if (entry.lockedByCurrentThread()) {
                     entry.unlockEntry();
 
-                    cctx.evicts().touch(entry, AffinityTopologyVersion.NONE);
                 }
             }
 
@@ -5639,7 +5639,7 @@ else if (res.resultType() == ResultType.REMOVED_NOT_NULL) {
                 if (entry.lockedByCurrentThread()) {
                     entry.unlockEntry();
 
-                    cctx.evicts().touch(entry, AffinityTopologyVersion.NONE);
                 }
             }
 
@@ -6839,7 +6839,7 @@ private IgniteBiTuple&lt;Object, Exception&gt; runEntryProcessor(CacheInvokeEntry&lt;Obje
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
-                cctx.evicts().touch(this, AffinityTopologyVersion.NONE);
             }
         }
 
</code_before><code_after>@@ -1070,7 +1070,7 @@ private EntryGetResult entryGetResult(CacheObject val, GridCacheVersion ver, boo
         }
         finally {
             if (touch)
+                touch();
         }
     }
 
@@ -1245,7 +1245,7 @@ else if (res.resultType() == ResultType.REMOVED_NOT_NULL) {
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
+                cctx.evicts().touch(this);
             }
         }
 
@@ -1361,7 +1361,7 @@ else if (res.resultType() == ResultType.LOCKED) {
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
+                cctx.evicts().touch(this);
             }
         }
 
@@ -1429,7 +1429,7 @@ else if (res.resultType() == ResultType.LOCKED) {
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
+                cctx.evicts().touch(this);
             }
         }
 
@@ -5083,8 +5083,8 @@ private void unlockListenerReadLock() {
     }
 
     /** {@inheritDoc} */
+    @Override public void touch() {
+        context().evicts().touch(this);
     }
 
     /** {@inheritDoc} */
@@ -5284,7 +5284,7 @@ else if (res.resultType() == ResultType.LOCKED) {
                 if (entry.lockedByCurrentThread()) {
                     entry.unlockEntry();
 
+                    cctx.evicts().touch(entry);
                 }
             }
 
@@ -5389,7 +5389,7 @@ else if (res.resultType() == ResultType.LOCKED) {
                 if (entry.lockedByCurrentThread()) {
                     entry.unlockEntry();
 
+                    cctx.evicts().touch(entry);
                 }
             }
 
@@ -5639,7 +5639,7 @@ else if (res.resultType() == ResultType.REMOVED_NOT_NULL) {
                 if (entry.lockedByCurrentThread()) {
                     entry.unlockEntry();
 
+                    cctx.evicts().touch(entry);
                 }
             }
 
@@ -6839,7 +6839,7 @@ private IgniteBiTuple&lt;Object, Exception&gt; runEntryProcessor(CacheInvokeEntry&lt;Obje
             if (lockedByCurrentThread()) {
                 unlockEntry();
 
+                cctx.evicts().touch(this);
             }
         }
 
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>551096</refactoring_id><commit_sha>2202dfa213a0b4808379f9829f78c7cb7bbb2ddd</commit_sha><commit_link>https://github.com/google/closure-compiler/commit/2202dfa213a0b4808379f9829f78c7cb7bbb2ddd</commit_link><file_path>src/com/google/javascript/jscomp/AccessControlUtils.java</file_path><description>Remove Parameter codingConvention : CodingConvention in method package getEffectiveVisibilityForOverriddenProperty(visibility Visibility, fileOverviewVisibility Visibility, propertyName String, codingConvention CodingConvention) : Visibility from class com.google.javascript.jscomp.AccessControlUtils</description><code_before>@@ -78,24 +78,21 @@ static Visibility getEffectiveNameVisibility(Node name, Var var,
   }
 
   /**
-   * Returns the effective visibility of the given property. This can differ
-   * from the property's declared visibility if the property is inherited from
-   * a superclass, or if the file's {@code @fileoverview} JsDoc specifies
-   * a default visibility.
    *
    * @param property The property to compute effective visibility for.
    * @param referenceType The JavaScript type of the property.
-   * @param fileVisibilityMap A map of {@code @fileoverview} visibility
-   *     annotations, used to compute the property's default visibility.
-   * @param codingConvention The coding convention in effect (if any),
-   *     used to determine whether the property is private by lexical convention
-   *     (example: trailing underscore).
    */
   static Visibility getEffectivePropertyVisibility(
       Node property,
       ObjectType referenceType,
-      ImmutableMap&lt;StaticSourceFile, Visibility&gt; fileVisibilityMap,
-      @Nullable CodingConvention codingConvention) {
     String propertyName = property.getLastChild().getString();
     StaticSourceFile definingSource = getDefiningSource(
         property, referenceType, propertyName);
@@ -110,10 +107,10 @@ static Visibility getEffectivePropertyVisibility(
       Visibility overridden = getOverriddenPropertyVisibility(
           objectType, propertyName);
       return getEffectiveVisibilityForOverriddenProperty(
-          overridden, fileOverviewVisibility, propertyName, codingConvention);
     } else {
       return getEffectiveVisibilityForNonOverriddenProperty(
-          property, objectType, fileOverviewVisibility, codingConvention);
     }
   }
 
@@ -164,34 +161,21 @@ static Visibility getOverriddenPropertyVisibility(ObjectType objectType, String
    * inherits the visibility of the property it overrides.
    */
   static Visibility getEffectiveVisibilityForOverriddenProperty(
-      Visibility visibility,
-      @Nullable Visibility fileOverviewVisibility,
-      String propertyName,
-      @Nullable CodingConvention codingConvention) {
-    if (codingConvention != null &amp;&amp; codingConvention.isPrivate(propertyName)) {
-      return Visibility.PRIVATE;
-    }
     return (fileOverviewVisibility != null
         &amp;&amp; visibility == Visibility.INHERITED)
         ? fileOverviewVisibility
         : visibility;
   }
 
   /**
-   * Returns the effective visibility of the given non-overridden property.
-   * Non-overridden properties without an explicit visibility annotation
-   * receive the default visibility declared in the file's {@code @fileoverview}
-   * block, if one exists.
    */
   private static Visibility getEffectiveVisibilityForNonOverriddenProperty(
-      Node getprop,
-      ObjectType objectType,
-      @Nullable Visibility fileOverviewVisibility,
-      @Nullable CodingConvention codingConvention) {
     String propertyName = getprop.getLastChild().getString();
-    if (codingConvention != null &amp;&amp; codingConvention.isPrivate(propertyName)) {
-      return Visibility.PRIVATE;
-    }
     Visibility raw = Visibility.INHERITED;
     if (objectType != null) {
       raw = objectType.getOwnPropertyJSDocInfo(propertyName).getVisibility();
</code_before><code_after>@@ -78,24 +78,21 @@ static Visibility getEffectiveNameVisibility(Node name, Var var,
   }
 
   /**
+   * Returns the effective visibility of the given property. This can differ from the property's
+   * declared visibility if the property is inherited from a superclass, or if the file's
+   * {@code @fileoverview} JsDoc specifies a default visibility.
    *
    * @param property The property to compute effective visibility for.
    * @param referenceType The JavaScript type of the property.
+   * @param fileVisibilityMap A map of {@code @fileoverview} visibility annotations, used to compute
+   *     the property's default visibility.
+   * @param codingConvention The coding convention in effect (if any), used to determine whether the
+   *     property is private by lexical convention (example: trailing underscore).
    */
   static Visibility getEffectivePropertyVisibility(
       Node property,
       ObjectType referenceType,
+      ImmutableMap&lt;StaticSourceFile, Visibility&gt; fileVisibilityMap) {
     String propertyName = property.getLastChild().getString();
     StaticSourceFile definingSource = getDefiningSource(
         property, referenceType, propertyName);
@@ -110,10 +107,10 @@ static Visibility getEffectivePropertyVisibility(
       Visibility overridden = getOverriddenPropertyVisibility(
           objectType, propertyName);
       return getEffectiveVisibilityForOverriddenProperty(
+          overridden, fileOverviewVisibility, propertyName);
     } else {
       return getEffectiveVisibilityForNonOverriddenProperty(
+          property, objectType, fileOverviewVisibility);
     }
   }
 
@@ -164,34 +161,21 @@ static Visibility getOverriddenPropertyVisibility(ObjectType objectType, String
    * inherits the visibility of the property it overrides.
    */
   static Visibility getEffectiveVisibilityForOverriddenProperty(
+      Visibility visibility, @Nullable Visibility fileOverviewVisibility, String propertyName) {
     return (fileOverviewVisibility != null
         &amp;&amp; visibility == Visibility.INHERITED)
         ? fileOverviewVisibility
         : visibility;
   }
 
   /**
+   * Returns the effective visibility of the given non-overridden property. Non-overridden
+   * properties without an explicit visibility annotation receive the default visibility declared in
+   * the file's {@code @fileoverview} block, if one exists.
    */
   private static Visibility getEffectiveVisibilityForNonOverriddenProperty(
+      Node getprop, ObjectType objectType, @Nullable Visibility fileOverviewVisibility) {
     String propertyName = getprop.getLastChild().getString();
     Visibility raw = Visibility.INHERITED;
     if (objectType != null) {
       raw = objectType.getOwnPropertyJSDocInfo(propertyName).getVisibility();
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>492652</refactoring_id><commit_sha>8fada650c6e426b9aa9c467a1729e314fc32aac3</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/8fada650c6e426b9aa9c467a1729e314fc32aac3</commit_link><file_path>community/io/src/test/java/org/neo4j/io/pagecache/impl/muninn/PageListTest.java</file_path><description>Remove Parameter page : Page in method public read(filePageId long, page Page) : long from class org.neo4j.io.pagecache.impl.muninn.PageListTest.doFailedFault.swapper.new DummyPageSwapper</description><code_before>@@ -40,7 +40,6 @@
 import java.util.function.LongFunction;
 
 import org.neo4j.io.ByteUnit;
-import org.neo4j.io.pagecache.Page;
 import org.neo4j.io.pagecache.PageCursor;
 import org.neo4j.io.pagecache.PageSwapper;
 import org.neo4j.io.pagecache.tracing.DummyPageSwapper;
@@ -837,6 +836,18 @@ public void addressMustNotBeZeroAfterInitialisation() throws Exception
         assertThat( pageList.address( pageRef ), is( not( equalTo( 0L ) ) ) );
     }
 
     @Test
     public void usageCounterMustBeZeroByDefault() throws Exception
     {
@@ -940,12 +951,12 @@ public void faultMustReadIntoPage() throws Exception
         PageSwapper swapper = new DummyPageSwapper( "some file" )
         {
             @Override
-            public long read( long fpId, Page page ) throws IOException
             {
                 if ( fpId == filePageId )
                 {
-                    UnsafeUtil.setMemory( page.address(), page.size(), pageByteContents );
-                    return page.size();
                 }
                 throw new IOException( "Did not expect this file page id = " + fpId );
             }
@@ -989,7 +1000,7 @@ public void pageMustBeLoadedAndNotBoundIfFaultThrows() throws Exception
         PageSwapper swapper = new DummyPageSwapper( "file" )
         {
             @Override
-            public long read( long filePageId, Page page ) throws IOException
             {
                 throw new IOException( "boo" );
             }
@@ -1046,7 +1057,7 @@ private void doFailedFault( int swapperId, long filePageId )
         DummyPageSwapper swapper = new DummyPageSwapper( "" )
         {
             @Override
-            public long read( long filePageId, Page page ) throws IOException
             {
                 throw new IOException( "boom" );
             }
@@ -1072,7 +1083,7 @@ public void faultMustPopulatePageFaultEvent() throws Exception
         DummyPageSwapper swapper = new DummyPageSwapper( "" )
         {
             @Override
-            public long read( long filePageId, Page page ) throws IOException
             {
                 return 333;
             }
</code_before><code_after>@@ -40,7 +40,6 @@
 import java.util.function.LongFunction;
 
 import org.neo4j.io.ByteUnit;
 import org.neo4j.io.pagecache.PageCursor;
 import org.neo4j.io.pagecache.PageSwapper;
 import org.neo4j.io.pagecache.tracing.DummyPageSwapper;
@@ -837,6 +836,18 @@ public void addressMustNotBeZeroAfterInitialisation() throws Exception
         assertThat( pageList.address( pageRef ), is( not( equalTo( 0L ) ) ) );
     }
 
+    @Test
+    public void pageListMustBeCopyableViaConstructor() throws Exception
+    {
+        assertThat( pageList.address( pageRef ), is( equalTo( 0L ) ) );
+        PageList pl = new PageList( pageList );
+        assertThat( pl.address( pageRef ), is( equalTo( 0L ) ) );
+
+        pageList.initBuffer( pageRef );
+        assertThat( pageList.address( pageRef ), is( not( equalTo( 0L ) ) ) );
+        assertThat( pl.address( pageRef ), is( not( equalTo( 0L ) ) ) );
+    }
+
     @Test
     public void usageCounterMustBeZeroByDefault() throws Exception
     {
@@ -940,12 +951,12 @@ public void faultMustReadIntoPage() throws Exception
         PageSwapper swapper = new DummyPageSwapper( "some file" )
         {
             @Override
+            public long read( long fpId, long bufferAddress, int bufferSize ) throws IOException
             {
                 if ( fpId == filePageId )
                 {
+                    UnsafeUtil.setMemory( bufferAddress, bufferSize, pageByteContents );
+                    return bufferSize;
                 }
                 throw new IOException( "Did not expect this file page id = " + fpId );
             }
@@ -989,7 +1000,7 @@ public void pageMustBeLoadedAndNotBoundIfFaultThrows() throws Exception
         PageSwapper swapper = new DummyPageSwapper( "file" )
         {
             @Override
+            public long read( long filePageId, long bufferAddress, int bufferSize ) throws IOException
             {
                 throw new IOException( "boo" );
             }
@@ -1046,7 +1057,7 @@ private void doFailedFault( int swapperId, long filePageId )
         DummyPageSwapper swapper = new DummyPageSwapper( "" )
         {
             @Override
+            public long read( long filePageId, long bufferAddress, int bufferSize ) throws IOException
             {
                 throw new IOException( "boom" );
             }
@@ -1072,7 +1083,7 @@ public void faultMustPopulatePageFaultEvent() throws Exception
         DummyPageSwapper swapper = new DummyPageSwapper( "" )
         {
             @Override
+            public long read( long filePageId, long bufferAddress, int bufferSize ) throws IOException
             {
                 return 333;
             }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>469940</refactoring_id><commit_sha>3289374c2b2582579f3420db48d6fa9016967094</commit_sha><commit_link>https://github.com/camunda/camunda-bpm-platform/commit/3289374c2b2582579f3420db48d6fa9016967094</commit_link><file_path>engine-dmn/engine/src/main/java/org/camunda/bpm/dmn/engine/impl/hitpolicy/CollectCountAggregator.java</file_path><description>Remove Parameter outputName : String in method public aggregate(outputName String, outputValues List&lt;Object&gt;) : DmnDecisionResult from class org.camunda.bpm.dmn.engine.impl.hitpolicy.CollectCountAggregator</description><code_before>@@ -15,23 +15,12 @@
 
 import java.util.List;
 
-import org.camunda.bpm.dmn.engine.DmnDecisionOutput;
-import org.camunda.bpm.dmn.engine.DmnDecisionResult;
-import org.camunda.bpm.dmn.engine.DmnDecisionTable;
 import org.camunda.bpm.dmn.engine.hitpolicy.DmnHitPolicyAggregator;
-import org.camunda.bpm.dmn.engine.impl.DmnDecisionOutputImpl;
-import org.camunda.bpm.dmn.engine.impl.DmnDecisionResultImpl;
 
 public class CollectCountAggregator implements DmnHitPolicyAggregator {
 
-  public DmnDecisionResult aggregate(String outputName, List&lt;Object&gt; outputValues) {
-    long count = outputValues.size();
-
-    DmnDecisionOutputImpl decisionOutput = new DmnDecisionOutputImpl();
-    decisionOutput.put(outputName, count);
-    DmnDecisionResultImpl decisionResult = new DmnDecisionResultImpl();
-    decisionResult.add(decisionOutput);
-    return decisionResult;
   }
 
 }
</code_before><code_after>@@ -15,23 +15,12 @@
 
 import java.util.List;
 
 import org.camunda.bpm.dmn.engine.hitpolicy.DmnHitPolicyAggregator;
 
 public class CollectCountAggregator implements DmnHitPolicyAggregator {
 
+  public Object aggregate(List&lt;Object&gt; outputValues) {
+    return (long) outputValues.size();
   }
 
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>579542</refactoring_id><commit_sha>feedfb23cdfef3d56a8cfaedf7fbaba4c83bb7cd</commit_sha><commit_link>https://github.com/apache/flink/commit/feedfb23cdfef3d56a8cfaedf7fbaba4c83bb7cd</commit_link><file_path>flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/stream/PartitionTimeCommitTrigger.java</file_path><description>Remove Parameter conf : Configuration in method public PartitionTimeCommitTrigger(isRestored boolean, stateStore OperatorStateStore, conf Configuration, cl ClassLoader, partitionKeys List&lt;String&gt;) from class org.apache.flink.table.filesystem.stream.PartitionTimeCommitTrigger</description><code_before>@@ -25,13 +25,8 @@
 import org.apache.flink.api.common.typeutils.base.LongSerializer;
 import org.apache.flink.api.common.typeutils.base.MapSerializer;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
-import org.apache.flink.configuration.Configuration;
-import org.apache.flink.core.fs.Path;
-import org.apache.flink.table.filesystem.PartitionTimeExtractor;
 import org.apache.flink.util.StringUtils;
 
-import java.time.LocalDateTime;
-import java.time.ZoneId;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -41,16 +36,11 @@
 import java.util.Set;
 import java.util.TreeMap;
 
-import static org.apache.flink.table.filesystem.FileSystemOptions.PARTITION_TIME_EXTRACTOR_CLASS;
-import static org.apache.flink.table.filesystem.FileSystemOptions.PARTITION_TIME_EXTRACTOR_KIND;
-import static org.apache.flink.table.filesystem.FileSystemOptions.PARTITION_TIME_EXTRACTOR_TIMESTAMP_PATTERN;
-import static org.apache.flink.table.filesystem.FileSystemOptions.SINK_PARTITION_COMMIT_DELAY;
-import static org.apache.flink.table.filesystem.FileSystemOptions.SINK_PARTITION_COMMIT_WATERMARK_TIME_ZONE;
-import static org.apache.flink.table.utils.PartitionPathUtils.extractPartitionValues;
 
 /**
- * Partition commit trigger by partition time and watermark, if 'watermark' &gt; 'partition-time' +
- * 'delay', will commit the partition.
  *
  * &lt;p&gt;Compares watermark, and watermark is related to records and checkpoint, so we need store
  * watermark information for checkpoint.
@@ -71,38 +61,23 @@ public class PartitionTimeCommitTrigger implements PartitionCommitTrigger {
 
     private final ListState&lt;Map&lt;Long, Long&gt;&gt; watermarksState;
     private final TreeMap&lt;Long, Long&gt; watermarks;
-    private final PartitionTimeExtractor extractor;
-    private final long commitDelay;
-    private final List&lt;String&gt; partitionKeys;
-    /** The time zone used to parse the long watermark value to TIMESTAMP. */
-    private final ZoneId watermarkTimeZone;
 
     public PartitionTimeCommitTrigger(
             boolean isRestored,
             OperatorStateStore stateStore,
-            Configuration conf,
-            ClassLoader cl,
-            List&lt;String&gt; partitionKeys)
             throws Exception {
         this.pendingPartitionsState = stateStore.getListState(PENDING_PARTITIONS_STATE_DESC);
         this.pendingPartitions = new HashSet&lt;&gt;();
         if (isRestored) {
             pendingPartitions.addAll(pendingPartitionsState.get().iterator().next());
         }
 
-        this.partitionKeys = partitionKeys;
-        this.commitDelay = conf.get(SINK_PARTITION_COMMIT_DELAY).toMillis();
-        this.extractor =
-                PartitionTimeExtractor.create(
-                        cl,
-                        conf.get(PARTITION_TIME_EXTRACTOR_KIND),
-                        conf.get(PARTITION_TIME_EXTRACTOR_CLASS),
-                        conf.get(PARTITION_TIME_EXTRACTOR_TIMESTAMP_PATTERN));
 
         this.watermarksState = stateStore.getListState(WATERMARKS_STATE_DESC);
         this.watermarks = new TreeMap&lt;&gt;();
-        this.watermarkTimeZone =
-                ZoneId.of(conf.getString(SINK_PARTITION_COMMIT_WATERMARK_TIME_ZONE));
         if (isRestored) {
             watermarks.putAll(watermarksState.get().iterator().next());
         }
@@ -131,26 +106,39 @@ public List&lt;String&gt; committablePartitions(long checkpointId) {
         Iterator&lt;String&gt; iter = pendingPartitions.iterator();
         while (iter.hasNext()) {
             String partition = iter.next();
-            LocalDateTime partitionTime =
-                    extractor.extract(partitionKeys, extractPartitionValues(new Path(partition)));
-            if (watermarkHasPassedWithDelay(watermark, partitionTime, commitDelay)) {
                 needCommit.add(partition);
                 iter.remove();
             }
         }
         return needCommit;
     }
 
-    /**
-     * Returns the watermark has passed the partition time or not, if true means it's time to commit
-     * the partition.
-     */
-    private boolean watermarkHasPassedWithDelay(
-            long watermark, LocalDateTime partitionTime, long commitDelay) {
-        // here we don't parse the long watermark to TIMESTAMP and then comparision,
-        // but parse the partition timestamp to epoch mills to avoid Daylight Saving Time issue
-        long epochPartTime = partitionTime.atZone(watermarkTimeZone).toInstant().toEpochMilli();
-        return watermark &gt; epochPartTime + commitDelay;
     }
 
     @Override
</code_before><code_after>@@ -25,13 +25,8 @@
 import org.apache.flink.api.common.typeutils.base.LongSerializer;
 import org.apache.flink.api.common.typeutils.base.MapSerializer;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
 import org.apache.flink.util.StringUtils;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -41,16 +36,11 @@
 import java.util.Set;
 import java.util.TreeMap;
 
+import static org.apache.flink.table.filesystem.stream.PartitionCommitPredicate.PredicateContext;
 
 /**
+ * Partition commit trigger by partition time and watermark. It'll commit the partition predicated
+ * to be committable by {@link PartitionCommitPredicate}
  *
  * &lt;p&gt;Compares watermark, and watermark is related to records and checkpoint, so we need store
  * watermark information for checkpoint.
@@ -71,38 +61,23 @@ public class PartitionTimeCommitTrigger implements PartitionCommitTrigger {
 
     private final ListState&lt;Map&lt;Long, Long&gt;&gt; watermarksState;
     private final TreeMap&lt;Long, Long&gt; watermarks;
+    private final PartitionCommitPredicate partitionCommitPredicate;
 
     public PartitionTimeCommitTrigger(
             boolean isRestored,
             OperatorStateStore stateStore,
+            PartitionCommitPredicate partitionCommitPredicate)
             throws Exception {
         this.pendingPartitionsState = stateStore.getListState(PENDING_PARTITIONS_STATE_DESC);
         this.pendingPartitions = new HashSet&lt;&gt;();
         if (isRestored) {
             pendingPartitions.addAll(pendingPartitionsState.get().iterator().next());
         }
 
+        this.partitionCommitPredicate = partitionCommitPredicate;
 
         this.watermarksState = stateStore.getListState(WATERMARKS_STATE_DESC);
         this.watermarks = new TreeMap&lt;&gt;();
         if (isRestored) {
             watermarks.putAll(watermarksState.get().iterator().next());
         }
@@ -131,26 +106,39 @@ public List&lt;String&gt; committablePartitions(long checkpointId) {
         Iterator&lt;String&gt; iter = pendingPartitions.iterator();
         while (iter.hasNext()) {
             String partition = iter.next();
+            PredicateContext predicateContext = createPredicateContext(partition, watermark);
+            if (partitionCommitPredicate.isPartitionCommittable(predicateContext)) {
                 needCommit.add(partition);
                 iter.remove();
             }
         }
         return needCommit;
     }
 
+    private PredicateContext createPredicateContext(String partition, long watermark) {
+        return new PredicateContext() {
+            @Override
+            public String partition() {
+                return partition;
+            }
+
+            @Override
+            public long createProcTime() {
+                throw new UnsupportedOperationException(
+                        "Method createProcTime isn't supported in PartitionTimeCommitTrigger.");
+            }
+
+            @Override
+            public long currentProcTime() {
+                throw new UnsupportedOperationException(
+                        "Method currentProcTime isn't supported in PartitionTimeCommitTrigger.");
+            }
+
+            @Override
+            public long currentWatermark() {
+                return watermark;
+            }
+        };
     }
 
     @Override
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>521032</refactoring_id><commit_sha>b8a2b9aff9fa09e68bf0848278610d56cdc23345</commit_sha><commit_link>https://github.com/apache/beam/commit/b8a2b9aff9fa09e68bf0848278610d56cdc23345</commit_link><file_path>sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/utils/POJOUtils.java</file_path><description>Remove Parameter boundTypes : Map&lt;Type,Type&gt; in method public schemaFromPojoClass(typeDescriptor TypeDescriptor&lt;?&gt;, fieldValueTypeSupplier FieldValueTypeSupplier, boundTypes Map&lt;Type,Type&gt;) : Schema from class org.apache.beam.sdk.schemas.utils.POJOUtils</description><code_before>@@ -49,7 +49,6 @@
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.jar.asm.ClassWriter;
 import net.bytebuddy.matcher.ElementMatchers;
-import org.apache.beam.sdk.annotations.Internal;
 import org.apache.beam.sdk.schemas.FieldValueGetter;
 import org.apache.beam.sdk.schemas.FieldValueSetter;
 import org.apache.beam.sdk.schemas.FieldValueTypeInformation;
@@ -71,15 +70,11 @@
   "nullness", // TODO(https://github.com/apache/beam/issues/20497)
   "rawtypes" // TODO(https://github.com/apache/beam/issues/20447)
 })
-@Internal
 public class POJOUtils {
 
   public static Schema schemaFromPojoClass(
-      TypeDescriptor&lt;?&gt; typeDescriptor,
-      FieldValueTypeSupplier fieldValueTypeSupplier,
-      Map&lt;Type, Type&gt; boundTypes) {
-    return StaticSchemaInference.schemaFromClass(
-        typeDescriptor, fieldValueTypeSupplier, boundTypes);
   }
 
   // Static ByteBuddy instance used by all helpers.
@@ -306,7 +301,7 @@ public static &lt;T&gt; SchemaUserTypeCreator createStaticCreator(
             field.getDeclaringClass(),
             typeConversionsFactory
                 .createTypeConversion(false)
-                .convert(TypeDescriptor.of(field.getGenericType())));
     builder =
         implementGetterMethods(builder, field, typeInformation.getName(), typeConversionsFactory);
     try {
@@ -388,7 +383,7 @@ private static &lt;ObjectT, ValueT&gt; FieldValueSetter&lt;ObjectT, ValueT&gt; createSetter(
             field.getDeclaringClass(),
             typeConversionsFactory
                 .createTypeConversion(false)
-                .convert(TypeDescriptor.of(field.getGenericType())));
     builder = implementSetterMethods(builder, field, typeConversionsFactory);
     try {
       return builder
@@ -496,7 +491,7 @@ public ByteCodeAppender appender(final Target implementationTarget) {
                 // Do any conversions necessary.
                 typeConversionsFactory
                     .createSetterConversions(readField)
-                    .convert(TypeDescriptor.of(field.getGenericType())),
                 // Now update the field and return void.
                 FieldAccess.forField(new ForLoadedField(field)).write(),
                 MethodReturn.VOID);
@@ -551,8 +546,7 @@ public ByteCodeAppender appender(final Target implementationTarget) {
           Field field = fields.get(i);
 
           ForLoadedType convertedType =
-              new ForLoadedType(
-                  (Class) convertType.convert(TypeDescriptor.of(field.getGenericType())));
 
           // The instruction to read the parameter.
           StackManipulation readParameter =
@@ -569,7 +563,7 @@ public ByteCodeAppender appender(final Target implementationTarget) {
                   // Do any conversions necessary.
                   typeConversionsFactory
                       .createSetterConversions(readParameter)
-                      .convert(TypeDescriptor.of(field.getGenericType())),
                   // Now update the field.
                   FieldAccess.forField(new ForLoadedField(field)).write());
           stackManipulation = new StackManipulation.Compound(stackManipulation, updateField);
</code_before><code_after>@@ -49,7 +49,6 @@
 import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
 import net.bytebuddy.jar.asm.ClassWriter;
 import net.bytebuddy.matcher.ElementMatchers;
 import org.apache.beam.sdk.schemas.FieldValueGetter;
 import org.apache.beam.sdk.schemas.FieldValueSetter;
 import org.apache.beam.sdk.schemas.FieldValueTypeInformation;
@@ -71,15 +70,11 @@
   "nullness", // TODO(https://github.com/apache/beam/issues/20497)
   "rawtypes" // TODO(https://github.com/apache/beam/issues/20447)
 })
 public class POJOUtils {
 
   public static Schema schemaFromPojoClass(
+      TypeDescriptor&lt;?&gt; typeDescriptor, FieldValueTypeSupplier fieldValueTypeSupplier) {
+    return StaticSchemaInference.schemaFromClass(typeDescriptor, fieldValueTypeSupplier);
   }
 
   // Static ByteBuddy instance used by all helpers.
@@ -306,7 +301,7 @@ public static &lt;T&gt; SchemaUserTypeCreator createStaticCreator(
             field.getDeclaringClass(),
             typeConversionsFactory
                 .createTypeConversion(false)
+                .convert(TypeDescriptor.of(field.getType())));
     builder =
         implementGetterMethods(builder, field, typeInformation.getName(), typeConversionsFactory);
     try {
@@ -388,7 +383,7 @@ private static &lt;ObjectT, ValueT&gt; FieldValueSetter&lt;ObjectT, ValueT&gt; createSetter(
             field.getDeclaringClass(),
             typeConversionsFactory
                 .createTypeConversion(false)
+                .convert(TypeDescriptor.of(field.getType())));
     builder = implementSetterMethods(builder, field, typeConversionsFactory);
     try {
       return builder
@@ -496,7 +491,7 @@ public ByteCodeAppender appender(final Target implementationTarget) {
                 // Do any conversions necessary.
                 typeConversionsFactory
                     .createSetterConversions(readField)
+                    .convert(TypeDescriptor.of(field.getType())),
                 // Now update the field and return void.
                 FieldAccess.forField(new ForLoadedField(field)).write(),
                 MethodReturn.VOID);
@@ -551,8 +546,7 @@ public ByteCodeAppender appender(final Target implementationTarget) {
           Field field = fields.get(i);
 
           ForLoadedType convertedType =
+              new ForLoadedType((Class) convertType.convert(TypeDescriptor.of(field.getType())));
 
           // The instruction to read the parameter.
           StackManipulation readParameter =
@@ -569,7 +563,7 @@ public ByteCodeAppender appender(final Target implementationTarget) {
                   // Do any conversions necessary.
                   typeConversionsFactory
                       .createSetterConversions(readParameter)
+                      .convert(TypeDescriptor.of(field.getType())),
                   // Now update the field.
                   FieldAccess.forField(new ForLoadedField(field)).write());
           stackManipulation = new StackManipulation.Compound(stackManipulation, updateField);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>566814</refactoring_id><commit_sha>1b9e1073885951697f34950a1ea706c93826e871</commit_sha><commit_link>https://github.com/AutoMQ/automq/commit/1b9e1073885951697f34950a1ea706c93826e871</commit_link><file_path>connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/WorkerCoordinator.java</file_path><description>Remove Parameter rebalanceTimeoutMs : int in method public WorkerCoordinator(logContext LogContext, client ConsumerNetworkClient, groupId String, rebalanceTimeoutMs int, sessionTimeoutMs int, heartbeatIntervalMs int, metrics Metrics, metricGrpPrefix String, time Time, retryBackoffMs long, restUrl String, configStorage ConfigBackingStore, listener WorkerRebalanceListener, protocolCompatibility ConnectProtocolCompatibility, maxDelay int) from class org.apache.kafka.connect.runtime.distributed.WorkerCoordinator</description><code_before>@@ -18,6 +18,7 @@
 
 import org.apache.kafka.clients.consumer.internals.AbstractCoordinator;
 import org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient;
 import org.apache.kafka.common.metrics.Measurable;
 import org.apache.kafka.common.metrics.MetricConfig;
 import org.apache.kafka.common.metrics.Metrics;
@@ -39,7 +40,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
-import java.util.Optional;
 
 import static org.apache.kafka.common.message.JoinGroupRequestData.JoinGroupRequestProtocolCollection;
 import static org.apache.kafka.common.message.JoinGroupResponseData.JoinGroupResponseMember;
@@ -70,33 +70,23 @@ public class WorkerCoordinator extends AbstractCoordinator implements Closeable
     /**
      * Initialize the coordination manager.
      */
-    public WorkerCoordinator(LogContext logContext,
                              ConsumerNetworkClient client,
-                             String groupId,
-                             int rebalanceTimeoutMs,
-                             int sessionTimeoutMs,
-                             int heartbeatIntervalMs,
                              Metrics metrics,
                              String metricGrpPrefix,
                              Time time,
-                             long retryBackoffMs,
                              String restUrl,
                              ConfigBackingStore configStorage,
                              WorkerRebalanceListener listener,
                              ConnectProtocolCompatibility protocolCompatibility,
                              int maxDelay) {
-        super(logContext,
               client,
-              groupId,
-              Optional.empty(),
-              rebalanceTimeoutMs,
-              sessionTimeoutMs,
-              heartbeatIntervalMs,
               metrics,
               metricGrpPrefix,
-              time,
-              retryBackoffMs,
-              true);
         this.log = logContext.logger(WorkerCoordinator.class);
         this.restUrl = restUrl;
         this.configStorage = configStorage;
</code_before><code_after>@@ -18,6 +18,7 @@
 
 import org.apache.kafka.clients.consumer.internals.AbstractCoordinator;
 import org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient;
+import org.apache.kafka.clients.GroupRebalanceConfig;
 import org.apache.kafka.common.metrics.Measurable;
 import org.apache.kafka.common.metrics.MetricConfig;
 import org.apache.kafka.common.metrics.Metrics;
@@ -39,7 +40,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
 import static org.apache.kafka.common.message.JoinGroupRequestData.JoinGroupRequestProtocolCollection;
 import static org.apache.kafka.common.message.JoinGroupResponseData.JoinGroupResponseMember;
@@ -70,33 +70,23 @@ public class WorkerCoordinator extends AbstractCoordinator implements Closeable
     /**
      * Initialize the coordination manager.
      */
+    public WorkerCoordinator(GroupRebalanceConfig config,
+                             LogContext logContext,
                              ConsumerNetworkClient client,
                              Metrics metrics,
                              String metricGrpPrefix,
                              Time time,
                              String restUrl,
                              ConfigBackingStore configStorage,
                              WorkerRebalanceListener listener,
                              ConnectProtocolCompatibility protocolCompatibility,
                              int maxDelay) {
+        super(config,
+              logContext,
               client,
               metrics,
               metricGrpPrefix,
+              time);
         this.log = logContext.logger(WorkerCoordinator.class);
         this.restUrl = restUrl;
         this.configStorage = configStorage;
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>501619</refactoring_id><commit_sha>08d1ef0b4905027ea0fe78a18d3c82793159cf61</commit_sha><commit_link>https://github.com/elastic/logstash/commit/08d1ef0b4905027ea0fe78a18d3c82793159cf61</commit_link><file_path>logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java</file_path><description>Remove Parameter pluginArgs : Map&lt;String,Object&gt; in method public buildOutput(name RubyString, source SourceWithMetadata, args IRubyObject, pluginArgs Map&lt;String,Object&gt;) : AbstractOutputDelegatorExt from class org.logstash.config.ir.CompiledPipelineTest.FixedPluginFactory</description><code_before>@@ -54,12 +54,8 @@
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.ComputeStepSyntaxElement;
 import org.logstash.config.ir.compiler.FilterDelegatorExt;
-import org.logstash.config.ir.compiler.PluginFactory;
 import org.logstash.ext.JrubyEventExtLibrary;
-import co.elastic.logstash.api.Configuration;
-import co.elastic.logstash.api.Filter;
-import co.elastic.logstash.api.Input;
-import co.elastic.logstash.api.Context;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -494,9 +490,9 @@ private Supplier&lt;Consumer&lt;Collection&lt;JrubyEventExtLibrary.RubyEvent&gt;&gt;&gt; mockOutpu
     }
 
     /**
-     * Configurable Mock {@link PluginFactory}
      */
-    static final class MockPluginFactory implements PluginFactory {
 
         private final Map&lt;String, Supplier&lt;IRubyObject&gt;&gt; inputs;
 
@@ -514,29 +510,28 @@ static final class MockPluginFactory implements PluginFactory {
         }
 
         @Override
-        public IRubyObject buildInput(final RubyString name, SourceWithMetadata source,
-                                      final IRubyObject args, Map&lt;String, Object&gt; pluginArgs) {
             return setupPlugin(name, inputs);
         }
 
         @Override
-        public AbstractOutputDelegatorExt buildOutput(final RubyString name, SourceWithMetadata source,
-                                                      final IRubyObject args, Map&lt;String, Object&gt; pluginArgs) {
             return PipelineTestUtil.buildOutput(setupPlugin(name, outputs));
         }
 
         @Override
-        public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithMetadata source,
-                                                      final IRubyObject args, Map&lt;String, Object&gt; pluginArgs) {
             final RubyObject configNameDouble = org.logstash.config.ir.PluginConfigNameMethodDouble.create(name);
             return new FilterDelegatorExt(
                 RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
                     .initForTesting(setupPlugin(name, filters), configNameDouble);
         }
 
         @Override
-        public IRubyObject buildCodec(final RubyString name, SourceWithMetadata source, final IRubyObject args,
-                                      Map&lt;String, Object&gt; pluginArgs) {
             throw new IllegalStateException("No codec setup expected in this test.");
         }
 
@@ -555,17 +550,6 @@ private static &lt;T&gt; T setupPlugin(final RubyString name,
             }
             return suppliers.get(name.asJavaString()).get();
         }
-
-        @Override
-        public Input buildInput(final String name, final String id, final Configuration configuration, final Context context) {
-            return null;
-        }
-
-        @Override
-        public Filter buildFilter(final String name, final String id,
-                                  final Configuration configuration, final Context context) {
-            return null;
-        }
     }
 
     @Test
@@ -698,9 +682,9 @@ private String createBigFilterSection(int numFilters) {
     }
 
     /**
-     * Fixed Mock {@link PluginFactory}
      * */
-    static final class FixedPluginFactory implements PluginFactory {
 
         private Supplier&lt;IRubyObject&gt; input;
         private Supplier&lt;IRubyObject&gt; filter;
@@ -714,35 +698,25 @@ static final class FixedPluginFactory implements PluginFactory {
         }
 
         @Override
-        public Input buildInput(String name, String id, Configuration configuration, Context context) {
-            return null;
-        }
-
-        @Override
-        public Filter buildFilter(String name, String id, Configuration configuration, Context context) {
-            return null;
-        }
-
-        @Override
-        public IRubyObject buildInput(RubyString name, SourceWithMetadata source, IRubyObject args, Map&lt;String, Object&gt; pluginArgs) {
             return this.input.get();
         }
 
         @Override
-        public AbstractOutputDelegatorExt buildOutput(RubyString name, SourceWithMetadata source, IRubyObject args, Map&lt;String, Object&gt; pluginArgs) {
             return PipelineTestUtil.buildOutput(this.output.get());
         }
 
         @Override
-        public AbstractFilterDelegatorExt buildFilter(RubyString name, SourceWithMetadata source, IRubyObject args, Map&lt;String, Object&gt; pluginArgs) {
             final RubyObject configNameDouble = org.logstash.config.ir.PluginConfigNameMethodDouble.create(name);
             return new FilterDelegatorExt(
                     RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
                     .initForTesting(this.filter.get(), configNameDouble);
         }
 
         @Override
-        public IRubyObject buildCodec(RubyString name, SourceWithMetadata source, IRubyObject args, Map&lt;String, Object&gt; pluginArgs) {
             return null;
         }
 
</code_before><code_after>@@ -54,12 +54,8 @@
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.ComputeStepSyntaxElement;
 import org.logstash.config.ir.compiler.FilterDelegatorExt;
+import org.logstash.config.ir.compiler.RubyIntegration;
 import org.logstash.ext.JrubyEventExtLibrary;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -494,9 +490,9 @@ private Supplier&lt;Consumer&lt;Collection&lt;JrubyEventExtLibrary.RubyEvent&gt;&gt;&gt; mockOutpu
     }
 
     /**
+     * Configurable Mock {@link RubyIntegration.PluginFactory}
      */
+    static final class MockPluginFactory implements RubyIntegration.PluginFactory {
 
         private final Map&lt;String, Supplier&lt;IRubyObject&gt;&gt; inputs;
 
@@ -514,29 +510,28 @@ static final class MockPluginFactory implements PluginFactory {
         }
 
         @Override
+        public IRubyObject buildInput(final RubyString name, final IRubyObject args,
+                                      SourceWithMetadata source) {
             return setupPlugin(name, inputs);
         }
 
         @Override
+        public AbstractOutputDelegatorExt buildOutput(final RubyString name, final IRubyObject args,
+                                                      SourceWithMetadata source) {
             return PipelineTestUtil.buildOutput(setupPlugin(name, outputs));
         }
 
         @Override
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final IRubyObject args,
+                                                      SourceWithMetadata source) {
             final RubyObject configNameDouble = org.logstash.config.ir.PluginConfigNameMethodDouble.create(name);
             return new FilterDelegatorExt(
                 RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
                     .initForTesting(setupPlugin(name, filters), configNameDouble);
         }
 
         @Override
+        public IRubyObject buildCodec(final RubyString name, final IRubyObject args, SourceWithMetadata source) {
             throw new IllegalStateException("No codec setup expected in this test.");
         }
 
@@ -555,17 +550,6 @@ private static &lt;T&gt; T setupPlugin(final RubyString name,
             }
             return suppliers.get(name.asJavaString()).get();
         }
     }
 
     @Test
@@ -698,9 +682,9 @@ private String createBigFilterSection(int numFilters) {
     }
 
     /**
+     * Fixed Mock {@link RubyIntegration.PluginFactory}
      * */
+    static final class FixedPluginFactory implements RubyIntegration.PluginFactory {
 
         private Supplier&lt;IRubyObject&gt; input;
         private Supplier&lt;IRubyObject&gt; filter;
@@ -714,35 +698,25 @@ static final class FixedPluginFactory implements PluginFactory {
         }
 
         @Override
+        public IRubyObject buildInput(RubyString name, IRubyObject args, SourceWithMetadata source) {
             return this.input.get();
         }
 
         @Override
+        public AbstractOutputDelegatorExt buildOutput(RubyString name, IRubyObject args, SourceWithMetadata source) {
             return PipelineTestUtil.buildOutput(this.output.get());
         }
 
         @Override
+        public AbstractFilterDelegatorExt buildFilter(RubyString name, IRubyObject args, SourceWithMetadata source) {
             final RubyObject configNameDouble = org.logstash.config.ir.PluginConfigNameMethodDouble.create(name);
             return new FilterDelegatorExt(
                     RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
                     .initForTesting(this.filter.get(), configNameDouble);
         }
 
         @Override
+        public IRubyObject buildCodec(RubyString name, IRubyObject args, SourceWithMetadata source) {
             return null;
         }
 
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>465654</refactoring_id><commit_sha>af4d9b636a93078972679055686f735091b98c90</commit_sha><commit_link>https://github.com/apache/doris/commit/af4d9b636a93078972679055686f735091b98c90</commit_link><file_path>fe/fe-core/src/main/java/org/apache/doris/nereids/trees/expressions/functions/agg/Max.java</file_path><description>Remove Parameter arguments : List&lt;Expression&gt; in method public customSignature(argumentTypes List&lt;DataType&gt;, arguments List&lt;Expression&gt;) : FunctionSignature from class org.apache.doris.nereids.trees.expressions.functions.agg.Max</description><code_before>@@ -26,6 +26,7 @@
 import org.apache.doris.nereids.types.DataType;
 
 import com.google.common.base.Preconditions;
 
 import java.util.List;
 
@@ -35,29 +36,31 @@ public Max(Expression child) {
         super("max", child);
     }
 
-    public Max(AggregateParam aggregateParam, Expression child) {
-        super("max", aggregateParam, child);
     }
 
     @Override
-    public FunctionSignature customSignature(List&lt;DataType&gt; argumentTypes, List&lt;Expression&gt; arguments) {
-        return FunctionSignature.ret(argumentTypes.get(0)).args(argumentTypes.get(0));
     }
 
     @Override
-    protected List&lt;DataType&gt; intermediateTypes(List&lt;DataType&gt; argumentTypes, List&lt;Expression&gt; arguments) {
-        return argumentTypes;
     }
 
     @Override
-    public Max withChildren(List&lt;Expression&gt; children) {
         Preconditions.checkArgument(children.size() == 1);
-        return new Max(getAggregateParam(), children.get(0));
     }
 
     @Override
-    public Max withAggregateParam(AggregateParam aggregateParam) {
-        return new Max(aggregateParam, child());
     }
 
     @Override
</code_before><code_after>@@ -26,6 +26,7 @@
 import org.apache.doris.nereids.types.DataType;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 
 import java.util.List;
 
@@ -35,29 +36,31 @@ public Max(Expression child) {
         super("max", child);
     }
 
+    public Max(boolean isDistinct, Expression arg) {
+        super("max", false, arg);
     }
 
     @Override
+    public FunctionSignature customSignature() {
+        DataType dataType = getArgument(0).getDataType();
+        return FunctionSignature.ret(dataType).args(dataType);
     }
 
     @Override
+    protected List&lt;DataType&gt; intermediateTypes() {
+        return ImmutableList.of(getDataType());
     }
 
     @Override
+    public Max withDistinctAndChildren(boolean isDistinct, List&lt;Expression&gt; children) {
         Preconditions.checkArgument(children.size() == 1);
+        return new Max(isDistinct, children.get(0));
     }
 
     @Override
+    public Max withChildren(List&lt;Expression&gt; children) {
+        Preconditions.checkArgument(children.size() == 1);
+        return new Max(children.get(0));
     }
 
     @Override
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>500796</refactoring_id><commit_sha>a700907522793e9ba7a765b9faef628398b6f936</commit_sha><commit_link>https://github.com/jetty/jetty.project/commit/a700907522793e9ba7a765b9faef628398b6f936</commit_link><file_path>jetty-http2/http2-http-client-transport/src/main/java/org/eclipse/jetty/http2/client/http/HttpReceiverOverHTTP2.java</file_path><description>Remove Parameter error : int in method public onFailure(stream Stream, error int, reason String, callback Callback) : void from class org.eclipse.jetty.http2.client.http.HttpReceiverOverHTTP2</description><code_before>@@ -35,21 +35,24 @@
 import org.eclipse.jetty.client.api.Response;
 import org.eclipse.jetty.http.HttpField;
 import org.eclipse.jetty.http.HttpFields;
 import org.eclipse.jetty.http.HttpStatus;
 import org.eclipse.jetty.http.MetaData;
 import org.eclipse.jetty.http2.ErrorCode;
 import org.eclipse.jetty.http2.IStream;
 import org.eclipse.jetty.http2.api.Stream;
 import org.eclipse.jetty.http2.frames.DataFrame;
 import org.eclipse.jetty.http2.frames.HeadersFrame;
 import org.eclipse.jetty.http2.frames.PushPromiseFrame;
 import org.eclipse.jetty.http2.frames.ResetFrame;
 import org.eclipse.jetty.util.BufferUtil;
 import org.eclipse.jetty.util.Callback;
 import org.eclipse.jetty.util.IteratingCallback;
 import org.eclipse.jetty.util.Retainable;
 
-public class HttpReceiverOverHTTP2 extends HttpReceiver implements Stream.Listener
 {
     private final ContentNotifier contentNotifier = new ContentNotifier();
 
@@ -71,8 +74,7 @@ protected void reset()
         contentNotifier.reset();
     }
 
-    @Override
-    public void onHeaders(Stream stream, HeadersFrame frame)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
@@ -94,6 +96,19 @@ public void onHeaders(Stream stream, HeadersFrame frame)
                         return;
                 }
 
                 if (responseHeaders(exchange))
                 {
                     int status = response.getStatus();
@@ -111,15 +126,14 @@ public void onHeaders(Stream stream, HeadersFrame frame)
         }
     }
 
-    @Override
-    public Stream.Listener onPush(Stream stream, PushPromiseFrame frame)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
             return null;
 
         HttpRequest request = exchange.getRequest();
-        MetaData.Request metaData = (MetaData.Request)frame.getMetaData();
         HttpRequest pushRequest = (HttpRequest)getHttpDestination().getHttpClient().newRequest(metaData.getURIString());
         // TODO: copy PUSH_PROMISE headers into pushRequest.
 
@@ -146,7 +160,7 @@ public Stream.Listener onPush(Stream stream, PushPromiseFrame frame)
     }
 
     @Override
-    public void onData(Stream stream, DataFrame frame, Callback callback)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
@@ -159,8 +173,7 @@ public void onData(Stream stream, DataFrame frame, Callback callback)
         }
     }
 
-    @Override
-    public void onReset(Stream stream, ResetFrame frame)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
@@ -170,23 +183,22 @@ public void onReset(Stream stream, ResetFrame frame)
     }
 
     @Override
-    public boolean onIdleTimeout(Stream stream, Throwable x)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
             return false;
-        return !exchange.abort(x);
     }
 
     @Override
-    public void onFailure(Stream stream, int error, String reason, Callback callback)
     {
-        responseFailure(new IOException(String.format("%s/%s", ErrorCode.toString(error, null), reason)));
         callback.succeeded();
     }
 
-    @Override
-    public void onClosed(Stream stream)
     {
         getHttpChannel().onStreamClosed((IStream)stream);
     }
</code_before><code_after>@@ -35,21 +35,24 @@
 import org.eclipse.jetty.client.api.Response;
 import org.eclipse.jetty.http.HttpField;
 import org.eclipse.jetty.http.HttpFields;
+import org.eclipse.jetty.http.HttpMethod;
 import org.eclipse.jetty.http.HttpStatus;
 import org.eclipse.jetty.http.MetaData;
 import org.eclipse.jetty.http2.ErrorCode;
+import org.eclipse.jetty.http2.HTTP2Channel;
 import org.eclipse.jetty.http2.IStream;
 import org.eclipse.jetty.http2.api.Stream;
 import org.eclipse.jetty.http2.frames.DataFrame;
 import org.eclipse.jetty.http2.frames.HeadersFrame;
 import org.eclipse.jetty.http2.frames.PushPromiseFrame;
 import org.eclipse.jetty.http2.frames.ResetFrame;
+import org.eclipse.jetty.io.EndPoint;
 import org.eclipse.jetty.util.BufferUtil;
 import org.eclipse.jetty.util.Callback;
 import org.eclipse.jetty.util.IteratingCallback;
 import org.eclipse.jetty.util.Retainable;
 
+public class HttpReceiverOverHTTP2 extends HttpReceiver implements HTTP2Channel.Client
 {
     private final ContentNotifier contentNotifier = new ContentNotifier();
 
@@ -71,8 +74,7 @@ protected void reset()
         contentNotifier.reset();
     }
 
+    void onHeaders(Stream stream, HeadersFrame frame)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
@@ -94,6 +96,19 @@ public void onHeaders(Stream stream, HeadersFrame frame)
                         return;
                 }
 
+                HttpRequest httpRequest = exchange.getRequest();
+                if (HttpMethod.CONNECT.is(httpRequest.getMethod()) &amp;&amp; httpResponse.getStatus() == HttpStatus.OK_200)
+                {
+                    ClientHTTP2StreamEndPoint endPoint = new ClientHTTP2StreamEndPoint((IStream)stream);
+                    long idleTimeout = httpRequest.getIdleTimeout();
+                    if (idleTimeout &gt; 0)
+                        endPoint.setIdleTimeout(idleTimeout);
+                    if (LOG.isDebugEnabled())
+                        LOG.debug("Successful HTTP2 tunnel on {} via {}", stream, endPoint);
+                    ((IStream)stream).setAttachment(endPoint);
+                    httpRequest.getConversation().setAttribute(EndPoint.class.getName(), endPoint);
+                }
+
                 if (responseHeaders(exchange))
                 {
                     int status = response.getStatus();
@@ -111,15 +126,14 @@ public void onHeaders(Stream stream, HeadersFrame frame)
         }
     }
 
+    Stream.Listener onPush(Stream stream, PushPromiseFrame frame)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
             return null;
 
         HttpRequest request = exchange.getRequest();
+        MetaData.Request metaData = frame.getMetaData();
         HttpRequest pushRequest = (HttpRequest)getHttpDestination().getHttpClient().newRequest(metaData.getURIString());
         // TODO: copy PUSH_PROMISE headers into pushRequest.
 
@@ -146,7 +160,7 @@ public Stream.Listener onPush(Stream stream, PushPromiseFrame frame)
     }
 
     @Override
+    public void onData(DataFrame frame, Callback callback)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
@@ -159,8 +173,7 @@ public void onData(Stream stream, DataFrame frame, Callback callback)
         }
     }
 
+    void onReset(Stream stream, ResetFrame frame)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
@@ -170,23 +183,22 @@ public void onReset(Stream stream, ResetFrame frame)
     }
 
     @Override
+    public boolean onTimeout(Throwable failure)
     {
         HttpExchange exchange = getHttpExchange();
         if (exchange == null)
             return false;
+        return !exchange.abort(failure);
     }
 
     @Override
+    public void onFailure(Throwable failure, Callback callback)
     {
+        responseFailure(failure);
         callback.succeeded();
     }
 
+    void onClosed(Stream stream)
     {
         getHttpChannel().onStreamClosed((IStream)stream);
     }
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>495170</refactoring_id><commit_sha>12eb666892a9153853d5fddeb50c328b86898766</commit_sha><commit_link>https://github.com/camunda/zeebe/commit/12eb666892a9153853d5fddeb50c328b86898766</commit_link><file_path>backend/src/main/java/org/camunda/optimize/service/importing/EngineEntityFetcher.java</file_path><description>Remove Parameter processInstanceIds : Set&lt;String&gt; in method public fetchHistoricProcessInstances(processInstanceIds Set&lt;String&gt;) : List&lt;HistoricProcessInstanceDto&gt; from class org.camunda.optimize.service.importing.EngineEntityFetcher</description><code_before>@@ -146,18 +146,19 @@ public Integer fetchProcessDefinitionCount() throws OptimizeException {
     return count.getCount();
   }
 
-  public List&lt;HistoricProcessInstanceDto&gt; fetchHistoricProcessInstances(Set&lt;String&gt; processInstanceIds) {
     List&lt;HistoricProcessInstanceDto&gt; entries;
-    Map&lt;String, Set&lt;String&gt;&gt; pids = new HashMap&lt;&gt;();
-    pids.put("processInstanceIds", processInstanceIds);
     try {
-      WebTarget baseRequest = client
-          .target(configurationService.getEngineRestApiEndpointOfCustomEngine())
-          .path(configurationService.getHistoricProcessInstanceEndpoint());
-      entries = baseRequest
         .request(MediaType.APPLICATION_JSON)
-        .post(Entity.entity(pids, MediaType.APPLICATION_JSON))
-        .readEntity(new GenericType&lt;List&lt;HistoricProcessInstanceDto&gt;&gt;(){});
       return entries;
     } catch (RuntimeException e) {
       logError("Could not fetch historic process instances from engine. Please check the connection!", e);
@@ -166,6 +167,21 @@ public List&lt;HistoricProcessInstanceDto&gt; fetchHistoricProcessInstances(Set&lt;String
     return entries;
   }
 
   public List&lt;HistoricVariableInstanceDto&gt; fetchHistoricVariableInstances(int indexOfFirstResult, int maxPageSize) {
     List&lt;HistoricVariableInstanceDto&gt; entries;
     try {
</code_before><code_after>@@ -146,18 +146,19 @@ public Integer fetchProcessDefinitionCount() throws OptimizeException {
     return count.getCount();
   }
 
+  public List&lt;HistoricProcessInstanceDto&gt; fetchHistoricProcessInstances(int indexOfFirstResult, int maxPageSize) {
     List&lt;HistoricProcessInstanceDto&gt; entries;
     try {
+      entries = client
+        .target(configurationService.getEngineRestApiEndpointOfCustomEngine())
+        .path(configurationService.getHistoricProcessInstanceEndpoint())
+        .queryParam(SORT_BY, SORT_TYPE_END_TIME)
+        .queryParam(SORT_ORDER, SORT_ORDER_TYPE_ASCENDING)
+        .queryParam(INDEX_OF_FIRST_RESULT, indexOfFirstResult)
+        .queryParam(MAX_RESULTS_TO_RETURN, maxPageSize)
         .request(MediaType.APPLICATION_JSON)
+        .get(new GenericType&lt;List&lt;HistoricProcessInstanceDto&gt;&gt;() {
+        });
       return entries;
     } catch (RuntimeException e) {
       logError("Could not fetch historic process instances from engine. Please check the connection!", e);
@@ -166,6 +167,21 @@ public List&lt;HistoricProcessInstanceDto&gt; fetchHistoricProcessInstances(Set&lt;String
     return entries;
   }
 
+  public Integer fetchHistoricProcessInstanceCount() throws OptimizeException {
+    CountDto count;
+    try {
+      count = client
+        .target(configurationService.getEngineRestApiEndpointOfCustomEngine())
+        .path(configurationService.getHistoricProcessInstanceCountEndpoint())
+        .request()
+        .get(CountDto.class);
+    } catch (RuntimeException e) {
+      throw new OptimizeException("Could not fetch process instance count from engine. Please check the connection!", e);
+    }
+
+    return count.getCount();
+  }
+
   public List&lt;HistoricVariableInstanceDto&gt; fetchHistoricVariableInstances(int indexOfFirstResult, int maxPageSize) {
     List&lt;HistoricVariableInstanceDto&gt; entries;
     try {
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>548751</refactoring_id><commit_sha>41853169a7ff44826266e6cd24c72885b5bd078d</commit_sha><commit_link>https://github.com/androidx/media/commit/41853169a7ff44826266e6cd24c72885b5bd078d</commit_link><file_path>library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java</file_path><description>Remove Parameter loadTaskId : long in method public onLoadCompleted(loadable Chunk, loadTaskId long, elapsedRealtimeMs long, loadDurationMs long) : void from class com.google.android.exoplayer2.source.hls.HlsSampleStreamWrapper</description><code_before>@@ -703,8 +703,7 @@ public void reevaluateBuffer(long positionUs) {
   // Loader.Callback implementation.
 
   @Override
-  public void onLoadCompleted(
-      Chunk loadable, long loadTaskId, long elapsedRealtimeMs, long loadDurationMs) {
     chunkSource.onChunkLoadCompleted(loadable);
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
@@ -729,11 +728,7 @@ public void onLoadCompleted(
 
   @Override
   public void onLoadCanceled(
-      Chunk loadable,
-      long loadTaskId,
-      long elapsedRealtimeMs,
-      long loadDurationMs,
-      boolean released) {
     eventDispatcher.loadCanceled(
         loadable.dataSpec,
         loadable.getUri(),
@@ -759,7 +754,6 @@ public void onLoadCanceled(
   @Override
   public LoadErrorAction onLoadError(
       Chunk loadable,
-      long loadTaskId,
       long elapsedRealtimeMs,
       long loadDurationMs,
       IOException error,
</code_before><code_after>@@ -703,8 +703,7 @@ public void reevaluateBuffer(long positionUs) {
   // Loader.Callback implementation.
 
   @Override
+  public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
     chunkSource.onChunkLoadCompleted(loadable);
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
@@ -729,11 +728,7 @@ public void onLoadCompleted(
 
   @Override
   public void onLoadCanceled(
+      Chunk loadable, long elapsedRealtimeMs, long loadDurationMs, boolean released) {
     eventDispatcher.loadCanceled(
         loadable.dataSpec,
         loadable.getUri(),
@@ -759,7 +754,6 @@ public void onLoadCanceled(
   @Override
   public LoadErrorAction onLoadError(
       Chunk loadable,
       long elapsedRealtimeMs,
       long loadDurationMs,
       IOException error,
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>499387</refactoring_id><commit_sha>8763cba08e9f6dd4e7a001c06bdfb499579ffac4</commit_sha><commit_link>https://github.com/mekanism/mekanism/commit/8763cba08e9f6dd4e7a001c06bdfb499579ffac4</commit_link><file_path>src/main/java/mekanism/client/gui/element/button/ToggleButton.java</file_path><description>Remove Parameter onHover : IHoverable in method public ToggleButton(gui IGuiWrapper, x int, y int, toggled BooleanSupplier, onPress IClickable, onHover IHoverable) from class mekanism.client.gui.element.button.ToggleButton</description><code_before>@@ -4,9 +4,10 @@
 import mekanism.client.gui.IGuiWrapper;
 import mekanism.common.util.MekanismUtils;
 import mekanism.common.util.MekanismUtils.ResourceType;
 import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
 
 public class ToggleButton extends MekanismImageButton {
 
@@ -15,33 +16,38 @@ public class ToggleButton extends MekanismImageButton {
 
     private final ResourceLocation flipped;
     private final BooleanSupplier toggled;
 
-    public ToggleButton(IGuiWrapper gui, int x, int y, BooleanSupplier toggled, @NotNull IClickable onPress, @Nullable IHoverable onHover) {
-        this(gui, x, y, 18, toggled, onPress, onHover);
     }
 
-    public ToggleButton(IGuiWrapper gui, int x, int y, int size, BooleanSupplier toggled, @NotNull IClickable onPress, @Nullable IHoverable onHover) {
-        this(gui, x, y, size, 18, TOGGLE, TOGGLE_FLIPPED, toggled, onPress, onHover);
     }
 
     public ToggleButton(IGuiWrapper gui, int x, int y, int size, int textureSize, ResourceLocation toggle, ResourceLocation flipped, BooleanSupplier toggled,
-          @NotNull IClickable onPress, @Nullable IHoverable onHover) {
-        this(gui, x, y, size, size, textureSize, textureSize, toggle, flipped, toggled, onPress, onHover);
     }
 
     public ToggleButton(IGuiWrapper gui, int x, int y, int width, int height, int textureWidth, int textureHeight, ResourceLocation toggle, ResourceLocation flipped,
-          BooleanSupplier toggled, @NotNull IClickable onPress, @Nullable IHoverable onHover) {
-        super(gui, x, y, width, height, textureWidth, textureHeight, toggle, onPress, onHover);
         this.toggled = toggled;
         this.flipped = flipped;
     }
 
     @Override
     protected ResourceLocation getResource() {
-        return isToggled() ? flipped : super.getResource();
     }
 
-    protected boolean isToggled() {
-        return toggled.getAsBoolean();
     }
 }
\ No newline at end of file
</code_before><code_after>@@ -4,9 +4,10 @@
 import mekanism.client.gui.IGuiWrapper;
 import mekanism.common.util.MekanismUtils;
 import mekanism.common.util.MekanismUtils.ResourceType;
+import net.minecraft.client.gui.components.Tooltip;
+import net.minecraft.network.chat.Component;
 import net.minecraft.resources.ResourceLocation;
 import org.jetbrains.annotations.NotNull;
 
 public class ToggleButton extends MekanismImageButton {
 
@@ -15,33 +16,38 @@ public class ToggleButton extends MekanismImageButton {
 
     private final ResourceLocation flipped;
     private final BooleanSupplier toggled;
+    private final Tooltip yes;
+    private final Tooltip no;
 
+    public ToggleButton(IGuiWrapper gui, int x, int y, BooleanSupplier toggled, @NotNull IClickable onPress) {
+        this(gui, x, y, 18, toggled, onPress);
     }
 
+    public ToggleButton(IGuiWrapper gui, int x, int y, int size, BooleanSupplier toggled, @NotNull IClickable onPress) {
+        this(gui, x, y, size, 18, TOGGLE, TOGGLE_FLIPPED, toggled, onPress, null, null);
     }
 
     public ToggleButton(IGuiWrapper gui, int x, int y, int size, int textureSize, ResourceLocation toggle, ResourceLocation flipped, BooleanSupplier toggled,
+          @NotNull IClickable onPress, Component yes, Component no) {
+        this(gui, x, y, size, size, textureSize, textureSize, toggle, flipped, toggled, onPress, yes, no);
     }
 
     public ToggleButton(IGuiWrapper gui, int x, int y, int width, int height, int textureWidth, int textureHeight, ResourceLocation toggle, ResourceLocation flipped,
+          BooleanSupplier toggled, @NotNull IClickable onPress, Component yes, Component no) {
+        super(gui, x, y, width, height, textureWidth, textureHeight, toggle, onPress);
         this.toggled = toggled;
         this.flipped = flipped;
+        this.yes = Tooltip.create(yes);
+        this.no = Tooltip.create(no);
     }
 
     @Override
     protected ResourceLocation getResource() {
+        return toggled.getAsBoolean() ? flipped : super.getResource();
     }
 
+    @Override
+    public void updateTooltip(int mouseX, int mouseY) {
+        setTooltip(toggled.getAsBoolean() ? yes : no);
     }
 }
\ No newline at end of file
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>587719</refactoring_id><commit_sha>0c52c6aa8f6bffc60b852a56969a0d1f3e226103</commit_sha><commit_link>https://github.com/oracle/graal/commit/0c52c6aa8f6bffc60b852a56969a0d1f3e226103</commit_link><file_path>truffle/src/com.oracle.truffle.api.strings/src/com/oracle/truffle/api/strings/JCodingsDisabled.java</file_path><description>Remove Parameter nativeProfile : InlinedConditionProfile in method public transcode(location Node, a AbstractTruffleString, arrayA Object, codePointLengthA int, targetEncoding TruffleString.Encoding, outOfMemoryProfile InlinedBranchProfile, nativeProfile InlinedConditionProfile, fromBufferWithStringCompactionNode TStringInternalNodes.FromBufferWithStringCompactionNode, errorHandler TranscodingErrorHandler) : TruffleString from class com.oracle.truffle.api.strings.JCodingsDisabled</description><code_before>@@ -42,8 +42,8 @@
 
 import com.oracle.truffle.api.CompilerDirectives;
 import com.oracle.truffle.api.nodes.Node;
-import com.oracle.truffle.api.profiles.InlinedBranchProfile;
 import com.oracle.truffle.api.profiles.InlinedConditionProfile;
 
 final class JCodingsDisabled implements JCodings {
 
@@ -132,8 +132,6 @@ public long calcStringAttributes(Node location, Object array, int offset, int le
 
     @Override
     public TruffleString transcode(Node location, AbstractTruffleString a, Object arrayA, int codePointLengthA, TruffleString.Encoding targetEncoding,
-                    InlinedBranchProfile outOfMemoryProfile,
-                    InlinedConditionProfile nativeProfile,
                     TStringInternalNodes.FromBufferWithStringCompactionNode fromBufferWithStringCompactionNode,
                     TranscodingErrorHandler errorHandler) {
         throw CompilerDirectives.shouldNotReachHere(MESSAGE);
</code_before><code_after>@@ -42,8 +42,8 @@
 
 import com.oracle.truffle.api.CompilerDirectives;
 import com.oracle.truffle.api.nodes.Node;
 import com.oracle.truffle.api.profiles.InlinedConditionProfile;
+import com.oracle.truffle.api.strings.provider.JCodingsProvider.Encoding;
 
 final class JCodingsDisabled implements JCodings {
 
@@ -132,8 +132,6 @@ public long calcStringAttributes(Node location, Object array, int offset, int le
 
     @Override
     public TruffleString transcode(Node location, AbstractTruffleString a, Object arrayA, int codePointLengthA, TruffleString.Encoding targetEncoding,
                     TStringInternalNodes.FromBufferWithStringCompactionNode fromBufferWithStringCompactionNode,
                     TranscodingErrorHandler errorHandler) {
         throw CompilerDirectives.shouldNotReachHere(MESSAGE);
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>549738</refactoring_id><commit_sha>f18373eeb23b67e46cbc84e1467beba79eebd67b</commit_sha><commit_link>https://github.com/androidx/media/commit/f18373eeb23b67e46cbc84e1467beba79eebd67b</commit_link><file_path>library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java</file_path><description>Remove Parameter pid : int in method public onPmtEntry(pid int, streamType int, esInfo EsInfo, output ExtractorOutput) : ElementaryStreamReader from class com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.Factory</description><code_before>@@ -33,17 +33,12 @@ public interface Factory {
      * Returns an {@link ElementaryStreamReader} for a given PMT entry. May return null if the
      * stream type is not supported or if the stream already has a reader assigned to it.
      *
-     * @param pid The pid for the PMT entry.
-     * @param streamType One of the {@link TsExtractor}{@code .TS_STREAM_TYPE_*} constants defining
-     *     the type of the stream.
-     * @param esInfo The descriptor information linked to the elementary stream.
-     * @param output The {@link ExtractorOutput} that provides the {@link TrackOutput}s for the
-     *     created readers.
      * @return An {@link ElementaryStreamReader} for the elementary streams carried by the provided
      *     pid. {@code null} if the stream is not supported or if it should be ignored.
      */
-    ElementaryStreamReader onPmtEntry(int pid, int streamType, EsInfo esInfo,
-        ExtractorOutput output);
 
   }
 
@@ -70,20 +65,40 @@ public EsInfo(int streamType, String language, byte[] descriptorBytes) {
 
   }
 
-  protected final TrackOutput output;
-
   /**
-   * @param output A {@link TrackOutput} to which samples should be written.
    */
-  protected ElementaryStreamReader(TrackOutput output) {
-    this.output = output;
   }
 
   /**
    * Notifies the reader that a seek has occurred.
    */
   public abstract void seek();
 
   /**
    * Called when a packet starts.
    *
</code_before><code_after>@@ -33,17 +33,12 @@ public interface Factory {
      * Returns an {@link ElementaryStreamReader} for a given PMT entry. May return null if the
      * stream type is not supported or if the stream already has a reader assigned to it.
      *
+     * @param streamType Stream type value as defined in the PMT entry or associated descriptors.
+     * @param esInfo Information associated to the elementary stream provided in the PMT.
      * @return An {@link ElementaryStreamReader} for the elementary streams carried by the provided
      *     pid. {@code null} if the stream is not supported or if it should be ignored.
      */
+    ElementaryStreamReader createStreamReader(int streamType, EsInfo esInfo);
 
   }
 
@@ -70,20 +65,40 @@ public EsInfo(int streamType, String language, byte[] descriptorBytes) {
 
   }
 
   /**
+   * Generates track ids for initializing {@link ElementaryStreamReader}s' {@link TrackOutput}s.
    */
+  public static final class TrackIdGenerator {
+
+    private final int firstId;
+    private final int idIncrement;
+    private int generatedIdCount;
+
+    public TrackIdGenerator(int firstId, int idIncrement) {
+      this.firstId = firstId;
+      this.idIncrement = idIncrement;
+    }
+
+    public int getNextId() {
+      return firstId + idIncrement * generatedIdCount++;
+    }
+
   }
 
   /**
    * Notifies the reader that a seek has occurred.
    */
   public abstract void seek();
 
+  /**
+   * Initializes the reader by providing outputs and ids for the tracks.
+   *
+   * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
+   * @param idGenerator A {@link TrackIdGenerator} that generates unique track ids for the
+   *     {@link TrackOutput}s.
+   */
+  public abstract void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator);
+
   /**
    * Called when a packet starts.
    *
</code_after><evaluations><evaluation><vote>0</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>528911</refactoring_id><commit_sha>33ac3d0e90efa1836f59749b6fc52399d9c4ccb4</commit_sha><commit_link>https://github.com/jetbrains/intellij-plugins/commit/33ac3d0e90efa1836f59749b6fc52399d9c4ccb4</commit_link><file_path>AngularJS/src/org/angularjs/codeInsight/AngularAttributesRegistry.java</file_path><description>Remove Parameter offset : int in method package createDescriptor(project Project, directiveName String, file VirtualFile, offset int) : AngularAttributeDescriptor from class org.angularjs.codeInsight.AngularAttributesRegistry</description><code_before>@@ -1,7 +1,6 @@
 package org.angularjs.codeInsight;
 
 import com.intellij.openapi.project.Project;
-import com.intellij.openapi.vfs.VirtualFile;
 import org.angularjs.codeInsight.attributes.AngularAttributeDescriptor;
 import org.angularjs.codeInsight.attributes.ControllerAttributeDescriptor;
 import org.jetbrains.annotations.NotNull;
@@ -12,12 +11,10 @@
  */
 public class AngularAttributesRegistry {
   static AngularAttributeDescriptor createDescriptor(@Nullable final Project project,
-                                                     @NotNull String directiveName,
-                                                     @Nullable VirtualFile file,
-                                                     final int offset) {
     if ("ng-controller".equals(directiveName)) {
-      return new ControllerAttributeDescriptor(project, file, offset);
     }
-    return new AngularAttributeDescriptor(project, directiveName, file, offset);
   }
 }
</code_before><code_after>@@ -1,7 +1,6 @@
 package org.angularjs.codeInsight;
 
 import com.intellij.openapi.project.Project;
 import org.angularjs.codeInsight.attributes.AngularAttributeDescriptor;
 import org.angularjs.codeInsight.attributes.ControllerAttributeDescriptor;
 import org.jetbrains.annotations.NotNull;
@@ -12,12 +11,10 @@
  */
 public class AngularAttributesRegistry {
   static AngularAttributeDescriptor createDescriptor(@Nullable final Project project,
+                                                     @NotNull String directiveName) {
     if ("ng-controller".equals(directiveName)) {
+      return new ControllerAttributeDescriptor(project);
     }
+    return new AngularAttributeDescriptor(project, directiveName);
   }
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>1</vote></evaluation></evaluations></refactoring><refactoring><refactoring_id>493243</refactoring_id><commit_sha>768b486be0191e8dc4ffaa13213411f9866832de</commit_sha><commit_link>https://github.com/neo4j/neo4j/commit/768b486be0191e8dc4ffaa13213411f9866832de</commit_link><file_path>community/community-it/bolt-it/src/test/java/org/neo4j/bolt/test/connection/resolver/AbstractAddressResolver.java</file_path><description>Remove Parameter transportType : TransportType in method protected abstract doResolve(extensionContext ExtensionContext, context ParameterContext, server Neo4jWithSocket, transportType TransportType) : SocketAddress from class org.neo4j.bolt.test.connection.resolver.AbstractAddressResolver</description><code_before>@@ -19,23 +19,18 @@
  */
 package org.neo4j.bolt.test.connection.resolver;
 
-import java.net.SocketAddress;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
-import org.neo4j.bolt.testing.client.TransportType;
 import org.neo4j.bolt.transport.Neo4jWithSocket;
 
 public abstract class AbstractAddressResolver implements AddressResolver {
 
     @Override
-    public SocketAddress resolve(
-            ExtensionContext extensionContext,
-            ParameterContext context,
-            Neo4jWithSocket server,
-            TransportType transportType)
             throws ParameterResolutionException {
-        var address = this.doResolve(extensionContext, context, server, transportType);
 
         if (address == null) {
             throw new ParameterResolutionException(
@@ -45,10 +40,7 @@ public SocketAddress resolve(
         return address;
     }
 
-    protected abstract SocketAddress doResolve(
-            ExtensionContext extensionContext,
-            ParameterContext context,
-            Neo4jWithSocket server,
-            TransportType transportType)
             throws ParameterResolutionException;
 }
</code_before><code_after>@@ -19,23 +19,18 @@
  */
 package org.neo4j.bolt.test.connection.resolver;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.neo4j.bolt.transport.Neo4jWithSocket;
+import org.neo4j.internal.helpers.HostnamePort;
 
 public abstract class AbstractAddressResolver implements AddressResolver {
 
     @Override
+    public HostnamePort resolve(ExtensionContext extensionContext, ParameterContext context, Neo4jWithSocket server)
             throws ParameterResolutionException {
+        var address = this.doResolve(extensionContext, context, server);
 
         if (address == null) {
             throw new ParameterResolutionException(
@@ -45,10 +40,7 @@ public SocketAddress resolve(
         return address;
     }
 
+    protected abstract HostnamePort doResolve(
+            ExtensionContext extensionContext, ParameterContext context, Neo4jWithSocket server)
             throws ParameterResolutionException;
 }
</code_after><evaluations><evaluation><vote>1</vote></evaluation><evaluation><vote>0</vote></evaluation></evaluations></refactoring></Remove_Parameter></root>
